{"ast":null,"code":"import _classCallCheck from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import _slicedToArray from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{skipToken}from'@reduxjs/toolkit/query/react';import{CurrencyAmount,TradeType}from'@uniswap/sdk-core';import{IMetric,setGlobalMetric}from'@uniswap/smart-order-router';import{sendTiming}from'components/analytics';import{AVERAGE_L1_BLOCK_TIME}from'constants/chainInfo';import{useStablecoinAmountFromFiatValue}from'hooks/useStablecoinPrice';import{useRoutingAPIArguments}from'lib/hooks/routing/useRoutingAPIArguments';import useIsValidBlock from'lib/hooks/useIsValidBlock';import{useMemo}from'react';import{RouterPreference,useGetQuoteQuery}from'state/routing/slice';import{TradeState}from'./types';import{computeRoutes,transformRoutesToTrade}from'./utils';/**\n * Returns the best trade by invoking the routing api or the smart order router on the client\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */export function useRoutingAPITrade(tradeType,amountSpecified,otherCurrency,routerPreference){var _useStablecoinAmountF;var _useMemo=useMemo(function(){return tradeType===TradeType.EXACT_INPUT?[amountSpecified===null||amountSpecified===void 0?void 0:amountSpecified.currency,otherCurrency]:[otherCurrency,amountSpecified===null||amountSpecified===void 0?void 0:amountSpecified.currency];},[amountSpecified,otherCurrency,tradeType]),_useMemo2=_slicedToArray(_useMemo,2),currencyIn=_useMemo2[0],currencyOut=_useMemo2[1];var queryArgs=useRoutingAPIArguments({tokenIn:currencyIn,tokenOut:currencyOut,amount:amountSpecified,tradeType:tradeType,routerPreference:routerPreference});var _useGetQuoteQuery=useGetQuoteQuery(queryArgs!==null&&queryArgs!==void 0?queryArgs:skipToken,{// Price-fetching is informational and costly, so it's done less frequently.\npollingInterval:routerPreference===RouterPreference.PRICE?120000:AVERAGE_L1_BLOCK_TIME}),isLoading=_useGetQuoteQuery.isLoading,isError=_useGetQuoteQuery.isError,data=_useGetQuoteQuery.data,currentData=_useGetQuoteQuery.currentData;var quoteResult=useIsValidBlock(Number(data===null||data===void 0?void 0:data.blockNumber)||0)?data:undefined;var route=useMemo(function(){return computeRoutes(currencyIn,currencyOut,tradeType,quoteResult);},[currencyIn,currencyOut,quoteResult,tradeType]);// get USD gas cost of trade in active chains stablecoin amount\nvar gasUseEstimateUSD=(_useStablecoinAmountF=useStablecoinAmountFromFiatValue(quoteResult===null||quoteResult===void 0?void 0:quoteResult.gasUseEstimateUSD))!==null&&_useStablecoinAmountF!==void 0?_useStablecoinAmountF:null;var isSyncing=currentData!==data;return useMemo(function(){if(!currencyIn||!currencyOut){return{state:TradeState.INVALID,trade:undefined};}if(isLoading&&!quoteResult){// only on first hook render\nreturn{state:TradeState.LOADING,trade:undefined};}var otherAmount=undefined;if(quoteResult){if(tradeType===TradeType.EXACT_INPUT&&currencyOut){otherAmount=CurrencyAmount.fromRawAmount(currencyOut,quoteResult.quote);}if(tradeType===TradeType.EXACT_OUTPUT&&currencyIn){otherAmount=CurrencyAmount.fromRawAmount(currencyIn,quoteResult.quote);}}if(isError||!otherAmount||!route||route.length===0||!queryArgs){return{state:TradeState.NO_ROUTE_FOUND,trade:undefined};}try{var trade=transformRoutesToTrade(route,tradeType,quoteResult===null||quoteResult===void 0?void 0:quoteResult.blockNumber,gasUseEstimateUSD);return{// always return VALID regardless of isFetching status\nstate:isSyncing?TradeState.SYNCING:TradeState.VALID,trade:trade};}catch(e){return{state:TradeState.INVALID,trade:undefined};}},[currencyIn,currencyOut,quoteResult,isLoading,tradeType,isError,route,queryArgs,gasUseEstimateUSD,isSyncing]);}// only want to enable this when app hook called\nvar GAMetric=/*#__PURE__*/function(_IMetric){_inherits(GAMetric,_IMetric);var _super=_createSuper(GAMetric);function GAMetric(){_classCallCheck(this,GAMetric);return _super.apply(this,arguments);}_createClass(GAMetric,[{key:\"putDimensions\",value:function putDimensions(){return;}},{key:\"putMetric\",value:function putMetric(key,value,unit){sendTiming('Routing API',\"\".concat(key,\" | \").concat(unit),value,'client');}}]);return GAMetric;}(IMetric);setGlobalMetric(new GAMetric());","map":{"version":3,"names":["skipToken","CurrencyAmount","TradeType","IMetric","setGlobalMetric","sendTiming","AVERAGE_L1_BLOCK_TIME","useStablecoinAmountFromFiatValue","useRoutingAPIArguments","useIsValidBlock","useMemo","RouterPreference","useGetQuoteQuery","TradeState","computeRoutes","transformRoutesToTrade","useRoutingAPITrade","tradeType","amountSpecified","otherCurrency","routerPreference","EXACT_INPUT","currency","currencyIn","currencyOut","queryArgs","tokenIn","tokenOut","amount","pollingInterval","PRICE","isLoading","isError","data","currentData","quoteResult","Number","blockNumber","undefined","route","gasUseEstimateUSD","isSyncing","state","INVALID","trade","LOADING","otherAmount","fromRawAmount","quote","EXACT_OUTPUT","length","NO_ROUTE_FOUND","SYNCING","VALID","e","GAMetric","key","value","unit"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/routing/useRoutingAPITrade.ts"],"sourcesContent":["import { skipToken } from '@reduxjs/toolkit/query/react'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { IMetric, MetricLoggerUnit, setGlobalMetric } from '@uniswap/smart-order-router'\nimport { sendTiming } from 'components/analytics'\nimport { AVERAGE_L1_BLOCK_TIME } from 'constants/chainInfo'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useStablecoinPrice'\nimport { useRoutingAPIArguments } from 'lib/hooks/routing/useRoutingAPIArguments'\nimport useIsValidBlock from 'lib/hooks/useIsValidBlock'\nimport ms from 'ms.macro'\nimport { useMemo } from 'react'\nimport { RouterPreference, useGetQuoteQuery } from 'state/routing/slice'\n\nimport { GetQuoteResult, InterfaceTrade, TradeState } from './types'\nimport { computeRoutes, transformRoutesToTrade } from './utils'\n\n/**\n * Returns the best trade by invoking the routing api or the smart order router on the client\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useRoutingAPITrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified: CurrencyAmount<Currency> | undefined,\n  otherCurrency: Currency | undefined,\n  routerPreference: RouterPreference\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    routerPreference,\n  })\n\n  const { isLoading, isError, data, currentData } = useGetQuoteQuery(queryArgs ?? skipToken, {\n    // Price-fetching is informational and costly, so it's done less frequently.\n    pollingInterval: routerPreference === RouterPreference.PRICE ? ms`2m` : AVERAGE_L1_BLOCK_TIME,\n  })\n\n  const quoteResult: GetQuoteResult | undefined = useIsValidBlock(Number(data?.blockNumber) || 0) ? data : undefined\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  const isSyncing = currentData !== data\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (isLoading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    let otherAmount = undefined\n    if (quoteResult) {\n      if (tradeType === TradeType.EXACT_INPUT && currencyOut) {\n        otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n      }\n\n      if (tradeType === TradeType.EXACT_OUTPUT && currencyIn) {\n        otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n      }\n    }\n\n    if (isError || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, quoteResult?.blockNumber, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: isSyncing ? TradeState.SYNCING : TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [\n    currencyIn,\n    currencyOut,\n    quoteResult,\n    isLoading,\n    tradeType,\n    isError,\n    route,\n    queryArgs,\n    gasUseEstimateUSD,\n    isSyncing,\n  ])\n}\n\n// only want to enable this when app hook called\nclass GAMetric extends IMetric {\n  putDimensions() {\n    return\n  }\n\n  putMetric(key: string, value: number, unit?: MetricLoggerUnit) {\n    sendTiming('Routing API', `${key} | ${unit}`, value, 'client')\n  }\n}\n\nsetGlobalMetric(new GAMetric())\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}