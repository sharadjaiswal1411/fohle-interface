{"ast":null,"code":"import { __assign, __values } from \"tslib\";\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { LogLevel } from '@amplitude/analytics-types';\nexport var getStacktrace = function (ignoreDepth) {\n  if (ignoreDepth === void 0) {\n    ignoreDepth = 0;\n  }\n  var trace = new Error().stack || '';\n  return trace.split('\\n').slice(2 + ignoreDepth).map(function (text) {\n    return text.trim();\n  });\n};\n// This hook makes sure we always get the latest logger and logLevel.\nexport var getClientLogConfig = function (client) {\n  return function () {\n    var _a = __assign({}, client.config),\n      logger = _a.loggerProvider,\n      logLevel = _a.logLevel;\n    return {\n      logger: logger,\n      logLevel: logLevel\n    };\n  };\n};\n// This is a convenient function to get the attribute from object with string path, similar to lodash '#get'.\nexport var getValueByStringPath = function (obj, path) {\n  var e_1, _a;\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  path = path.replace(/^\\./, ''); // strip a leading dot\n  try {\n    for (var _b = __values(path.split('.')), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var attr = _c.value;\n      if (attr in obj) {\n        obj = obj[attr];\n      } else {\n        return;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return obj;\n};\nexport var getClientStates = function (client, paths) {\n  return function () {\n    var e_2, _a;\n    var res = {};\n    try {\n      for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {\n        var path = paths_1_1.value;\n        res[path] = getValueByStringPath(client, path);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return res;\n  };\n};\nexport var debugWrapper = function (fn, fnName, getLogConfig, getStates, fnContext) {\n  if (fnContext === void 0) {\n    fnContext = null;\n  }\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = getLogConfig(),\n      logger = _a.logger,\n      logLevel = _a.logLevel;\n    // return early if possible to reduce overhead\n    if (logLevel && logLevel < LogLevel.Debug || !logLevel || !logger) {\n      return fn.apply(fnContext, args);\n    }\n    var debugContext = {\n      type: 'invoke public method',\n      name: fnName,\n      args: args,\n      stacktrace: getStacktrace(1),\n      time: {\n        start: new Date().toISOString()\n      },\n      states: {}\n    };\n    if (getStates && debugContext.states) {\n      debugContext.states.before = getStates();\n    }\n    var result = fn.apply(fnContext, args);\n    if (result && result.promise) {\n      // if result is a promise, add the callback\n      result.promise.then(function () {\n        if (getStates && debugContext.states) {\n          debugContext.states.after = getStates();\n        }\n        if (debugContext.time) {\n          debugContext.time.end = new Date().toISOString();\n        }\n        logger.debug(JSON.stringify(debugContext, null, 2));\n      });\n    } else {\n      if (getStates && debugContext.states) {\n        debugContext.states.after = getStates();\n      }\n      if (debugContext.time) {\n        debugContext.time.end = new Date().toISOString();\n      }\n      logger.debug(JSON.stringify(debugContext, null, 2));\n    }\n    return result;\n  };\n};","map":{"version":3,"sources":["../../../src/utils/debug.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { Config, LogLevel, LogConfig, DebugContext } from '@amplitude/analytics-types';\nimport { AmplitudeCore } from '../core-client';\n\nexport const getStacktrace = (ignoreDepth = 0): string[] => {\n  const trace = new Error().stack || '';\n  return trace\n    .split('\\n')\n    .slice(2 + ignoreDepth)\n    .map((text) => text.trim());\n};\n\n// This hook makes sure we always get the latest logger and logLevel.\nexport const getClientLogConfig = (client: AmplitudeCore<Config>) => (): LogConfig => {\n  const { loggerProvider: logger, logLevel } = { ...client.config };\n  return {\n    logger,\n    logLevel,\n  };\n};\n\n// This is a convenient function to get the attribute from object with string path, similar to lodash '#get'.\nexport const getValueByStringPath = (obj: any, path: string): any => {\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  path = path.replace(/^\\./, ''); // strip a leading dot\n  for (const attr of path.split('.')) {\n    if (attr in obj) {\n      obj = obj[attr];\n    } else {\n      return;\n    }\n  }\n  return obj;\n};\n\nexport const getClientStates = (client: AmplitudeCore<Config>, paths: Array<string>) => (): { [key: string]: any } => {\n  const res: { [key: string]: any } = {};\n  for (const path of paths) {\n    res[path] = getValueByStringPath(client, path);\n  }\n  return res;\n};\n\nexport const debugWrapper =\n  <T extends Array<any>, R>(\n    fn: (...args: T) => R,\n    fnName: string,\n    getLogConfig: () => LogConfig,\n    getStates?: () => { [key: string]: any },\n    fnContext: any = null,\n  ) =>\n  (...args: T): R => {\n    const { logger, logLevel } = getLogConfig();\n    // return early if possible to reduce overhead\n    if ((logLevel && logLevel < LogLevel.Debug) || !logLevel || !logger) {\n      return fn.apply(fnContext, args);\n    }\n    const debugContext: DebugContext = {\n      type: 'invoke public method',\n      name: fnName,\n      args,\n      stacktrace: getStacktrace(1),\n      time: {\n        start: new Date().toISOString(),\n      },\n      states: {},\n    };\n    if (getStates && debugContext.states) {\n      debugContext.states.before = getStates();\n    }\n    const result = fn.apply(fnContext, args);\n    if (result && (result as any).promise) {\n      // if result is a promise, add the callback\n      (result as any).promise.then(() => {\n        if (getStates && debugContext.states) {\n          debugContext.states.after = getStates();\n        }\n        if (debugContext.time) {\n          debugContext.time.end = new Date().toISOString();\n        }\n        logger.debug(JSON.stringify(debugContext, null, 2));\n      });\n    } else {\n      if (getStates && debugContext.states) {\n        debugContext.states.after = getStates();\n      }\n      if (debugContext.time) {\n        debugContext.time.end = new Date().toISOString();\n      }\n      logger.debug(JSON.stringify(debugContext, null, 2));\n    }\n    return result;\n  };\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}