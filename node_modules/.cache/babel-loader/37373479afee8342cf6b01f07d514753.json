{"ast":null,"code":"import{isAddress}from'../../../utils';var alwaysTrue=function alwaysTrue(){return true;};/** Creates a filter function that filters tokens that do not match the query. */export function getTokenFilter(query){var searchingAddress=isAddress(query);if(searchingAddress){var address=searchingAddress.toLowerCase();return function(t){return'address'in t&&address===t.address.toLowerCase();};}var queryParts=query.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});if(queryParts.length===0)return alwaysTrue;var match=function match(s){var parts=s.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});return queryParts.every(function(p){return p.length===0||parts.some(function(sp){return sp.startsWith(p)||sp.endsWith(p);});});};return function(_ref){var name=_ref.name,symbol=_ref.symbol;return Boolean(symbol&&match(symbol)||name&&match(name));};}","map":{"version":3,"names":["isAddress","alwaysTrue","getTokenFilter","query","searchingAddress","address","toLowerCase","t","queryParts","split","filter","s","length","match","parts","every","p","some","sp","startsWith","endsWith","name","symbol","Boolean"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useTokenList/filtering.ts"],"sourcesContent":["import { NativeCurrency, Token } from '@uniswap/sdk-core'\nimport { TokenInfo } from '@uniswap/token-lists'\n\nimport { isAddress } from '../../../utils'\n\nconst alwaysTrue = () => true\n\n/** Creates a filter function that filters tokens that do not match the query. */\nexport function getTokenFilter<T extends Token | TokenInfo>(query: string): (token: T | NativeCurrency) => boolean {\n  const searchingAddress = isAddress(query)\n\n  if (searchingAddress) {\n    const address = searchingAddress.toLowerCase()\n    return (t: T | NativeCurrency) => 'address' in t && address === t.address.toLowerCase()\n  }\n\n  const queryParts = query\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0)\n\n  if (queryParts.length === 0) return alwaysTrue\n\n  const match = (s: string): boolean => {\n    const parts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    return queryParts.every((p) => p.length === 0 || parts.some((sp) => sp.startsWith(p) || sp.endsWith(p)))\n  }\n\n  return ({ name, symbol }: T | NativeCurrency): boolean => Boolean((symbol && match(symbol)) || (name && match(name)))\n}\n"],"mappings":"AAGA,OAASA,SAAS,KAAQ,gBAAgB,CAE1C,GAAMC,WAAU,CAAG,QAAbA,WAAU,SAAS,KAAI,GAE7B,iFACA,MAAO,SAASC,eAAc,CAA8BC,KAAa,CAA0C,CACjH,GAAMC,iBAAgB,CAAGJ,SAAS,CAACG,KAAK,CAAC,CAEzC,GAAIC,gBAAgB,CAAE,CACpB,GAAMC,QAAO,CAAGD,gBAAgB,CAACE,WAAW,EAAE,CAC9C,MAAO,UAACC,CAAqB,QAAK,SAAS,EAAIA,EAAC,EAAIF,OAAO,GAAKE,CAAC,CAACF,OAAO,CAACC,WAAW,EAAE,GACzF,CAEA,GAAME,WAAU,CAAGL,KAAK,CACrBG,WAAW,EAAE,CACbG,KAAK,CAAC,KAAK,CAAC,CACZC,MAAM,CAAC,SAACC,CAAC,QAAKA,EAAC,CAACC,MAAM,CAAG,CAAC,GAAC,CAE9B,GAAIJ,UAAU,CAACI,MAAM,GAAK,CAAC,CAAE,MAAOX,WAAU,CAE9C,GAAMY,MAAK,CAAG,QAARA,MAAK,CAAIF,CAAS,CAAc,CACpC,GAAMG,MAAK,CAAGH,CAAC,CACZL,WAAW,EAAE,CACbG,KAAK,CAAC,KAAK,CAAC,CACZC,MAAM,CAAC,SAACC,CAAC,QAAKA,EAAC,CAACC,MAAM,CAAG,CAAC,GAAC,CAE9B,MAAOJ,WAAU,CAACO,KAAK,CAAC,SAACC,CAAC,QAAKA,EAAC,CAACJ,MAAM,GAAK,CAAC,EAAIE,KAAK,CAACG,IAAI,CAAC,SAACC,EAAE,QAAKA,GAAE,CAACC,UAAU,CAACH,CAAC,CAAC,EAAIE,EAAE,CAACE,QAAQ,CAACJ,CAAC,CAAC,GAAC,GAAC,CAC1G,CAAC,CAED,MAAO,mBAAGK,KAAI,MAAJA,IAAI,CAAEC,MAAM,MAANA,MAAM,OAAoCC,QAAO,CAAED,MAAM,EAAIT,KAAK,CAACS,MAAM,CAAC,EAAMD,IAAI,EAAIR,KAAK,CAACQ,IAAI,CAAE,CAAC,GACvH"},"metadata":{},"sourceType":"module"}