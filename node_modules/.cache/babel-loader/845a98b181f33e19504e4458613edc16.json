{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt) {\n    const {\n      schema,\n      it\n    } = cxt;\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema);\n    it.items = true;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) return;\n    cxt.ok((0, code_1.validateArray)(cxt));\n  }\n};\nfunction validateTuple(cxt, extraItems) {\n  let schArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cxt.schema;\n  const {\n    gen,\n    parentSchema,\n    data,\n    keyword,\n    it\n  } = cxt;\n  checkStrictTuple(parentSchema);\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n  }\n  const valid = gen.name(\"valid\");\n  const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n  schArr.forEach((sch, i) => {\n    if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n    gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({\n      keyword,\n      schemaProp: i,\n      dataProp: i\n    }, valid));\n    cxt.ok(valid);\n  });\n  function checkStrictTuple(sch) {\n    const {\n      opts,\n      errSchemaPath\n    } = it;\n    const l = schArr.length;\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n      (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n    }\n  }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/items.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map"]},"metadata":{},"sourceType":"script"}