{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar JSBI = _interopDefault(require('jsbi'));\nvar abi = require('@ethersproject/abi');\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar IApproveAndCall_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json');\nvar v3Sdk = require('@uniswap/v3-sdk');\nvar IMulticallExtended_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json');\nvar sdkCore = require('@uniswap/sdk-core');\nvar IPeripheryPaymentsWithFeeExtended_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json');\nvar ISwapRouter02_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json');\nvar v2Sdk = require('@uniswap/v2-sdk');\nvar solidity = require('@ethersproject/solidity');\nvar MSG_SENDER = '0x0000000000000000000000000000000000000001';\nvar ADDRESS_THIS = '0x0000000000000000000000000000000000000002';\nvar ZERO = /*#__PURE__*/JSBI.BigInt(0);\nvar ONE = /*#__PURE__*/JSBI.BigInt(1); // = 1 << 23 or 100000000000000000000000\n\nvar V2_FEE_PATH_PLACEHOLDER = 8388608;\n(function (ApprovalTypes) {\n  ApprovalTypes[ApprovalTypes[\"NOT_REQUIRED\"] = 0] = \"NOT_REQUIRED\";\n  ApprovalTypes[ApprovalTypes[\"MAX\"] = 1] = \"MAX\";\n  ApprovalTypes[ApprovalTypes[\"MAX_MINUS_ONE\"] = 2] = \"MAX_MINUS_ONE\";\n  ApprovalTypes[ApprovalTypes[\"ZERO_THEN_MAX\"] = 3] = \"ZERO_THEN_MAX\";\n  ApprovalTypes[ApprovalTypes[\"ZERO_THEN_MAX_MINUS_ONE\"] = 4] = \"ZERO_THEN_MAX_MINUS_ONE\";\n})(exports.ApprovalTypes || (exports.ApprovalTypes = {})); // type guard\n\nfunction isMint(options) {\n  return Object.keys(options).some(function (k) {\n    return k === 'recipient';\n  });\n}\nvar ApproveAndCall = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function ApproveAndCall() {}\n  ApproveAndCall.encodeApproveMax = function encodeApproveMax(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address]);\n  };\n  ApproveAndCall.encodeApproveMaxMinusOne = function encodeApproveMaxMinusOne(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address]);\n  };\n  ApproveAndCall.encodeApproveZeroThenMax = function encodeApproveZeroThenMax(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address]);\n  };\n  ApproveAndCall.encodeApproveZeroThenMaxMinusOne = function encodeApproveZeroThenMaxMinusOne(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address]);\n  };\n  ApproveAndCall.encodeCallPositionManager = function encodeCallPositionManager(calldatas) {\n    !(calldatas.length > 0) ? invariant(false, 'NULL_CALLDATA') : void 0;\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas);\n    } else {\n      var encodedMulticall = v3Sdk.NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas]);\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall]);\n    }\n  }\n  /**\r\n   * Encode adding liquidity to a position in the nft manager contract\r\n   * @param position Forcasted position with expected amount out from swap\r\n   * @param minimalPosition Forcasted position with custom minimal token amounts\r\n   * @param addLiquidityOptions Options for adding liquidity\r\n   * @param slippageTolerance Defines maximum slippage\r\n   */;\n\n  ApproveAndCall.encodeAddLiquidity = function encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, slippageTolerance) {\n    var _position$mintAmounts = position.mintAmountsWithSlippage(slippageTolerance),\n      amount0Min = _position$mintAmounts.amount0,\n      amount1Min = _position$mintAmounts.amount1; // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient;\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient;\n    }\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [{\n        token0: position.pool.token0.address,\n        token1: position.pool.token1.address,\n        fee: position.pool.fee,\n        tickLower: position.tickLower,\n        tickUpper: position.tickUpper,\n        amount0Min: v3Sdk.toHex(amount0Min),\n        amount1Min: v3Sdk.toHex(amount1Min),\n        recipient: addLiquidityOptions.recipient\n      }]);\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [{\n        token0: position.pool.token0.address,\n        token1: position.pool.token1.address,\n        amount0Min: v3Sdk.toHex(amount0Min),\n        amount1Min: v3Sdk.toHex(amount1Min),\n        tokenId: v3Sdk.toHex(addLiquidityOptions.tokenId)\n      }]);\n    }\n  };\n  ApproveAndCall.encodeApprove = function encodeApprove(token, approvalType) {\n    switch (approvalType) {\n      case exports.ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped);\n      case exports.ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped);\n      case exports.ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped);\n      case exports.ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped);\n      default:\n        throw 'Error: invalid ApprovalType';\n    }\n  };\n  return ApproveAndCall;\n}();\nApproveAndCall.INTERFACE = /*#__PURE__*/new abi.Interface(IApproveAndCall_json.abi);\nfunction validateAndParseBytes32(bytes32) {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(bytes32 + \" is not valid bytes32.\");\n  }\n  return bytes32.toLowerCase();\n}\nvar MulticallExtended = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function MulticallExtended() {}\n  MulticallExtended.encodeMulticall = function encodeMulticall(calldatas, validation) {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return v3Sdk.Multicall.encodeMulticall(calldatas);\n    } // if there is validation, we have to normalize calldatas\n\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas];\n    } // this means the validation value should be a previousBlockhash\n\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      var previousBlockhash = validateAndParseBytes32(validation);\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [previousBlockhash, calldatas]);\n    } else {\n      var deadline = v3Sdk.toHex(validation);\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas]);\n    }\n  };\n  return MulticallExtended;\n}();\nMulticallExtended.INTERFACE = /*#__PURE__*/new abi.Interface(IMulticallExtended_json.abi);\nfunction encodeFeeBips(fee) {\n  return v3Sdk.toHex(fee.multiply(10000).quotient);\n}\nvar PaymentsExtended = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function PaymentsExtended() {}\n  PaymentsExtended.encodeUnwrapWETH9 = function encodeUnwrapWETH9(amountMinimum, recipient, feeOptions) {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return v3Sdk.Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions);\n    }\n    if (!!feeOptions) {\n      var feeBips = encodeFeeBips(feeOptions.fee);\n      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [v3Sdk.toHex(amountMinimum), feeBips, feeRecipient]);\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [v3Sdk.toHex(amountMinimum)]);\n    }\n  };\n  PaymentsExtended.encodeSweepToken = function encodeSweepToken(token, amountMinimum, recipient, feeOptions) {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return v3Sdk.Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions);\n    }\n    if (!!feeOptions) {\n      var feeBips = encodeFeeBips(feeOptions.fee);\n      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [token.address, v3Sdk.toHex(amountMinimum), feeBips, feeRecipient]);\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [token.address, v3Sdk.toHex(amountMinimum)]);\n    }\n  };\n  PaymentsExtended.encodePull = function encodePull(token, amount) {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, v3Sdk.toHex(amount)]);\n  };\n  PaymentsExtended.encodeWrapETH = function encodeWrapETH(amount) {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [v3Sdk.toHex(amount)]);\n  };\n  return PaymentsExtended;\n}();\nPaymentsExtended.INTERFACE = /*#__PURE__*/new abi.Interface(IPeripheryPaymentsWithFeeExtended_json.abi);\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function (obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []);\n\n      // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n    exports.wrap = wrap;\n\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function () {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction ||\n      // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    };\n\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n      var previousPromise;\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,\n        // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n\n      // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n      this._invoke = enqueue;\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          }\n\n          // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n          return doneResult();\n        }\n        context.method = method;\n        context.arg = arg;\n        while (true) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted;\n            // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    }\n\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n        return ContinueSentinel;\n      }\n      var record = tryCatch(method, delegate.iterator, context.arg);\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      var info = record.arg;\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value;\n\n        // Resume execution at the desired location (see delegateYield).\n        context.next = delegate.nextLoc;\n\n        // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      }\n\n      // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    define(Gp, iteratorSymbol, function () {\n      return this;\n    });\n    define(Gp, \"toString\", function () {\n      return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n      this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n    exports.keys = function (object) {\n      var keys = [];\n      for (var key in object) {\n        keys.push(key);\n      }\n      keys.reverse();\n\n      // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        }\n\n        // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n        next.done = true;\n        return next;\n      };\n    };\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n            next = function next() {\n              while (++i < iterable.length) {\n                if (hasOwn.call(iterable, i)) {\n                  next.value = iterable[i];\n                  next.done = false;\n                  return next;\n                }\n              }\n              next.value = undefined$1;\n              next.done = true;\n              return next;\n            };\n          return next.next = next;\n        }\n      }\n\n      // Return an iterator with no values.\n      return {\n        next: doneResult\n      };\n    }\n    exports.values = values;\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n    Context.prototype = {\n      constructor: Context,\n      reset: function (skipTempReset) {\n        this.prev = 0;\n        this.next = 0;\n        // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function () {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n        return this.rval;\n      },\n      dispatchException: function (exception) {\n        if (this.done) {\n          throw exception;\n        }\n        var context = this;\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n          return !!caught;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function (type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n        return this.complete(record);\n      },\n      complete: function (record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n        return ContinueSentinel;\n      },\n      finish: function (finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function (tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n            return thrown;\n          }\n        }\n\n        // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n        return ContinueSentinel;\n      }\n    };\n\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n  }(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n    }\n  }\n});\n\n/**\r\n * Represents a list of pools or pairs through which a swap can occur\r\n * @template TInput The input token\r\n * @template TOutput The output token\r\n */\n\nvar MixedRouteSDK = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of route.\r\n   * @param pools An array of `TPool` objects (pools or pairs), ordered by the route the swap will take\r\n   * @param input The input token\r\n   * @param output The output token\r\n   */\n  function MixedRouteSDK(pools, input, output) {\n    this._midPrice = null;\n    !(pools.length > 0) ? invariant(false, 'POOLS') : void 0;\n    var chainId = pools[0].chainId;\n    var allOnSameChain = pools.every(function (pool) {\n      return pool.chainId === chainId;\n    });\n    !allOnSameChain ? invariant(false, 'CHAIN_IDS') : void 0;\n    var wrappedInput = input.wrapped;\n    !pools[0].involvesToken(wrappedInput) ? invariant(false, 'INPUT') : void 0;\n    !pools[pools.length - 1].involvesToken(output.wrapped) ? invariant(false, 'OUTPUT') : void 0;\n    /**\r\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\r\n     * */\n\n    var tokenPath = [wrappedInput];\n    for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        i = _step$value[0],\n        pool = _step$value[1];\n      var currentInputToken = tokenPath[i];\n      !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1)) ? invariant(false, 'PATH') : void 0;\n      var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0;\n      tokenPath.push(nextToken);\n    }\n    this.pools = pools;\n    this.path = tokenPath;\n    this.input = input;\n    this.output = output != null ? output : tokenPath[tokenPath.length - 1];\n  }\n  _createClass(MixedRouteSDK, [{\n    key: \"chainId\",\n    get: function get() {\n      return this.pools[0].chainId;\n    }\n    /**\r\n     * Returns the mid price of the route\r\n     */\n  }, {\n    key: \"midPrice\",\n    get: function get() {\n      if (this._midPrice !== null) return this._midPrice;\n      var price = this.pools.slice(1).reduce(function (_ref, pool) {\n        var nextInput = _ref.nextInput,\n          price = _ref.price;\n        return nextInput.equals(pool.token0) ? {\n          nextInput: pool.token1,\n          price: price.multiply(pool.token0Price)\n        } : {\n          nextInput: pool.token0,\n          price: price.multiply(pool.token1Price)\n        };\n      }, this.pools[0].token0.equals(this.input.wrapped) ? {\n        nextInput: this.pools[0].token1,\n        price: this.pools[0].token0Price\n      } : {\n        nextInput: this.pools[0].token0,\n        price: this.pools[0].token1Price\n      }).price;\n      return this._midPrice = new sdkCore.Price(this.input, this.output, price.denominator, price.numerator);\n    }\n  }]);\n  return MixedRouteSDK;\n}();\n\n/**\r\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n * @param a The first trade to compare\r\n * @param b The second trade to compare\r\n * @returns A sorted ordering for two neighboring elements in a trade array\r\n */\n\nfunction tradeComparator(a, b) {\n  // must have same input and output token for comparison\n  !a.inputAmount.currency.equals(b.inputAmount.currency) ? invariant(false, 'INPUT_CURRENCY') : void 0;\n  !a.outputAmount.currency.equals(b.outputAmount.currency) ? invariant(false, 'OUTPUT_CURRENCY') : void 0;\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      // consider the number of hops since each hop costs gas\n      var aHops = a.swaps.reduce(function (total, cur) {\n        return total + cur.route.path.length;\n      }, 0);\n      var bHops = b.swaps.reduce(function (total, cur) {\n        return total + cur.route.path.length;\n      }, 0);\n      return aHops - bHops;\n    } // trade A requires less input than trade B, so A should come first\n\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n/**\r\n * Represents a trade executed against a set of routes where some percentage of the input is\r\n * split across each route.\r\n *\r\n * Each route has its own set of pools. Pools can not be re-used across routes.\r\n *\r\n * Does not account for slippage, i.e., changes in price environment that can occur between\r\n * the time the trade is submitted and when it is executed.\r\n * @notice This class is functionally the same as the `Trade` class in the `@uniswap/v3-sdk` package, aside from typing and some input validation.\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n */\n\nvar MixedRouteTrade = /*#__PURE__*/function () {\n  /**\r\n   * Construct a trade by passing in the pre-computed property values\r\n   * @param routes The routes through which the trade occurs\r\n   * @param tradeType The type of trade, exact input or exact output\r\n   */\n  function MixedRouteTrade(_ref) {\n    var routes = _ref.routes,\n      tradeType = _ref.tradeType;\n    var inputCurrency = routes[0].inputAmount.currency;\n    var outputCurrency = routes[0].outputAmount.currency;\n    !routes.every(function (_ref2) {\n      var route = _ref2.route;\n      return inputCurrency.wrapped.equals(route.input.wrapped);\n    }) ? invariant(false, 'INPUT_CURRENCY_MATCH') : void 0;\n    !routes.every(function (_ref3) {\n      var route = _ref3.route;\n      return outputCurrency.wrapped.equals(route.output.wrapped);\n    }) ? invariant(false, 'OUTPUT_CURRENCY_MATCH') : void 0;\n    var numPools = routes.map(function (_ref4) {\n      var route = _ref4.route;\n      return route.pools.length;\n    }).reduce(function (total, cur) {\n      return total + cur;\n    }, 0);\n    var poolAddressSet = new Set();\n    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done;) {\n      var route = _step.value.route;\n      for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done;) {\n        var pool = _step2.value;\n        pool instanceof v3Sdk.Pool ? poolAddressSet.add(v3Sdk.Pool.getAddress(pool.token0, pool.token1, pool.fee)) : poolAddressSet.add(v2Sdk.Pair.getAddress(pool.token0, pool.token1));\n      }\n    }\n    !(numPools == poolAddressSet.size) ? invariant(false, 'POOLS_DUPLICATED') : void 0;\n    !(tradeType === sdkCore.TradeType.EXACT_INPUT) ? invariant(false, 'TRADE_TYPE') : void 0;\n    this.swaps = routes;\n    this.tradeType = tradeType;\n  }\n  /**\r\n   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\r\n   * this will return an error.\r\n   *\r\n   * When the trade consists of just a single route, this returns the route of the trade,\r\n   * i.e. which pools the trade goes through.\r\n   */\n\n  /**\r\n   * Constructs a trade by simulating swaps through the given route\r\n   * @template TInput The input token, either Ether or an ERC-20.\r\n   * @template TOutput The output token, either Ether or an ERC-20.\r\n   * @template TTradeType The type of the trade, either exact in or exact out.\r\n   * @param route route to swap through\r\n   * @param amount the amount specified, either input or output, depending on tradeType\r\n   * @param tradeType whether the trade is an exact input or exact output swap\r\n   * @returns The route\r\n   */\n  MixedRouteTrade.fromRoute = /*#__PURE__*/\n  function () {\n    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(route, amount, tradeType) {\n      var amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput, _outputAmount;\n      return runtime_1.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              amounts = new Array(route.path.length);\n              !(tradeType === sdkCore.TradeType.EXACT_INPUT) ? invariant(false, 'TRADE_TYPE') : void 0;\n              !amount.currency.equals(route.input) ? invariant(false, 'INPUT') : void 0;\n              amounts[0] = amount.wrapped;\n              i = 0;\n            case 5:\n              if (!(i < route.path.length - 1)) {\n                _context.next = 15;\n                break;\n              }\n              pool = route.pools[i];\n              _context.next = 9;\n              return pool.getOutputAmount(amounts[i]);\n            case 9:\n              _yield$pool$getOutput = _context.sent;\n              _outputAmount = _yield$pool$getOutput[0];\n              amounts[i + 1] = _outputAmount;\n            case 12:\n              i++;\n              _context.next = 5;\n              break;\n            case 15:\n              inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\n              outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\n              return _context.abrupt(\"return\", new MixedRouteTrade({\n                routes: [{\n                  inputAmount: inputAmount,\n                  outputAmount: outputAmount,\n                  route: route\n                }],\n                tradeType: tradeType\n              }));\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function fromRoute(_x, _x2, _x3) {\n      return _fromRoute.apply(this, arguments);\n    }\n    return fromRoute;\n  }()\n  /**\r\n   * Constructs a trade from routes by simulating swaps\r\n   *\r\n   * @template TInput The input token, either Ether or an ERC-20.\r\n   * @template TOutput The output token, either Ether or an ERC-20.\r\n   * @template TTradeType The type of the trade, either exact in or exact out.\r\n   * @param routes the routes to swap through and how much of the amount should be routed through each\r\n   * @param tradeType whether the trade is an exact input or exact output swap\r\n   * @returns The trade\r\n   */;\n\n  MixedRouteTrade.fromRoutes = /*#__PURE__*/\n  function () {\n    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(routes, tradeType) {\n      var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput2, _outputAmount2;\n      return runtime_1.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              populatedRoutes = [];\n              !(tradeType === sdkCore.TradeType.EXACT_INPUT) ? invariant(false, 'TRADE_TYPE') : void 0;\n              _iterator3 = _createForOfIteratorHelperLoose(routes);\n            case 3:\n              if ((_step3 = _iterator3()).done) {\n                _context2.next = 26;\n                break;\n              }\n              _step3$value = _step3.value, route = _step3$value.route, amount = _step3$value.amount;\n              amounts = new Array(route.path.length);\n              inputAmount = void 0;\n              outputAmount = void 0;\n              !amount.currency.equals(route.input) ? invariant(false, 'INPUT') : void 0;\n              inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\n              amounts[0] = sdkCore.CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);\n              i = 0;\n            case 12:\n              if (!(i < route.path.length - 1)) {\n                _context2.next = 22;\n                break;\n              }\n              pool = route.pools[i];\n              _context2.next = 16;\n              return pool.getOutputAmount(amounts[i]);\n            case 16:\n              _yield$pool$getOutput2 = _context2.sent;\n              _outputAmount2 = _yield$pool$getOutput2[0];\n              amounts[i + 1] = _outputAmount2;\n            case 19:\n              i++;\n              _context2.next = 12;\n              break;\n            case 22:\n              outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\n              populatedRoutes.push({\n                route: route,\n                inputAmount: inputAmount,\n                outputAmount: outputAmount\n              });\n            case 24:\n              _context2.next = 3;\n              break;\n            case 26:\n              return _context2.abrupt(\"return\", new MixedRouteTrade({\n                routes: populatedRoutes,\n                tradeType: tradeType\n              }));\n            case 27:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    function fromRoutes(_x4, _x5) {\n      return _fromRoutes.apply(this, arguments);\n    }\n    return fromRoutes;\n  }()\n  /**\r\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n   * elsewhere and do not have any tick data\r\n   * @template TInput The input token, either Ether or an ERC-20\r\n   * @template TOutput The output token, either Ether or an ERC-20\r\n   * @template TTradeType The type of the trade, either exact in or exact out\r\n   * @param constructorArguments The arguments passed to the trade constructor\r\n   * @returns The unchecked trade\r\n   */;\n\n  MixedRouteTrade.createUncheckedTrade = function createUncheckedTrade(constructorArguments) {\n    return new MixedRouteTrade(_extends({}, constructorArguments, {\n      routes: [{\n        inputAmount: constructorArguments.inputAmount,\n        outputAmount: constructorArguments.outputAmount,\n        route: constructorArguments.route\n      }]\n    }));\n  }\n  /**\r\n   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\r\n   * elsewhere and do not have any tick data\r\n   * @template TInput The input token, either Ether or an ERC-20\r\n   * @template TOutput The output token, either Ether or an ERC-20\r\n   * @template TTradeType The type of the trade, either exact in or exact out\r\n   * @param constructorArguments The arguments passed to the trade constructor\r\n   * @returns The unchecked trade\r\n   */;\n\n  MixedRouteTrade.createUncheckedTradeWithMultipleRoutes = function createUncheckedTradeWithMultipleRoutes(constructorArguments) {\n    return new MixedRouteTrade(constructorArguments);\n  }\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n   * @returns The amount out\r\n   */;\n\n  var _proto = MixedRouteTrade.prototype;\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {\n    if (amountOut === void 0) {\n      amountOut = this.outputAmount;\n    }\n    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0; /// does not support exactOutput, as enforced in the constructor\n\n    var slippageAdjustedAmountOut = new sdkCore.Fraction(ONE).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;\n    return sdkCore.CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n   * @returns The amount in\r\n   */;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {\n    if (amountIn === void 0) {\n      amountIn = this.inputAmount;\n    }\n    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0;\n    return amountIn; /// does not support exactOutput\n  }\n  /**\r\n   * Return the execution price after accounting for slippage tolerance\r\n   * @param slippageTolerance the allowed tolerated slippage\r\n   * @returns The execution price\r\n   */;\n\n  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {\n    return new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  }\n  /**\r\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pools the pools to consider in finding the best trade\r\n   * @param nextAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n   * @param currentPools used in recursion; the current list of pools\r\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   * @returns The exact in trade\r\n   */;\n\n  MixedRouteTrade.bestTradeExactIn = /*#__PURE__*/\n  function () {\n    var _bestTradeExactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(pools, currencyAmountIn, currencyOut, _temp,\n    // used in recursion.\n    currentPools, nextAmountIn, bestTrades) {\n      var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i, pool, amountOut, _yield$pool$getOutput3, poolsExcludingThisPool;\n      return runtime_1.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _ref5 = _temp === void 0 ? {} : _temp, _ref5$maxNumResults = _ref5.maxNumResults, maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults, _ref5$maxHops = _ref5.maxHops, maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops;\n              if (currentPools === void 0) {\n                currentPools = [];\n              }\n              if (nextAmountIn === void 0) {\n                nextAmountIn = currencyAmountIn;\n              }\n              if (bestTrades === void 0) {\n                bestTrades = [];\n              }\n              !(pools.length > 0) ? invariant(false, 'POOLS') : void 0;\n              !(maxHops > 0) ? invariant(false, 'MAX_HOPS') : void 0;\n              !(currencyAmountIn === nextAmountIn || currentPools.length > 0) ? invariant(false, 'INVALID_RECURSION') : void 0;\n              amountIn = nextAmountIn.wrapped;\n              tokenOut = currencyOut.wrapped;\n              i = 0;\n            case 10:\n              if (!(i < pools.length)) {\n                _context3.next = 49;\n                break;\n              }\n              pool = pools[i]; // pool irrelevant\n\n              if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {\n                _context3.next = 14;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 46);\n            case 14:\n              if (!(pool instanceof v2Sdk.Pair)) {\n                _context3.next = 17;\n                break;\n              }\n              if (!(pool.reserve0.equalTo(ZERO) || pool.reserve1.equalTo(ZERO))) {\n                _context3.next = 17;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 46);\n            case 17:\n              amountOut = void 0;\n              _context3.prev = 18;\n              _context3.next = 22;\n              return pool.getOutputAmount(amountIn);\n            case 22:\n              _yield$pool$getOutput3 = _context3.sent;\n              amountOut = _yield$pool$getOutput3[0];\n              _context3.next = 31;\n              break;\n            case 26:\n              _context3.prev = 26;\n              _context3.t0 = _context3[\"catch\"](18);\n              if (!_context3.t0.isInsufficientInputAmountError) {\n                _context3.next = 30;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 46);\n            case 30:\n              throw _context3.t0;\n            case 31:\n              if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {\n                _context3.next = 42;\n                break;\n              }\n              _context3.t1 = sdkCore.sortedInsert;\n              _context3.t2 = bestTrades;\n              _context3.next = 36;\n              return MixedRouteTrade.fromRoute(new MixedRouteSDK([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut), currencyAmountIn, sdkCore.TradeType.EXACT_INPUT);\n            case 36:\n              _context3.t3 = _context3.sent;\n              _context3.t4 = maxNumResults;\n              _context3.t5 = tradeComparator;\n              (0, _context3.t1)(_context3.t2, _context3.t3, _context3.t4, _context3.t5);\n              _context3.next = 46;\n              break;\n            case 42:\n              if (!(maxHops > 1 && pools.length > 1)) {\n                _context3.next = 46;\n                break;\n              }\n              poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n\n              _context3.next = 46;\n              return MixedRouteTrade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {\n                maxNumResults: maxNumResults,\n                maxHops: maxHops - 1\n              }, [].concat(currentPools, [pool]), amountOut, bestTrades);\n            case 46:\n              i++;\n              _context3.next = 10;\n              break;\n            case 49:\n              return _context3.abrupt(\"return\", bestTrades);\n            case 50:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[18, 26]]);\n    }));\n    function bestTradeExactIn(_x6, _x7, _x8, _x9, _x10, _x11, _x12) {\n      return _bestTradeExactIn.apply(this, arguments);\n    }\n    return bestTradeExactIn;\n  }();\n  _createClass(MixedRouteTrade, [{\n    key: \"route\",\n    get: function get() {\n      !(this.swaps.length == 1) ? invariant(false, 'MULTIPLE_ROUTES') : void 0;\n      return this.swaps[0].route;\n    }\n    /**\r\n     * The input amount for the trade assuming no slippage.\r\n     */\n  }, {\n    key: \"inputAmount\",\n    get: function get() {\n      if (this._inputAmount) {\n        return this._inputAmount;\n      }\n      var inputCurrency = this.swaps[0].inputAmount.currency;\n      var totalInputFromRoutes = this.swaps.map(function (_ref6) {\n        var inputAmount = _ref6.inputAmount;\n        return inputAmount;\n      }).reduce(function (total, cur) {\n        return total.add(cur);\n      }, sdkCore.CurrencyAmount.fromRawAmount(inputCurrency, 0));\n      this._inputAmount = totalInputFromRoutes;\n      return this._inputAmount;\n    }\n    /**\r\n     * The output amount for the trade assuming no slippage.\r\n     */\n  }, {\n    key: \"outputAmount\",\n    get: function get() {\n      if (this._outputAmount) {\n        return this._outputAmount;\n      }\n      var outputCurrency = this.swaps[0].outputAmount.currency;\n      var totalOutputFromRoutes = this.swaps.map(function (_ref7) {\n        var outputAmount = _ref7.outputAmount;\n        return outputAmount;\n      }).reduce(function (total, cur) {\n        return total.add(cur);\n      }, sdkCore.CurrencyAmount.fromRawAmount(outputCurrency, 0));\n      this._outputAmount = totalOutputFromRoutes;\n      return this._outputAmount;\n    }\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\n  }, {\n    key: \"executionPrice\",\n    get: function get() {\n      var _this$_executionPrice;\n      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    }\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\n  }, {\n    key: \"priceImpact\",\n    get: function get() {\n      if (this._priceImpact) {\n        return this._priceImpact;\n      }\n      var spotOutputAmount = sdkCore.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);\n      for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done;) {\n        var _step4$value = _step4.value,\n          route = _step4$value.route,\n          inputAmount = _step4$value.inputAmount;\n        var midPrice = route.midPrice;\n        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));\n      }\n      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);\n      this._priceImpact = new sdkCore.Percent(priceImpact.numerator, priceImpact.denominator);\n      return this._priceImpact;\n    }\n  }]);\n  return MixedRouteTrade;\n}();\n(function (Protocol) {\n  Protocol[\"V2\"] = \"V2\";\n  Protocol[\"V3\"] = \"V3\";\n  Protocol[\"MIXED\"] = \"MIXED\";\n})(exports.Protocol || (exports.Protocol = {}));\nvar RouteV2 = /*#__PURE__*/function (_V2RouteSDK) {\n  _inheritsLoose(RouteV2, _V2RouteSDK);\n  function RouteV2(v2Route) {\n    var _this;\n    _this = _V2RouteSDK.call(this, v2Route.pairs, v2Route.input, v2Route.output) || this;\n    _this.protocol = exports.Protocol.V2;\n    _this.pools = _this.pairs;\n    return _this;\n  }\n  return RouteV2;\n}(v2Sdk.Route); // V3 route wrapper\n\nvar RouteV3 = /*#__PURE__*/function (_V3RouteSDK) {\n  _inheritsLoose(RouteV3, _V3RouteSDK);\n  function RouteV3(v3Route) {\n    var _this2;\n    _this2 = _V3RouteSDK.call(this, v3Route.pools, v3Route.input, v3Route.output) || this;\n    _this2.protocol = exports.Protocol.V3;\n    _this2.path = v3Route.tokenPath;\n    return _this2;\n  }\n  return RouteV3;\n}(v3Sdk.Route); // Mixed route wrapper\n\nvar MixedRoute = /*#__PURE__*/function (_MixedRouteSDK) {\n  _inheritsLoose(MixedRoute, _MixedRouteSDK);\n  function MixedRoute(mixedRoute) {\n    var _this3;\n    _this3 = _MixedRouteSDK.call(this, mixedRoute.pools, mixedRoute.input, mixedRoute.output) || this;\n    _this3.protocol = exports.Protocol.MIXED;\n    return _this3;\n  }\n  return MixedRoute;\n}(MixedRouteSDK);\nvar Trade = /*#__PURE__*/function () {\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  function Trade(_ref) {\n    var v2Routes = _ref.v2Routes,\n      v3Routes = _ref.v3Routes,\n      tradeType = _ref.tradeType,\n      mixedRoutes = _ref.mixedRoutes;\n    this.swaps = [];\n    this.routes = []; // wrap v2 routes\n\n    for (var _iterator = _createForOfIteratorHelperLoose(v2Routes), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        routev2 = _step$value.routev2,\n        _inputAmount = _step$value.inputAmount,\n        _outputAmount = _step$value.outputAmount;\n      var _route = new RouteV2(routev2);\n      this.routes.push(_route);\n      this.swaps.push({\n        route: _route,\n        inputAmount: _inputAmount,\n        outputAmount: _outputAmount\n      });\n    } // wrap v3 routes\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(v3Routes), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n        routev3 = _step2$value.routev3,\n        _inputAmount2 = _step2$value.inputAmount,\n        _outputAmount2 = _step2$value.outputAmount;\n      var _route2 = new RouteV3(routev3);\n      this.routes.push(_route2);\n      this.swaps.push({\n        route: _route2,\n        inputAmount: _inputAmount2,\n        outputAmount: _outputAmount2\n      });\n    } // wrap mixedRoutes\n\n    if (mixedRoutes) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(mixedRoutes), _step3; !(_step3 = _iterator3()).done;) {\n        var _step3$value = _step3.value,\n          mixedRoute = _step3$value.mixedRoute,\n          inputAmount = _step3$value.inputAmount,\n          outputAmount = _step3$value.outputAmount;\n        var route = new MixedRoute(mixedRoute);\n        this.routes.push(route);\n        this.swaps.push({\n          route: route,\n          inputAmount: inputAmount,\n          outputAmount: outputAmount\n        });\n      }\n    }\n    this.tradeType = tradeType; // each route must have the same input and output currency\n\n    var inputCurrency = this.swaps[0].inputAmount.currency;\n    var outputCurrency = this.swaps[0].outputAmount.currency;\n    !this.swaps.every(function (_ref2) {\n      var route = _ref2.route;\n      return inputCurrency.wrapped.equals(route.input.wrapped);\n    }) ? invariant(false, 'INPUT_CURRENCY_MATCH') : void 0;\n    !this.swaps.every(function (_ref3) {\n      var route = _ref3.route;\n      return outputCurrency.wrapped.equals(route.output.wrapped);\n    }) ? invariant(false, 'OUTPUT_CURRENCY_MATCH') : void 0; // pools must be unique inter protocols\n\n    var numPools = this.swaps.map(function (_ref4) {\n      var route = _ref4.route;\n      return route.pools.length;\n    }).reduce(function (total, cur) {\n      return total + cur;\n    }, 0);\n    var poolAddressSet = new Set();\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done;) {\n      var _route3 = _step4.value.route;\n      for (var _iterator5 = _createForOfIteratorHelperLoose(_route3.pools), _step5; !(_step5 = _iterator5()).done;) {\n        var pool = _step5.value;\n        if (pool instanceof v3Sdk.Pool) {\n          poolAddressSet.add(v3Sdk.Pool.getAddress(pool.token0, pool.token1, pool.fee));\n        } else if (pool instanceof v2Sdk.Pair) {\n          var pair = pool;\n          poolAddressSet.add(v2Sdk.Pair.getAddress(pair.token0, pair.token1));\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object');\n        }\n      }\n    }\n    !(numPools == poolAddressSet.size) ? invariant(false, 'POOLS_DUPLICATED') : void 0;\n  }\n  var _proto = Trade.prototype;\n\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n   * @returns The amount out\r\n   */\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {\n    if (amountOut === void 0) {\n      amountOut = this.outputAmount;\n    }\n    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0;\n    if (this.tradeType === sdkCore.TradeType.EXACT_OUTPUT) {\n      return amountOut;\n    } else {\n      var slippageAdjustedAmountOut = new sdkCore.Fraction(ONE).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;\n      return sdkCore.CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n   * @returns The amount in\r\n   */;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {\n    if (amountIn === void 0) {\n      amountIn = this.inputAmount;\n    }\n    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0;\n    if (this.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n      return amountIn;\n    } else {\n      var slippageAdjustedAmountIn = new sdkCore.Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient;\n      return sdkCore.CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Return the execution price after accounting for slippage tolerance\r\n   * @param slippageTolerance the allowed tolerated slippage\r\n   * @returns The execution price\r\n   */;\n\n  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {\n    return new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  };\n  Trade.fromRoutes = /*#__PURE__*/function () {\n    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(v2Routes, v3Routes, tradeType, mixedRoutes) {\n      var populatedV2Routes, populatedV3Routes, populatedMixedRoutes, _iterator6, _step6, _step6$value, routev2, _amount, v2Trade, _inputAmount3, _outputAmount3, _iterator7, _step7, _step7$value, routev3, _amount2, v3Trade, _inputAmount4, _outputAmount4, _iterator8, _step8, _step8$value, mixedRoute, amount, mixedRouteTrade, inputAmount, outputAmount;\n      return runtime_1.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              populatedV2Routes = [];\n              populatedV3Routes = [];\n              populatedMixedRoutes = [];\n              for (_iterator6 = _createForOfIteratorHelperLoose(v2Routes); !(_step6 = _iterator6()).done;) {\n                _step6$value = _step6.value, routev2 = _step6$value.routev2, _amount = _step6$value.amount;\n                v2Trade = new v2Sdk.Trade(routev2, _amount, tradeType);\n                _inputAmount3 = v2Trade.inputAmount, _outputAmount3 = v2Trade.outputAmount;\n                populatedV2Routes.push({\n                  routev2: routev2,\n                  inputAmount: _inputAmount3,\n                  outputAmount: _outputAmount3\n                });\n              }\n              _iterator7 = _createForOfIteratorHelperLoose(v3Routes);\n            case 5:\n              if ((_step7 = _iterator7()).done) {\n                _context.next = 14;\n                break;\n              }\n              _step7$value = _step7.value, routev3 = _step7$value.routev3, _amount2 = _step7$value.amount;\n              _context.next = 9;\n              return v3Sdk.Trade.fromRoute(routev3, _amount2, tradeType);\n            case 9:\n              v3Trade = _context.sent;\n              _inputAmount4 = v3Trade.inputAmount, _outputAmount4 = v3Trade.outputAmount;\n              populatedV3Routes.push({\n                routev3: routev3,\n                inputAmount: _inputAmount4,\n                outputAmount: _outputAmount4\n              });\n            case 12:\n              _context.next = 5;\n              break;\n            case 14:\n              if (!mixedRoutes) {\n                _context.next = 25;\n                break;\n              }\n              _iterator8 = _createForOfIteratorHelperLoose(mixedRoutes);\n            case 16:\n              if ((_step8 = _iterator8()).done) {\n                _context.next = 25;\n                break;\n              }\n              _step8$value = _step8.value, mixedRoute = _step8$value.mixedRoute, amount = _step8$value.amount;\n              _context.next = 20;\n              return MixedRouteTrade.fromRoute(mixedRoute, amount, tradeType);\n            case 20:\n              mixedRouteTrade = _context.sent;\n              inputAmount = mixedRouteTrade.inputAmount, outputAmount = mixedRouteTrade.outputAmount;\n              populatedMixedRoutes.push({\n                mixedRoute: mixedRoute,\n                inputAmount: inputAmount,\n                outputAmount: outputAmount\n              });\n            case 23:\n              _context.next = 16;\n              break;\n            case 25:\n              return _context.abrupt(\"return\", new Trade({\n                v2Routes: populatedV2Routes,\n                v3Routes: populatedV3Routes,\n                mixedRoutes: populatedMixedRoutes,\n                tradeType: tradeType\n              }));\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function fromRoutes(_x, _x2, _x3, _x4) {\n      return _fromRoutes.apply(this, arguments);\n    }\n    return fromRoutes;\n  }();\n  Trade.fromRoute = /*#__PURE__*/function () {\n    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(route, amount, tradeType) {\n      var v2Routes, v3Routes, mixedRoutes, v2Trade, inputAmount, outputAmount, v3Trade, _inputAmount5, _outputAmount5, mixedRouteTrade, _inputAmount6, _outputAmount6;\n      return runtime_1.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              v2Routes = [];\n              v3Routes = [];\n              mixedRoutes = [];\n              if (!(route instanceof v2Sdk.Route)) {\n                _context2.next = 9;\n                break;\n              }\n              v2Trade = new v2Sdk.Trade(route, amount, tradeType);\n              inputAmount = v2Trade.inputAmount, outputAmount = v2Trade.outputAmount;\n              v2Routes = [{\n                routev2: route,\n                inputAmount: inputAmount,\n                outputAmount: outputAmount\n              }];\n              _context2.next = 26;\n              break;\n            case 9:\n              if (!(route instanceof v3Sdk.Route)) {\n                _context2.next = 17;\n                break;\n              }\n              _context2.next = 12;\n              return v3Sdk.Trade.fromRoute(route, amount, tradeType);\n            case 12:\n              v3Trade = _context2.sent;\n              _inputAmount5 = v3Trade.inputAmount, _outputAmount5 = v3Trade.outputAmount;\n              v3Routes = [{\n                routev3: route,\n                inputAmount: _inputAmount5,\n                outputAmount: _outputAmount5\n              }];\n              _context2.next = 26;\n              break;\n            case 17:\n              if (!(route instanceof MixedRouteSDK)) {\n                _context2.next = 25;\n                break;\n              }\n              _context2.next = 20;\n              return MixedRouteTrade.fromRoute(route, amount, tradeType);\n            case 20:\n              mixedRouteTrade = _context2.sent;\n              _inputAmount6 = mixedRouteTrade.inputAmount, _outputAmount6 = mixedRouteTrade.outputAmount;\n              mixedRoutes = [{\n                mixedRoute: route,\n                inputAmount: _inputAmount6,\n                outputAmount: _outputAmount6\n              }];\n              _context2.next = 26;\n              break;\n            case 25:\n              throw new Error('Invalid route type');\n            case 26:\n              return _context2.abrupt(\"return\", new Trade({\n                v2Routes: v2Routes,\n                v3Routes: v3Routes,\n                mixedRoutes: mixedRoutes,\n                tradeType: tradeType\n              }));\n            case 27:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    function fromRoute(_x5, _x6, _x7) {\n      return _fromRoute.apply(this, arguments);\n    }\n    return fromRoute;\n  }();\n  _createClass(Trade, [{\n    key: \"inputAmount\",\n    get: function get() {\n      if (this._inputAmount) {\n        return this._inputAmount;\n      }\n      var inputCurrency = this.swaps[0].inputAmount.currency;\n      var totalInputFromRoutes = this.swaps.map(function (_ref5) {\n        var inputAmount = _ref5.inputAmount;\n        return inputAmount;\n      }).reduce(function (total, cur) {\n        return total.add(cur);\n      }, sdkCore.CurrencyAmount.fromRawAmount(inputCurrency, 0));\n      this._inputAmount = totalInputFromRoutes;\n      return this._inputAmount;\n    }\n  }, {\n    key: \"outputAmount\",\n    get: function get() {\n      if (this._outputAmount) {\n        return this._outputAmount;\n      }\n      var outputCurrency = this.swaps[0].outputAmount.currency;\n      var totalOutputFromRoutes = this.swaps.map(function (_ref6) {\n        var outputAmount = _ref6.outputAmount;\n        return outputAmount;\n      }).reduce(function (total, cur) {\n        return total.add(cur);\n      }, sdkCore.CurrencyAmount.fromRawAmount(outputCurrency, 0));\n      this._outputAmount = totalOutputFromRoutes;\n      return this._outputAmount;\n    }\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\n  }, {\n    key: \"executionPrice\",\n    get: function get() {\n      var _this$_executionPrice;\n      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    }\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\n  }, {\n    key: \"priceImpact\",\n    get: function get() {\n      if (this._priceImpact) {\n        return this._priceImpact;\n      }\n      var spotOutputAmount = sdkCore.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);\n      for (var _iterator9 = _createForOfIteratorHelperLoose(this.swaps), _step9; !(_step9 = _iterator9()).done;) {\n        var _step9$value = _step9.value,\n          route = _step9$value.route,\n          inputAmount = _step9$value.inputAmount;\n        var midPrice = route.midPrice;\n        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));\n      }\n      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);\n      this._priceImpact = new sdkCore.Percent(priceImpact.numerator, priceImpact.denominator);\n      return this._priceImpact;\n    }\n  }]);\n  return Trade;\n}();\n\n/**\r\n * Converts a route to a hex encoded path\r\n * @notice only supports exactIn route encodings\r\n * @param route the mixed path to convert to an encoded path\r\n * @returns the exactIn encoded path\r\n */\n\nfunction encodeMixedRouteToPath(route) {\n  var firstInputToken = route.input.wrapped;\n  var _route$pools$reduce = route.pools.reduce(function (_ref, pool, index) {\n      var inputToken = _ref.inputToken,\n        path = _ref.path,\n        types = _ref.types;\n      var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [inputToken.address, pool instanceof v3Sdk.Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address]\n        };\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [].concat(types, ['uint24', 'address']),\n          path: [].concat(path, [pool instanceof v3Sdk.Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address])\n        };\n      }\n    }, {\n      inputToken: firstInputToken,\n      path: [],\n      types: []\n    }),\n    path = _route$pools$reduce.path,\n    types = _route$pools$reduce.types;\n  return solidity.pack(types, path);\n}\n\n/**\r\n * Utility function to return each consecutive section of Pools or Pairs in a MixedRoute\r\n * @param route\r\n * @returns a nested array of Pools or Pairs in the order of the route\r\n */\n\nvar partitionMixedRouteByProtocol = function partitionMixedRouteByProtocol(route) {\n  var acc = [];\n  var left = 0;\n  var right = 0;\n  while (right < route.pools.length) {\n    if (route.pools[left] instanceof v3Sdk.Pool && route.pools[right] instanceof v2Sdk.Pair || route.pools[left] instanceof v2Sdk.Pair && route.pools[right] instanceof v3Sdk.Pool) {\n      acc.push(route.pools.slice(left, right));\n      left = right;\n    } // seek forward with right pointer\n\n    right++;\n    if (right === route.pools.length) {\n      /// we reached the end, take the rest\n      acc.push(route.pools.slice(left, right));\n    }\n  }\n  return acc;\n};\n/**\r\n * Simple utility function to get the output of an array of Pools or Pairs\r\n * @param pools\r\n * @param firstInputToken\r\n * @returns the output token of the last pool in the array\r\n */\n\nvar getOutputOfPools = function getOutputOfPools(pools, firstInputToken) {\n  var _pools$reduce = pools.reduce(function (_ref, pool) {\n      var inputToken = _ref.inputToken;\n      if (!pool.involvesToken(inputToken)) throw new Error('PATH');\n      var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;\n      return {\n        inputToken: outputToken\n      };\n    }, {\n      inputToken: firstInputToken\n    }),\n    outputToken = _pools$reduce.inputToken;\n  return outputToken;\n};\nvar ZERO$1 = /*#__PURE__*/JSBI.BigInt(0);\nvar REFUND_ETH_PRICE_IMPACT_THRESHOLD = /*#__PURE__*/new sdkCore.Percent( /*#__PURE__*/JSBI.BigInt(50), /*#__PURE__*/JSBI.BigInt(100));\n/**\r\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\r\n */\n\nvar SwapRouter = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function SwapRouter() {}\n  /**\r\n   * @notice Generates the calldata for a Swap with a V2 Route.\r\n   * @param trade The V2Trade to encode.\r\n   * @param options SwapOptions to use for the trade.\r\n   * @param routerMustCustody Flag for whether funds should be sent to the router\r\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\r\n   * @returns A string array of calldatas for the trade.\r\n   */\n\n  SwapRouter.encodeV2Swap = function encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck) {\n    var amountIn = v3Sdk.toHex(trade.maximumAmountIn(options.slippageTolerance).quotient);\n    var amountOut = v3Sdk.toHex(trade.minimumAmountOut(options.slippageTolerance).quotient);\n    var path = trade.route.path.map(function (token) {\n      return token.address;\n    });\n    var recipient = routerMustCustody ? ADDRESS_THIS : typeof options.recipient === 'undefined' ? MSG_SENDER : sdkCore.validateAndParseAddress(options.recipient);\n    if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n      var exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient];\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams);\n    } else {\n      var exactOutputParams = [amountOut, amountIn, path, recipient];\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams);\n    }\n  }\n  /**\r\n   * @notice Generates the calldata for a Swap with a V3 Route.\r\n   * @param trade The V3Trade to encode.\r\n   * @param options SwapOptions to use for the trade.\r\n   * @param routerMustCustody Flag for whether funds should be sent to the router\r\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\r\n   * @returns A string array of calldatas for the trade.\r\n   */;\n\n  SwapRouter.encodeV3Swap = function encodeV3Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck) {\n    var calldatas = [];\n    for (var _iterator = _createForOfIteratorHelperLoose(trade.swaps), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        route = _step$value.route,\n        inputAmount = _step$value.inputAmount,\n        outputAmount = _step$value.outputAmount;\n      var amountIn = v3Sdk.toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);\n      var amountOut = v3Sdk.toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient); // flag for whether the trade is single hop or not\n\n      var singleHop = route.pools.length === 1;\n      var recipient = routerMustCustody ? ADDRESS_THIS : typeof options.recipient === 'undefined' ? MSG_SENDER : sdkCore.validateAndParseAddress(options.recipient);\n      if (singleHop) {\n        if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n          var exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient: recipient,\n            amountIn: amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]));\n        } else {\n          var exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient: recipient,\n            amountOut: amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]));\n        }\n      } else {\n        var path = v3Sdk.encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);\n        if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n          var exactInputParams = {\n            path: path,\n            recipient: recipient,\n            amountIn: amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]));\n        } else {\n          var exactOutputParams = {\n            path: path,\n            recipient: recipient,\n            amountOut: amountOut,\n            amountInMaximum: amountIn\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]));\n        }\n      }\n    }\n    return calldatas;\n  }\n  /**\r\n   * @notice Generates the calldata for a MixedRouteSwap. Since single hop routes are not MixedRoutes, we will instead generate\r\n   *         them via the existing encodeV3Swap and encodeV2Swap methods.\r\n   * @param trade The MixedRouteTrade to encode.\r\n   * @param options SwapOptions to use for the trade.\r\n   * @param routerMustCustody Flag for whether funds should be sent to the router\r\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\r\n   * @returns A string array of calldatas for the trade.\r\n   */;\n\n  SwapRouter.encodeMixedRouteSwap = function encodeMixedRouteSwap(trade, options, routerMustCustody, performAggregatedSlippageCheck) {\n    var calldatas = [];\n    !(trade.tradeType === sdkCore.TradeType.EXACT_INPUT) ? invariant(false, 'TRADE_TYPE') : void 0;\n    for (var _iterator2 = _createForOfIteratorHelperLoose(trade.swaps), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n        route = _step2$value.route,\n        inputAmount = _step2$value.inputAmount,\n        outputAmount = _step2$value.outputAmount;\n      var amountIn = v3Sdk.toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);\n      var amountOut = v3Sdk.toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient); // flag for whether the trade is single hop or not\n\n      var singleHop = route.pools.length === 1;\n      var recipient = routerMustCustody ? ADDRESS_THIS : typeof options.recipient === 'undefined' ? MSG_SENDER : sdkCore.validateAndParseAddress(options.recipient);\n      var mixedRouteIsAllV3 = function mixedRouteIsAllV3(route) {\n        return route.pools.every(function (pool) {\n          return pool instanceof v3Sdk.Pool;\n        });\n      };\n      if (singleHop) {\n        /// For single hop, since it isn't really a mixedRoute, we'll just mimic behavior of V3 or V2\n        /// We don't use encodeV3Swap() or encodeV2Swap() because casting the trade to a V3Trade or V2Trade is overcomplex\n        if (mixedRouteIsAllV3(route)) {\n          var exactInputSingleParams = {\n            tokenIn: route.path[0].address,\n            tokenOut: route.path[1].address,\n            fee: route.pools[0].fee,\n            recipient: recipient,\n            amountIn: amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]));\n        } else {\n          var path = route.path.map(function (token) {\n            return token.address;\n          });\n          var exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient];\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams));\n        }\n      } else {\n        (function () {\n          var sections = partitionMixedRouteByProtocol(route);\n          var isLastSectionInRoute = function isLastSectionInRoute(i) {\n            return i === sections.length - 1;\n          };\n          var outputToken = void 0;\n          var inputToken = route.input.wrapped;\n          for (var i = 0; i < sections.length; i++) {\n            var section = sections[i]; /// Now, we get output of this section\n\n            outputToken = getOutputOfPools(section, inputToken);\n            var newRouteOriginal = new MixedRouteSDK([].concat(section), section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1, outputToken);\n            var newRoute = new MixedRoute(newRouteOriginal); /// Previous output is now input\n\n            inputToken = outputToken;\n            if (mixedRouteIsAllV3(newRoute)) {\n              var _path = encodeMixedRouteToPath(newRoute);\n              var _exactInputParams = {\n                path: _path,\n                // By default router holds funds until the last swap, then it is sent to the recipient\n                // special case exists where we are unwrapping WETH output, in which case `routerMustCustody` is set to true\n                // and router still holds the funds. That logic bundled into how the value of `recipient` is calculated\n                recipient: isLastSectionInRoute(i) ? recipient : ADDRESS_THIS,\n                amountIn: i == 0 ? amountIn : 0,\n                amountOutMinimum: !isLastSectionInRoute(i) ? 0 : amountOut\n              };\n              calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [_exactInputParams]));\n            } else {\n              var _exactInputParams2 = [i == 0 ? amountIn : 0, !isLastSectionInRoute(i) ? 0 : amountOut, newRoute.path.map(function (token) {\n                return token.address;\n              }), isLastSectionInRoute(i) ? recipient : ADDRESS_THIS];\n              calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', _exactInputParams2));\n            }\n          }\n        })();\n      }\n    }\n    return calldatas;\n  };\n  SwapRouter.encodeSwaps = function encodeSwaps(trades, options, isSwapAndAdd) {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual trade objects.\n    if (trades instanceof Trade) {\n      !trades.swaps.every(function (swap) {\n        return swap.route.protocol == exports.Protocol.V3 || swap.route.protocol == exports.Protocol.V2 || swap.route.protocol == exports.Protocol.MIXED;\n      }) ? invariant(false, 'UNSUPPORTED_PROTOCOL') : void 0;\n      var individualTrades = [];\n      for (var _iterator3 = _createForOfIteratorHelperLoose(trades.swaps), _step3; !(_step3 = _iterator3()).done;) {\n        var _step3$value = _step3.value,\n          route = _step3$value.route,\n          inputAmount = _step3$value.inputAmount,\n          outputAmount = _step3$value.outputAmount;\n        if (route.protocol == exports.Protocol.V2) {\n          individualTrades.push(new v2Sdk.Trade(route, trades.tradeType == sdkCore.TradeType.EXACT_INPUT ? inputAmount : outputAmount, trades.tradeType));\n        } else if (route.protocol == exports.Protocol.V3) {\n          individualTrades.push(v3Sdk.Trade.createUncheckedTrade({\n            route: route,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            tradeType: trades.tradeType\n          }));\n        } else if (route.protocol == exports.Protocol.MIXED) {\n          individualTrades.push(\n          /// we can change the naming of this function on MixedRouteTrade if needed\n          MixedRouteTrade.createUncheckedTrade({\n            route: route,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            tradeType: trades.tradeType\n          }));\n        } else {\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL');\n        }\n      }\n      trades = individualTrades;\n    }\n    if (!Array.isArray(trades)) {\n      trades = [trades];\n    }\n    var numberOfTrades = trades.reduce(function (numberOfTrades, trade) {\n      return numberOfTrades + (trade instanceof v3Sdk.Trade || trade instanceof MixedRouteTrade ? trade.swaps.length : 1);\n    }, 0);\n    var sampleTrade = trades[0]; // All trades should have the same starting/ending currency and trade type\n\n    !trades.every(function (trade) {\n      return trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency);\n    }) ? invariant(false, 'TOKEN_IN_DIFF') : void 0;\n    !trades.every(function (trade) {\n      return trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency);\n    }) ? invariant(false, 'TOKEN_OUT_DIFF') : void 0;\n    !trades.every(function (trade) {\n      return trade.tradeType === sampleTrade.tradeType;\n    }) ? invariant(false, 'TRADE_TYPE_DIFF') : void 0;\n    var calldatas = [];\n    var inputIsNative = sampleTrade.inputAmount.currency.isNative;\n    var outputIsNative = sampleTrade.outputAmount.currency.isNative; // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n\n    var performAggregatedSlippageCheck = sampleTrade.tradeType === sdkCore.TradeType.EXACT_INPUT && numberOfTrades > 2; // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n\n    var routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck; // encode permit if necessary\n\n    if (options.inputTokenPermit) {\n      !sampleTrade.inputAmount.currency.isToken ? invariant(false, 'NON_TOKEN_PERMIT') : void 0;\n      calldatas.push(v3Sdk.SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));\n    }\n    for (var _iterator4 = _createForOfIteratorHelperLoose(trades), _step4; !(_step4 = _iterator4()).done;) {\n      var trade = _step4.value;\n      if (trade instanceof v2Sdk.Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck));\n      } else if (trade instanceof v3Sdk.Trade) {\n        for (var _iterator5 = _createForOfIteratorHelperLoose(SwapRouter.encodeV3Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck)), _step5; !(_step5 = _iterator5()).done;) {\n          var calldata = _step5.value;\n          calldatas.push(calldata);\n        }\n      } else if (trade instanceof MixedRouteTrade) {\n        for (var _iterator6 = _createForOfIteratorHelperLoose(SwapRouter.encodeMixedRouteSwap(trade, options, routerMustCustody, performAggregatedSlippageCheck)), _step6; !(_step6 = _iterator6()).done;) {\n          var _calldata = _step6.value;\n          calldatas.push(_calldata);\n        }\n      } else {\n        throw new Error('Unsupported trade object');\n      }\n    }\n    var ZERO_IN = sdkCore.CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0);\n    var ZERO_OUT = sdkCore.CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0);\n    var minimumAmountOut = trades.reduce(function (sum, trade) {\n      return sum.add(trade.minimumAmountOut(options.slippageTolerance));\n    }, ZERO_OUT);\n    var quoteAmountOut = trades.reduce(function (sum, trade) {\n      return sum.add(trade.outputAmount);\n    }, ZERO_OUT);\n    var totalAmountIn = trades.reduce(function (sum, trade) {\n      return sum.add(trade.maximumAmountIn(options.slippageTolerance));\n    }, ZERO_IN);\n    return {\n      calldatas: calldatas,\n      sampleTrade: sampleTrade,\n      routerMustCustody: routerMustCustody,\n      inputIsNative: inputIsNative,\n      outputIsNative: outputIsNative,\n      totalAmountIn: totalAmountIn,\n      minimumAmountOut: minimumAmountOut,\n      quoteAmountOut: quoteAmountOut\n    };\n  }\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trades to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */;\n\n  SwapRouter.swapCallParameters = function swapCallParameters(trades, options) {\n    var _SwapRouter$encodeSwa = SwapRouter.encodeSwaps(trades, options),\n      calldatas = _SwapRouter$encodeSwa.calldatas,\n      sampleTrade = _SwapRouter$encodeSwa.sampleTrade,\n      routerMustCustody = _SwapRouter$encodeSwa.routerMustCustody,\n      inputIsNative = _SwapRouter$encodeSwa.inputIsNative,\n      outputIsNative = _SwapRouter$encodeSwa.outputIsNative,\n      totalAmountIn = _SwapRouter$encodeSwa.totalAmountIn,\n      minimumAmountOut = _SwapRouter$encodeSwa.minimumAmountOut; // unwrap or sweep\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee));\n      } else {\n        calldatas.push(PaymentsExtended.encodeSweepToken(sampleTrade.outputAmount.currency.wrapped, minimumAmountOut.quotient, options.recipient, options.fee));\n      }\n    } // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n\n    if (inputIsNative && (sampleTrade.tradeType === sdkCore.TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(v3Sdk.Payments.encodeRefundETH());\n    }\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: v3Sdk.toHex(inputIsNative ? totalAmountIn.quotient : ZERO$1)\n    };\n  }\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trades to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */;\n\n  SwapRouter.swapAndAddCallParameters = function swapAndAddCallParameters(trades, options, position, addLiquidityOptions, tokenInApprovalType, tokenOutApprovalType) {\n    var _SwapRouter$encodeSwa2 = SwapRouter.encodeSwaps(trades, options, true),\n      calldatas = _SwapRouter$encodeSwa2.calldatas,\n      inputIsNative = _SwapRouter$encodeSwa2.inputIsNative,\n      outputIsNative = _SwapRouter$encodeSwa2.outputIsNative,\n      sampleTrade = _SwapRouter$encodeSwa2.sampleTrade,\n      totalAmountSwapped = _SwapRouter$encodeSwa2.totalAmountIn,\n      quoteAmountOut = _SwapRouter$encodeSwa2.quoteAmountOut,\n      minimumAmountOut = _SwapRouter$encodeSwa2.minimumAmountOut; // encode output token permit if necessary\n\n    if (options.outputTokenPermit) {\n      !quoteAmountOut.currency.isToken ? invariant(false, 'NON_TOKEN_PERMIT_OUTPUT') : void 0;\n      calldatas.push(v3Sdk.SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit));\n    }\n    var chainId = sampleTrade.route.chainId;\n    var zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address;\n    var _SwapRouter$getPositi = SwapRouter.getPositionAmounts(position, zeroForOne),\n      positionAmountIn = _SwapRouter$getPositi.positionAmountIn,\n      positionAmountOut = _SwapRouter$getPositi.positionAmountOut; // if tokens are native they will be converted to WETH9\n\n    var tokenIn = inputIsNative ? sdkCore.WETH9[chainId] : positionAmountIn.currency.wrapped;\n    var tokenOut = outputIsNative ? sdkCore.WETH9[chainId] : positionAmountOut.currency.wrapped; // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n\n    var amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped);\n    if (amountOutRemaining.greaterThan(sdkCore.CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient)) : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient));\n    } // if input is native, convert to WETH9, else pull ERC20 token\n\n    inputIsNative ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient)) : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient)); // approve token balances to NFTManager\n\n    if (tokenInApprovalType !== exports.ApprovalTypes.NOT_REQUIRED) calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType));\n    if (tokenOutApprovalType !== exports.ApprovalTypes.NOT_REQUIRED) calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType)); // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n\n    var minimalPosition = v3Sdk.Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false\n    }); // encode NFTManager add liquidity\n\n    calldatas.push(ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)); // sweep remaining tokens\n\n    inputIsNative ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO$1)) : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO$1));\n    outputIsNative ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO$1)) : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO$1));\n    var value;\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient;\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient;\n    } else {\n      value = ZERO$1;\n    }\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString()\n    };\n  } // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  ;\n\n  SwapRouter.riskOfPartialFill = function riskOfPartialFill(trades) {\n    if (Array.isArray(trades)) {\n      return trades.some(function (trade) {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade);\n      });\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades);\n    }\n  };\n  SwapRouter.v3TradeWithHighPriceImpact = function v3TradeWithHighPriceImpact(trade) {\n    return !(trade instanceof v2Sdk.Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD);\n  };\n  SwapRouter.getPositionAmounts = function getPositionAmounts(position, zeroForOne) {\n    var _position$mintAmounts = position.mintAmounts,\n      amount0 = _position$mintAmounts.amount0,\n      amount1 = _position$mintAmounts.amount1;\n    var currencyAmount0 = sdkCore.CurrencyAmount.fromRawAmount(position.pool.token0, amount0);\n    var currencyAmount1 = sdkCore.CurrencyAmount.fromRawAmount(position.pool.token1, amount1);\n    var _ref = zeroForOne ? [currencyAmount0, currencyAmount1] : [currencyAmount1, currencyAmount0],\n      positionAmountIn = _ref[0],\n      positionAmountOut = _ref[1];\n    return {\n      positionAmountIn: positionAmountIn,\n      positionAmountOut: positionAmountOut\n    };\n  };\n  return SwapRouter;\n}();\nSwapRouter.INTERFACE = /*#__PURE__*/new abi.Interface(ISwapRouter02_json.abi);\nexports.ADDRESS_THIS = ADDRESS_THIS;\nexports.ApproveAndCall = ApproveAndCall;\nexports.MSG_SENDER = MSG_SENDER;\nexports.MixedRoute = MixedRoute;\nexports.MixedRouteSDK = MixedRouteSDK;\nexports.MixedRouteTrade = MixedRouteTrade;\nexports.MulticallExtended = MulticallExtended;\nexports.ONE = ONE;\nexports.PaymentsExtended = PaymentsExtended;\nexports.RouteV2 = RouteV2;\nexports.RouteV3 = RouteV3;\nexports.SwapRouter = SwapRouter;\nexports.Trade = Trade;\nexports.V2_FEE_PATH_PLACEHOLDER = V2_FEE_PATH_PLACEHOLDER;\nexports.ZERO = ZERO;\nexports.encodeMixedRouteToPath = encodeMixedRouteToPath;\nexports.getOutputOfPools = getOutputOfPools;\nexports.isMint = isMint;\nexports.partitionMixedRouteByProtocol = partitionMixedRouteByProtocol;\nexports.tradeComparator = tradeComparator;","map":{"version":3,"sources":["../src/constants.ts","../src/approveAndCall.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../node_modules/regenerator-runtime/runtime.js","../src/entities/mixedRoute/route.ts","../src/entities/mixedRoute/trade.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/utils/encodeMixedRouteToPath.ts","../src/utils/index.ts","../src/swapRouter.ts"],"names":["MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","V2_FEE_PATH_PLACEHOLDER","ApprovalTypes","isMint","options","keys","some","k","ApproveAndCall","Interface","abi","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","amount0","amount0Min","amount1","amount1Min","mintAmountsWithSlippage","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","validateAndParseBytes32","bytes32","match","Error","toLowerCase","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","undefined","MixedRouteSDK","pools","input","output","chainId","allOnSameChain","every","wrappedInput","involvesToken","tokenPath","i","entries","currentInputToken","equals","nextToken","push","path","_midPrice","price","slice","reduce","nextInput","token0Price","token1Price","Price","denominator","numerator","tradeComparator","a","b","inputAmount","currency","outputAmount","equalTo","aHops","swaps","total","cur","route","bHops","MixedRouteTrade","_inputAmount","inputCurrency","totalInputFromRoutes","map","add","CurrencyAmount","fromRawAmount","_outputAmount","outputCurrency","totalOutputFromRoutes","_executionPrice","_priceImpact","spotOutputAmount","midPrice","quote","priceImpact","subtract","divide","Percent","fromRoute","tradeType","amounts","TradeType","EXACT_INPUT","getOutputAmount","fromFractionalAmount","routes","fromRoutes","populatedRoutes","createUncheckedTrade","constructorArguments","createUncheckedTradeWithMultipleRoutes","numPools","poolAddressSet","Set","Pool","getAddress","Pair","size","minimumAmountOut","amountOut","slippageAdjustedAmountOut","Fraction","invert","maximumAmountIn","amountIn","worstExecutionPrice","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPools","nextAmountIn","bestTrades","tokenOut","reserve0","reserve1","isInsufficientInputAmountError","isToken","sortedInsert","poolsExcludingThisPool","concat","Protocol","RouteV2","V2RouteSDK","V2","v2Route","pairs","RouteV3","V3RouteSDK","V3","v3Route","MixedRoute","MIXED","mixedRoute","Trade","v2Routes","v3Routes","mixedRoutes","routev2","routev3","pair","EXACT_OUTPUT","slippageAdjustedAmountIn","populatedV2Routes","populatedV3Routes","populatedMixedRoutes","v2Trade","V2TradeSDK","v3Trade","V3TradeSDK","mixedRouteTrade","MixedRouteTradeSDK","encodeMixedRouteToPath","firstInputToken","types","inputToken","index","outputToken","pack","partitionMixedRouteByProtocol","acc","left","right","getOutputOfPools","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","exactInputParams","exactOutputParams","encodeV3Swap","singleHop","exactInputSingleParams","tokenIn","amountOutMinimum","sqrtPriceLimitX96","exactOutputSingleParams","amountInMaximum","encodeRouteToPath","encodeMixedRouteSwap","mixedRouteIsAllV3","sections","isLastSectionInRoute","section","newRouteOriginal","newRoute","encodeSwaps","trades","isSwapAndAdd","swap","protocol","individualTrades","V2Trade","numberOfTrades","V3Trade","sampleTrade","inputIsNative","isNative","outputIsNative","inputTokenPermit","SelfPermit","encodePermit","calldata","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","riskOfPartialFill","encodeRefundETH","deadlineOrPreviousBlockhash","value","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","totalAmountSwapped","outputTokenPermit","zeroForOne","positionAmountIn","positionAmountOut","getPositionAmounts","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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","sourcesContent":["import JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n\n// = 1 << 23 or 100000000000000000000000\nexport const V2_FEE_PATH_PLACEHOLDER = 8388608\n","import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw 'Error: invalid ApprovalType'\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\n\ntype TPool = Pair | Pool\n\n/**\n * Represents a list of pools or pairs through which a swap can occur\n * @template TInput The input token\n * @template TOutput The output token\n */\nexport class MixedRouteSDK<TInput extends Currency, TOutput extends Currency> {\n  public readonly pools: TPool[]\n  public readonly path: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  /**\n   * Creates an instance of route.\n   * @param pools An array of `TPool` objects (pools or pairs), ordered by the route the swap will take\n   * @param input The input token\n   * @param output The output token\n   */\n  public constructor(pools: TPool[], input: TInput, output: TOutput) {\n    invariant(pools.length > 0, 'POOLS')\n\n    const chainId = pools[0].chainId\n    const allOnSameChain = pools.every((pool) => pool.chainId === chainId)\n    invariant(allOnSameChain, 'CHAIN_IDS')\n\n    const wrappedInput = input.wrapped\n    invariant(pools[0].involvesToken(wrappedInput), 'INPUT')\n\n    invariant(pools[pools.length - 1].involvesToken(output.wrapped), 'OUTPUT')\n\n    /**\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\n     * */\n    const tokenPath: Token[] = [wrappedInput]\n    for (const [i, pool] of pools.entries()) {\n      const currentInputToken = tokenPath[i]\n      invariant(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1), 'PATH')\n      const nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0\n      tokenPath.push(nextToken)\n    }\n\n    this.pools = pools\n    this.path = tokenPath\n    this.input = input\n    this.output = output ?? tokenPath[tokenPath.length - 1]\n  }\n\n  public get chainId(): number {\n    return this.pools[0].chainId\n  }\n\n  /**\n   * Returns the mid price of the route\n   */\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n\n    const price = this.pools.slice(1).reduce(\n      ({ nextInput, price }, pool) => {\n        return nextInput.equals(pool.token0)\n          ? {\n              nextInput: pool.token1,\n              price: price.multiply(pool.token0Price),\n            }\n          : {\n              nextInput: pool.token0,\n              price: price.multiply(pool.token1Price),\n            }\n      },\n      this.pools[0].token0.equals(this.input.wrapped)\n        ? {\n            nextInput: this.pools[0].token1,\n            price: this.pools[0].token0Price,\n          }\n        : {\n            nextInput: this.pools[0].token0,\n            price: this.pools[0].token1Price,\n          }\n    ).price\n\n    return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))\n  }\n}\n","import { Currency, Fraction, Percent, Price, sortedInsert, CurrencyAmount, TradeType, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { BestTradeOptions, Pool } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../../constants'\nimport { MixedRouteSDK } from './route'\n\n/**\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n * @param a The first trade to compare\n * @param b The second trade to compare\n * @returns A sorted ordering for two neighboring elements in a trade array\n */\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: MixedRouteTrade<TInput, TOutput, TTradeType>,\n  b: MixedRouteTrade<TInput, TOutput, TTradeType>\n) {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      // consider the number of hops since each hop costs gas\n      const aHops = a.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      const bHops = b.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      return aHops - bHops\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n/**\n * Represents a trade executed against a set of routes where some percentage of the input is\n * split across each route.\n *\n * Each route has its own set of pools. Pools can not be re-used across routes.\n *\n * Does not account for slippage, i.e., changes in price environment that can occur between\n * the time the trade is submitted and when it is executed.\n * @notice This class is functionally the same as the `Trade` class in the `@uniswap/v3-sdk` package, aside from typing and some input validation.\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n */\nexport class MixedRouteTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\n   * this will return an error.\n   *\n   * When the trade consists of just a single route, this returns the route of the trade,\n   * i.e. which pools the trade goes through.\n   */\n  public get route(): MixedRouteSDK<TInput, TOutput> {\n    invariant(this.swaps.length == 1, 'MULTIPLE_ROUTES')\n    return this.swaps[0].route\n  }\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade.\n   */\n  public readonly swaps: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n\n  /**\n   * The cached result of the input amount computation\n   * @private\n   */\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  /**\n   * The cached result of the output amount computation\n   * @private\n   */\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  /**\n   * The cached result of the computed execution price\n   * @private\n   */\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Constructs a trade by simulating swaps through the given route\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param route route to swap through\n   * @param amount the amount specified, either input or output, depending on tradeType\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The route\n   */\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const amounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n    let inputAmount: CurrencyAmount<TInput>\n    let outputAmount: CurrencyAmount<TOutput>\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    invariant(amount.currency.equals(route.input), 'INPUT')\n    amounts[0] = amount.wrapped\n    for (let i = 0; i < route.path.length - 1; i++) {\n      const pool = route.pools[i]\n      const [outputAmount] = await pool.getOutputAmount(amounts[i])\n      amounts[i + 1] = outputAmount\n    }\n    inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n    outputAmount = CurrencyAmount.fromFractionalAmount(\n      route.output,\n      amounts[amounts.length - 1].numerator,\n      amounts[amounts.length - 1].denominator\n    )\n\n    return new MixedRouteTrade({\n      routes: [{ inputAmount, outputAmount, route }],\n      tradeType,\n    })\n  }\n\n  /**\n   * Constructs a trade from routes by simulating swaps\n   *\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param routes the routes to swap through and how much of the amount should be routed through each\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The trade\n   */\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    routes: {\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n      route: MixedRouteSDK<TInput, TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const populatedRoutes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, amount } of routes) {\n      const amounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n      let inputAmount: CurrencyAmount<TInput>\n      let outputAmount: CurrencyAmount<TOutput>\n\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      amounts[0] = CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator)\n\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pool = route.pools[i]\n        const [outputAmount] = await pool.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n      }\n\n      outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        amounts[amounts.length - 1].numerator,\n        amounts[amounts.length - 1].denominator\n      )\n\n      populatedRoutes.push({ route, inputAmount, outputAmount })\n    }\n\n    return new MixedRouteTrade({\n      routes: populatedRoutes,\n      tradeType,\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTrade<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade({\n      ...constructorArguments,\n      routes: [\n        {\n          inputAmount: constructorArguments.inputAmount,\n          outputAmount: constructorArguments.outputAmount,\n          route: constructorArguments.route,\n        },\n      ],\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTradeWithMultipleRoutes<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade(constructorArguments)\n  }\n\n  /**\n   * Construct a trade by passing in the pre-computed property values\n   * @param routes The routes through which the trade occurs\n   * @param tradeType The type of trade, exact input or exact output\n   */\n  private constructor({\n    routes,\n    tradeType,\n  }: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    const inputCurrency = routes[0].inputAmount.currency\n    const outputCurrency = routes[0].outputAmount.currency\n    invariant(\n      routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    const numPools = routes.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of routes) {\n      for (const pool of route.pools) {\n        pool instanceof Pool\n          ? poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee))\n          : poolAddressSet.add(Pair.getAddress(pool.token0, pool.token1))\n      }\n    }\n\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    this.swaps = routes\n    this.tradeType = tradeType\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    /// does not support exactOutput, as enforced in the constructor\n    const slippageAdjustedAmountOut = new Fraction(ONE)\n      .add(slippageTolerance)\n      .invert()\n      .multiply(amountOut.quotient).quotient\n    return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    return amountIn\n    /// does not support exactOutput\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pools the pools to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\n   * @param currentPools used in recursion; the current list of pools\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   * @returns The exact in trade\n   */\n  public static async bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pools: (Pool | Pair)[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPools: (Pool | Pair)[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Promise<MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[]> {\n    invariant(pools.length > 0, 'POOLS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn.wrapped\n    const tokenOut = currencyOut.wrapped\n    for (let i = 0; i < pools.length; i++) {\n      const pool = pools[i]\n      // pool irrelevant\n      if (!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency)) continue\n      if (pool instanceof Pair) {\n        if ((pool as Pair).reserve0.equalTo(ZERO) || (pool as Pair).reserve1.equalTo(ZERO)) continue\n      }\n\n      let amountOut: CurrencyAmount<Token>\n      try {\n        ;[amountOut] = await pool.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        // @ts-ignore[2571] error is unknown\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          await MixedRouteTrade.fromRoute(\n            new MixedRouteSDK([...currentPools, pool], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pools.length > 1) {\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        await MixedRouteTrade.bestTradeExactIn(\n          poolsExcludingThisPool,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPools, pool],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n  MIXED = 'MIXED',\n}\n","// entities/route.ts\n\nimport { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { MixedRouteSDK } from './mixedRoute/route'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n\n// Mixed route wrapper\nexport class MixedRoute<TInput extends Currency, TOutput extends Currency>\n  extends MixedRouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool | Pair>\n{\n  public readonly protocol: Protocol = Protocol.MIXED\n\n  constructor(mixedRoute: MixedRouteSDK<TInput, TOutput>) {\n    super(mixedRoute.pools, mixedRoute.input, mixedRoute.output)\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../constants'\nimport { MixedRouteSDK } from './mixedRoute/route'\nimport { MixedRouteTrade as MixedRouteTradeSDK } from './mixedRoute/trade'\nimport { IRoute, MixedRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n    mixedRoutes,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap mixedRoutes\n    if (mixedRoutes) {\n      for (const { mixedRoute, inputAmount, outputAmount } of mixedRoutes) {\n        const route = new MixedRoute(mixedRoute)\n        this.routes.push(route)\n        this.swaps.push({\n          route,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (pool instanceof Pool) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[]\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedMixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    if (mixedRoutes) {\n      for (const { mixedRoute, amount } of mixedRoutes) {\n        const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(mixedRoute, amount, tradeType)\n        const { inputAmount, outputAmount } = mixedRouteTrade\n\n        populatedMixedRoutes.push({\n          mixedRoute,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      mixedRoutes: populatedMixedRoutes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput> | MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let mixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n    } else if (route instanceof V3RouteSDK) {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n    } else if (route instanceof MixedRouteSDK) {\n      const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = mixedRouteTrade\n      mixedRoutes = [{ mixedRoute: route, inputAmount, outputAmount }]\n    } else {\n      throw new Error('Invalid route type')\n    }\n\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      mixedRoutes,\n      tradeType,\n    })\n  }\n}\n","import { pack } from '@ethersproject/solidity'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\nimport { V2_FEE_PATH_PLACEHOLDER } from '../constants'\n\n/**\n * Converts a route to a hex encoded path\n * @notice only supports exactIn route encodings\n * @param route the mixed path to convert to an encoded path\n * @returns the exactIn encoded path\n */\nexport function encodeMixedRouteToPath(route: MixedRouteSDK<Currency, Currency>): string {\n  const firstInputToken: Token = route.input.wrapped\n\n  const { path, types } = route.pools.reduce(\n    (\n      { inputToken, path, types }: { inputToken: Token; path: (string | number)[]; types: string[] },\n      pool: Pool | Pair,\n      index\n    ): { inputToken: Token; path: (string | number)[]; types: string[] } => {\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [inputToken.address, pool instanceof Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address],\n        }\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [...types, 'uint24', 'address'],\n          path: [...path, pool instanceof Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address],\n        }\n      }\n    },\n    { inputToken: firstInputToken, path: [], types: [] }\n  )\n\n  return pack(types, path)\n}\n","import { Currency, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\n\n/**\n * Utility function to return each consecutive section of Pools or Pairs in a MixedRoute\n * @param route\n * @returns a nested array of Pools or Pairs in the order of the route\n */\nexport const partitionMixedRouteByProtocol = (route: MixedRouteSDK<Currency, Currency>): (Pool | Pair)[][] => {\n  let acc = []\n\n  let left = 0\n  let right = 0\n  while (right < route.pools.length) {\n    if (\n      (route.pools[left] instanceof Pool && route.pools[right] instanceof Pair) ||\n      (route.pools[left] instanceof Pair && route.pools[right] instanceof Pool)\n    ) {\n      acc.push(route.pools.slice(left, right))\n      left = right\n    }\n    // seek forward with right pointer\n    right++\n    if (right === route.pools.length) {\n      /// we reached the end, take the rest\n      acc.push(route.pools.slice(left, right))\n    }\n  }\n  return acc\n}\n\n/**\n * Simple utility function to get the output of an array of Pools or Pairs\n * @param pools\n * @param firstInputToken\n * @returns the output token of the last pool in the array\n */\nexport const getOutputOfPools = (pools: (Pool | Pair)[], firstInputToken: Token): Token => {\n  const { inputToken: outputToken } = pools.reduce(\n    ({ inputToken }, pool: Pool | Pair): { inputToken: Token } => {\n      if (!pool.involvesToken(inputToken)) throw new Error('PATH')\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      return {\n        inputToken: outputToken,\n      }\n    },\n    { inputToken: firstInputToken }\n  )\n  return outputToken\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Pool,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { MixedRoute, RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\nimport { MixedRouteTrade } from './entities/mixedRoute/trade'\nimport { encodeMixedRouteToPath } from './utils/encodeMixedRouteToPath'\nimport { MixedRouteSDK } from './entities/mixedRoute/route'\nimport { partitionMixedRouteByProtocol, getOutputOfPools } from './utils'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | MixedRouteTrade<Currency, Currency, TradeType>\n  | (\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    )[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * @notice Generates the calldata for a Swap with a V2 Route.\n   * @param trade The V2Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  /**\n   * @notice Generates the calldata for a Swap with a V3 Route.\n   * @param trade The V3Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  /**\n   * @notice Generates the calldata for a MixedRouteSwap. Since single hop routes are not MixedRoutes, we will instead generate\n   *         them via the existing encodeV3Swap and encodeV2Swap methods.\n   * @param trade The MixedRouteTrade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeMixedRouteSwap(\n    trade: MixedRouteTrade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    invariant(trade.tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n        return route.pools.every((pool) => pool instanceof Pool)\n      }\n\n      if (singleHop) {\n        /// For single hop, since it isn't really a mixedRoute, we'll just mimic behavior of V3 or V2\n        /// We don't use encodeV3Swap() or encodeV2Swap() because casting the trade to a V3Trade or V2Trade is overcomplex\n        if (mixedRouteIsAllV3(route)) {\n          const exactInputSingleParams = {\n            tokenIn: route.path[0].address,\n            tokenOut: route.path[1].address,\n            fee: (route.pools as Pool[])[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const path = route.path.map((token) => token.address)\n\n          const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n        }\n      } else {\n        const sections = partitionMixedRouteByProtocol(route)\n\n        const isLastSectionInRoute = (i: number) => {\n          return i === sections.length - 1\n        }\n\n        let outputToken\n        let inputToken = route.input.wrapped\n\n        for (let i = 0; i < sections.length; i++) {\n          const section = sections[i]\n          /// Now, we get output of this section\n          outputToken = getOutputOfPools(section, inputToken)\n\n          const newRouteOriginal = new MixedRouteSDK(\n            [...section],\n            section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n            outputToken\n          )\n          const newRoute = new MixedRoute(newRouteOriginal)\n\n          /// Previous output is now input\n          inputToken = outputToken\n\n          if (mixedRouteIsAllV3(newRoute)) {\n            const path: string = encodeMixedRouteToPath(newRoute)\n            const exactInputParams = {\n              path,\n              // By default router holds funds until the last swap, then it is sent to the recipient\n              // special case exists where we are unwrapping WETH output, in which case `routerMustCustody` is set to true\n              // and router still holds the funds. That logic bundled into how the value of `recipient` is calculated\n              recipient: isLastSectionInRoute(i) ? recipient : ADDRESS_THIS,\n              amountIn: i == 0 ? amountIn : 0,\n              amountOutMinimum: !isLastSectionInRoute(i) ? 0 : amountOut,\n            }\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n          } else {\n            const exactInputParams = [\n              i == 0 ? amountIn : 0, // amountIn\n              !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n              newRoute.path.map((token) => token.address), // path\n              isLastSectionInRoute(i) ? recipient : ADDRESS_THIS, // to\n            ]\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n          }\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade:\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every(\n          (swap) =>\n            swap.route.protocol == Protocol.V3 ||\n            swap.route.protocol == Protocol.V2 ||\n            swap.route.protocol == Protocol.MIXED\n        ),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let individualTrades: (\n        | V2Trade<Currency, Currency, TradeType>\n        | V3Trade<Currency, Currency, TradeType>\n        | MixedRouteTrade<Currency, Currency, TradeType>\n      )[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol == Protocol.V2) {\n          individualTrades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol == Protocol.V3) {\n          individualTrades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else if (route.protocol == Protocol.MIXED) {\n          individualTrades.push(\n            /// we can change the naming of this function on MixedRouteTrade if needed\n            MixedRouteTrade.createUncheckedTrade({\n              route: route as MixedRoute<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else {\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n        }\n      }\n      trades = individualTrades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) =>\n        numberOfTrades + (trade instanceof V3Trade || trade instanceof MixedRouteTrade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else if (trade instanceof V3Trade) {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else if (trade instanceof MixedRouteTrade) {\n        for (const calldata of SwapRouter.encodeMixedRouteSwap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else {\n        throw new Error('Unsupported trade object')\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n      | (\n          | V2Trade<Currency, Currency, TradeType>\n          | V3Trade<Currency, Currency, TradeType>\n          | MixedRouteTrade<Currency, Currency, TradeType>\n        )[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): {\n    positionAmountIn: CurrencyAmount<Currency>\n    positionAmountOut: CurrencyAmount<Currency>\n  } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}