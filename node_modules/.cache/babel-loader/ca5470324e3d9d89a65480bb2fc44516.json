{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useWeb3React } from '@web3-react/core';\nimport useBlockNumber from 'lib/hooks/useBlockNumber';\nimport { useEffect, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from '../hooks';\nimport { addListener, removeListener } from './slice';\nimport { filterToKey, isHistoricalLog } from './utils';\nvar LogsState;\n(function (LogsState) {\n  LogsState[LogsState[\"INVALID\"] = 0] = \"INVALID\";\n  LogsState[LogsState[\"LOADING\"] = 1] = \"LOADING\";\n  LogsState[LogsState[\"SYNCING\"] = 2] = \"SYNCING\";\n  LogsState[LogsState[\"ERROR\"] = 3] = \"ERROR\";\n  LogsState[LogsState[\"SYNCED\"] = 4] = \"SYNCED\";\n})(LogsState || (LogsState = {}));\n/**\n * Returns the logs for the given filter as of the latest block, re-fetching from the library every block.\n * @param filter The logs filter, with `fromBlock` or `toBlock` optionally specified.\n * The filter parameter should _always_ be memoized, or else will trigger constant refetching\n */\nexport function useLogs(filter) {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  const blockNumber = useBlockNumber();\n  const logs = useAppSelector(state => state.logs);\n  const dispatch = useAppDispatch();\n  useEffect(() => {\n    if (!filter || !chainId) return;\n    dispatch(addListener({\n      chainId,\n      filter\n    }));\n    return () => {\n      dispatch(removeListener({\n        chainId,\n        filter\n      }));\n    };\n  }, [chainId, dispatch, filter]);\n  return useMemo(() => {\n    var _logs$chainId;\n    if (!chainId || !filter || !blockNumber) return {\n      logs: undefined,\n      state: LogsState.INVALID\n    };\n    const state = (_logs$chainId = logs[chainId]) === null || _logs$chainId === void 0 ? void 0 : _logs$chainId[filterToKey(filter)];\n    const result = state === null || state === void 0 ? void 0 : state.results;\n    if (!result) {\n      return {\n        state: LogsState.LOADING,\n        logs: undefined\n      };\n    }\n    if (result.error) {\n      return {\n        state: LogsState.ERROR,\n        logs: undefined\n      };\n    }\n    return {\n      // if we're only fetching logs until a block that has already elapsed, we're synced regardless of result.blockNumber\n      state: isHistoricalLog(filter, blockNumber) ? LogsState.SYNCED : result.blockNumber >= blockNumber ? LogsState.SYNCED : LogsState.SYNCING,\n      logs: result.logs\n    };\n  }, [blockNumber, chainId, filter, logs]);\n}\n_s(useLogs, \"asfNdc91umsOe08wZyvwv4qu5Fs=\", false, function () {\n  return [useWeb3React, useBlockNumber, useAppSelector, useAppDispatch];\n});","map":{"version":3,"names":["useWeb3React","useBlockNumber","useEffect","useMemo","useAppDispatch","useAppSelector","addListener","removeListener","filterToKey","isHistoricalLog","LogsState","useLogs","filter","chainId","blockNumber","logs","state","dispatch","undefined","INVALID","result","results","LOADING","error","ERROR","SYNCED","SYNCING"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/logs/hooks.ts"],"sourcesContent":["import type { Filter } from '@ethersproject/providers'\nimport { useWeb3React } from '@web3-react/core'\nimport useBlockNumber from 'lib/hooks/useBlockNumber'\nimport { useEffect, useMemo } from 'react'\n\nimport { useAppDispatch, useAppSelector } from '../hooks'\nimport { addListener, removeListener } from './slice'\nimport { filterToKey, isHistoricalLog, Log } from './utils'\n\nenum LogsState {\n  // The filter is invalid\n  INVALID,\n  // The logs are being loaded\n  LOADING,\n  // Logs are from a previous block number\n  SYNCING,\n  // Tried to fetch logs but received an error\n  ERROR,\n  // Logs have been fetched as of the latest block number\n  SYNCED,\n}\n\ninterface UseLogsResult {\n  logs: Log[] | undefined\n  state: LogsState\n}\n\n/**\n * Returns the logs for the given filter as of the latest block, re-fetching from the library every block.\n * @param filter The logs filter, with `fromBlock` or `toBlock` optionally specified.\n * The filter parameter should _always_ be memoized, or else will trigger constant refetching\n */\nexport function useLogs(filter: Filter | undefined): UseLogsResult {\n  const { chainId } = useWeb3React()\n  const blockNumber = useBlockNumber()\n\n  const logs = useAppSelector((state) => state.logs)\n  const dispatch = useAppDispatch()\n\n  useEffect(() => {\n    if (!filter || !chainId) return\n\n    dispatch(addListener({ chainId, filter }))\n    return () => {\n      dispatch(removeListener({ chainId, filter }))\n    }\n  }, [chainId, dispatch, filter])\n\n  return useMemo(() => {\n    if (!chainId || !filter || !blockNumber)\n      return {\n        logs: undefined,\n        state: LogsState.INVALID,\n      }\n\n    const state = logs[chainId]?.[filterToKey(filter)]\n    const result = state?.results\n\n    if (!result) {\n      return {\n        state: LogsState.LOADING,\n        logs: undefined,\n      }\n    }\n\n    if (result.error) {\n      return {\n        state: LogsState.ERROR,\n        logs: undefined,\n      }\n    }\n\n    return {\n      // if we're only fetching logs until a block that has already elapsed, we're synced regardless of result.blockNumber\n      state: isHistoricalLog(filter, blockNumber)\n        ? LogsState.SYNCED\n        : result.blockNumber >= blockNumber\n        ? LogsState.SYNCED\n        : LogsState.SYNCING,\n      logs: result.logs,\n    }\n  }, [blockNumber, chainId, filter, logs])\n}\n"],"mappings":";AACA,SAASA,YAAY,QAAQ,kBAAkB;AAC/C,OAAOC,cAAc,MAAM,0BAA0B;AACrD,SAASC,SAAS,EAAEC,OAAO,QAAQ,OAAO;AAE1C,SAASC,cAAc,EAAEC,cAAc,QAAQ,UAAU;AACzD,SAASC,WAAW,EAAEC,cAAc,QAAQ,SAAS;AACrD,SAASC,WAAW,EAAEC,eAAe,QAAa,SAAS;AAAA,IAEtDC,SAAS;AAAA,WAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;AAAA,GAATA,SAAS,KAATA,SAAS;AAkBd;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAO,CAACC,MAA0B,EAAiB;EAAA;EACjE,MAAM;IAAEC;EAAQ,CAAC,GAAGb,YAAY,EAAE;EAClC,MAAMc,WAAW,GAAGb,cAAc,EAAE;EAEpC,MAAMc,IAAI,GAAGV,cAAc,CAAEW,KAAK,IAAKA,KAAK,CAACD,IAAI,CAAC;EAClD,MAAME,QAAQ,GAAGb,cAAc,EAAE;EAEjCF,SAAS,CAAC,MAAM;IACd,IAAI,CAACU,MAAM,IAAI,CAACC,OAAO,EAAE;IAEzBI,QAAQ,CAACX,WAAW,CAAC;MAAEO,OAAO;MAAED;IAAO,CAAC,CAAC,CAAC;IAC1C,OAAO,MAAM;MACXK,QAAQ,CAACV,cAAc,CAAC;QAAEM,OAAO;QAAED;MAAO,CAAC,CAAC,CAAC;IAC/C,CAAC;EACH,CAAC,EAAE,CAACC,OAAO,EAAEI,QAAQ,EAAEL,MAAM,CAAC,CAAC;EAE/B,OAAOT,OAAO,CAAC,MAAM;IAAA;IACnB,IAAI,CAACU,OAAO,IAAI,CAACD,MAAM,IAAI,CAACE,WAAW,EACrC,OAAO;MACLC,IAAI,EAAEG,SAAS;MACfF,KAAK,EAAEN,SAAS,CAACS;IACnB,CAAC;IAEH,MAAMH,KAAK,oBAAGD,IAAI,CAACF,OAAO,CAAC,kDAAb,cAAgBL,WAAW,CAACI,MAAM,CAAC,CAAC;IAClD,MAAMQ,MAAM,GAAGJ,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEK,OAAO;IAE7B,IAAI,CAACD,MAAM,EAAE;MACX,OAAO;QACLJ,KAAK,EAAEN,SAAS,CAACY,OAAO;QACxBP,IAAI,EAAEG;MACR,CAAC;IACH;IAEA,IAAIE,MAAM,CAACG,KAAK,EAAE;MAChB,OAAO;QACLP,KAAK,EAAEN,SAAS,CAACc,KAAK;QACtBT,IAAI,EAAEG;MACR,CAAC;IACH;IAEA,OAAO;MACL;MACAF,KAAK,EAAEP,eAAe,CAACG,MAAM,EAAEE,WAAW,CAAC,GACvCJ,SAAS,CAACe,MAAM,GAChBL,MAAM,CAACN,WAAW,IAAIA,WAAW,GACjCJ,SAAS,CAACe,MAAM,GAChBf,SAAS,CAACgB,OAAO;MACrBX,IAAI,EAAEK,MAAM,CAACL;IACf,CAAC;EACH,CAAC,EAAE,CAACD,WAAW,EAAED,OAAO,EAAED,MAAM,EAAEG,IAAI,CAAC,CAAC;AAC1C;AAAC,GAlDeJ,OAAO;EAAA,QACDX,YAAY,EACZC,cAAc,EAErBI,cAAc,EACVD,cAAc;AAAA"},"metadata":{},"sourceType":"module"}