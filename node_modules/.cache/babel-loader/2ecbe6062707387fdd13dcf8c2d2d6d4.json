{"ast":null,"code":"import { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { ChainId } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { getHighestLiquidityV3NativePool, getHighestLiquidityV3USDPool, getL2ToL1GasUsed } from '../../../../util/gas-factory-helpers';\nimport { log } from '../../../../util/log';\nimport { buildSwapMethodParameters, buildTrade } from '../../../../util/methodParameters';\nimport { IOnChainGasModelFactory } from '../gas-model';\nimport { BASE_SWAP_COST, COST_PER_HOP, COST_PER_INIT_TICK, COST_PER_UNINIT_TICK } from './gas-costs';\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport class V3HeuristicGasModelFactory extends IOnChainGasModelFactory {\n  constructor() {\n    super();\n  }\n  async buildGasModel(_ref) {\n    let {\n      chainId,\n      gasPriceWei,\n      v3poolProvider: poolProvider,\n      token,\n      l2GasDataProvider\n    } = _ref;\n    const l2GasData = l2GasDataProvider ? await l2GasDataProvider.getGasData() : undefined;\n    const usdPool = await getHighestLiquidityV3USDPool(chainId, poolProvider);\n    const calculateL1GasFees = async route => {\n      const swapOptions = {\n        recipient: '0x0000000000000000000000000000000000000001',\n        deadline: 100,\n        slippageTolerance: new Percent(5, 10000)\n      };\n      let l1Used = BigNumber.from(0);\n      let l1FeeInWei = BigNumber.from(0);\n      if (chainId == ChainId.OPTIMISM || chainId == ChainId.OPTIMISTIC_KOVAN) {\n        [l1Used, l1FeeInWei] = this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);\n      } else if (chainId == ChainId.ARBITRUM_ONE || chainId == ChainId.ARBITRUM_RINKEBY) {\n        [l1Used, l1FeeInWei] = this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);\n      }\n      // wrap fee to native currency\n      const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n      const costNativeCurrency = CurrencyAmount.fromRawAmount(nativeCurrency, l1FeeInWei.toString());\n      // convert fee into usd\n      const nativeTokenPrice = usdPool.token0.address == nativeCurrency.address ? usdPool.token0Price : usdPool.token1Price;\n      const gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);\n      let gasCostL1QuoteToken = costNativeCurrency;\n      // if the inputted token is not in the native currency, quote a native/quote token pool to get the gas cost in terms of the quote token\n      if (!token.equals(nativeCurrency)) {\n        const nativePool = await getHighestLiquidityV3NativePool(token, poolProvider);\n        if (!nativePool) {\n          log.info('Could not find a pool to convert the cost into the quote token');\n          gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(token, 0);\n        } else {\n          const nativeTokenPrice = nativePool.token0.address == nativeCurrency.address ? nativePool.token0Price : nativePool.token1Price;\n          gasCostL1QuoteToken = nativeTokenPrice.quote(costNativeCurrency);\n        }\n      }\n      // gasUsedL1 is the gas units used calculated from the bytes of the calldata\n      // gasCostL1USD and gasCostL1QuoteToken is the cost of gas in each of those tokens\n      return {\n        gasUsedL1: l1Used,\n        gasCostL1USD,\n        gasCostL1QuoteToken\n      };\n    };\n    // If our quote token is WETH, we don't need to convert our gas use to be in terms\n    // of the quote token in order to produce a gas adjusted amount.\n    // We do return a gas use in USD however, so we still convert to usd.\n    const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n    if (token.equals(nativeCurrency)) {\n      const estimateGasCost = routeWithValidQuote => {\n        const {\n          totalGasCostNativeCurrency,\n          baseGasUse\n        } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n        const token0 = usdPool.token0.address == nativeCurrency.address;\n        const nativeTokenPrice = token0 ? usdPool.token0Price : usdPool.token1Price;\n        const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n        return {\n          gasEstimate: baseGasUse,\n          gasCostInToken: totalGasCostNativeCurrency,\n          gasCostInUSD: gasCostInTermsOfUSD\n        };\n      };\n      return {\n        estimateGasCost,\n        calculateL1GasFees\n      };\n    }\n    // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n    // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n    const nativePool = await getHighestLiquidityV3NativePool(token, poolProvider);\n    const usdToken = usdPool.token0.address == nativeCurrency.address ? usdPool.token1 : usdPool.token0;\n    const estimateGasCost = routeWithValidQuote => {\n      const {\n        totalGasCostNativeCurrency,\n        baseGasUse\n      } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n      if (!nativePool) {\n        log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n        return {\n          gasEstimate: baseGasUse,\n          gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n          gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0)\n        };\n      }\n      const token0 = nativePool.token0.address == nativeCurrency.address;\n      // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n      const nativeTokenPrice = token0 ? nativePool.token0Price : nativePool.token1Price;\n      let gasCostInTermsOfQuoteToken;\n      try {\n        // native token is base currency\n        gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n      } catch (err) {\n        log.info({\n          nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n          nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n          gasCostInEth: totalGasCostNativeCurrency.currency\n        }, 'Debug eth price token issue');\n        throw err;\n      }\n      // true if token0 is the native currency\n      const token0USDPool = usdPool.token0.address == nativeCurrency.address;\n      // gets the mid price of the pool in terms of the native token\n      const nativeTokenPriceUSDPool = token0USDPool ? usdPool.token0Price : usdPool.token1Price;\n      let gasCostInTermsOfUSD;\n      try {\n        gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);\n      } catch (err) {\n        log.info({\n          usdT1: usdPool.token0.symbol,\n          usdT2: usdPool.token1.symbol,\n          gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol\n        }, 'Failed to compute USD gas price');\n        throw err;\n      }\n      return {\n        gasEstimate: baseGasUse,\n        gasCostInToken: gasCostInTermsOfQuoteToken,\n        gasCostInUSD: gasCostInTermsOfUSD\n      };\n    };\n    return {\n      estimateGasCost: estimateGasCost.bind(this),\n      calculateL1GasFees\n    };\n  }\n  estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n    const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList)));\n    const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n    const hopsGasUse = COST_PER_HOP(chainId).mul(totalHops);\n    const tickGasUse = COST_PER_INIT_TICK(chainId).mul(totalInitializedTicksCrossed);\n    const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n    // base estimate gas used based on chainId estimates for hops and ticks gas useage\n    const baseGasUse = BASE_SWAP_COST(chainId).add(hopsGasUse).add(tickGasUse).add(uninitializedTickGasUse);\n    const baseGasCostWei = gasPriceWei.mul(baseGasUse);\n    const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n    const totalGasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());\n    return {\n      totalGasCostNativeCurrency,\n      totalInitializedTicksCrossed,\n      baseGasUse\n    };\n  }\n  /**\n   * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,\n   * we replicate the gas cost accounting here.\n   */\n  calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {\n    const {\n      l1BaseFee,\n      scalar,\n      decimals,\n      overhead\n    } = gasData;\n    const route = routes[0];\n    const inputToken = route.tradeType == TradeType.EXACT_INPUT ? route.amount.currency : route.quote.currency;\n    const outputToken = route.tradeType == TradeType.EXACT_INPUT ? route.quote.currency : route.amount.currency;\n    // build trade for swap calldata\n    const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n    const data = buildSwapMethodParameters(trade, swapConfig).calldata;\n    const l1GasUsed = getL2ToL1GasUsed(data, overhead);\n    // l1BaseFee is L1 Gas Price on etherscan\n    const l1Fee = l1GasUsed.mul(l1BaseFee);\n    const unscaled = l1Fee.mul(scalar);\n    // scaled = unscaled / (10 ** decimals)\n    const scaledConversion = BigNumber.from(10).pow(decimals);\n    const scaled = unscaled.div(scaledConversion);\n    return [l1GasUsed, scaled];\n  }\n  calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {\n    const {\n      perL2TxFee,\n      perL1CalldataFee\n    } = gasData;\n    const route = routes[0];\n    const inputToken = route.tradeType == TradeType.EXACT_INPUT ? route.amount.currency : route.quote.currency;\n    const outputToken = route.tradeType == TradeType.EXACT_INPUT ? route.quote.currency : route.amount.currency;\n    // build trade for swap calldata\n    const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n    const data = buildSwapMethodParameters(trade, swapConfig).calldata;\n    // calculates gas amounts based on bytes of calldata, use 0 as overhead.\n    const l1GasUsed = getL2ToL1GasUsed(data, BigNumber.from(0));\n    // multiply by the fee per calldata and add the flat l2 fee\n    let l1Fee = l1GasUsed.mul(perL1CalldataFee);\n    l1Fee = l1Fee.add(perL2TxFee);\n    return [l1GasUsed, l1Fee];\n  }\n}","map":{"version":3,"sources":["../../../../../../src/routers/alpha-router/gas-models/v3/v3-heuristic-gas-model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { ChainId } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { getHighestLiquidityV3NativePool, getHighestLiquidityV3USDPool, getL2ToL1GasUsed, } from '../../../../util/gas-factory-helpers';\nimport { log } from '../../../../util/log';\nimport { buildSwapMethodParameters, buildTrade, } from '../../../../util/methodParameters';\nimport { IOnChainGasModelFactory, } from '../gas-model';\nimport { BASE_SWAP_COST, COST_PER_HOP, COST_PER_INIT_TICK, COST_PER_UNINIT_TICK, } from './gas-costs';\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport class V3HeuristicGasModelFactory extends IOnChainGasModelFactory {\n    constructor() {\n        super();\n    }\n    async buildGasModel({ chainId, gasPriceWei, v3poolProvider: poolProvider, token, l2GasDataProvider, }) {\n        const l2GasData = l2GasDataProvider\n            ? await l2GasDataProvider.getGasData()\n            : undefined;\n        const usdPool = await getHighestLiquidityV3USDPool(chainId, poolProvider);\n        const calculateL1GasFees = async (route) => {\n            const swapOptions = {\n                recipient: '0x0000000000000000000000000000000000000001',\n                deadline: 100,\n                slippageTolerance: new Percent(5, 10000),\n            };\n            let l1Used = BigNumber.from(0);\n            let l1FeeInWei = BigNumber.from(0);\n            if (chainId == ChainId.OPTIMISM || chainId == ChainId.OPTIMISTIC_KOVAN) {\n                [l1Used, l1FeeInWei] = this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);\n            }\n            else if (chainId == ChainId.ARBITRUM_ONE ||\n                chainId == ChainId.ARBITRUM_RINKEBY) {\n                [l1Used, l1FeeInWei] = this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);\n            }\n            // wrap fee to native currency\n            const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n            const costNativeCurrency = CurrencyAmount.fromRawAmount(nativeCurrency, l1FeeInWei.toString());\n            // convert fee into usd\n            const nativeTokenPrice = usdPool.token0.address == nativeCurrency.address\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            const gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);\n            let gasCostL1QuoteToken = costNativeCurrency;\n            // if the inputted token is not in the native currency, quote a native/quote token pool to get the gas cost in terms of the quote token\n            if (!token.equals(nativeCurrency)) {\n                const nativePool = await getHighestLiquidityV3NativePool(token, poolProvider);\n                if (!nativePool) {\n                    log.info('Could not find a pool to convert the cost into the quote token');\n                    gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(token, 0);\n                }\n                else {\n                    const nativeTokenPrice = nativePool.token0.address == nativeCurrency.address\n                        ? nativePool.token0Price\n                        : nativePool.token1Price;\n                    gasCostL1QuoteToken = nativeTokenPrice.quote(costNativeCurrency);\n                }\n            }\n            // gasUsedL1 is the gas units used calculated from the bytes of the calldata\n            // gasCostL1USD and gasCostL1QuoteToken is the cost of gas in each of those tokens\n            return {\n                gasUsedL1: l1Used,\n                gasCostL1USD,\n                gasCostL1QuoteToken,\n            };\n        };\n        // If our quote token is WETH, we don't need to convert our gas use to be in terms\n        // of the quote token in order to produce a gas adjusted amount.\n        // We do return a gas use in USD however, so we still convert to usd.\n        const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        if (token.equals(nativeCurrency)) {\n            const estimateGasCost = (routeWithValidQuote) => {\n                const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                const token0 = usdPool.token0.address == nativeCurrency.address;\n                const nativeTokenPrice = token0\n                    ? usdPool.token0Price\n                    : usdPool.token1Price;\n                const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n                return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: totalGasCostNativeCurrency,\n                    gasCostInUSD: gasCostInTermsOfUSD,\n                };\n            };\n            return {\n                estimateGasCost,\n                calculateL1GasFees,\n            };\n        }\n        // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n        // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n        const nativePool = await getHighestLiquidityV3NativePool(token, poolProvider);\n        const usdToken = usdPool.token0.address == nativeCurrency.address\n            ? usdPool.token1\n            : usdPool.token0;\n        const estimateGasCost = (routeWithValidQuote) => {\n            const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n            if (!nativePool) {\n                log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n                return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                    gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0),\n                };\n            }\n            const token0 = nativePool.token0.address == nativeCurrency.address;\n            // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n            const nativeTokenPrice = token0\n                ? nativePool.token0Price\n                : nativePool.token1Price;\n            let gasCostInTermsOfQuoteToken;\n            try {\n                // native token is base currency\n                gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n                    nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n                    gasCostInEth: totalGasCostNativeCurrency.currency,\n                }, 'Debug eth price token issue');\n                throw err;\n            }\n            // true if token0 is the native currency\n            const token0USDPool = usdPool.token0.address == nativeCurrency.address;\n            // gets the mid price of the pool in terms of the native token\n            const nativeTokenPriceUSDPool = token0USDPool\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            let gasCostInTermsOfUSD;\n            try {\n                gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    usdT1: usdPool.token0.symbol,\n                    usdT2: usdPool.token1.symbol,\n                    gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol,\n                }, 'Failed to compute USD gas price');\n                throw err;\n            }\n            return {\n                gasEstimate: baseGasUse,\n                gasCostInToken: gasCostInTermsOfQuoteToken,\n                gasCostInUSD: gasCostInTermsOfUSD,\n            };\n        };\n        return {\n            estimateGasCost: estimateGasCost.bind(this),\n            calculateL1GasFees,\n        };\n    }\n    estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n        const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList)));\n        const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n        const hopsGasUse = COST_PER_HOP(chainId).mul(totalHops);\n        const tickGasUse = COST_PER_INIT_TICK(chainId).mul(totalInitializedTicksCrossed);\n        const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n        // base estimate gas used based on chainId estimates for hops and ticks gas useage\n        const baseGasUse = BASE_SWAP_COST(chainId)\n            .add(hopsGasUse)\n            .add(tickGasUse)\n            .add(uninitializedTickGasUse);\n        const baseGasCostWei = gasPriceWei.mul(baseGasUse);\n        const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        const totalGasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());\n        return {\n            totalGasCostNativeCurrency,\n            totalInitializedTicksCrossed,\n            baseGasUse,\n        };\n    }\n    /**\n     * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,\n     * we replicate the gas cost accounting here.\n     */\n    calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {\n        const { l1BaseFee, scalar, decimals, overhead } = gasData;\n        const route = routes[0];\n        const inputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.amount.currency\n            : route.quote.currency;\n        const outputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.quote.currency\n            : route.amount.currency;\n        // build trade for swap calldata\n        const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n        const data = buildSwapMethodParameters(trade, swapConfig).calldata;\n        const l1GasUsed = getL2ToL1GasUsed(data, overhead);\n        // l1BaseFee is L1 Gas Price on etherscan\n        const l1Fee = l1GasUsed.mul(l1BaseFee);\n        const unscaled = l1Fee.mul(scalar);\n        // scaled = unscaled / (10 ** decimals)\n        const scaledConversion = BigNumber.from(10).pow(decimals);\n        const scaled = unscaled.div(scaledConversion);\n        return [l1GasUsed, scaled];\n    }\n    calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {\n        const { perL2TxFee, perL1CalldataFee } = gasData;\n        const route = routes[0];\n        const inputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.amount.currency\n            : route.quote.currency;\n        const outputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.quote.currency\n            : route.amount.currency;\n        // build trade for swap calldata\n        const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n        const data = buildSwapMethodParameters(trade, swapConfig).calldata;\n        // calculates gas amounts based on bytes of calldata, use 0 as overhead.\n        const l1GasUsed = getL2ToL1GasUsed(data, BigNumber.from(0));\n        // multiply by the fee per calldata and add the flat l2 fee\n        let l1Fee = l1GasUsed.mul(perL1CalldataFee);\n        l1Fee = l1Fee.add(perL2TxFee);\n        return [l1GasUsed, l1Fee];\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjMtaGV1cmlzdGljLWdhcy1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9nYXMtbW9kZWxzL3YzL3YzLWhldXJpc3RpYy1nYXMtbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFdkQsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBRXZCLE9BQU8sRUFBZSx1QkFBdUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUtuRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFDTCwrQkFBK0IsRUFDL0IsNEJBQTRCLEVBQzVCLGdCQUFnQixHQUNqQixNQUFNLHNDQUFzQyxDQUFDO0FBQzlDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzQyxPQUFPLEVBQ0wseUJBQXlCLEVBQ3pCLFVBQVUsR0FDWCxNQUFNLG1DQUFtQyxDQUFDO0FBRTNDLE9BQU8sRUFHTCx1QkFBdUIsR0FDeEIsTUFBTSxjQUFjLENBQUM7QUFFdEIsT0FBTyxFQUNMLGNBQWMsRUFDZCxZQUFZLEVBQ1osa0JBQWtCLEVBQ2xCLG9CQUFvQixHQUNyQixNQUFNLGFBQWEsQ0FBQztBQUVyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsdUJBQXVCO0lBQ3JFO1FBQ0UsS0FBSyxFQUFFLENBQUM7SUFDVixDQUFDO0lBRU0sS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUN6QixPQUFPLEVBQ1AsV0FBVyxFQUNYLGNBQWMsRUFBRSxZQUFZLEVBQzVC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"]},"metadata":{},"sourceType":"module"}