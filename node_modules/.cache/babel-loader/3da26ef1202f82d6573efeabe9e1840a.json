{"ast":null,"code":"'use strict';\n\n/* Dependencies. */\nvar extend = require('extend');\nvar bail = require('bail');\nvar vfile = require('vfile');\nvar trough = require('trough');\nvar string = require('x-is-string');\nvar plain = require('is-plain-obj');\n\n/* Expose a frozen processor. */\nmodule.exports = unified().freeze();\nvar slice = [].slice;\nvar own = {}.hasOwnProperty;\n\n/* Process pipeline. */\nvar pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file);\n}\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done);\n  function done(err, tree, file) {\n    if (err) {\n      next(err);\n    } else {\n      ctx.tree = tree;\n      ctx.file = file;\n      next();\n    }\n  }\n}\nfunction pipelineStringify(p, ctx) {\n  ctx.file.contents = p.stringify(ctx.tree, ctx.file);\n}\n\n/* Function to create the first processor. */\nfunction unified() {\n  var attachers = [];\n  var transformers = trough();\n  var namespace = {};\n  var frozen = false;\n  var freezeIndex = -1;\n\n  /* Data management. */\n  processor.data = data;\n\n  /* Lock. */\n  processor.freeze = freeze;\n\n  /* Plug-ins. */\n  processor.attachers = attachers;\n  processor.use = use;\n\n  /* API. */\n  processor.parse = parse;\n  processor.stringify = stringify;\n  processor.run = run;\n  processor.runSync = runSync;\n  processor.process = process;\n  processor.processSync = processSync;\n\n  /* Expose. */\n  return processor;\n\n  /* Create a new processor based on the processor\n   * in the current scope. */\n  function processor() {\n    var destination = unified();\n    var length = attachers.length;\n    var index = -1;\n    while (++index < length) {\n      destination.use.apply(null, attachers[index]);\n    }\n    destination.data(extend(true, {}, namespace));\n    return destination;\n  }\n\n  /* Freeze: used to signal a processor that has finished\n   * configuration.\n   *\n   * For example, take unified itself.  Itâ€™s frozen.\n   * Plug-ins should not be added to it.  Rather, it should\n   * be extended, by invoking it, before modifying it.\n   *\n   * In essence, always invoke this when exporting a\n   * processor. */\n  function freeze() {\n    var values;\n    var plugin;\n    var options;\n    var transformer;\n    if (frozen) {\n      return processor;\n    }\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex];\n      plugin = values[0];\n      options = values[1];\n      transformer = null;\n      if (options === false) {\n        continue;\n      }\n      if (options === true) {\n        values[1] = undefined;\n      }\n      transformer = plugin.apply(processor, values.slice(1));\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n    frozen = true;\n    freezeIndex = Infinity;\n    return processor;\n  }\n\n  /* Data management.\n   * Getter / setter for processor-specific informtion. */\n  function data(key, value) {\n    if (string(key)) {\n      /* Set `key`. */\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      }\n\n      /* Get `key`. */\n      return own.call(namespace, key) && namespace[key] || null;\n    }\n\n    /* Set space. */\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    }\n\n    /* Get space. */\n    return namespace;\n  }\n\n  /* Plug-in management.\n   *\n   * Pass it:\n   * *   an attacher and options,\n   * *   a preset,\n   * *   a list of presets, attachers, and arguments (list\n   *     of attachers and options). */\n  function use(value) {\n    var settings;\n    assertUnfrozen('use', frozen);\n    if (value === null || value === undefined) {\n      /* Empty */\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments);\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`');\n    }\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings);\n    }\n    return processor;\n    function addPreset(result) {\n      addList(result.plugins);\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings);\n      }\n    }\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`');\n      }\n    }\n    function addList(plugins) {\n      var length;\n      var index;\n      if (plugins === null || plugins === undefined) {\n        /* Empty */\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length;\n        index = -1;\n        while (++index < length) {\n          add(plugins[index]);\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n    function addPlugin(plugin, value) {\n      var entry = find(plugin);\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value);\n        }\n        entry[1] = value;\n      } else {\n        attachers.push(slice.call(arguments));\n      }\n    }\n  }\n  function find(plugin) {\n    var length = attachers.length;\n    var index = -1;\n    var entry;\n    while (++index < length) {\n      entry = attachers[index];\n      if (entry[0] === plugin) {\n        return entry;\n      }\n    }\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the\n   * processor. */\n  function parse(doc) {\n    var file = vfile(doc);\n    var Parser;\n    freeze();\n    Parser = processor.Parser;\n    assertParser('parse', Parser);\n    if (newable(Parser)) {\n      return new Parser(String(file), file).parse();\n    }\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), async. */\n  function run(node, file, cb) {\n    assertNode(node);\n    freeze();\n    if (!cb && typeof file === 'function') {\n      cb = file;\n      file = null;\n    }\n    if (!cb) {\n      return new Promise(executor);\n    }\n    executor(null, cb);\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done);\n      function done(err, tree, file) {\n        tree = tree || node;\n        if (err) {\n          reject(err);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          cb(null, tree, file);\n        }\n      }\n    }\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), sync. */\n  function runSync(node, file) {\n    var complete = false;\n    var result;\n    run(node, file, done);\n    assertDone('runSync', 'run', complete);\n    return result;\n    function done(err, tree) {\n      complete = true;\n      bail(err);\n      result = tree;\n    }\n  }\n\n  /* Stringify a Unist node representation of a file\n   * (in string or VFile representation) into a string\n   * using the `Compiler` on the processor. */\n  function stringify(node, doc) {\n    var file = vfile(doc);\n    var Compiler;\n    freeze();\n    Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n    if (newable(Compiler)) {\n      return new Compiler(node, file).compile();\n    }\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the processor,\n   * then run transforms on that node, and compile the\n   * resulting node using the `Compiler` on the processor,\n   * and store that result on the VFile. */\n  function process(doc, cb) {\n    freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n    if (!cb) {\n      return new Promise(executor);\n    }\n    executor(null, cb);\n    function executor(resolve, reject) {\n      var file = vfile(doc);\n      pipeline.run(processor, {\n        file: file\n      }, done);\n      function done(err) {\n        if (err) {\n          reject(err);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          cb(null, file);\n        }\n      }\n    }\n  }\n\n  /* Process the given document (in string or VFile\n   * representation), sync. */\n  function processSync(doc) {\n    var complete = false;\n    var file;\n    freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    file = vfile(doc);\n    process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n    function done(err) {\n      complete = true;\n      bail(err);\n    }\n  }\n}\n\n/* Check if `func` is a constructor. */\nfunction newable(value) {\n  return typeof value === 'function' && keys(value.prototype);\n}\n\n/* Check if `value` is an object with keys. */\nfunction keys(value) {\n  var key;\n  for (key in value) {\n    return true;\n  }\n  return false;\n}\n\n/* Assert a parser is available. */\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`');\n  }\n}\n\n/* Assert a compiler is available. */\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`');\n  }\n}\n\n/* Assert the processor is not frozen. */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(['Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new ', 'processor first, by invoking it: use `processor()` instead of ', '`processor`.'].join(''));\n  }\n}\n\n/* Assert `node` is a Unist node. */\nfunction assertNode(node) {\n  if (!node || !string(node.type)) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n}\n\n/* Assert that `complete` is `true`. */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}","map":{"version":3,"names":["extend","require","bail","vfile","trough","string","plain","module","exports","unified","freeze","slice","own","hasOwnProperty","pipeline","use","pipelineParse","pipelineRun","pipelineStringify","p","ctx","tree","parse","file","next","run","done","err","contents","stringify","attachers","transformers","namespace","frozen","freezeIndex","processor","data","runSync","process","processSync","destination","length","index","apply","values","plugin","options","transformer","undefined","Infinity","key","value","arguments","assertUnfrozen","call","settings","addPlugin","addList","addPreset","Error","result","plugins","add","entry","find","push","doc","Parser","assertParser","newable","String","node","cb","assertNode","Promise","executor","resolve","reject","complete","assertDone","Compiler","assertCompiler","compile","keys","prototype","name","join","type","asyncName"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/unified/index.js"],"sourcesContent":["'use strict'\n\n/* Dependencies. */\nvar extend = require('extend')\nvar bail = require('bail')\nvar vfile = require('vfile')\nvar trough = require('trough')\nvar string = require('x-is-string')\nvar plain = require('is-plain-obj')\n\n/* Expose a frozen processor. */\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n/* Process pipeline. */\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(err, tree, file) {\n    if (err) {\n      next(err)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  ctx.file.contents = p.stringify(ctx.tree, ctx.file)\n}\n\n/* Function to create the first processor. */\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var frozen = false\n  var freezeIndex = -1\n\n  /* Data management. */\n  processor.data = data\n\n  /* Lock. */\n  processor.freeze = freeze\n\n  /* Plug-ins. */\n  processor.attachers = attachers\n  processor.use = use\n\n  /* API. */\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  /* Expose. */\n  return processor\n\n  /* Create a new processor based on the processor\n   * in the current scope. */\n  function processor() {\n    var destination = unified()\n    var length = attachers.length\n    var index = -1\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /* Freeze: used to signal a processor that has finished\n   * configuration.\n   *\n   * For example, take unified itself.  Itâ€™s frozen.\n   * Plug-ins should not be added to it.  Rather, it should\n   * be extended, by invoking it, before modifying it.\n   *\n   * In essence, always invoke this when exporting a\n   * processor. */\n  function freeze() {\n    var values\n    var plugin\n    var options\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n      plugin = values[0]\n      options = values[1]\n      transformer = null\n\n      if (options === false) {\n        continue\n      }\n\n      if (options === true) {\n        values[1] = undefined\n      }\n\n      transformer = plugin.apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  /* Data management.\n   * Getter / setter for processor-specific informtion. */\n  function data(key, value) {\n    if (string(key)) {\n      /* Set `key`. */\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n\n        namespace[key] = value\n\n        return processor\n      }\n\n      /* Get `key`. */\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    /* Set space. */\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    /* Get space. */\n    return namespace\n  }\n\n  /* Plug-in management.\n   *\n   * Pass it:\n   * *   an attacher and options,\n   * *   a preset,\n   * *   a list of presets, attachers, and arguments (list\n   *     of attachers and options). */\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      /* Empty */\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var length\n      var index\n\n      if (plugins === null || plugins === undefined) {\n        /* Empty */\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length\n        index = -1\n\n        while (++index < length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var length = attachers.length\n    var index = -1\n    var entry\n\n    while (++index < length) {\n      entry = attachers[index]\n\n      if (entry[0] === plugin) {\n        return entry\n      }\n    }\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the\n   * processor. */\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser)) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), async. */\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(err, tree, file) {\n        tree = tree || node\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), sync. */\n  function runSync(node, file) {\n    var complete = false\n    var result\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(err, tree) {\n      complete = true\n      bail(err)\n      result = tree\n    }\n  }\n\n  /* Stringify a Unist node representation of a file\n   * (in string or VFile representation) into a string\n   * using the `Compiler` on the processor. */\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler)) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the processor,\n   * then run transforms on that node, and compile the\n   * resulting node using the `Compiler` on the processor,\n   * and store that result on the VFile. */\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(err) {\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  /* Process the given document (in string or VFile\n   * representation), sync. */\n  function processSync(doc) {\n    var complete = false\n    var file\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(err) {\n      complete = true\n      bail(err)\n    }\n  }\n}\n\n/* Check if `func` is a constructor. */\nfunction newable(value) {\n  return typeof value === 'function' && keys(value.prototype)\n}\n\n/* Check if `value` is an object with keys. */\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n  return false\n}\n\n/* Assert a parser is available. */\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/* Assert a compiler is available. */\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/* Assert the processor is not frozen. */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      [\n        'Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new ',\n        'processor first, by invoking it: use `processor()` instead of ',\n        '`processor`.'\n      ].join('')\n    )\n  }\n}\n\n/* Assert `node` is a Unist node. */\nfunction assertNode(node) {\n  if (!node || !string(node.type)) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n/* Assert that `complete` is `true`. */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}