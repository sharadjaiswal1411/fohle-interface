{"ast":null,"code":"var _toConsumableArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _toArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\nvar _classCallCheck = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _assertThisInitialized = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nvar _inherits = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _createSuper = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function () {\n  var EventEmitter,\n    NodeCache,\n    clone,\n    splice = [].splice,\n    boundMethodCheck = function boundMethodCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new Error('Bound instance method accessed before binding');\n      }\n    },\n    indexOf = [].indexOf;\n  clone = require(\"clone\");\n  EventEmitter = require('events').EventEmitter;\n\n  // generate superclass\n  module.exports = NodeCache = function () {\n    var NodeCache = /*#__PURE__*/function (_EventEmitter) {\n      \"use strict\";\n\n      _inherits(NodeCache, _EventEmitter);\n      var _super = _createSuper(NodeCache);\n      function NodeCache() {\n        var _this;\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _classCallCheck(this, NodeCache);\n        _this = _super.call(this);\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        _this.get = _this.get.bind(_assertThisInitialized(_this));\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        _this.mget = _this.mget.bind(_assertThisInitialized(_this));\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        _this.set = _this.set.bind(_assertThisInitialized(_this));\n\n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        _this.mset = _this.mset.bind(_assertThisInitialized(_this));\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String | Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        _this.del = _this.del.bind(_assertThisInitialized(_this));\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        _this.take = _this.take.bind(_assertThisInitialized(_this));\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        _this.ttl = _this.ttl.bind(_assertThisInitialized(_this));\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        _this.getTtl = _this.getTtl.bind(_assertThisInitialized(_this));\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        _this.keys = _this.keys.bind(_assertThisInitialized(_this));\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        _this.has = _this.has.bind(_assertThisInitialized(_this));\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        _this.getStats = _this.getStats.bind(_assertThisInitialized(_this));\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        _this.flushAll = _this.flushAll.bind(_assertThisInitialized(_this));\n\n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        _this.flushStats = _this.flushStats.bind(_assertThisInitialized(_this));\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        _this.close = _this.close.bind(_assertThisInitialized(_this));\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        _this._checkData = _this._checkData.bind(_assertThisInitialized(_this));\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        _this._check = _this._check.bind(_assertThisInitialized(_this));\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        _this._isInvalidKey = _this._isInvalidKey.bind(_assertThisInitialized(_this));\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        _this._wrap = _this._wrap.bind(_assertThisInitialized(_this));\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        _this._getValLength = _this._getValLength.bind(_assertThisInitialized(_this));\n        // ## _error\n\n        // internal method to handle an error message\n        _this._error = _this._error.bind(_assertThisInitialized(_this));\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        _this._initErrors = _this._initErrors.bind(_assertThisInitialized(_this));\n        _this.options = options;\n        _this._initErrors();\n        // container for cached data\n        _this.data = {};\n        // module options\n        _this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, _this.options);\n        // generate functions with callbacks (legacy)\n        if (_this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach(function (methodKey) {\n            var oldMethod;\n            // reference real function\n            oldMethod = _this[methodKey];\n            _this[methodKey] = function () {\n              var _ref, _ref2, _splice$call, _splice$call2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              var cb, err, ref, res;\n              ref = args, (_ref = ref, _ref2 = _toArray(_ref), args = _ref2.slice(0)), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0]);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod.apply(void 0, _toConsumableArray(args));\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod.apply(void 0, _toConsumableArray(args).concat([cb]));\n              }\n            };\n          });\n        }\n        // statistics container\n        _this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        _this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        _this._checkData();\n        return _possibleConstructorReturn(_this);\n      }\n      _createClass(NodeCache, [{\n        key: \"get\",\n        value: function get(key) {\n          var _ret, err;\n          boundMethodCheck(this, NodeCache);\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and incremet stats\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            _ret = this._unwrap(this.data[key]);\n            // return data\n            return _ret;\n          } else {\n            // if not found return undefined\n            this.stats.misses++;\n            return void 0;\n          }\n        }\n      }, {\n        key: \"mget\",\n        value: function mget(keys) {\n          var _err, err, i, key, len, oRet;\n          boundMethodCheck(this, NodeCache);\n          // convert a string to an array of one key\n          if (!Array.isArray(keys)) {\n            _err = this._error(\"EKEYSTYPE\");\n            throw _err;\n          }\n          // define return\n          oRet = {};\n          for (i = 0, len = keys.length; i < len; i++) {\n            key = keys[i];\n            // handle invalid key types\n            if ((err = this._isInvalidKey(key)) != null) {\n              throw err;\n            }\n            // get data and increment stats\n            if (this.data[key] != null && this._check(key, this.data[key])) {\n              this.stats.hits++;\n              oRet[key] = this._unwrap(this.data[key]);\n            } else {\n              // if not found return a error\n              this.stats.misses++;\n            }\n          }\n          // return all found keys\n          return oRet;\n        }\n      }, {\n        key: \"set\",\n        value: function set(key, value, ttl) {\n          var _err, err, existent;\n          boundMethodCheck(this, NodeCache);\n          // check if cache is overflowing\n          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n            _err = this._error(\"ECACHEFULL\");\n            throw _err;\n          }\n          // force the data to string\n          if (this.options.forceString && !typeof value === \"string\") {\n            value = JSON.stringify(value);\n          }\n          // set default ttl if not passed\n          if (ttl == null) {\n            ttl = this.options.stdTTL;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // internal helper variables\n          existent = false;\n          // remove existing data from stats\n          if (this.data[key]) {\n            existent = true;\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n          }\n          // set the value\n          this.data[key] = this._wrap(value, ttl);\n          this.stats.vsize += this._getValLength(value);\n          // only add the keys and key-size if the key is new\n          if (!existent) {\n            this.stats.ksize += this._getKeyLength(key);\n            this.stats.keys++;\n          }\n          this.emit(\"set\", key, value);\n          // return true\n          return true;\n        }\n      }, {\n        key: \"mset\",\n        value: function mset(keyValueSet) {\n          var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n          boundMethodCheck(this, NodeCache);\n          // check if cache is overflowing\n          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n            _err = this._error(\"ECACHEFULL\");\n            throw _err;\n          }\n\n          // loop over keyValueSet to validate key and ttl\n          for (i = 0, len = keyValueSet.length; i < len; i++) {\n            keyValuePair = keyValueSet[i];\n            var _keyValuePair = keyValuePair;\n            key = _keyValuePair.key;\n            val = _keyValuePair.val;\n            ttl = _keyValuePair.ttl;\n            // check if there is ttl and it's a number\n            if (ttl && typeof ttl !== \"number\") {\n              _err = this._error(\"ETTLTYPE\");\n              throw _err;\n            }\n            // handle invalid key types\n            if ((err = this._isInvalidKey(key)) != null) {\n              throw err;\n            }\n          }\n          for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n            keyValuePair = keyValueSet[j];\n            var _keyValuePair2 = keyValuePair;\n            key = _keyValuePair2.key;\n            val = _keyValuePair2.val;\n            ttl = _keyValuePair2.ttl;\n            this.set(key, val, ttl);\n          }\n          return true;\n        }\n      }, {\n        key: \"del\",\n        value: function del(keys) {\n          var delCount, err, i, key, len, oldVal;\n          boundMethodCheck(this, NodeCache);\n          // convert keys to an array of itself\n          if (!Array.isArray(keys)) {\n            keys = [keys];\n          }\n          delCount = 0;\n          for (i = 0, len = keys.length; i < len; i++) {\n            key = keys[i];\n            // handle invalid key types\n            if ((err = this._isInvalidKey(key)) != null) {\n              throw err;\n            }\n            // only delete if existent\n            if (this.data[key] != null) {\n              // calc the stats\n              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n              this.stats.ksize -= this._getKeyLength(key);\n              this.stats.keys--;\n              delCount++;\n              // delete the value\n              oldVal = this.data[key];\n              delete this.data[key];\n              // return true\n              this.emit(\"del\", key, oldVal.v);\n            }\n          }\n          return delCount;\n        }\n      }, {\n        key: \"take\",\n        value: function take(key) {\n          var _ret;\n          boundMethodCheck(this, NodeCache);\n          _ret = this.get(key);\n          if (_ret != null) {\n            this.del(key);\n          }\n          return _ret;\n        }\n      }, {\n        key: \"ttl\",\n        value: function ttl(key, _ttl2) {\n          var err;\n          boundMethodCheck(this, NodeCache);\n          _ttl2 || (_ttl2 = this.options.stdTTL);\n          if (!key) {\n            return false;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // check for existent data and update the ttl value\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            // if ttl < 0 delete the key. otherwise reset the value\n            if (_ttl2 >= 0) {\n              this.data[key] = this._wrap(this.data[key].v, _ttl2, false);\n            } else {\n              this.del(key);\n            }\n            return true;\n          } else {\n            // return false if key has not been found\n            return false;\n          }\n        }\n      }, {\n        key: \"getTtl\",\n        value: function getTtl(key) {\n          var _ttl, err;\n          boundMethodCheck(this, NodeCache);\n          if (!key) {\n            return void 0;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // check for existant data and update the ttl value\n          if (this.data[key] != null && this._check(key, this.data[key])) {\n            _ttl = this.data[key].t;\n            return _ttl;\n          } else {\n            // return undefined if key has not been found\n            return void 0;\n          }\n        }\n      }, {\n        key: \"keys\",\n        value: function keys() {\n          var _keys;\n          boundMethodCheck(this, NodeCache);\n          _keys = Object.keys(this.data);\n          return _keys;\n        }\n      }, {\n        key: \"has\",\n        value: function has(key) {\n          var _exists;\n          boundMethodCheck(this, NodeCache);\n          _exists = this.data[key] != null && this._check(key, this.data[key]);\n          return _exists;\n        }\n      }, {\n        key: \"getStats\",\n        value: function getStats() {\n          boundMethodCheck(this, NodeCache);\n          return this.stats;\n        }\n      }, {\n        key: \"flushAll\",\n        value: function flushAll() {\n          var _startPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n          boundMethodCheck(this, NodeCache);\n          // parameter just for testing\n\n          // set data empty\n          this.data = {};\n          // reset stats\n          this.stats = {\n            hits: 0,\n            misses: 0,\n            keys: 0,\n            ksize: 0,\n            vsize: 0\n          };\n          // reset check period\n          this._killCheckPeriod();\n          this._checkData(_startPeriod);\n          this.emit(\"flush\");\n        }\n      }, {\n        key: \"flushStats\",\n        value: function flushStats() {\n          boundMethodCheck(this, NodeCache);\n          // reset stats\n          this.stats = {\n            hits: 0,\n            misses: 0,\n            keys: 0,\n            ksize: 0,\n            vsize: 0\n          };\n          this.emit(\"flush_stats\");\n        }\n      }, {\n        key: \"close\",\n        value: function close() {\n          boundMethodCheck(this, NodeCache);\n          this._killCheckPeriod();\n        }\n      }, {\n        key: \"_checkData\",\n        value: function _checkData() {\n          var startPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n          var key, ref, value;\n          boundMethodCheck(this, NodeCache);\n          ref = this.data;\n          // run the housekeeping method\n          for (key in ref) {\n            value = ref[key];\n            this._check(key, value);\n          }\n          if (startPeriod && this.options.checkperiod > 0) {\n            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n            if (this.checkTimeout != null && this.checkTimeout.unref != null) {\n              this.checkTimeout.unref();\n            }\n          }\n        }\n\n        // ## _killCheckPeriod\n\n        // stop the checkdata period. Only needed to abort the script in testing mode.\n      }, {\n        key: \"_killCheckPeriod\",\n        value: function _killCheckPeriod() {\n          if (this.checkTimeout != null) {\n            return clearTimeout(this.checkTimeout);\n          }\n        }\n      }, {\n        key: \"_check\",\n        value: function _check(key, data) {\n          var _retval;\n          boundMethodCheck(this, NodeCache);\n          _retval = true;\n          // data is invalid if the ttl is too old and is not 0\n          // console.log data.t < Date.now(), data.t, Date.now()\n          if (data.t !== 0 && data.t < Date.now()) {\n            if (this.options.deleteOnExpire) {\n              _retval = false;\n              this.del(key);\n            }\n            this.emit(\"expired\", key, this._unwrap(data));\n          }\n          return _retval;\n        }\n      }, {\n        key: \"_isInvalidKey\",\n        value: function _isInvalidKey(key) {\n          var ref;\n          boundMethodCheck(this, NodeCache);\n          if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n            return this._error(\"EKEYTYPE\", {\n              type: typeof key\n            });\n          }\n        }\n      }, {\n        key: \"_wrap\",\n        value: function _wrap(value, ttl) {\n          var asClone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n          var livetime, now, oReturn, ttlMultiplicator;\n          boundMethodCheck(this, NodeCache);\n          if (!this.options.useClones) {\n            asClone = false;\n          }\n          // define the time to live\n          now = Date.now();\n          livetime = 0;\n          ttlMultiplicator = 1000;\n          // use given ttl\n          if (ttl === 0) {\n            livetime = 0;\n          } else if (ttl) {\n            livetime = now + ttl * ttlMultiplicator;\n          } else {\n            // use standard ttl\n            if (this.options.stdTTL === 0) {\n              livetime = this.options.stdTTL;\n            } else {\n              livetime = now + this.options.stdTTL * ttlMultiplicator;\n            }\n          }\n          // return the wrapped value\n          return oReturn = {\n            t: livetime,\n            v: asClone ? clone(value) : value\n          };\n        }\n\n        // ## _unwrap\n\n        // internal method to extract get the value out of the wrapped value\n      }, {\n        key: \"_unwrap\",\n        value: function _unwrap(value) {\n          var asClone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          if (!this.options.useClones) {\n            asClone = false;\n          }\n          if (value.v != null) {\n            if (asClone) {\n              return clone(value.v);\n            } else {\n              return value.v;\n            }\n          }\n          return null;\n        }\n\n        // ## _getKeyLength\n\n        // internal method the calculate the key length\n      }, {\n        key: \"_getKeyLength\",\n        value: function _getKeyLength(key) {\n          return key.toString().length;\n        }\n      }, {\n        key: \"_getValLength\",\n        value: function _getValLength(value) {\n          boundMethodCheck(this, NodeCache);\n          if (typeof value === \"string\") {\n            // if the value is a String get the real length\n            return value.length;\n          } else if (this.options.forceString) {\n            // force string if it's defined and not passed\n            return JSON.stringify(value).length;\n          } else if (Array.isArray(value)) {\n            // if the data is an Array multiply each element with a defined default length\n            return this.options.arrayValueSize * value.length;\n          } else if (typeof value === \"number\") {\n            return 8;\n          } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n            // if the data is a Promise, use defined default\n            // (can't calculate actual/resolved value size synchronously)\n            return this.options.promiseValueSize;\n          } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n            return value.length;\n          } else if (value != null && typeof value === \"object\") {\n            // if the data is an Object multiply each element with a defined default length\n            return this.options.objectValueSize * Object.keys(value).length;\n          } else if (typeof value === \"boolean\") {\n            return 8;\n          } else {\n            // default fallback\n            return 0;\n          }\n        }\n      }, {\n        key: \"_error\",\n        value: function _error(type) {\n          var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          var error;\n          boundMethodCheck(this, NodeCache);\n          // generate the error object\n          error = new Error();\n          error.name = type;\n          error.errorcode = type;\n          error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n          error.data = data;\n          // return the error object\n          return error;\n        }\n      }, {\n        key: \"_initErrors\",\n        value: function _initErrors() {\n          var _errMsg, _errT, ref;\n          boundMethodCheck(this, NodeCache);\n          this.ERRORS = {};\n          ref = this._ERRORS;\n          for (_errT in ref) {\n            _errMsg = ref[_errT];\n            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n          }\n        }\n      }, {\n        key: \"createErrorMessage\",\n        value: function createErrorMessage(errMsg) {\n          return function (args) {\n            return errMsg.replace(\"__key\", args.type);\n          };\n        }\n      }]);\n      return NodeCache;\n    }(EventEmitter);\n    ;\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n    return NodeCache;\n  }.call(this);\n}).call(this);","map":{"version":3,"names":["EventEmitter","NodeCache","clone","splice","boundMethodCheck","instance","Constructor","Error","indexOf","require","module","exports","options","get","bind","mget","set","mset","del","take","ttl","getTtl","keys","has","getStats","flushAll","flushStats","close","_checkData","_check","_isInvalidKey","_wrap","_getValLength","_error","_initErrors","data","Object","assign","forceString","objectValueSize","promiseValueSize","arrayValueSize","stdTTL","checkperiod","useClones","deleteOnExpire","enableLegacyCallbacks","maxKeys","console","warn","forEach","methodKey","oldMethod","args","cb","err","ref","res","call","error1","stats","hits","misses","ksize","vsize","validKeyTypes","key","_ret","_unwrap","_err","i","len","oRet","Array","isArray","length","value","existent","JSON","stringify","_getKeyLength","emit","keyValueSet","j","keyValuePair","len1","val","delCount","oldVal","v","_ttl","t","_keys","_exists","_startPeriod","_killCheckPeriod","startPeriod","checkTimeout","setTimeout","unref","clearTimeout","_retval","Date","now","type","asClone","livetime","oReturn","ttlMultiplicator","toString","then","Buffer","isBuffer","error","name","errorcode","message","ERRORS","_errMsg","_errT","_ERRORS","createErrorMessage","errMsg","replace","prototype"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/node-cache/lib/node_cache.js"],"sourcesContent":["/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = require(\"clone\");\n\n  EventEmitter = require('events').EventEmitter;\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String | Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}