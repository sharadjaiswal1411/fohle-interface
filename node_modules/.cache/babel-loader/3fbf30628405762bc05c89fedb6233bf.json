{"ast":null,"code":"import { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { CELO, CELO_ALFAJORES, CEUR_CELO, CEUR_CELO_ALFAJORES, CUSD_CELO, CUSD_CELO_ALFAJORES, DAI_ARBITRUM, DAI_ARBITRUM_RINKEBY, DAI_MAINNET, DAI_MOONBEAM, DAI_OPTIMISM, DAI_OPTIMISTIC_KOVAN, DAI_POLYGON_MUMBAI, DAI_RINKEBY_1, DAI_RINKEBY_2, FEI_MAINNET, USDC_ARBITRUM, USDC_ETHEREUM_GNOSIS, USDC_MAINNET, USDC_MOONBEAM, USDC_OPTIMISM, USDC_OPTIMISTIC_KOVAN, USDC_POLYGON, USDT_ARBITRUM, USDT_ARBITRUM_RINKEBY, USDT_MAINNET, USDT_OPTIMISM, USDT_OPTIMISTIC_KOVAN, WBTC_ARBITRUM, WBTC_GNOSIS, WBTC_MAINNET, WBTC_MOONBEAM, WBTC_OPTIMISM, WBTC_OPTIMISTIC_KOVAN, WGLMR_MOONBEAM, WMATIC_POLYGON, WMATIC_POLYGON_MUMBAI, WXDAI_GNOSIS } from '../../../providers/token-provider';\nimport { ChainId, WRAPPED_NATIVE_CURRENCY } from '../../../util';\nimport { parseFeeAmount, unparseFeeAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nconst baseTokensByChain = {\n  [ChainId.MAINNET]: [USDC_MAINNET, USDT_MAINNET, WBTC_MAINNET, DAI_MAINNET, WRAPPED_NATIVE_CURRENCY[1], FEI_MAINNET],\n  [ChainId.RINKEBY]: [DAI_RINKEBY_1, DAI_RINKEBY_2],\n  [ChainId.OPTIMISM]: [DAI_OPTIMISM, USDC_OPTIMISM, USDT_OPTIMISM, WBTC_OPTIMISM],\n  [ChainId.OPTIMISTIC_KOVAN]: [DAI_OPTIMISTIC_KOVAN, USDC_OPTIMISTIC_KOVAN, WBTC_OPTIMISTIC_KOVAN, USDT_OPTIMISTIC_KOVAN],\n  [ChainId.ARBITRUM_ONE]: [DAI_ARBITRUM, USDC_ARBITRUM, WBTC_ARBITRUM, USDT_ARBITRUM],\n  [ChainId.ARBITRUM_RINKEBY]: [DAI_ARBITRUM_RINKEBY, USDT_ARBITRUM_RINKEBY],\n  [ChainId.POLYGON]: [USDC_POLYGON, WMATIC_POLYGON],\n  [ChainId.POLYGON_MUMBAI]: [DAI_POLYGON_MUMBAI, WMATIC_POLYGON_MUMBAI],\n  [ChainId.CELO]: [CUSD_CELO, CEUR_CELO, CELO],\n  [ChainId.CELO_ALFAJORES]: [CUSD_CELO_ALFAJORES, CEUR_CELO_ALFAJORES, CELO_ALFAJORES],\n  [ChainId.GNOSIS]: [WBTC_GNOSIS, WXDAI_GNOSIS, USDC_ETHEREUM_GNOSIS],\n  [ChainId.MOONBEAM]: [DAI_MOONBEAM, USDC_MOONBEAM, WBTC_MOONBEAM, WGLMR_MOONBEAM]\n};\nexport async function getV3CandidatePools(_ref) {\n  let {\n    tokenIn,\n    tokenOut,\n    routeType,\n    routingConfig,\n    subgraphProvider,\n    tokenProvider,\n    poolProvider,\n    blockedTokenListProvider,\n    chainId\n  } = _ref;\n  var _a, _b, _c, _d, _e;\n  const {\n    blockNumber,\n    v3PoolSelection: {\n      topN,\n      topNDirectSwaps,\n      topNTokenInOut,\n      topNSecondHop,\n      topNWithEachBaseToken,\n      topNWithBaseToken\n    }\n  } = routingConfig;\n  const tokenInAddress = tokenIn.address.toLowerCase();\n  const tokenOutAddress = tokenOut.address.toLowerCase();\n  const beforeSubgraphPools = Date.now();\n  const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n    blockNumber\n  });\n  log.info({\n    samplePools: allPoolsRaw.slice(0, 3)\n  }, 'Got all pools from V3 subgraph provider');\n  const allPools = _.map(allPoolsRaw, pool => {\n    return {\n      ...pool,\n      token0: {\n        ...pool.token0,\n        id: pool.token0.id.toLowerCase()\n      },\n      token1: {\n        ...pool.token1,\n        id: pool.token1.id.toLowerCase()\n      }\n    };\n  });\n  metric.putMetric('V3SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n  // Only consider pools where neither tokens are in the blocked token list.\n  let filteredPools = allPools;\n  if (blockedTokenListProvider) {\n    filteredPools = [];\n    for (const pool of allPools) {\n      const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n      const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n      if (token0InBlocklist || token1InBlocklist) {\n        continue;\n      }\n      filteredPools.push(pool);\n    }\n  }\n  const subgraphPoolsSorted = _(filteredPools).sortBy(tokenListPool => -tokenListPool.tvlUSD).value();\n  log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n  const poolAddressesSoFar = new Set();\n  const addToAddressSet = pools => {\n    _(pools).map(pool => pool.id).forEach(poolAddress => poolAddressesSoFar.add(poolAddress));\n  };\n  const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n  const topByBaseWithTokenIn = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenInAddress;\n    }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithBaseToken).value();\n  const topByBaseWithTokenOut = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenOutAddress;\n    }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithBaseToken).value();\n  let top2DirectSwapPool = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenInAddress && subgraphPool.token0.id == tokenOutAddress);\n  }).slice(0, topNDirectSwaps).value();\n  if (top2DirectSwapPool.length == 0 && topNDirectSwaps > 0) {\n    // If we requested direct swap pools but did not find any in the subgraph query.\n    // Optimistically add them into the query regardless. Invalid pools ones will be dropped anyway\n    // when we query the pool on-chain. Ensures that new pools for new pairs can be swapped on immediately.\n    top2DirectSwapPool = _.map([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST], feeAmount => {\n      const {\n        token0,\n        token1,\n        poolAddress\n      } = poolProvider.getPoolAddress(tokenIn, tokenOut, feeAmount);\n      return {\n        id: poolAddress,\n        feeTier: unparseFeeAmount(feeAmount),\n        liquidity: '10000',\n        token0: {\n          id: token0.address\n        },\n        token1: {\n          id: token1.address\n        },\n        tvlETH: 10000,\n        tvlUSD: 10000\n      };\n    });\n  }\n  addToAddressSet(top2DirectSwapPool);\n  const wrappedNativeAddress = (_b = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _b === void 0 ? void 0 : _b.address;\n  // Main reason we need this is for gas estimates, only needed if token out is not native.\n  // We don't check the seen address set because if we've already added pools for getting native quotes\n  // theres no need to add more.\n  let top2EthQuoteTokenPool = [];\n  if (((_c = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _c === void 0 ? void 0 : _c.symbol) == ((_d = WRAPPED_NATIVE_CURRENCY[ChainId.MAINNET]) === null || _d === void 0 ? void 0 : _d.symbol) && tokenOut.symbol != 'WETH' && tokenOut.symbol != 'WETH9' && tokenOut.symbol != 'ETH' || ((_e = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _e === void 0 ? void 0 : _e.symbol) == WMATIC_POLYGON.symbol && tokenOut.symbol != 'MATIC' && tokenOut.symbol != 'WMATIC') {\n    top2EthQuoteTokenPool = _(subgraphPoolsSorted).filter(subgraphPool => {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return subgraphPool.token0.id == wrappedNativeAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == wrappedNativeAddress && subgraphPool.token0.id == tokenOutAddress;\n      } else {\n        return subgraphPool.token0.id == wrappedNativeAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == wrappedNativeAddress && subgraphPool.token0.id == tokenInAddress;\n      }\n    }).slice(0, 1).value();\n  }\n  addToAddressSet(top2EthQuoteTokenPool);\n  const topByTVL = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id);\n  }).slice(0, topN).value();\n  addToAddressSet(topByTVL);\n  const topByTVLUsingTokenIn = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress || subgraphPool.token1.id == tokenInAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenIn);\n  const topByTVLUsingTokenOut = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenOutAddress || subgraphPool.token1.id == tokenOutAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenOut);\n  const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn).map(subgraphPool => {\n    return tokenInAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenInSecondHops);\n  const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut).map(subgraphPool => {\n    return tokenOutAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenOutSecondHops);\n  const subgraphPools = _([...topByBaseWithTokenIn, ...topByBaseWithTokenOut, ...top2DirectSwapPool, ...top2EthQuoteTokenPool, ...topByTVL, ...topByTVLUsingTokenIn, ...topByTVLUsingTokenOut, ...topByTVLUsingTokenInSecondHops, ...topByTVLUsingTokenOutSecondHops]).compact().uniqBy(pool => pool.id).value();\n  const tokenAddresses = _(subgraphPools).flatMap(subgraphPool => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();\n  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V3 pools we are considering`);\n  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n    blockNumber\n  });\n  const printV3SubgraphPool = s => {\n    var _a, _b, _c, _d;\n    return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}/${s.feeTier}`;\n  };\n  log.info({\n    topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV3SubgraphPool),\n    topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV3SubgraphPool),\n    topByTVL: topByTVL.map(printV3SubgraphPool),\n    topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV3SubgraphPool),\n    topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV3SubgraphPool),\n    topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV3SubgraphPool),\n    topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV3SubgraphPool),\n    top2DirectSwap: top2DirectSwapPool.map(printV3SubgraphPool),\n    top2EthQuotePool: top2EthQuoteTokenPool.map(printV3SubgraphPool)\n  }, `V3 Candidate Pools`);\n  const tokenPairsRaw = _.map(subgraphPools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    let fee;\n    try {\n      fee = parseFeeAmount(subgraphPool.feeTier);\n    } catch (err) {\n      log.info({\n        subgraphPool\n      }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n      return undefined;\n    }\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n      return undefined;\n    }\n    return [tokenA, tokenB, fee];\n  });\n  const tokenPairs = _.compact(tokenPairsRaw);\n  const beforePoolsLoad = Date.now();\n  const poolAccessor = await poolProvider.getPools(tokenPairs);\n  metric.putMetric('V3PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n  const poolsBySelection = {\n    protocol: Protocol.V3,\n    selections: {\n      topByBaseWithTokenIn,\n      topByBaseWithTokenOut,\n      topByDirectSwapPool: top2DirectSwapPool,\n      topByEthQuoteTokenPool: top2EthQuoteTokenPool,\n      topByTVL,\n      topByTVLUsingTokenIn,\n      topByTVLUsingTokenOut,\n      topByTVLUsingTokenInSecondHops,\n      topByTVLUsingTokenOutSecondHops\n    }\n  };\n  return {\n    poolAccessor,\n    candidatePools: poolsBySelection,\n    subgraphPools\n  };\n}\nexport async function getV2CandidatePools(_ref2) {\n  let {\n    tokenIn,\n    tokenOut,\n    routeType,\n    routingConfig,\n    subgraphProvider,\n    tokenProvider,\n    poolProvider,\n    blockedTokenListProvider,\n    chainId\n  } = _ref2;\n  var _a;\n  const {\n    blockNumber,\n    v2PoolSelection: {\n      topN,\n      topNDirectSwaps,\n      topNTokenInOut,\n      topNSecondHop,\n      topNWithEachBaseToken,\n      topNWithBaseToken\n    }\n  } = routingConfig;\n  const tokenInAddress = tokenIn.address.toLowerCase();\n  const tokenOutAddress = tokenOut.address.toLowerCase();\n  const beforeSubgraphPools = Date.now();\n  const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n    blockNumber\n  });\n  const allPools = _.map(allPoolsRaw, pool => {\n    return {\n      ...pool,\n      token0: {\n        ...pool.token0,\n        id: pool.token0.id.toLowerCase()\n      },\n      token1: {\n        ...pool.token1,\n        id: pool.token1.id.toLowerCase()\n      }\n    };\n  });\n  metric.putMetric('V2SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n  // Only consider pools where neither tokens are in the blocked token list.\n  let filteredPools = allPools;\n  if (blockedTokenListProvider) {\n    filteredPools = [];\n    for (const pool of allPools) {\n      const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n      const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n      if (token0InBlocklist || token1InBlocklist) {\n        continue;\n      }\n      filteredPools.push(pool);\n    }\n  }\n  const subgraphPoolsSorted = _(filteredPools).sortBy(tokenListPool => -tokenListPool.reserve).value();\n  log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n  const poolAddressesSoFar = new Set();\n  const addToAddressSet = pools => {\n    _(pools).map(pool => pool.id).forEach(poolAddress => poolAddressesSoFar.add(poolAddress));\n  };\n  const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n  const topByBaseWithTokenIn = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenInAddress;\n    }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithBaseToken).value();\n  const topByBaseWithTokenOut = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenOutAddress;\n    }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithBaseToken).value();\n  // Always add the direct swap pool into the mix regardless of if it exists in the subgraph pool list.\n  // Ensures that new pools can be swapped on immediately, and that if a pool was filtered out of the\n  // subgraph query for some reason (e.g. trackedReserveETH was 0), then we still consider it.\n  let topByDirectSwapPool = [];\n  if (topNDirectSwaps != 0) {\n    const {\n      token0,\n      token1,\n      poolAddress\n    } = poolProvider.getPoolAddress(tokenIn, tokenOut);\n    topByDirectSwapPool = [{\n      id: poolAddress,\n      token0: {\n        id: token0.address\n      },\n      token1: {\n        id: token1.address\n      },\n      supply: 10000,\n      reserve: 10000,\n      reserveUSD: 10000 // Not used. Set to arbitrary number.\n    }];\n  }\n\n  addToAddressSet(topByDirectSwapPool);\n  const wethAddress = WRAPPED_NATIVE_CURRENCY[chainId].address;\n  // Main reason we need this is for gas estimates, only needed if token out is not ETH.\n  // We don't check the seen address set because if we've already added pools for getting ETH quotes\n  // theres no need to add more.\n  // Note: we do not need to check other native currencies for the V2 Protocol\n  let topByEthQuoteTokenPool = [];\n  if (tokenOut.symbol != 'WETH' && tokenOut.symbol != 'WETH9' && tokenOut.symbol != 'ETH') {\n    topByEthQuoteTokenPool = _(subgraphPoolsSorted).filter(subgraphPool => {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return subgraphPool.token0.id == wethAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == wethAddress && subgraphPool.token0.id == tokenOutAddress;\n      } else {\n        return subgraphPool.token0.id == wethAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == wethAddress && subgraphPool.token0.id == tokenInAddress;\n      }\n    }).slice(0, 1).value();\n  }\n  addToAddressSet(topByEthQuoteTokenPool);\n  const topByTVL = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id);\n  }).slice(0, topN).value();\n  addToAddressSet(topByTVL);\n  const topByTVLUsingTokenIn = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress || subgraphPool.token1.id == tokenInAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenIn);\n  const topByTVLUsingTokenOut = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenOutAddress || subgraphPool.token1.id == tokenOutAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenOut);\n  const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn).map(subgraphPool => {\n    return tokenInAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenInSecondHops);\n  const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut).map(subgraphPool => {\n    return tokenOutAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenOutSecondHops);\n  const subgraphPools = _([...topByBaseWithTokenIn, ...topByBaseWithTokenOut, ...topByDirectSwapPool, ...topByEthQuoteTokenPool, ...topByTVL, ...topByTVLUsingTokenIn, ...topByTVLUsingTokenOut, ...topByTVLUsingTokenInSecondHops, ...topByTVLUsingTokenOutSecondHops]).compact().uniqBy(pool => pool.id).value();\n  const tokenAddresses = _(subgraphPools).flatMap(subgraphPool => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();\n  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V2 pools we are considering`);\n  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n    blockNumber\n  });\n  const printV2SubgraphPool = s => {\n    var _a, _b, _c, _d;\n    return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}`;\n  };\n  log.info({\n    topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV2SubgraphPool),\n    topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV2SubgraphPool),\n    topByTVL: topByTVL.map(printV2SubgraphPool),\n    topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV2SubgraphPool),\n    topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV2SubgraphPool),\n    topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV2SubgraphPool),\n    topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV2SubgraphPool),\n    top2DirectSwap: topByDirectSwapPool.map(printV2SubgraphPool),\n    top2EthQuotePool: topByEthQuoteTokenPool.map(printV2SubgraphPool)\n  }, `V2 Candidate pools`);\n  const tokenPairsRaw = _.map(subgraphPools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n      return undefined;\n    }\n    return [tokenA, tokenB];\n  });\n  const tokenPairs = _.compact(tokenPairsRaw);\n  const beforePoolsLoad = Date.now();\n  const poolAccessor = await poolProvider.getPools(tokenPairs, {\n    blockNumber\n  });\n  metric.putMetric('V2PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n  const poolsBySelection = {\n    protocol: Protocol.V2,\n    selections: {\n      topByBaseWithTokenIn,\n      topByBaseWithTokenOut,\n      topByDirectSwapPool,\n      topByEthQuoteTokenPool: topByEthQuoteTokenPool,\n      topByTVL,\n      topByTVLUsingTokenIn,\n      topByTVLUsingTokenOut,\n      topByTVLUsingTokenInSecondHops,\n      topByTVLUsingTokenOutSecondHops\n    }\n  };\n  return {\n    poolAccessor,\n    candidatePools: poolsBySelection,\n    subgraphPools\n  };\n}\nexport async function getMixedRouteCandidatePools(_ref3) {\n  let {\n    tokenIn,\n    tokenOut,\n    routeType,\n    routingConfig,\n    v3subgraphProvider,\n    v2subgraphProvider,\n    tokenProvider,\n    v3poolProvider,\n    v2poolProvider,\n    blockedTokenListProvider,\n    chainId\n  } = _ref3;\n  const {\n    blockNumber\n  } = routingConfig;\n  const {\n    subgraphPools: V3subgraphPools,\n    candidatePools: V3candidatePools\n  } = await getV3CandidatePools({\n    tokenIn,\n    tokenOut,\n    tokenProvider,\n    blockedTokenListProvider,\n    poolProvider: v3poolProvider,\n    routeType,\n    subgraphProvider: v3subgraphProvider,\n    routingConfig,\n    chainId\n  });\n  const {\n    subgraphPools: V2subgraphPools,\n    candidatePools: V2candidatePools\n  } = await getV2CandidatePools({\n    tokenIn,\n    tokenOut,\n    tokenProvider,\n    blockedTokenListProvider,\n    poolProvider: v2poolProvider,\n    routeType,\n    subgraphProvider: v2subgraphProvider,\n    routingConfig,\n    chainId\n  });\n  /**\n   * Main heuristic for pruning mixedRoutes:\n   * - we pick V2 pools with higher liq than respective V3 pools, or if the v3 pool doesn't exist\n   *\n   * This way we can reduce calls to our provider since it's possible to generate a lot of mixed routes\n   */\n  /// We only really care about pools involving the tokenIn or tokenOut explictly,\n  /// since there's no way a long tail token in V2 would be routed through as an intermediary\n  const V2topByTVLPoolIds = new Set([...V2candidatePools.selections.topByTVLUsingTokenIn, ...V2candidatePools.selections.topByBaseWithTokenIn,\n  /// tokenOut:\n  ...V2candidatePools.selections.topByTVLUsingTokenOut, ...V2candidatePools.selections.topByBaseWithTokenOut,\n  /// Direct swap:\n  ...V2candidatePools.selections.topByDirectSwapPool].map(poolId => poolId.id));\n  let V2topByTVLSortedPools = _(V2subgraphPools).filter(pool => V2topByTVLPoolIds.has(pool.id)).sortBy(pool => -pool.reserveUSD).value();\n  /// we consider all returned V3 pools for this heuristic to \"fill in the gaps\"\n  const V3sortedPools = _(V3subgraphPools).sortBy(pool => -pool.tvlUSD).value();\n  /// Finding pools with greater reserveUSD on v2 than tvlUSD on v3, or if there is no v3 liquidity\n  const buildV2Pools = [];\n  V2topByTVLSortedPools.forEach(V2subgraphPool => {\n    const V3subgraphPool = V3sortedPools.find(pool => pool.token0.id == V2subgraphPool.token0.id && pool.token1.id == V2subgraphPool.token1.id || pool.token0.id == V2subgraphPool.token1.id && pool.token1.id == V2subgraphPool.token0.id);\n    if (V3subgraphPool) {\n      if (V2subgraphPool.reserveUSD > V3subgraphPool.tvlUSD) {\n        log.info({\n          token0: V2subgraphPool.token0.id,\n          token1: V2subgraphPool.token1.id,\n          v2reserveUSD: V2subgraphPool.reserveUSD,\n          v3tvlUSD: V3subgraphPool.tvlUSD\n        }, `MixedRoute heuristic, found a V2 pool with higher liquidity than its V3 counterpart`);\n        buildV2Pools.push(V2subgraphPool);\n      }\n    } else {\n      log.info({\n        token0: V2subgraphPool.token0.id,\n        token1: V2subgraphPool.token1.id,\n        v2reserveUSD: V2subgraphPool.reserveUSD\n      }, `MixedRoute heuristic, found a V2 pool with no V3 counterpart`);\n      buildV2Pools.push(V2subgraphPool);\n    }\n  });\n  log.info(buildV2Pools.length, `Number of V2 candidate pools that fit first heuristic`);\n  const subgraphPools = [...buildV2Pools, ...V3sortedPools];\n  const tokenAddresses = _(subgraphPools).flatMap(subgraphPool => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();\n  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} pools we are considering`);\n  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n    blockNumber\n  });\n  const V3tokenPairsRaw = _.map(V3sortedPools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    let fee;\n    try {\n      fee = parseFeeAmount(subgraphPool.feeTier);\n    } catch (err) {\n      log.info({\n        subgraphPool\n      }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n      return undefined;\n    }\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n      return undefined;\n    }\n    return [tokenA, tokenB, fee];\n  });\n  const V3tokenPairs = _.compact(V3tokenPairsRaw);\n  const V2tokenPairsRaw = _.map(buildV2Pools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n      return undefined;\n    }\n    return [tokenA, tokenB];\n  });\n  const V2tokenPairs = _.compact(V2tokenPairsRaw);\n  const [V2poolAccessor, V3poolAccessor] = await Promise.all([v2poolProvider.getPools(V2tokenPairs, {\n    blockNumber\n  }), v3poolProvider.getPools(V3tokenPairs, {\n    blockNumber\n  })]);\n  /// @dev a bit tricky here since the original V2CandidateSelections object included pools that we may have dropped\n  /// as part of the heuristic. We need to reconstruct a new object with the v3 pools too.\n  const buildPoolsBySelection = key => {\n    return [...buildV2Pools.filter(pool => V2candidatePools.selections[key].map(p => p.id).includes(pool.id)), ...V3candidatePools.selections[key]];\n  };\n  const poolsBySelection = {\n    protocol: Protocol.MIXED,\n    selections: {\n      topByBaseWithTokenIn: buildPoolsBySelection('topByBaseWithTokenIn'),\n      topByBaseWithTokenOut: buildPoolsBySelection('topByBaseWithTokenOut'),\n      topByDirectSwapPool: buildPoolsBySelection('topByDirectSwapPool'),\n      topByEthQuoteTokenPool: buildPoolsBySelection('topByEthQuoteTokenPool'),\n      topByTVL: buildPoolsBySelection('topByTVL'),\n      topByTVLUsingTokenIn: buildPoolsBySelection('topByTVLUsingTokenIn'),\n      topByTVLUsingTokenOut: buildPoolsBySelection('topByTVLUsingTokenOut'),\n      topByTVLUsingTokenInSecondHops: buildPoolsBySelection('topByTVLUsingTokenInSecondHops'),\n      topByTVLUsingTokenOutSecondHops: buildPoolsBySelection('topByTVLUsingTokenOutSecondHops')\n    }\n  };\n  return {\n    V2poolAccessor,\n    V3poolAccessor,\n    candidatePools: poolsBySelection,\n    subgraphPools\n  };\n}","map":{"version":3,"sources":["../../../../../src/routers/alpha-router/functions/get-candidate-pools.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { CELO, CELO_ALFAJORES, CEUR_CELO, CEUR_CELO_ALFAJORES, CUSD_CELO, CUSD_CELO_ALFAJORES, DAI_ARBITRUM, DAI_ARBITRUM_RINKEBY, DAI_MAINNET, DAI_MOONBEAM, DAI_OPTIMISM, DAI_OPTIMISTIC_KOVAN, DAI_POLYGON_MUMBAI, DAI_RINKEBY_1, DAI_RINKEBY_2, FEI_MAINNET, USDC_ARBITRUM, USDC_ETHEREUM_GNOSIS, USDC_MAINNET, USDC_MOONBEAM, USDC_OPTIMISM, USDC_OPTIMISTIC_KOVAN, USDC_POLYGON, USDT_ARBITRUM, USDT_ARBITRUM_RINKEBY, USDT_MAINNET, USDT_OPTIMISM, USDT_OPTIMISTIC_KOVAN, WBTC_ARBITRUM, WBTC_GNOSIS, WBTC_MAINNET, WBTC_MOONBEAM, WBTC_OPTIMISM, WBTC_OPTIMISTIC_KOVAN, WGLMR_MOONBEAM, WMATIC_POLYGON, WMATIC_POLYGON_MUMBAI, WXDAI_GNOSIS, } from '../../../providers/token-provider';\nimport { ChainId, WRAPPED_NATIVE_CURRENCY } from '../../../util';\nimport { parseFeeAmount, unparseFeeAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nconst baseTokensByChain = {\n    [ChainId.MAINNET]: [\n        USDC_MAINNET,\n        USDT_MAINNET,\n        WBTC_MAINNET,\n        DAI_MAINNET,\n        WRAPPED_NATIVE_CURRENCY[1],\n        FEI_MAINNET,\n    ],\n    [ChainId.RINKEBY]: [DAI_RINKEBY_1, DAI_RINKEBY_2],\n    [ChainId.OPTIMISM]: [\n        DAI_OPTIMISM,\n        USDC_OPTIMISM,\n        USDT_OPTIMISM,\n        WBTC_OPTIMISM,\n    ],\n    [ChainId.OPTIMISTIC_KOVAN]: [\n        DAI_OPTIMISTIC_KOVAN,\n        USDC_OPTIMISTIC_KOVAN,\n        WBTC_OPTIMISTIC_KOVAN,\n        USDT_OPTIMISTIC_KOVAN,\n    ],\n    [ChainId.ARBITRUM_ONE]: [\n        DAI_ARBITRUM,\n        USDC_ARBITRUM,\n        WBTC_ARBITRUM,\n        USDT_ARBITRUM,\n    ],\n    [ChainId.ARBITRUM_RINKEBY]: [DAI_ARBITRUM_RINKEBY, USDT_ARBITRUM_RINKEBY],\n    [ChainId.POLYGON]: [USDC_POLYGON, WMATIC_POLYGON],\n    [ChainId.POLYGON_MUMBAI]: [DAI_POLYGON_MUMBAI, WMATIC_POLYGON_MUMBAI],\n    [ChainId.CELO]: [CUSD_CELO, CEUR_CELO, CELO],\n    [ChainId.CELO_ALFAJORES]: [\n        CUSD_CELO_ALFAJORES,\n        CEUR_CELO_ALFAJORES,\n        CELO_ALFAJORES,\n    ],\n    [ChainId.GNOSIS]: [WBTC_GNOSIS, WXDAI_GNOSIS, USDC_ETHEREUM_GNOSIS],\n    [ChainId.MOONBEAM]: [\n        DAI_MOONBEAM,\n        USDC_MOONBEAM,\n        WBTC_MOONBEAM,\n        WGLMR_MOONBEAM,\n    ],\n};\nexport async function getV3CandidatePools({ tokenIn, tokenOut, routeType, routingConfig, subgraphProvider, tokenProvider, poolProvider, blockedTokenListProvider, chainId, }) {\n    var _a, _b, _c, _d, _e;\n    const { blockNumber, v3PoolSelection: { topN, topNDirectSwaps, topNTokenInOut, topNSecondHop, topNWithEachBaseToken, topNWithBaseToken, }, } = routingConfig;\n    const tokenInAddress = tokenIn.address.toLowerCase();\n    const tokenOutAddress = tokenOut.address.toLowerCase();\n    const beforeSubgraphPools = Date.now();\n    const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n        blockNumber,\n    });\n    log.info({ samplePools: allPoolsRaw.slice(0, 3) }, 'Got all pools from V3 subgraph provider');\n    const allPools = _.map(allPoolsRaw, (pool) => {\n        return {\n            ...pool,\n            token0: {\n                ...pool.token0,\n                id: pool.token0.id.toLowerCase(),\n            },\n            token1: {\n                ...pool.token1,\n                id: pool.token1.id.toLowerCase(),\n            },\n        };\n    });\n    metric.putMetric('V3SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n    // Only consider pools where neither tokens are in the blocked token list.\n    let filteredPools = allPools;\n    if (blockedTokenListProvider) {\n        filteredPools = [];\n        for (const pool of allPools) {\n            const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n            const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n            if (token0InBlocklist || token1InBlocklist) {\n                continue;\n            }\n            filteredPools.push(pool);\n        }\n    }\n    const subgraphPoolsSorted = _(filteredPools)\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .value();\n    log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n    const poolAddressesSoFar = new Set();\n    const addToAddressSet = (pools) => {\n        _(pools)\n            .map((pool) => pool.id)\n            .forEach((poolAddress) => poolAddressesSoFar.add(poolAddress));\n    };\n    const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n    const topByBaseWithTokenIn = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenInAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenInAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNWithBaseToken)\n        .value();\n    const topByBaseWithTokenOut = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenOutAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenOutAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNWithBaseToken)\n        .value();\n    let top2DirectSwapPool = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            ((subgraphPool.token0.id == tokenInAddress &&\n                subgraphPool.token1.id == tokenOutAddress) ||\n                (subgraphPool.token1.id == tokenInAddress &&\n                    subgraphPool.token0.id == tokenOutAddress)));\n    })\n        .slice(0, topNDirectSwaps)\n        .value();\n    if (top2DirectSwapPool.length == 0 && topNDirectSwaps > 0) {\n        // If we requested direct swap pools but did not find any in the subgraph query.\n        // Optimistically add them into the query regardless. Invalid pools ones will be dropped anyway\n        // when we query the pool on-chain. Ensures that new pools for new pairs can be swapped on immediately.\n        top2DirectSwapPool = _.map([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST], (feeAmount) => {\n            const { token0, token1, poolAddress } = poolProvider.getPoolAddress(tokenIn, tokenOut, feeAmount);\n            return {\n                id: poolAddress,\n                feeTier: unparseFeeAmount(feeAmount),\n                liquidity: '10000',\n                token0: {\n                    id: token0.address,\n                },\n                token1: {\n                    id: token1.address,\n                },\n                tvlETH: 10000,\n                tvlUSD: 10000,\n            };\n        });\n    }\n    addToAddressSet(top2DirectSwapPool);\n    const wrappedNativeAddress = (_b = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _b === void 0 ? void 0 : _b.address;\n    // Main reason we need this is for gas estimates, only needed if token out is not native.\n    // We don't check the seen address set because if we've already added pools for getting native quotes\n    // theres no need to add more.\n    let top2EthQuoteTokenPool = [];\n    if ((((_c = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _c === void 0 ? void 0 : _c.symbol) ==\n        ((_d = WRAPPED_NATIVE_CURRENCY[ChainId.MAINNET]) === null || _d === void 0 ? void 0 : _d.symbol) &&\n        tokenOut.symbol != 'WETH' &&\n        tokenOut.symbol != 'WETH9' &&\n        tokenOut.symbol != 'ETH') ||\n        (((_e = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _e === void 0 ? void 0 : _e.symbol) == WMATIC_POLYGON.symbol &&\n            tokenOut.symbol != 'MATIC' &&\n            tokenOut.symbol != 'WMATIC')) {\n        top2EthQuoteTokenPool = _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return ((subgraphPool.token0.id == wrappedNativeAddress &&\n                    subgraphPool.token1.id == tokenOutAddress) ||\n                    (subgraphPool.token1.id == wrappedNativeAddress &&\n                        subgraphPool.token0.id == tokenOutAddress));\n            }\n            else {\n                return ((subgraphPool.token0.id == wrappedNativeAddress &&\n                    subgraphPool.token1.id == tokenInAddress) ||\n                    (subgraphPool.token1.id == wrappedNativeAddress &&\n                        subgraphPool.token0.id == tokenInAddress));\n            }\n        })\n            .slice(0, 1)\n            .value();\n    }\n    addToAddressSet(top2EthQuoteTokenPool);\n    const topByTVL = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return !poolAddressesSoFar.has(subgraphPool.id);\n    })\n        .slice(0, topN)\n        .value();\n    addToAddressSet(topByTVL);\n    const topByTVLUsingTokenIn = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenInAddress ||\n                subgraphPool.token1.id == tokenInAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenIn);\n    const topByTVLUsingTokenOut = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenOutAddress ||\n                subgraphPool.token1.id == tokenOutAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOut);\n    const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn)\n        .map((subgraphPool) => {\n        return tokenInAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenInSecondHops);\n    const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut)\n        .map((subgraphPool) => {\n        return tokenOutAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOutSecondHops);\n    const subgraphPools = _([\n        ...topByBaseWithTokenIn,\n        ...topByBaseWithTokenOut,\n        ...top2DirectSwapPool,\n        ...top2EthQuoteTokenPool,\n        ...topByTVL,\n        ...topByTVLUsingTokenIn,\n        ...topByTVLUsingTokenOut,\n        ...topByTVLUsingTokenInSecondHops,\n        ...topByTVLUsingTokenOutSecondHops,\n    ])\n        .compact()\n        .uniqBy((pool) => pool.id)\n        .value();\n    const tokenAddresses = _(subgraphPools)\n        .flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id])\n        .compact()\n        .uniq()\n        .value();\n    log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V3 pools we are considering`);\n    const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n        blockNumber,\n    });\n    const printV3SubgraphPool = (s) => {\n        var _a, _b, _c, _d;\n        return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}/${s.feeTier}`;\n    };\n    log.info({\n        topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV3SubgraphPool),\n        topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV3SubgraphPool),\n        topByTVL: topByTVL.map(printV3SubgraphPool),\n        topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV3SubgraphPool),\n        topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV3SubgraphPool),\n        topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV3SubgraphPool),\n        topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV3SubgraphPool),\n        top2DirectSwap: top2DirectSwapPool.map(printV3SubgraphPool),\n        top2EthQuotePool: top2EthQuoteTokenPool.map(printV3SubgraphPool),\n    }, `V3 Candidate Pools`);\n    const tokenPairsRaw = _.map(subgraphPools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        let fee;\n        try {\n            fee = parseFeeAmount(subgraphPool.feeTier);\n        }\n        catch (err) {\n            log.info({ subgraphPool }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n            return undefined;\n        }\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n            return undefined;\n        }\n        return [tokenA, tokenB, fee];\n    });\n    const tokenPairs = _.compact(tokenPairsRaw);\n    const beforePoolsLoad = Date.now();\n    const poolAccessor = await poolProvider.getPools(tokenPairs);\n    metric.putMetric('V3PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n    const poolsBySelection = {\n        protocol: Protocol.V3,\n        selections: {\n            topByBaseWithTokenIn,\n            topByBaseWithTokenOut,\n            topByDirectSwapPool: top2DirectSwapPool,\n            topByEthQuoteTokenPool: top2EthQuoteTokenPool,\n            topByTVL,\n            topByTVLUsingTokenIn,\n            topByTVLUsingTokenOut,\n            topByTVLUsingTokenInSecondHops,\n            topByTVLUsingTokenOutSecondHops,\n        },\n    };\n    return { poolAccessor, candidatePools: poolsBySelection, subgraphPools };\n}\nexport async function getV2CandidatePools({ tokenIn, tokenOut, routeType, routingConfig, subgraphProvider, tokenProvider, poolProvider, blockedTokenListProvider, chainId, }) {\n    var _a;\n    const { blockNumber, v2PoolSelection: { topN, topNDirectSwaps, topNTokenInOut, topNSecondHop, topNWithEachBaseToken, topNWithBaseToken, }, } = routingConfig;\n    const tokenInAddress = tokenIn.address.toLowerCase();\n    const tokenOutAddress = tokenOut.address.toLowerCase();\n    const beforeSubgraphPools = Date.now();\n    const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n        blockNumber,\n    });\n    const allPools = _.map(allPoolsRaw, (pool) => {\n        return {\n            ...pool,\n            token0: {\n                ...pool.token0,\n                id: pool.token0.id.toLowerCase(),\n            },\n            token1: {\n                ...pool.token1,\n                id: pool.token1.id.toLowerCase(),\n            },\n        };\n    });\n    metric.putMetric('V2SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n    // Only consider pools where neither tokens are in the blocked token list.\n    let filteredPools = allPools;\n    if (blockedTokenListProvider) {\n        filteredPools = [];\n        for (const pool of allPools) {\n            const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n            const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n            if (token0InBlocklist || token1InBlocklist) {\n                continue;\n            }\n            filteredPools.push(pool);\n        }\n    }\n    const subgraphPoolsSorted = _(filteredPools)\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .value();\n    log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n    const poolAddressesSoFar = new Set();\n    const addToAddressSet = (pools) => {\n        _(pools)\n            .map((pool) => pool.id)\n            .forEach((poolAddress) => poolAddressesSoFar.add(poolAddress));\n    };\n    const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n    const topByBaseWithTokenIn = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenInAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenInAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.reserve)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNWithBaseToken)\n        .value();\n    const topByBaseWithTokenOut = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenOutAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenOutAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.reserve)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNWithBaseToken)\n        .value();\n    // Always add the direct swap pool into the mix regardless of if it exists in the subgraph pool list.\n    // Ensures that new pools can be swapped on immediately, and that if a pool was filtered out of the\n    // subgraph query for some reason (e.g. trackedReserveETH was 0), then we still consider it.\n    let topByDirectSwapPool = [];\n    if (topNDirectSwaps != 0) {\n        const { token0, token1, poolAddress } = poolProvider.getPoolAddress(tokenIn, tokenOut);\n        topByDirectSwapPool = [\n            {\n                id: poolAddress,\n                token0: {\n                    id: token0.address,\n                },\n                token1: {\n                    id: token1.address,\n                },\n                supply: 10000,\n                reserve: 10000,\n                reserveUSD: 10000, // Not used. Set to arbitrary number.\n            },\n        ];\n    }\n    addToAddressSet(topByDirectSwapPool);\n    const wethAddress = WRAPPED_NATIVE_CURRENCY[chainId].address;\n    // Main reason we need this is for gas estimates, only needed if token out is not ETH.\n    // We don't check the seen address set because if we've already added pools for getting ETH quotes\n    // theres no need to add more.\n    // Note: we do not need to check other native currencies for the V2 Protocol\n    let topByEthQuoteTokenPool = [];\n    if (tokenOut.symbol != 'WETH' &&\n        tokenOut.symbol != 'WETH9' &&\n        tokenOut.symbol != 'ETH') {\n        topByEthQuoteTokenPool = _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return ((subgraphPool.token0.id == wethAddress &&\n                    subgraphPool.token1.id == tokenOutAddress) ||\n                    (subgraphPool.token1.id == wethAddress &&\n                        subgraphPool.token0.id == tokenOutAddress));\n            }\n            else {\n                return ((subgraphPool.token0.id == wethAddress &&\n                    subgraphPool.token1.id == tokenInAddress) ||\n                    (subgraphPool.token1.id == wethAddress &&\n                        subgraphPool.token0.id == tokenInAddress));\n            }\n        })\n            .slice(0, 1)\n            .value();\n    }\n    addToAddressSet(topByEthQuoteTokenPool);\n    const topByTVL = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return !poolAddressesSoFar.has(subgraphPool.id);\n    })\n        .slice(0, topN)\n        .value();\n    addToAddressSet(topByTVL);\n    const topByTVLUsingTokenIn = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenInAddress ||\n                subgraphPool.token1.id == tokenInAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenIn);\n    const topByTVLUsingTokenOut = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenOutAddress ||\n                subgraphPool.token1.id == tokenOutAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOut);\n    const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn)\n        .map((subgraphPool) => {\n        return tokenInAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenInSecondHops);\n    const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut)\n        .map((subgraphPool) => {\n        return tokenOutAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOutSecondHops);\n    const subgraphPools = _([\n        ...topByBaseWithTokenIn,\n        ...topByBaseWithTokenOut,\n        ...topByDirectSwapPool,\n        ...topByEthQuoteTokenPool,\n        ...topByTVL,\n        ...topByTVLUsingTokenIn,\n        ...topByTVLUsingTokenOut,\n        ...topByTVLUsingTokenInSecondHops,\n        ...topByTVLUsingTokenOutSecondHops,\n    ])\n        .compact()\n        .uniqBy((pool) => pool.id)\n        .value();\n    const tokenAddresses = _(subgraphPools)\n        .flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id])\n        .compact()\n        .uniq()\n        .value();\n    log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V2 pools we are considering`);\n    const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n        blockNumber,\n    });\n    const printV2SubgraphPool = (s) => {\n        var _a, _b, _c, _d;\n        return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}`;\n    };\n    log.info({\n        topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV2SubgraphPool),\n        topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV2SubgraphPool),\n        topByTVL: topByTVL.map(printV2SubgraphPool),\n        topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV2SubgraphPool),\n        topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV2SubgraphPool),\n        topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV2SubgraphPool),\n        topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV2SubgraphPool),\n        top2DirectSwap: topByDirectSwapPool.map(printV2SubgraphPool),\n        top2EthQuotePool: topByEthQuoteTokenPool.map(printV2SubgraphPool),\n    }, `V2 Candidate pools`);\n    const tokenPairsRaw = _.map(subgraphPools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n            return undefined;\n        }\n        return [tokenA, tokenB];\n    });\n    const tokenPairs = _.compact(tokenPairsRaw);\n    const beforePoolsLoad = Date.now();\n    const poolAccessor = await poolProvider.getPools(tokenPairs, { blockNumber });\n    metric.putMetric('V2PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n    const poolsBySelection = {\n        protocol: Protocol.V2,\n        selections: {\n            topByBaseWithTokenIn,\n            topByBaseWithTokenOut,\n            topByDirectSwapPool,\n            topByEthQuoteTokenPool: topByEthQuoteTokenPool,\n            topByTVL,\n            topByTVLUsingTokenIn,\n            topByTVLUsingTokenOut,\n            topByTVLUsingTokenInSecondHops,\n            topByTVLUsingTokenOutSecondHops,\n        },\n    };\n    return { poolAccessor, candidatePools: poolsBySelection, subgraphPools };\n}\nexport async function getMixedRouteCandidatePools({ tokenIn, tokenOut, routeType, routingConfig, v3subgraphProvider, v2subgraphProvider, tokenProvider, v3poolProvider, v2poolProvider, blockedTokenListProvider, chainId, }) {\n    const { blockNumber } = routingConfig;\n    const { subgraphPools: V3subgraphPools, candidatePools: V3candidatePools } = await getV3CandidatePools({\n        tokenIn,\n        tokenOut,\n        tokenProvider,\n        blockedTokenListProvider,\n        poolProvider: v3poolProvider,\n        routeType,\n        subgraphProvider: v3subgraphProvider,\n        routingConfig,\n        chainId,\n    });\n    const { subgraphPools: V2subgraphPools, candidatePools: V2candidatePools } = await getV2CandidatePools({\n        tokenIn,\n        tokenOut,\n        tokenProvider,\n        blockedTokenListProvider,\n        poolProvider: v2poolProvider,\n        routeType,\n        subgraphProvider: v2subgraphProvider,\n        routingConfig,\n        chainId,\n    });\n    /**\n     * Main heuristic for pruning mixedRoutes:\n     * - we pick V2 pools with higher liq than respective V3 pools, or if the v3 pool doesn't exist\n     *\n     * This way we can reduce calls to our provider since it's possible to generate a lot of mixed routes\n     */\n    /// We only really care about pools involving the tokenIn or tokenOut explictly,\n    /// since there's no way a long tail token in V2 would be routed through as an intermediary\n    const V2topByTVLPoolIds = new Set([\n        ...V2candidatePools.selections.topByTVLUsingTokenIn,\n        ...V2candidatePools.selections.topByBaseWithTokenIn,\n        /// tokenOut:\n        ...V2candidatePools.selections.topByTVLUsingTokenOut,\n        ...V2candidatePools.selections.topByBaseWithTokenOut,\n        /// Direct swap:\n        ...V2candidatePools.selections.topByDirectSwapPool,\n    ].map((poolId) => poolId.id));\n    let V2topByTVLSortedPools = _(V2subgraphPools)\n        .filter((pool) => V2topByTVLPoolIds.has(pool.id))\n        .sortBy((pool) => -pool.reserveUSD)\n        .value();\n    /// we consider all returned V3 pools for this heuristic to \"fill in the gaps\"\n    const V3sortedPools = _(V3subgraphPools)\n        .sortBy((pool) => -pool.tvlUSD)\n        .value();\n    /// Finding pools with greater reserveUSD on v2 than tvlUSD on v3, or if there is no v3 liquidity\n    const buildV2Pools = [];\n    V2topByTVLSortedPools.forEach((V2subgraphPool) => {\n        const V3subgraphPool = V3sortedPools.find((pool) => (pool.token0.id == V2subgraphPool.token0.id &&\n            pool.token1.id == V2subgraphPool.token1.id) ||\n            (pool.token0.id == V2subgraphPool.token1.id &&\n                pool.token1.id == V2subgraphPool.token0.id));\n        if (V3subgraphPool) {\n            if (V2subgraphPool.reserveUSD > V3subgraphPool.tvlUSD) {\n                log.info({\n                    token0: V2subgraphPool.token0.id,\n                    token1: V2subgraphPool.token1.id,\n                    v2reserveUSD: V2subgraphPool.reserveUSD,\n                    v3tvlUSD: V3subgraphPool.tvlUSD,\n                }, `MixedRoute heuristic, found a V2 pool with higher liquidity than its V3 counterpart`);\n                buildV2Pools.push(V2subgraphPool);\n            }\n        }\n        else {\n            log.info({\n                token0: V2subgraphPool.token0.id,\n                token1: V2subgraphPool.token1.id,\n                v2reserveUSD: V2subgraphPool.reserveUSD,\n            }, `MixedRoute heuristic, found a V2 pool with no V3 counterpart`);\n            buildV2Pools.push(V2subgraphPool);\n        }\n    });\n    log.info(buildV2Pools.length, `Number of V2 candidate pools that fit first heuristic`);\n    const subgraphPools = [...buildV2Pools, ...V3sortedPools];\n    const tokenAddresses = _(subgraphPools)\n        .flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id])\n        .compact()\n        .uniq()\n        .value();\n    log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} pools we are considering`);\n    const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n        blockNumber,\n    });\n    const V3tokenPairsRaw = _.map(V3sortedPools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        let fee;\n        try {\n            fee = parseFeeAmount(subgraphPool.feeTier);\n        }\n        catch (err) {\n            log.info({ subgraphPool }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n            return undefined;\n        }\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n            return undefined;\n        }\n        return [tokenA, tokenB, fee];\n    });\n    const V3tokenPairs = _.compact(V3tokenPairsRaw);\n    const V2tokenPairsRaw = _.map(buildV2Pools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n            return undefined;\n        }\n        return [tokenA, tokenB];\n    });\n    const V2tokenPairs = _.compact(V2tokenPairsRaw);\n    const [V2poolAccessor, V3poolAccessor] = await Promise.all([\n        v2poolProvider.getPools(V2tokenPairs, {\n            blockNumber,\n        }),\n        v3poolProvider.getPools(V3tokenPairs, {\n            blockNumber,\n        }),\n    ]);\n    /// @dev a bit tricky here since the original V2CandidateSelections object included pools that we may have dropped\n    /// as part of the heuristic. We need to reconstruct a new object with the v3 pools too.\n    const buildPoolsBySelection = (key) => {\n        return [\n            ...buildV2Pools.filter((pool) => V2candidatePools.selections[key].map((p) => p.id).includes(pool.id)),\n            ...V3candidatePools.selections[key],\n        ];\n    };\n    const poolsBySelection = {\n        protocol: Protocol.MIXED,\n        selections: {\n            topByBaseWithTokenIn: buildPoolsBySelection('topByBaseWithTokenIn'),\n            topByBaseWithTokenOut: buildPoolsBySelection('topByBaseWithTokenOut'),\n            topByDirectSwapPool: buildPoolsBySelection('topByDirectSwapPool'),\n            topByEthQuoteTokenPool: buildPoolsBySelection('topByEthQuoteTokenPool'),\n            topByTVL: buildPoolsBySelection('topByTVL'),\n            topByTVLUsingTokenIn: buildPoolsBySelection('topByTVLUsingTokenIn'),\n            topByTVLUsingTokenOut: buildPoolsBySelection('topByTVLUsingTokenOut'),\n            topByTVLUsingTokenInSecondHops: buildPoolsBySelection('topByTVLUsingTokenInSecondHops'),\n            topByTVLUsingTokenOutSecondHops: buildPoolsBySelection('topByTVLUsingTokenOutSecondHops'),\n        },\n    };\n    return {\n        V2poolAccessor,\n        V3poolAccessor,\n        candidatePools: poolsBySelection,\n        subgraphPools,\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWNhbmRpZGF0ZS1wb29scy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9mdW5jdGlvbnMvZ2V0LWNhbmRpZGF0ZS1wb29scy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDL0MsT0FBTyxFQUFTLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM1QyxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFPdkIsT0FBTyxFQUNMLElBQUksRUFDSixjQUFjLEVBQ2QsU0FBUyxFQUNULG1CQUFtQixFQUNuQixTQUFTLEVBQ1QsbUJBQW1CLEVBQ25CLFlBQVksRUFDWixvQkFBb0IsRUFDcEIsV0FBVyxFQUNYLFlBQVksRUFDWixZQUFZLEVBQ1osb0JBQW9CLEVBQ3BCLGtCQUFrQixFQUNsQixhQUFhLEVBQ2IsYUFBYSxFQUNiLFdBQVcsRUFFWCxhQUFhLEVBQ2Isb0JBQW9CLEVBQ3BCLFlBQVksRUFDWixhQUFhLEVBQ2IsYUFBYSxFQUNiLHFCQUFxQixFQUNyQixZQUFZLEVBQ1osYUFBYSxFQUNiLHFCQUFxQixFQUNyQixZQUFZLEVBQ1osYUFBYSxFQUNiLHFCQUFxQixFQUNyQixhQUFhLEVBQ2IsV0FBVyxFQUNYLFlBQVksRUFDWixhQUFhLEVBQ2IsYUFBYSxFQUNiLHFCQUFxQixFQUNyQixjQUFjLEVBQ2QsY0FBYyxFQUNkLHFCQUFxQixFQUNyQixZQUFZLEdBQ2IsTUFBTSxtQ0FBbUMsQ0FBQztBQWEzQyxPQUFPLEVBQUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RSxPQUFPLEVBQUUs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"]},"metadata":{},"sourceType":"module"}