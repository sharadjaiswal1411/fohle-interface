{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction(_ref, body) {\n  let {\n    gen,\n    validateName,\n    schema,\n    schemaEnv,\n    opts\n  } = _ref;\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code((0, codegen_1._)`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`\"\"`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);\n  });\n}\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)`${validateName}.evaluated`);\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules(_ref2) {\n  let {\n    schema,\n    self\n  } = _ref2;\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (self.RULES.all[key]) return true;\n  return false;\n}\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount);\n  // TODO var\n  gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = (0, dataType_1.getSchemaTypes)(it.schema);\n  const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword(_ref3) {\n  let {\n    gen,\n    schemaEnv,\n    schema,\n    errSchemaPath,\n    opts\n  } = _ref3;\n  const msg = schema.$comment;\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);\n  }\n}\nfunction assignEvaluated(_ref4) {\n  let {\n    gen,\n    evaluated,\n    props,\n    items\n  } = _ref4;\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n    return;\n  }\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n    groupKeywords(RULES.post);\n  });\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(t => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n  result(condition, successAction, failAction) {\n    this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n  }\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n  pass(condition, failAction) {\n    this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n  }\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n      return;\n    }\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n  }\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n      this._error(append, errorPaths);\n      this.setParams({});\n      return;\n    }\n    this._error(append, errorPaths);\n  }\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n  $dataError() {\n    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n  }\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n  block$data(valid, codeBlock) {\n    let $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n  check$data() {\n    let valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    let $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n    gen.else();\n  }\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n      }\n      return codegen_1.nil;\n    }\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n        return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;\n      }\n      return codegen_1.nil;\n    }\n  }\n  subschema(appl, valid) {\n    const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n    (0, subschema_1.extendSubschemaMode)(subschema, appl);\n    const nextContext = {\n      ...this.it,\n      ...subschema,\n      items: undefined,\n      props: undefined\n    };\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, _ref5) {\n  let {\n    dataLevel,\n    dataNames,\n    dataPathArr\n  } = _ref5;\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n  for (const segment of segments) {\n    if (segment) {\n      data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n      expr = (0, codegen_1._)`${expr} && ${data}`;\n    }\n  }\n  return expr;\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\nexports.getData = getData;","map":{"version":3,"sources":["../../../lib/compile/validate/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}