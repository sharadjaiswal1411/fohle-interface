{"ast":null,"code":"import { Token } from '@uniswap/sdk-core';\nimport { TickMath, tickToPrice } from '@uniswap/v3-sdk';\nimport gql from 'graphql-tag';\nimport JSBI from 'jsbi';\nimport keyBy from 'lodash.keyby';\nconst PRICE_FIXED_DIGITS = 4;\nconst DEFAULT_SURROUNDING_TICKS = 300;\nconst FEE_TIER_TO_TICK_SPACING = feeTier => {\n  switch (feeTier) {\n    case '10000':\n      return 200;\n    case '3000':\n      return 60;\n    case '500':\n      return 10;\n    case '100':\n      return 1;\n    default:\n      throw Error(`Tick spacing for fee tier ${feeTier} undefined.`);\n  }\n};\n_c = FEE_TIER_TO_TICK_SPACING;\nconst fetchInitializedTicks = async (poolAddress, tickIdxLowerBound, tickIdxUpperBound, client) => {\n  const tickQuery = gql`\n    query surroundingTicks(\n      $poolAddress: String!\n      $tickIdxLowerBound: BigInt!\n      $tickIdxUpperBound: BigInt!\n      $skip: Int!\n    ) {\n      ticks(\n        subgraphError: allow\n        first: 1000\n        skip: $skip\n        where: { poolAddress: $poolAddress, tickIdx_lte: $tickIdxUpperBound, tickIdx_gte: $tickIdxLowerBound }\n      ) {\n        tickIdx\n        liquidityGross\n        liquidityNet\n        price0\n        price1\n      }\n    }\n  `;\n  let surroundingTicks = [];\n  let surroundingTicksResult = [];\n  let skip = 0;\n  do {\n    const {\n      data,\n      error,\n      loading\n    } = await client.query({\n      query: tickQuery,\n      fetchPolicy: 'cache-first',\n      variables: {\n        poolAddress,\n        tickIdxLowerBound,\n        tickIdxUpperBound,\n        skip\n      }\n    });\n\n    // console.log({ data, error, loading }, 'Result. Skip: ' + skip)\n\n    if (loading) {\n      continue;\n    }\n    if (error) {\n      return {\n        error: Boolean(error),\n        loading,\n        ticks: surroundingTicksResult\n      };\n    }\n    surroundingTicks = data.ticks;\n    surroundingTicksResult = surroundingTicksResult.concat(surroundingTicks);\n    skip += 1000;\n  } while (surroundingTicks.length > 0);\n  return {\n    ticks: surroundingTicksResult,\n    loading: false,\n    error: false\n  };\n};\nconst poolQuery = gql`\n  query pool($poolAddress: String!) {\n    pool(id: $poolAddress) {\n      tick\n      token0 {\n        symbol\n        id\n        decimals\n      }\n      token1 {\n        symbol\n        id\n        decimals\n      }\n      feeTier\n      sqrtPrice\n      liquidity\n    }\n  }\n`;\nexport const fetchTicksSurroundingPrice = async function (poolAddress, client) {\n  let numSurroundingTicks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_SURROUNDING_TICKS;\n  const {\n    data: poolResult,\n    error,\n    loading\n  } = await client.query({\n    query: poolQuery,\n    variables: {\n      poolAddress\n    }\n  });\n  if (loading || error || !poolResult) {\n    return {\n      loading,\n      error: Boolean(error),\n      data: undefined\n    };\n  }\n  const {\n    pool: {\n      tick: poolCurrentTick,\n      feeTier,\n      liquidity,\n      token0: {\n        id: token0Address,\n        decimals: token0Decimals\n      },\n      token1: {\n        id: token1Address,\n        decimals: token1Decimals\n      }\n    }\n  } = poolResult;\n  const poolCurrentTickIdx = parseInt(poolCurrentTick);\n  const tickSpacing = FEE_TIER_TO_TICK_SPACING(feeTier);\n\n  // The pools current tick isn't necessarily a tick that can actually be initialized.\n  // Find the nearest valid tick given the tick spacing.\n  const activeTickIdx = Math.floor(poolCurrentTickIdx / tickSpacing) * tickSpacing;\n\n  // Our search bounds must take into account fee spacing. i.e. for fee tier 1%, only\n  // ticks with index 200, 400, 600, etc can be active.\n  const tickIdxLowerBound = activeTickIdx - numSurroundingTicks * tickSpacing;\n  const tickIdxUpperBound = activeTickIdx + numSurroundingTicks * tickSpacing;\n  const initializedTicksResult = await fetchInitializedTicks(poolAddress, tickIdxLowerBound, tickIdxUpperBound, client);\n  if (initializedTicksResult.error || initializedTicksResult.loading) {\n    return {\n      error: initializedTicksResult.error,\n      loading: initializedTicksResult.loading\n    };\n  }\n  const {\n    ticks: initializedTicks\n  } = initializedTicksResult;\n  const tickIdxToInitializedTick = keyBy(initializedTicks, 'tickIdx');\n  const token0 = new Token(1, token0Address, parseInt(token0Decimals));\n  const token1 = new Token(1, token1Address, parseInt(token1Decimals));\n\n  // console.log({ activeTickIdx, poolCurrentTickIdx }, 'Active ticks')\n\n  // If the pool's tick is MIN_TICK (-887272), then when we find the closest\n  // initializable tick to its left, the value would be smaller than MIN_TICK.\n  // In this case we must ensure that the prices shown never go below/above.\n  // what actual possible from the protocol.\n  let activeTickIdxForPrice = activeTickIdx;\n  if (activeTickIdxForPrice < TickMath.MIN_TICK) {\n    activeTickIdxForPrice = TickMath.MIN_TICK;\n  }\n  if (activeTickIdxForPrice > TickMath.MAX_TICK) {\n    activeTickIdxForPrice = TickMath.MAX_TICK;\n  }\n  const activeTickProcessed = {\n    liquidityActive: JSBI.BigInt(liquidity),\n    tickIdx: activeTickIdx,\n    liquidityNet: JSBI.BigInt(0),\n    price0: tickToPrice(token0, token1, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),\n    price1: tickToPrice(token1, token0, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),\n    liquidityGross: JSBI.BigInt(0)\n  };\n\n  // If our active tick happens to be initialized (i.e. there is a position that starts or\n  // ends at that tick), ensure we set the gross and net.\n  // correctly.\n  const activeTick = tickIdxToInitializedTick[activeTickIdx];\n  if (activeTick) {\n    activeTickProcessed.liquidityGross = JSBI.BigInt(activeTick.liquidityGross);\n    activeTickProcessed.liquidityNet = JSBI.BigInt(activeTick.liquidityNet);\n  }\n  let Direction; // Computes the numSurroundingTicks above or below the active tick.\n  (function (Direction) {\n    Direction[Direction[\"ASC\"] = 0] = \"ASC\";\n    Direction[Direction[\"DESC\"] = 1] = \"DESC\";\n  })(Direction || (Direction = {}));\n  const computeSurroundingTicks = (activeTickProcessed, tickSpacing, numSurroundingTicks, direction) => {\n    let previousTickProcessed = {\n      ...activeTickProcessed\n    };\n\n    // Iterate outwards (either up or down depending on 'Direction') from the active tick,\n    // building active liquidity for every tick.\n    let processedTicks = [];\n    for (let i = 0; i < numSurroundingTicks; i++) {\n      const currentTickIdx = direction == Direction.ASC ? previousTickProcessed.tickIdx + tickSpacing : previousTickProcessed.tickIdx - tickSpacing;\n      if (currentTickIdx < TickMath.MIN_TICK || currentTickIdx > TickMath.MAX_TICK) {\n        break;\n      }\n      const currentTickProcessed = {\n        liquidityActive: previousTickProcessed.liquidityActive,\n        tickIdx: currentTickIdx,\n        liquidityNet: JSBI.BigInt(0),\n        price0: tickToPrice(token0, token1, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),\n        price1: tickToPrice(token1, token0, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),\n        liquidityGross: JSBI.BigInt(0)\n      };\n\n      // Check if there is an initialized tick at our current tick.\n      // If so copy the gross and net liquidity from the initialized tick.\n      const currentInitializedTick = tickIdxToInitializedTick[currentTickIdx.toString()];\n      if (currentInitializedTick) {\n        currentTickProcessed.liquidityGross = JSBI.BigInt(currentInitializedTick.liquidityGross);\n        currentTickProcessed.liquidityNet = JSBI.BigInt(currentInitializedTick.liquidityNet);\n      }\n\n      // Update the active liquidity.\n      // If we are iterating ascending and we found an initialized tick we immediately apply\n      // it to the current processed tick we are building.\n      // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n      if (direction == Direction.ASC && currentInitializedTick) {\n        currentTickProcessed.liquidityActive = JSBI.add(previousTickProcessed.liquidityActive, JSBI.BigInt(currentInitializedTick.liquidityNet));\n      } else if (direction == Direction.DESC && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n        // We are iterating descending, so look at the previous tick and apply any net liquidity.\n        currentTickProcessed.liquidityActive = JSBI.subtract(previousTickProcessed.liquidityActive, previousTickProcessed.liquidityNet);\n      }\n      processedTicks.push(currentTickProcessed);\n      previousTickProcessed = currentTickProcessed;\n    }\n    if (direction == Direction.DESC) {\n      processedTicks = processedTicks.reverse();\n    }\n    return processedTicks;\n  };\n  const subsequentTicks = computeSurroundingTicks(activeTickProcessed, tickSpacing, numSurroundingTicks, Direction.ASC);\n  const previousTicks = computeSurroundingTicks(activeTickProcessed, tickSpacing, numSurroundingTicks, Direction.DESC);\n  const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks);\n  return {\n    data: {\n      ticksProcessed,\n      feeTier,\n      tickSpacing,\n      activeTickIdx\n    }\n  };\n};\nvar _c;\n$RefreshReg$(_c, \"FEE_TIER_TO_TICK_SPACING\");","map":{"version":3,"names":["Token","TickMath","tickToPrice","gql","JSBI","keyBy","PRICE_FIXED_DIGITS","DEFAULT_SURROUNDING_TICKS","FEE_TIER_TO_TICK_SPACING","feeTier","Error","fetchInitializedTicks","poolAddress","tickIdxLowerBound","tickIdxUpperBound","client","tickQuery","surroundingTicks","surroundingTicksResult","skip","data","error","loading","query","fetchPolicy","variables","Boolean","ticks","concat","length","poolQuery","fetchTicksSurroundingPrice","numSurroundingTicks","poolResult","undefined","pool","tick","poolCurrentTick","liquidity","token0","id","token0Address","decimals","token0Decimals","token1","token1Address","token1Decimals","poolCurrentTickIdx","parseInt","tickSpacing","activeTickIdx","Math","floor","initializedTicksResult","initializedTicks","tickIdxToInitializedTick","activeTickIdxForPrice","MIN_TICK","MAX_TICK","activeTickProcessed","liquidityActive","BigInt","tickIdx","liquidityNet","price0","toFixed","price1","liquidityGross","activeTick","Direction","computeSurroundingTicks","direction","previousTickProcessed","processedTicks","i","currentTickIdx","ASC","currentTickProcessed","currentInitializedTick","toString","add","DESC","notEqual","subtract","push","reverse","subsequentTicks","previousTicks","ticksProcessed"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/data/pools/tickData.ts"],"sourcesContent":["import { ApolloClient, NormalizedCacheObject } from '@apollo/client'\nimport { Token } from '@uniswap/sdk-core'\nimport { TickMath, tickToPrice } from '@uniswap/v3-sdk'\nimport gql from 'graphql-tag'\nimport JSBI from 'jsbi'\nimport keyBy from 'lodash.keyby'\n\nconst PRICE_FIXED_DIGITS = 4\nconst DEFAULT_SURROUNDING_TICKS = 300\nconst FEE_TIER_TO_TICK_SPACING = (feeTier: string): number => {\n  switch (feeTier) {\n    case '10000':\n      return 200\n    case '3000':\n      return 60\n    case '500':\n      return 10\n    case '100':\n      return 1\n    default:\n      throw Error(`Tick spacing for fee tier ${feeTier} undefined.`)\n  }\n}\n\ninterface TickPool {\n  tick: string\n  feeTier: string\n  token0: {\n    symbol: string\n    id: string\n    decimals: string\n  }\n  token1: {\n    symbol: string\n    id: string\n    decimals: string\n  }\n  sqrtPrice: string\n  liquidity: string\n}\n\ninterface PoolResult {\n  pool: TickPool\n}\n\n// Raw tick returned from GQL\ninterface Tick {\n  tickIdx: string\n  liquidityGross: string\n  liquidityNet: string\n  price0: string\n  price1: string\n}\n\ninterface SurroundingTicksResult {\n  ticks: Tick[]\n}\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\nexport interface TickProcessed {\n  liquidityGross: JSBI\n  liquidityNet: JSBI\n  tickIdx: number\n  liquidityActive: JSBI\n  price0: string\n  price1: string\n}\n\nconst fetchInitializedTicks = async (\n  poolAddress: string,\n  tickIdxLowerBound: number,\n  tickIdxUpperBound: number,\n  client: ApolloClient<NormalizedCacheObject>\n): Promise<{ loading?: boolean; error?: boolean; ticks?: Tick[] }> => {\n  const tickQuery = gql`\n    query surroundingTicks(\n      $poolAddress: String!\n      $tickIdxLowerBound: BigInt!\n      $tickIdxUpperBound: BigInt!\n      $skip: Int!\n    ) {\n      ticks(\n        subgraphError: allow\n        first: 1000\n        skip: $skip\n        where: { poolAddress: $poolAddress, tickIdx_lte: $tickIdxUpperBound, tickIdx_gte: $tickIdxLowerBound }\n      ) {\n        tickIdx\n        liquidityGross\n        liquidityNet\n        price0\n        price1\n      }\n    }\n  `\n\n  let surroundingTicks: Tick[] = []\n  let surroundingTicksResult: Tick[] = []\n  let skip = 0\n  do {\n    const { data, error, loading } = await client.query<SurroundingTicksResult>({\n      query: tickQuery,\n      fetchPolicy: 'cache-first',\n      variables: {\n        poolAddress,\n        tickIdxLowerBound,\n        tickIdxUpperBound,\n        skip,\n      },\n    })\n\n    // console.log({ data, error, loading }, 'Result. Skip: ' + skip)\n\n    if (loading) {\n      continue\n    }\n\n    if (error) {\n      return { error: Boolean(error), loading, ticks: surroundingTicksResult }\n    }\n\n    surroundingTicks = data.ticks\n    surroundingTicksResult = surroundingTicksResult.concat(surroundingTicks)\n    skip += 1000\n  } while (surroundingTicks.length > 0)\n\n  return { ticks: surroundingTicksResult, loading: false, error: false }\n}\n\nexport interface PoolTickData {\n  ticksProcessed: TickProcessed[]\n  feeTier: string\n  tickSpacing: number\n  activeTickIdx: number\n}\n\nconst poolQuery = gql`\n  query pool($poolAddress: String!) {\n    pool(id: $poolAddress) {\n      tick\n      token0 {\n        symbol\n        id\n        decimals\n      }\n      token1 {\n        symbol\n        id\n        decimals\n      }\n      feeTier\n      sqrtPrice\n      liquidity\n    }\n  }\n`\n\nexport const fetchTicksSurroundingPrice = async (\n  poolAddress: string,\n  client: ApolloClient<NormalizedCacheObject>,\n  numSurroundingTicks = DEFAULT_SURROUNDING_TICKS\n): Promise<{\n  loading?: boolean\n  error?: boolean\n  data?: PoolTickData\n}> => {\n  const {\n    data: poolResult,\n    error,\n    loading,\n  } = await client.query<PoolResult>({\n    query: poolQuery,\n    variables: {\n      poolAddress,\n    },\n  })\n\n  if (loading || error || !poolResult) {\n    return {\n      loading,\n      error: Boolean(error),\n      data: undefined,\n    }\n  }\n\n  const {\n    pool: {\n      tick: poolCurrentTick,\n      feeTier,\n      liquidity,\n      token0: { id: token0Address, decimals: token0Decimals },\n      token1: { id: token1Address, decimals: token1Decimals },\n    },\n  } = poolResult\n\n  const poolCurrentTickIdx = parseInt(poolCurrentTick)\n  const tickSpacing = FEE_TIER_TO_TICK_SPACING(feeTier)\n\n  // The pools current tick isn't necessarily a tick that can actually be initialized.\n  // Find the nearest valid tick given the tick spacing.\n  const activeTickIdx = Math.floor(poolCurrentTickIdx / tickSpacing) * tickSpacing\n\n  // Our search bounds must take into account fee spacing. i.e. for fee tier 1%, only\n  // ticks with index 200, 400, 600, etc can be active.\n  const tickIdxLowerBound = activeTickIdx - numSurroundingTicks * tickSpacing\n  const tickIdxUpperBound = activeTickIdx + numSurroundingTicks * tickSpacing\n\n  const initializedTicksResult = await fetchInitializedTicks(poolAddress, tickIdxLowerBound, tickIdxUpperBound, client)\n  if (initializedTicksResult.error || initializedTicksResult.loading) {\n    return {\n      error: initializedTicksResult.error,\n      loading: initializedTicksResult.loading,\n    }\n  }\n\n  const { ticks: initializedTicks } = initializedTicksResult\n\n  const tickIdxToInitializedTick = keyBy(initializedTicks, 'tickIdx')\n\n  const token0 = new Token(1, token0Address, parseInt(token0Decimals))\n  const token1 = new Token(1, token1Address, parseInt(token1Decimals))\n\n  // console.log({ activeTickIdx, poolCurrentTickIdx }, 'Active ticks')\n\n  // If the pool's tick is MIN_TICK (-887272), then when we find the closest\n  // initializable tick to its left, the value would be smaller than MIN_TICK.\n  // In this case we must ensure that the prices shown never go below/above.\n  // what actual possible from the protocol.\n  let activeTickIdxForPrice = activeTickIdx\n  if (activeTickIdxForPrice < TickMath.MIN_TICK) {\n    activeTickIdxForPrice = TickMath.MIN_TICK\n  }\n  if (activeTickIdxForPrice > TickMath.MAX_TICK) {\n    activeTickIdxForPrice = TickMath.MAX_TICK\n  }\n\n  const activeTickProcessed: TickProcessed = {\n    liquidityActive: JSBI.BigInt(liquidity),\n    tickIdx: activeTickIdx,\n    liquidityNet: JSBI.BigInt(0),\n    price0: tickToPrice(token0, token1, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),\n    price1: tickToPrice(token1, token0, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),\n    liquidityGross: JSBI.BigInt(0),\n  }\n\n  // If our active tick happens to be initialized (i.e. there is a position that starts or\n  // ends at that tick), ensure we set the gross and net.\n  // correctly.\n  const activeTick = tickIdxToInitializedTick[activeTickIdx]\n  if (activeTick) {\n    activeTickProcessed.liquidityGross = JSBI.BigInt(activeTick.liquidityGross)\n    activeTickProcessed.liquidityNet = JSBI.BigInt(activeTick.liquidityNet)\n  }\n\n  enum Direction {\n    ASC,\n    DESC,\n  }\n\n  // Computes the numSurroundingTicks above or below the active tick.\n  const computeSurroundingTicks = (\n    activeTickProcessed: TickProcessed,\n    tickSpacing: number,\n    numSurroundingTicks: number,\n    direction: Direction\n  ) => {\n    let previousTickProcessed: TickProcessed = {\n      ...activeTickProcessed,\n    }\n\n    // Iterate outwards (either up or down depending on 'Direction') from the active tick,\n    // building active liquidity for every tick.\n    let processedTicks: TickProcessed[] = []\n    for (let i = 0; i < numSurroundingTicks; i++) {\n      const currentTickIdx =\n        direction == Direction.ASC\n          ? previousTickProcessed.tickIdx + tickSpacing\n          : previousTickProcessed.tickIdx - tickSpacing\n\n      if (currentTickIdx < TickMath.MIN_TICK || currentTickIdx > TickMath.MAX_TICK) {\n        break\n      }\n\n      const currentTickProcessed: TickProcessed = {\n        liquidityActive: previousTickProcessed.liquidityActive,\n        tickIdx: currentTickIdx,\n        liquidityNet: JSBI.BigInt(0),\n        price0: tickToPrice(token0, token1, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),\n        price1: tickToPrice(token1, token0, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),\n        liquidityGross: JSBI.BigInt(0),\n      }\n\n      // Check if there is an initialized tick at our current tick.\n      // If so copy the gross and net liquidity from the initialized tick.\n      const currentInitializedTick = tickIdxToInitializedTick[currentTickIdx.toString()]\n      if (currentInitializedTick) {\n        currentTickProcessed.liquidityGross = JSBI.BigInt(currentInitializedTick.liquidityGross)\n        currentTickProcessed.liquidityNet = JSBI.BigInt(currentInitializedTick.liquidityNet)\n      }\n\n      // Update the active liquidity.\n      // If we are iterating ascending and we found an initialized tick we immediately apply\n      // it to the current processed tick we are building.\n      // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n      if (direction == Direction.ASC && currentInitializedTick) {\n        currentTickProcessed.liquidityActive = JSBI.add(\n          previousTickProcessed.liquidityActive,\n          JSBI.BigInt(currentInitializedTick.liquidityNet)\n        )\n      } else if (direction == Direction.DESC && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n        // We are iterating descending, so look at the previous tick and apply any net liquidity.\n        currentTickProcessed.liquidityActive = JSBI.subtract(\n          previousTickProcessed.liquidityActive,\n          previousTickProcessed.liquidityNet\n        )\n      }\n\n      processedTicks.push(currentTickProcessed)\n      previousTickProcessed = currentTickProcessed\n    }\n\n    if (direction == Direction.DESC) {\n      processedTicks = processedTicks.reverse()\n    }\n\n    return processedTicks\n  }\n\n  const subsequentTicks: TickProcessed[] = computeSurroundingTicks(\n    activeTickProcessed,\n    tickSpacing,\n    numSurroundingTicks,\n    Direction.ASC\n  )\n\n  const previousTicks: TickProcessed[] = computeSurroundingTicks(\n    activeTickProcessed,\n    tickSpacing,\n    numSurroundingTicks,\n    Direction.DESC\n  )\n\n  const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)\n\n  return {\n    data: {\n      ticksProcessed,\n      feeTier,\n      tickSpacing,\n      activeTickIdx,\n    },\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}