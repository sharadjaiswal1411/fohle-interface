{"ast":null,"code":"import { MixedRouteSDK, Protocol } from '@uniswap/router-sdk';\nimport { CurrencyAmount, Token } from '@uniswap/sdk-core';\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk';\nimport { Pool, Route as V3Route } from '@uniswap/v3-sdk';\nimport { InterfaceTrade } from './types';\n\n/**\n * Transforms a Routing API quote into an array of routes that can be used to create\n * a `Trade`.\n */\nexport function computeRoutes(currencyIn, currencyOut, tradeType, quoteResult) {\n  if (!quoteResult || !quoteResult.route || !currencyIn || !currencyOut) return undefined;\n  if (quoteResult.route.length === 0) return [];\n  const parsedTokenIn = parseToken(quoteResult.route[0][0].tokenIn);\n  const parsedTokenOut = parseToken(quoteResult.route[0][quoteResult.route[0].length - 1].tokenOut);\n  if (parsedTokenIn.address !== currencyIn.wrapped.address) return undefined;\n  if (parsedTokenOut.address !== currencyOut.wrapped.address) return undefined;\n  try {\n    return quoteResult.route.map(route => {\n      if (route.length === 0) {\n        throw new Error('Expected route to have at least one pair or pool');\n      }\n      const rawAmountIn = route[0].amountIn;\n      const rawAmountOut = route[route.length - 1].amountOut;\n      if (!rawAmountIn || !rawAmountOut) {\n        throw new Error('Expected both amountIn and amountOut to be present');\n      }\n      const routeProtocol = getRouteProtocol(route);\n      return {\n        routev3: routeProtocol === Protocol.V3 ? new V3Route(route.map(genericPoolPairParser), currencyIn, currencyOut) : null,\n        routev2: routeProtocol === Protocol.V2 ? new V2Route(route.map(genericPoolPairParser), currencyIn, currencyOut) : null,\n        mixedRoute: routeProtocol === Protocol.MIXED ? new MixedRouteSDK(route.map(genericPoolPairParser), currencyIn, currencyOut) : null,\n        inputAmount: CurrencyAmount.fromRawAmount(currencyIn, rawAmountIn),\n        outputAmount: CurrencyAmount.fromRawAmount(currencyOut, rawAmountOut)\n      };\n    });\n  } catch (e) {\n    // `Route` constructor may throw if inputs/outputs are temporarily out of sync\n    // (RTK-Query always returns the latest data which may not be the right inputs/outputs)\n    // This is not fatal and will fix itself in future render cycles\n    console.error(e);\n    return undefined;\n  }\n}\nexport function transformRoutesToTrade(route, tradeType, blockNumber, gasUseEstimateUSD) {\n  var _route$filter$map, _route$filter$map2, _route$filter$map3;\n  return new InterfaceTrade({\n    v2Routes: (_route$filter$map = route === null || route === void 0 ? void 0 : route.filter(r => r.routev2 !== null).map(_ref => {\n      let {\n        routev2,\n        inputAmount,\n        outputAmount\n      } = _ref;\n      return {\n        routev2,\n        inputAmount,\n        outputAmount\n      };\n    })) !== null && _route$filter$map !== void 0 ? _route$filter$map : [],\n    v3Routes: (_route$filter$map2 = route === null || route === void 0 ? void 0 : route.filter(r => r.routev3 !== null).map(_ref2 => {\n      let {\n        routev3,\n        inputAmount,\n        outputAmount\n      } = _ref2;\n      return {\n        routev3,\n        inputAmount,\n        outputAmount\n      };\n    })) !== null && _route$filter$map2 !== void 0 ? _route$filter$map2 : [],\n    mixedRoutes: (_route$filter$map3 = route === null || route === void 0 ? void 0 : route.filter(r => r.mixedRoute !== null).map(_ref3 => {\n      let {\n        mixedRoute,\n        inputAmount,\n        outputAmount\n      } = _ref3;\n      return {\n        mixedRoute,\n        inputAmount,\n        outputAmount\n      };\n    })) !== null && _route$filter$map3 !== void 0 ? _route$filter$map3 : [],\n    tradeType,\n    gasUseEstimateUSD,\n    blockNumber\n  });\n}\nconst parseToken = _ref4 => {\n  let {\n    address,\n    chainId,\n    decimals,\n    symbol\n  } = _ref4;\n  return new Token(chainId, address, parseInt(decimals.toString()), symbol);\n};\nconst parsePool = _ref5 => {\n  let {\n    fee,\n    sqrtRatioX96,\n    liquidity,\n    tickCurrent,\n    tokenIn,\n    tokenOut\n  } = _ref5;\n  return new Pool(parseToken(tokenIn), parseToken(tokenOut), parseInt(fee), sqrtRatioX96, liquidity, parseInt(tickCurrent));\n};\nconst parsePair = _ref6 => {\n  let {\n    reserve0,\n    reserve1\n  } = _ref6;\n  return new Pair(CurrencyAmount.fromRawAmount(parseToken(reserve0.token), reserve0.quotient), CurrencyAmount.fromRawAmount(parseToken(reserve1.token), reserve1.quotient));\n};\nconst genericPoolPairParser = pool => {\n  return pool.type === 'v3-pool' ? parsePool(pool) : parsePair(pool);\n};\nfunction getRouteProtocol(route) {\n  if (route.every(pool => pool.type === 'v2-pool')) return Protocol.V2;\n  if (route.every(pool => pool.type === 'v3-pool')) return Protocol.V3;\n  return Protocol.MIXED;\n}","map":{"version":3,"names":["MixedRouteSDK","Protocol","CurrencyAmount","Token","Pair","Route","V2Route","Pool","V3Route","InterfaceTrade","computeRoutes","currencyIn","currencyOut","tradeType","quoteResult","route","undefined","length","parsedTokenIn","parseToken","tokenIn","parsedTokenOut","tokenOut","address","wrapped","map","Error","rawAmountIn","amountIn","rawAmountOut","amountOut","routeProtocol","getRouteProtocol","routev3","V3","genericPoolPairParser","routev2","V2","mixedRoute","MIXED","inputAmount","fromRawAmount","outputAmount","e","console","error","transformRoutesToTrade","blockNumber","gasUseEstimateUSD","v2Routes","filter","r","v3Routes","mixedRoutes","chainId","decimals","symbol","parseInt","toString","parsePool","fee","sqrtRatioX96","liquidity","tickCurrent","parsePair","reserve0","reserve1","token","quotient","pool","type","every"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/routing/utils.ts"],"sourcesContent":["import { MixedRouteSDK, Protocol } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk'\nimport { FeeAmount, Pool, Route as V3Route } from '@uniswap/v3-sdk'\n\nimport { GetQuoteResult, InterfaceTrade, V2PoolInRoute, V3PoolInRoute } from './types'\n\n/**\n * Transforms a Routing API quote into an array of routes that can be used to create\n * a `Trade`.\n */\nexport function computeRoutes(\n  currencyIn: Currency | undefined,\n  currencyOut: Currency | undefined,\n  tradeType: TradeType,\n  quoteResult: Pick<GetQuoteResult, 'route'> | undefined\n) {\n  if (!quoteResult || !quoteResult.route || !currencyIn || !currencyOut) return undefined\n\n  if (quoteResult.route.length === 0) return []\n\n  const parsedTokenIn = parseToken(quoteResult.route[0][0].tokenIn)\n  const parsedTokenOut = parseToken(quoteResult.route[0][quoteResult.route[0].length - 1].tokenOut)\n\n  if (parsedTokenIn.address !== currencyIn.wrapped.address) return undefined\n  if (parsedTokenOut.address !== currencyOut.wrapped.address) return undefined\n\n  try {\n    return quoteResult.route.map((route) => {\n      if (route.length === 0) {\n        throw new Error('Expected route to have at least one pair or pool')\n      }\n      const rawAmountIn = route[0].amountIn\n      const rawAmountOut = route[route.length - 1].amountOut\n\n      if (!rawAmountIn || !rawAmountOut) {\n        throw new Error('Expected both amountIn and amountOut to be present')\n      }\n\n      const routeProtocol = getRouteProtocol(route)\n\n      return {\n        routev3:\n          routeProtocol === Protocol.V3\n            ? new V3Route(route.map(genericPoolPairParser) as Pool[], currencyIn, currencyOut)\n            : null,\n        routev2:\n          routeProtocol === Protocol.V2\n            ? new V2Route(route.map(genericPoolPairParser) as Pair[], currencyIn, currencyOut)\n            : null,\n        mixedRoute:\n          routeProtocol === Protocol.MIXED\n            ? new MixedRouteSDK(route.map(genericPoolPairParser), currencyIn, currencyOut)\n            : null,\n        inputAmount: CurrencyAmount.fromRawAmount(currencyIn, rawAmountIn),\n        outputAmount: CurrencyAmount.fromRawAmount(currencyOut, rawAmountOut),\n      }\n    })\n  } catch (e) {\n    // `Route` constructor may throw if inputs/outputs are temporarily out of sync\n    // (RTK-Query always returns the latest data which may not be the right inputs/outputs)\n    // This is not fatal and will fix itself in future render cycles\n    console.error(e)\n    return undefined\n  }\n}\n\nexport function transformRoutesToTrade<TTradeType extends TradeType>(\n  route: ReturnType<typeof computeRoutes>,\n  tradeType: TTradeType,\n  blockNumber?: string | null,\n  gasUseEstimateUSD?: CurrencyAmount<Token> | null\n): InterfaceTrade<Currency, Currency, TTradeType> {\n  return new InterfaceTrade({\n    v2Routes:\n      route\n        ?.filter((r): r is typeof route[0] & { routev2: NonNullable<typeof route[0]['routev2']> } => r.routev2 !== null)\n        .map(({ routev2, inputAmount, outputAmount }) => ({ routev2, inputAmount, outputAmount })) ?? [],\n    v3Routes:\n      route\n        ?.filter((r): r is typeof route[0] & { routev3: NonNullable<typeof route[0]['routev3']> } => r.routev3 !== null)\n        .map(({ routev3, inputAmount, outputAmount }) => ({ routev3, inputAmount, outputAmount })) ?? [],\n    mixedRoutes:\n      route\n        ?.filter(\n          (r): r is typeof route[0] & { mixedRoute: NonNullable<typeof route[0]['mixedRoute']> } =>\n            r.mixedRoute !== null\n        )\n        .map(({ mixedRoute, inputAmount, outputAmount }) => ({ mixedRoute, inputAmount, outputAmount })) ?? [],\n    tradeType,\n    gasUseEstimateUSD,\n    blockNumber,\n  })\n}\n\nconst parseToken = ({ address, chainId, decimals, symbol }: GetQuoteResult['route'][0][0]['tokenIn']): Token => {\n  return new Token(chainId, address, parseInt(decimals.toString()), symbol)\n}\n\nconst parsePool = ({ fee, sqrtRatioX96, liquidity, tickCurrent, tokenIn, tokenOut }: V3PoolInRoute): Pool =>\n  new Pool(\n    parseToken(tokenIn),\n    parseToken(tokenOut),\n    parseInt(fee) as FeeAmount,\n    sqrtRatioX96,\n    liquidity,\n    parseInt(tickCurrent)\n  )\n\nconst parsePair = ({ reserve0, reserve1 }: V2PoolInRoute): Pair =>\n  new Pair(\n    CurrencyAmount.fromRawAmount(parseToken(reserve0.token), reserve0.quotient),\n    CurrencyAmount.fromRawAmount(parseToken(reserve1.token), reserve1.quotient)\n  )\n\nconst genericPoolPairParser = (pool: V3PoolInRoute | V2PoolInRoute): Pool | Pair => {\n  return pool.type === 'v3-pool' ? parsePool(pool) : parsePair(pool)\n}\n\nfunction getRouteProtocol(route: (V3PoolInRoute | V2PoolInRoute)[]): Protocol {\n  if (route.every((pool) => pool.type === 'v2-pool')) return Protocol.V2\n  if (route.every((pool) => pool.type === 'v3-pool')) return Protocol.V3\n  return Protocol.MIXED\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}