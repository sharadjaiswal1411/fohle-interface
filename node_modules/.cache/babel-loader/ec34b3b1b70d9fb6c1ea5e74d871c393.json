{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit } from 'graphql';\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition } from \"./getFromAST.js\";\nimport { filterInPlace } from \"../common/filterInPlace.js\";\nimport { isField, isInlineFragment } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nvar TYPENAME_FIELD = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename'\n  }\n};\nfunction isEmpty(op, fragmentMap) {\n  return !op || op.selectionSet.selections.every(function (selection) {\n    return selection.kind === 'FragmentSpread' && isEmpty(fragmentMap[selection.name.value], fragmentMap);\n  });\n}\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\nfunction getDirectiveMatcher(directives) {\n  return function directiveMatcher(directive) {\n    return directives.some(function (dir) {\n      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);\n    });\n  };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n  var variablesInUse = Object.create(null);\n  var variablesToRemove = [];\n  var fragmentSpreadsInUse = Object.create(null);\n  var fragmentSpreadsToRemove = [];\n  var modifiedDoc = nullIfDocIsEmpty(visit(doc, {\n    Variable: {\n      enter: function (node, _key, parent) {\n        if (parent.kind !== 'VariableDefinition') {\n          variablesInUse[node.name.value] = true;\n        }\n      }\n    },\n    Field: {\n      enter: function (node) {\n        if (directives && node.directives) {\n          var shouldRemoveField = directives.some(function (directive) {\n            return directive.remove;\n          });\n          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {\n            if (node.arguments) {\n              node.arguments.forEach(function (arg) {\n                if (arg.value.kind === 'Variable') {\n                  variablesToRemove.push({\n                    name: arg.value.name.value\n                  });\n                }\n              });\n            }\n            if (node.selectionSet) {\n              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {\n                fragmentSpreadsToRemove.push({\n                  name: frag.name.value\n                });\n              });\n            }\n            return null;\n          }\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function (node) {\n        fragmentSpreadsInUse[node.name.value] = true;\n      }\n    },\n    Directive: {\n      enter: function (node) {\n        if (getDirectiveMatcher(directives)(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n  if (modifiedDoc && filterInPlace(variablesToRemove, function (v) {\n    return !!v.name && !variablesInUse[v.name];\n  }).length) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function (fs) {\n    return !!fs.name && !fragmentSpreadsInUse[fs.name];\n  }).length) {\n    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);\n  }\n  return modifiedDoc;\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n  return visit(doc, {\n    SelectionSet: {\n      enter: function (node, _key, parent) {\n        if (parent && parent.kind === 'OperationDefinition') {\n          return;\n        }\n        var selections = node.selections;\n        if (!selections) {\n          return;\n        }\n        var skip = selections.some(function (selection) {\n          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);\n        });\n        if (skip) {\n          return;\n        }\n        var field = parent;\n        if (isField(field) && field.directives && field.directives.some(function (d) {\n          return d.name.value === 'export';\n        })) {\n          return;\n        }\n        return __assign(__assign({}, node), {\n          selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false)\n        });\n      }\n    }\n  });\n}, {\n  added: function (field) {\n    return field === TYPENAME_FIELD;\n  }\n});\nvar connectionRemoveConfig = {\n  test: function (directive) {\n    var willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function (arg) {\n        return arg.name.value === 'key';\n      })) {\n        __DEV__ && invariant.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');\n      }\n    }\n    return willRemove;\n  }\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  if (!isField(selection)) {\n    return true;\n  }\n  if (!selection.directives) {\n    return false;\n  }\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function (aConfig) {\n      return argument.value && argument.value.kind === 'Variable' && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n            return !config.some(function (arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          }) : []\n        });\n      }\n    },\n    Field: {\n      enter: function (node) {\n        var shouldRemoveField = config.some(function (argConfig) {\n          return argConfig.remove;\n        });\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n          if (node.arguments) {\n            node.arguments.forEach(function (arg) {\n              if (argMatcher(arg)) {\n                argMatchCount_1 += 1;\n              }\n            });\n          }\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function (node) {\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function (def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: {\n      enter: enter\n    },\n    FragmentDefinition: {\n      enter: enter\n    }\n  }));\n}\nfunction getAllFragmentSpreadsFromSelectionSet(selectionSet) {\n  var allFragments = [];\n  selectionSet.selections.forEach(function (selection) {\n    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) {\n        return allFragments.push(frag);\n      });\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n  return allFragments;\n}\nexport function buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n  if (definitionOperation === 'query') {\n    return document;\n  }\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          operation: 'query'\n        });\n      }\n    }\n  });\n  return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([{\n    test: function (directive) {\n      return directive.name.value === 'client';\n    },\n    remove: true\n  }], document);\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter: function (node) {\n          if (node.selectionSet) {\n            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {\n              return isField(selection) && selection.name.value === '__typename';\n            });\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        }\n      }\n    });\n  }\n  return modifiedDoc;\n}","map":{"version":3,"sources":["../../../src/utilities/graphql/transform.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from '../globals';\n\nimport {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n  visit,\n  ASTNode,\n} from 'graphql';\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from '../common/filterInPlace';\nimport { isField, isInlineFragment } from './storeUtils';\nimport {\n  createFragmentMap,\n  FragmentMap,\n} from './fragments';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field' as Kind,\n  name: {\n    kind: 'Name' as Kind,\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap,\n): boolean {\n  return !op || op.selectionSet.selections.every(\n    selection => selection.kind === 'FragmentSpread' &&\n      isEmpty(fragmentMap[selection.name.value], fragmentMap)\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll first check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // document.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !!v.name && !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !!fs.name && !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport const addTypenameToDocument = Object.assign(function <\n  TNode extends ASTNode\n>(\n  doc: TNode\n): TNode {\n  return visit(doc, {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}, {\n  added(field: FieldNode): boolean {\n    return field === TYPENAME_FIELD;\n  },\n});\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true,\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ) : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach(arg => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}