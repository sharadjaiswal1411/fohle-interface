{"ast":null,"code":"import { fill, getFunctionName, getOriginalFunction } from '@sentry/utils';\nimport { WINDOW, wrap } from '../helpers.js';\nconst DEFAULT_EVENT_TARGET = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nclass TryCatch {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'TryCatch';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  __init() {\n    this.name = TryCatch.id;\n  }\n\n  /** JSDoc */\n\n  /**\n   * @inheritDoc\n   */\n  constructor(options) {\n    ;\n    TryCatch.prototype.__init.call(this);\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n  setupOnce() {\n    if (this._options.setTimeout) {\n      fill(WINDOW, 'setTimeout', _wrapTimeFunction);\n    }\n    if (this._options.setInterval) {\n      fill(WINDOW, 'setInterval', _wrapTimeFunction);\n    }\n    if (this._options.requestAnimationFrame) {\n      fill(WINDOW, 'requestAnimationFrame', _wrapRAF);\n    }\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {\n      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n    const eventTargetOption = this._options.eventTarget;\n    if (eventTargetOption) {\n      const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  }\n}\nTryCatch.__initStatic();\n\n/** JSDoc */\nfunction _wrapTimeFunction(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: {\n          function: getFunctionName(original)\n        },\n        handled: true,\n        type: 'instrument'\n      }\n    });\n    return original.apply(this, args);\n  };\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _wrapRAF(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (callback) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.apply(this, [wrap(callback, {\n      mechanism: {\n        data: {\n          function: 'requestAnimationFrame',\n          handler: getFunctionName(original)\n        },\n        handled: true,\n        type: 'instrument'\n      }\n    })]);\n  };\n}\n\n/** JSDoc */\nfunction _wrapXHR(originalSend) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original) {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original)\n              },\n              handled: true,\n              type: 'instrument'\n            }\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return originalSend.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapEventTarget(target) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalObject = WINDOW;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const proto = globalObject[target] && globalObject[target].prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n  fill(proto, 'addEventListener', function (original) {\n    return function (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    eventName, fn, options) {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target\n              },\n              handled: true,\n              type: 'instrument'\n            }\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n      return original.apply(this, [eventName,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      wrap(fn, {\n        mechanism: {\n          data: {\n            function: 'addEventListener',\n            handler: getFunctionName(fn),\n            target\n          },\n          handled: true,\n          type: 'instrument'\n        }\n      }), options]);\n    };\n  });\n  fill(proto, 'removeEventListener', function (originalRemoveEventListener\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return function (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    eventName, fn, options) {\n      /**\n       * There are 2 possible scenarios here:\n       *\n       * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n       * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n       * as a pass-through, and call original `removeEventListener` with it.\n       *\n       * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n       * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n       * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n       * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n       * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n       *\n       * When someone adds a handler prior to initialization, and then do it again, but after,\n       * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n       * to get rid of the initial handler and it'd stick there forever.\n       */\n      const wrappedEventHandler = fn;\n      try {\n        const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n        if (originalEventHandler) {\n          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n        }\n      } catch (e) {\n        // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n      }\n      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n    };\n  });\n}\nexport { TryCatch };","map":{"version":3,"sources":["../../../../src/integrations/trycatch.ts"],"names":[],"mappings":"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","sourcesContent":["import { Integration, WrappedFunction } from '@sentry/types';\nimport { fill, getFunctionName, getOriginalFunction } from '@sentry/utils';\n\nimport { WINDOW, wrap } from '../helpers';\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\ntype XMLHttpRequestProp = 'onload' | 'onerror' | 'onprogress' | 'onreadystatechange';\n\n/** JSDoc */\ninterface TryCatchOptions {\n  setTimeout: boolean;\n  setInterval: boolean;\n  requestAnimationFrame: boolean;\n  XMLHttpRequest: boolean;\n  eventTarget: boolean | string[];\n}\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nexport class TryCatch implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'TryCatch';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = TryCatch.id;\n\n  /** JSDoc */\n  private readonly _options: TryCatchOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options?: Partial<TryCatchOptions>) {\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n  public setupOnce(): void {\n    if (this._options.setTimeout) {\n      fill(WINDOW, 'setTimeout', _wrapTimeFunction);\n    }\n\n    if (this._options.setInterval) {\n      fill(WINDOW, 'setInterval', _wrapTimeFunction);\n    }\n\n    if (this._options.requestAnimationFrame) {\n      fill(WINDOW, 'requestAnimationFrame', _wrapRAF);\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {\n      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n\n    const eventTargetOption = this._options.eventTarget;\n    if (eventTargetOption) {\n      const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  }\n}\n\n/** JSDoc */\nfunction _wrapTimeFunction(original: () => void): () => number {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, ...args: any[]): number {\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: getFunctionName(original) },\n        handled: true,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _wrapRAF(original: any): (callback: () => void) => any {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, callback: () => void): () => void {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.apply(this, [\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original),\n          },\n          handled: true,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\n/** JSDoc */\nfunction _wrapXHR(originalSend: () => void): () => void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: XMLHttpRequest, ...args: any[]): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps: XMLHttpRequestProp[] = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original: WrappedFunction): () => any {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original),\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapEventTarget(target: string): void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalObject = WINDOW as { [key: string]: any };\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const proto = globalObject[target] && globalObject[target].prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original: () => void): (\n    eventName: string,\n    fn: EventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ) => void {\n    return function (\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this: any,\n      eventName: string,\n      fn: EventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ): (eventName: string, fn: EventListenerObject, capture?: boolean, secure?: boolean) => void {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.apply(this, [\n        eventName,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        wrap(fn as any as WrappedFunction, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target,\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  fill(\n    proto,\n    'removeEventListener',\n    function (\n      originalRemoveEventListener: () => void,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): (this: any, eventName: string, fn: EventListenerObject, options?: boolean | EventListenerOptions) => () => void {\n      return function (\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        const wrappedEventHandler = fn as unknown as WrappedFunction;\n        try {\n          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    },\n  );\n}\n"]},"metadata":{},"sourceType":"module"}