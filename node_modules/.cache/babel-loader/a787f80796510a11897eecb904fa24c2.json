{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { filterStringAtom, filterTimeAtom, sortAscendingAtom, sortMethodAtom, TokenSortMethod } from 'components/Tokens/state';\nimport gql from 'graphql-tag';\nimport { useAtomValue } from 'jotai/utils';\nimport { useMemo } from 'react';\nimport { useTopTokens100Query, useTopTokensSparklineQuery } from './__generated__/types-and-hooks';\nimport { CHAIN_NAME_TO_CHAIN_ID, isPricePoint, toHistoryDuration, unwrapToken } from './util';\ngql`\n  query TopTokens100($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain) {\n      id\n      name\n      chain\n      address\n      symbol\n      market(currency: USD) {\n        totalValueLocked {\n          value\n          currency\n        }\n        price {\n          value\n          currency\n        }\n        pricePercentChange(duration: $duration) {\n          currency\n          value\n        }\n        volume(duration: $duration) {\n          value\n          currency\n        }\n      }\n      project {\n        logoUrl\n      }\n    }\n  }\n`;\ngql`\n  query TopTokensSparkline($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain) {\n      address\n      market(currency: USD) {\n        priceHistory(duration: $duration) {\n          timestamp\n          value\n        }\n      }\n    }\n  }\n`;\nfunction useSortedTokens(tokens) {\n  _s();\n  const sortMethod = useAtomValue(sortMethodAtom);\n  const sortAscending = useAtomValue(sortAscendingAtom);\n  return useMemo(() => {\n    let tokenArray = Array.from(tokens);\n    switch (sortMethod) {\n      case TokenSortMethod.PRICE:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$price$value, _b$market, _b$market$price, _a$market$price$value, _a$market, _a$market$price;\n          return ((_b$market$price$value = b === null || b === void 0 ? void 0 : (_b$market = b.market) === null || _b$market === void 0 ? void 0 : (_b$market$price = _b$market.price) === null || _b$market$price === void 0 ? void 0 : _b$market$price.value) !== null && _b$market$price$value !== void 0 ? _b$market$price$value : 0) - ((_a$market$price$value = a === null || a === void 0 ? void 0 : (_a$market = a.market) === null || _a$market === void 0 ? void 0 : (_a$market$price = _a$market.price) === null || _a$market$price === void 0 ? void 0 : _a$market$price.value) !== null && _a$market$price$value !== void 0 ? _a$market$price$value : 0);\n        });\n        break;\n      case TokenSortMethod.PERCENT_CHANGE:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$pricePercen, _b$market2, _b$market2$pricePerce, _a$market$pricePercen, _a$market2, _a$market2$pricePerce;\n          return ((_b$market$pricePercen = b === null || b === void 0 ? void 0 : (_b$market2 = b.market) === null || _b$market2 === void 0 ? void 0 : (_b$market2$pricePerce = _b$market2.pricePercentChange) === null || _b$market2$pricePerce === void 0 ? void 0 : _b$market2$pricePerce.value) !== null && _b$market$pricePercen !== void 0 ? _b$market$pricePercen : 0) - ((_a$market$pricePercen = a === null || a === void 0 ? void 0 : (_a$market2 = a.market) === null || _a$market2 === void 0 ? void 0 : (_a$market2$pricePerce = _a$market2.pricePercentChange) === null || _a$market2$pricePerce === void 0 ? void 0 : _a$market2$pricePerce.value) !== null && _a$market$pricePercen !== void 0 ? _a$market$pricePercen : 0);\n        });\n        break;\n      case TokenSortMethod.TOTAL_VALUE_LOCKED:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$totalValueL, _b$market3, _b$market3$totalValue, _a$market$totalValueL, _a$market3, _a$market3$totalValue;\n          return ((_b$market$totalValueL = b === null || b === void 0 ? void 0 : (_b$market3 = b.market) === null || _b$market3 === void 0 ? void 0 : (_b$market3$totalValue = _b$market3.totalValueLocked) === null || _b$market3$totalValue === void 0 ? void 0 : _b$market3$totalValue.value) !== null && _b$market$totalValueL !== void 0 ? _b$market$totalValueL : 0) - ((_a$market$totalValueL = a === null || a === void 0 ? void 0 : (_a$market3 = a.market) === null || _a$market3 === void 0 ? void 0 : (_a$market3$totalValue = _a$market3.totalValueLocked) === null || _a$market3$totalValue === void 0 ? void 0 : _a$market3$totalValue.value) !== null && _a$market$totalValueL !== void 0 ? _a$market$totalValueL : 0);\n        });\n        break;\n      case TokenSortMethod.VOLUME:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$volume$valu, _b$market4, _b$market4$volume, _a$market$volume$valu, _a$market4, _a$market4$volume;\n          return ((_b$market$volume$valu = b === null || b === void 0 ? void 0 : (_b$market4 = b.market) === null || _b$market4 === void 0 ? void 0 : (_b$market4$volume = _b$market4.volume) === null || _b$market4$volume === void 0 ? void 0 : _b$market4$volume.value) !== null && _b$market$volume$valu !== void 0 ? _b$market$volume$valu : 0) - ((_a$market$volume$valu = a === null || a === void 0 ? void 0 : (_a$market4 = a.market) === null || _a$market4 === void 0 ? void 0 : (_a$market4$volume = _a$market4.volume) === null || _a$market4$volume === void 0 ? void 0 : _a$market4$volume.value) !== null && _a$market$volume$valu !== void 0 ? _a$market$volume$valu : 0);\n        });\n        break;\n    }\n    return sortAscending ? tokenArray.reverse() : tokenArray;\n  }, [tokens, sortMethod, sortAscending]);\n}\n_s(useSortedTokens, \"BkaqJpRjsaINhaxesa9Xi404Dwg=\", false, function () {\n  return [useAtomValue, useAtomValue];\n});\nfunction useFilteredTokens(tokens) {\n  _s2();\n  const filterString = useAtomValue(filterStringAtom);\n  const lowercaseFilterString = useMemo(() => filterString.toLowerCase(), [filterString]);\n  return useMemo(() => {\n    let returnTokens = tokens;\n    if (lowercaseFilterString) {\n      var _returnTokens;\n      returnTokens = (_returnTokens = returnTokens) === null || _returnTokens === void 0 ? void 0 : _returnTokens.filter(token => {\n        var _token$address, _token$name, _token$symbol;\n        const addressIncludesFilterString = token === null || token === void 0 ? void 0 : (_token$address = token.address) === null || _token$address === void 0 ? void 0 : _token$address.toLowerCase().includes(lowercaseFilterString);\n        const nameIncludesFilterString = token === null || token === void 0 ? void 0 : (_token$name = token.name) === null || _token$name === void 0 ? void 0 : _token$name.toLowerCase().includes(lowercaseFilterString);\n        const symbolIncludesFilterString = token === null || token === void 0 ? void 0 : (_token$symbol = token.symbol) === null || _token$symbol === void 0 ? void 0 : _token$symbol.toLowerCase().includes(lowercaseFilterString);\n        return nameIncludesFilterString || symbolIncludesFilterString || addressIncludesFilterString;\n      });\n    }\n    return returnTokens;\n  }, [tokens, lowercaseFilterString]);\n}\n\n// Number of items to render in each fetch in infinite scroll.\n_s2(useFilteredTokens, \"n+zAzfCMGXS9ksESTnO2KIuyfhQ=\", false, function () {\n  return [useAtomValue];\n});\nexport const PAGE_SIZE = 20;\nexport function useTopTokens(chain) {\n  _s3();\n  const chainId = CHAIN_NAME_TO_CHAIN_ID[chain];\n  const duration = toHistoryDuration(useAtomValue(filterTimeAtom));\n  const {\n    data: sparklineQuery\n  } = useTopTokensSparklineQuery({\n    variables: {\n      duration,\n      chain\n    }\n  });\n  const sparklines = useMemo(() => {\n    var _sparklineQuery$topTo;\n    const unwrappedTokens = sparklineQuery === null || sparklineQuery === void 0 ? void 0 : (_sparklineQuery$topTo = sparklineQuery.topTokens) === null || _sparklineQuery$topTo === void 0 ? void 0 : _sparklineQuery$topTo.map(topToken => unwrapToken(chainId, topToken));\n    const map = {};\n    unwrappedTokens === null || unwrappedTokens === void 0 ? void 0 : unwrappedTokens.forEach(current => {\n      var _current$market, _current$market$price;\n      return (current === null || current === void 0 ? void 0 : current.address) && (map[current.address] = current === null || current === void 0 ? void 0 : (_current$market = current.market) === null || _current$market === void 0 ? void 0 : (_current$market$price = _current$market.priceHistory) === null || _current$market$price === void 0 ? void 0 : _current$market$price.filter(isPricePoint));\n    });\n    return map;\n  }, [chainId, sparklineQuery === null || sparklineQuery === void 0 ? void 0 : sparklineQuery.topTokens]);\n  const {\n    data,\n    loading: loadingTokens\n  } = useTopTokens100Query({\n    variables: {\n      duration,\n      chain\n    }\n  });\n  const mappedTokens = useMemo(() => {\n    var _data$topTokens$map, _data$topTokens;\n    return (_data$topTokens$map = data === null || data === void 0 ? void 0 : (_data$topTokens = data.topTokens) === null || _data$topTokens === void 0 ? void 0 : _data$topTokens.map(token => unwrapToken(chainId, token))) !== null && _data$topTokens$map !== void 0 ? _data$topTokens$map : [];\n  }, [chainId, data]);\n  const filteredTokens = useFilteredTokens(mappedTokens);\n  const sortedTokens = useSortedTokens(filteredTokens);\n  return useMemo(() => ({\n    tokens: sortedTokens,\n    loadingTokens,\n    sparklines\n  }), [loadingTokens, sortedTokens, sparklines]);\n}\n_s3(useTopTokens, \"wG96GduiRbFPpFswGxOR1Me7rTU=\", false, function () {\n  return [useAtomValue, useTopTokensSparklineQuery, useTopTokens100Query, useFilteredTokens, useSortedTokens];\n});","map":{"version":3,"names":["filterStringAtom","filterTimeAtom","sortAscendingAtom","sortMethodAtom","TokenSortMethod","gql","useAtomValue","useMemo","useTopTokens100Query","useTopTokensSparklineQuery","CHAIN_NAME_TO_CHAIN_ID","isPricePoint","toHistoryDuration","unwrapToken","useSortedTokens","tokens","sortMethod","sortAscending","tokenArray","Array","from","PRICE","sort","a","b","market","price","value","PERCENT_CHANGE","pricePercentChange","TOTAL_VALUE_LOCKED","totalValueLocked","VOLUME","volume","reverse","useFilteredTokens","filterString","lowercaseFilterString","toLowerCase","returnTokens","filter","token","addressIncludesFilterString","address","includes","nameIncludesFilterString","name","symbolIncludesFilterString","symbol","PAGE_SIZE","useTopTokens","chain","chainId","duration","data","sparklineQuery","variables","sparklines","unwrappedTokens","topTokens","map","topToken","forEach","current","priceHistory","loading","loadingTokens","mappedTokens","filteredTokens","sortedTokens"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/graphql/data/TopPools.ts"],"sourcesContent":["import {\n  filterStringAtom,\n  filterTimeAtom,\n  sortAscendingAtom,\n  sortMethodAtom,\n  TokenSortMethod,\n} from 'components/Tokens/state'\nimport gql from 'graphql-tag'\nimport { useAtomValue } from 'jotai/utils'\nimport { useMemo } from 'react'\n\nimport {\n  Chain,\n  TopTokens100Query,\n  useTopTokens100Query,\n  useTopTokensSparklineQuery,\n} from './__generated__/types-and-hooks'\nimport { CHAIN_NAME_TO_CHAIN_ID, isPricePoint, PricePoint, toHistoryDuration, unwrapToken } from './util'\n\ngql`\n  query TopTokens100($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain) {\n      id\n      name\n      chain\n      address\n      symbol\n      market(currency: USD) {\n        totalValueLocked {\n          value\n          currency\n        }\n        price {\n          value\n          currency\n        }\n        pricePercentChange(duration: $duration) {\n          currency\n          value\n        }\n        volume(duration: $duration) {\n          value\n          currency\n        }\n      }\n      project {\n        logoUrl\n      }\n    }\n  }\n`\n\ngql`\n  query TopTokensSparkline($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain) {\n      address\n      market(currency: USD) {\n        priceHistory(duration: $duration) {\n          timestamp\n          value\n        }\n      }\n    }\n  }\n`\n\nfunction useSortedTokens(tokens: NonNullable<TopTokens100Query['topTokens']>) {\n  const sortMethod = useAtomValue(sortMethodAtom)\n  const sortAscending = useAtomValue(sortAscendingAtom)\n\n  return useMemo(() => {\n    let tokenArray = Array.from(tokens)\n    switch (sortMethod) {\n      case TokenSortMethod.PRICE:\n        tokenArray = tokenArray.sort((a, b) => (b?.market?.price?.value ?? 0) - (a?.market?.price?.value ?? 0))\n        break\n      case TokenSortMethod.PERCENT_CHANGE:\n        tokenArray = tokenArray.sort(\n          (a, b) => (b?.market?.pricePercentChange?.value ?? 0) - (a?.market?.pricePercentChange?.value ?? 0)\n        )\n        break\n      case TokenSortMethod.TOTAL_VALUE_LOCKED:\n        tokenArray = tokenArray.sort(\n          (a, b) => (b?.market?.totalValueLocked?.value ?? 0) - (a?.market?.totalValueLocked?.value ?? 0)\n        )\n        break\n      case TokenSortMethod.VOLUME:\n        tokenArray = tokenArray.sort((a, b) => (b?.market?.volume?.value ?? 0) - (a?.market?.volume?.value ?? 0))\n        break\n    }\n\n    return sortAscending ? tokenArray.reverse() : tokenArray\n  }, [tokens, sortMethod, sortAscending])\n}\n\nfunction useFilteredTokens(tokens: NonNullable<TopTokens100Query['topTokens']>) {\n  const filterString = useAtomValue(filterStringAtom)\n\n  const lowercaseFilterString = useMemo(() => filterString.toLowerCase(), [filterString])\n\n  return useMemo(() => {\n    let returnTokens = tokens\n    if (lowercaseFilterString) {\n      returnTokens = returnTokens?.filter((token) => {\n        const addressIncludesFilterString = token?.address?.toLowerCase().includes(lowercaseFilterString)\n        const nameIncludesFilterString = token?.name?.toLowerCase().includes(lowercaseFilterString)\n        const symbolIncludesFilterString = token?.symbol?.toLowerCase().includes(lowercaseFilterString)\n        return nameIncludesFilterString || symbolIncludesFilterString || addressIncludesFilterString\n      })\n    }\n    return returnTokens\n  }, [tokens, lowercaseFilterString])\n}\n\n// Number of items to render in each fetch in infinite scroll.\nexport const PAGE_SIZE = 20\nexport type SparklineMap = { [key: string]: PricePoint[] | undefined }\nexport type TopToken = NonNullable<NonNullable<TopTokens100Query>['topTokens']>[number]\n\ninterface UseTopTokensReturnValue {\n  tokens: TopToken[] | undefined\n  loadingTokens: boolean\n  sparklines: SparklineMap\n}\n\nexport function useTopTokens(chain: Chain): UseTopTokensReturnValue {\n  const chainId = CHAIN_NAME_TO_CHAIN_ID[chain]\n  const duration = toHistoryDuration(useAtomValue(filterTimeAtom))\n\n  const { data: sparklineQuery } = useTopTokensSparklineQuery({\n    variables: { duration, chain },\n  })\n\n  const sparklines = useMemo(() => {\n    const unwrappedTokens = sparklineQuery?.topTokens?.map((topToken) => unwrapToken(chainId, topToken))\n    const map: SparklineMap = {}\n    unwrappedTokens?.forEach(\n      (current) => current?.address && (map[current.address] = current?.market?.priceHistory?.filter(isPricePoint))\n    )\n    return map\n  }, [chainId, sparklineQuery?.topTokens])\n\n  const { data, loading: loadingTokens } = useTopTokens100Query({\n    variables: { duration, chain },\n  })\n  const mappedTokens = useMemo(\n    () => data?.topTokens?.map((token) => unwrapToken(chainId, token)) ?? [],\n    [chainId, data]\n  )\n  const filteredTokens = useFilteredTokens(mappedTokens)\n  const sortedTokens = useSortedTokens(filteredTokens)\n  return useMemo(() => ({ tokens: sortedTokens, loadingTokens, sparklines }), [loadingTokens, sortedTokens, sparklines])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}