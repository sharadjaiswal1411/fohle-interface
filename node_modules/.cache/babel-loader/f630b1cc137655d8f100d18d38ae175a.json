{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nconst removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nconst deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n  const s = o.strict;\n  const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? {\n      ...o.code,\n      optimize,\n      regExp\n    } : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\nclass Ajv {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = {\n      ...opts,\n      ...requiredOptions(opts)\n    };\n    const {\n      es5,\n      lines\n    } = this.opts.code;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    const formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n  _addDefaultMetaSchema() {\n    const {\n      $data,\n      meta,\n      schemaId\n    } = this.opts;\n    let _dataRefSchema = $dataRefSchema;\n    if (schemaId === \"id\") {\n      _dataRefSchema = {\n        ...$dataRefSchema\n      };\n      _dataRefSchema.id = _dataRefSchema.$id;\n      delete _dataRefSchema.$id;\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n  }\n  defaultMeta() {\n    const {\n      meta,\n      schemaId\n    } = this.opts;\n    return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n  }\n  validate(schemaKeyRef,\n  // key, ref or schema object\n  data // to be validated\n  ) {\n    let v;\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n    } else {\n      v = this.compile(schemaKeyRef);\n    }\n    const valid = v(data);\n    if (!(\"$async\" in v)) this.errors = v.errors;\n    return valid;\n  }\n  compile(schema, _meta) {\n    const sch = this._addSchema(schema, _meta);\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  compileAsync(schema, meta) {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\");\n    }\n    const {\n      loadSchema\n    } = this.opts;\n    return runCompileAsync.call(this, schema, meta);\n    async function runCompileAsync(_schema, _meta) {\n      await loadMetaSchema.call(this, _schema.$schema);\n      const sch = this._addSchema(_schema, _meta);\n      return sch.validate || _compileAsync.call(this, sch);\n    }\n    async function loadMetaSchema($ref) {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {\n          $ref\n        }, true);\n      }\n    }\n    async function _compileAsync(sch) {\n      try {\n        return this._compileSchemaEnv(sch);\n      } catch (e) {\n        if (!(e instanceof ref_error_1.default)) throw e;\n        checkLoaded.call(this, e);\n        await loadMissingSchema.call(this, e.missingSchema);\n        return _compileAsync.call(this, sch);\n      }\n    }\n    function checkLoaded(_ref) {\n      let {\n        missingSchema: ref,\n        missingRef\n      } = _ref;\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n      }\n    }\n    async function loadMissingSchema(ref) {\n      const _schema = await _loadSchema.call(this, ref);\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n    }\n    async function _loadSchema(ref) {\n      const p = this._loading[ref];\n      if (p) return p;\n      try {\n        return await (this._loading[ref] = loadSchema(ref));\n      } finally {\n        delete this._loading[ref];\n      }\n    }\n  }\n  // Adds schema to the instance\n  addSchema(schema,\n  // If array is passed, `key` will be ignored\n  key,\n  // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n  _meta) {\n    let _validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);\n      return this;\n    }\n    let id;\n    if (typeof schema === \"object\") {\n      const {\n        schemaId\n      } = this.opts;\n      id = schema[schemaId];\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`);\n      }\n    }\n    key = (0, resolve_1.normalizeId)(key || id);\n    this._checkUnique(key);\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n    return this;\n  }\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(schema, key) {\n    let _validateSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts.validateSchema;\n    this.addSchema(schema, key, true, _validateSchema);\n    return this;\n  }\n  //  Validate schema against its meta-schema\n  validateSchema(schema, throwOrLogError) {\n    if (typeof schema == \"boolean\") return true;\n    let $schema;\n    $schema = schema.$schema;\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\");\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n    const valid = this.validate($schema, schema);\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText();\n      if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n    }\n    return valid;\n  }\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema(keyRef) {\n    let sch;\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch;\n    if (sch === undefined) {\n      const {\n        schemaId\n      } = this.opts;\n      const root = new compile_1.SchemaEnv({\n        schema: {},\n        schemaId\n      });\n      sch = compile_1.resolveSchema.call(this, root, keyRef);\n      if (!sch) return;\n      this.refs[keyRef] = sch;\n    }\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef);\n      this._removeAllSchemas(this.refs, schemaKeyRef);\n      return this;\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n        this._removeAllSchemas(this.refs);\n        this._cache.clear();\n        return this;\n      case \"string\":\n        {\n          const sch = getSchEnv.call(this, schemaKeyRef);\n          if (typeof sch == \"object\") this._cache.delete(sch.schema);\n          delete this.schemas[schemaKeyRef];\n          delete this.refs[schemaKeyRef];\n          return this;\n        }\n      case \"object\":\n        {\n          const cacheKey = schemaKeyRef;\n          this._cache.delete(cacheKey);\n          let id = schemaKeyRef[this.opts.schemaId];\n          if (id) {\n            id = (0, resolve_1.normalizeId)(id);\n            delete this.schemas[id];\n            delete this.refs[id];\n          }\n          return this;\n        }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  }\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions) {\n    for (const def of definitions) this.addKeyword(def);\n    return this;\n  }\n  addKeyword(kwdOrDef, def // deprecated\n  ) {\n    let keyword;\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef;\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n        def.keyword = keyword;\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef;\n      keyword = def.keyword;\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\");\n    }\n    checkKeyword.call(this, keyword, def);\n    if (!def) {\n      (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd));\n      return this;\n    }\n    keywordMetaschema.call(this, def);\n    const definition = {\n      ...def,\n      type: (0, dataType_1.getJSONTypes)(def.type),\n      schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n    };\n    (0, util_1.eachItem)(keyword, definition.type.length === 0 ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t)));\n    return this;\n  }\n  getKeyword(keyword) {\n    const rule = this.RULES.all[keyword];\n    return typeof rule == \"object\" ? rule.definition : !!rule;\n  }\n  // Remove keyword\n  removeKeyword(keyword) {\n    // TODO return type should be Ajv\n    const {\n      RULES\n    } = this;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex(rule => rule.keyword === keyword);\n      if (i >= 0) group.rules.splice(i, 1);\n    }\n    return this;\n  }\n  // Add format\n  addFormat(name, format) {\n    if (typeof format == \"string\") format = new RegExp(format);\n    this.formats[name] = format;\n    return this;\n  }\n  errorsText() {\n    let errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.errors;\n    let {\n      separator = \", \",\n      dataVar = \"data\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!errors || errors.length === 0) return \"No errors\";\n    return errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n  }\n  $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n    const rules = this.RULES.all;\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n      let keywords = metaSchema;\n      for (const seg of segments) keywords = keywords[seg];\n      for (const key in rules) {\n        const rule = rules[key];\n        if (typeof rule != \"object\") continue;\n        const {\n          $data\n        } = rule.definition;\n        const schema = keywords[key];\n        if ($data && schema) keywords[key] = schemaOrData(schema);\n      }\n    }\n    return metaSchema;\n  }\n  _removeAllSchemas(schemas, regex) {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef];\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef];\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema);\n          delete schemas[keyRef];\n        }\n      }\n    }\n  }\n  _addSchema(schema, meta, baseId) {\n    let validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n    let addSchema = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.addUsedSchema;\n    let id;\n    const {\n      schemaId\n    } = this.opts;\n    if (typeof schema == \"object\") {\n      id = schema[schemaId];\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n    }\n    let sch = this._cache.get(schema);\n    if (sch !== undefined) return sch;\n    baseId = (0, resolve_1.normalizeId)(id || baseId);\n    const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n    sch = new compile_1.SchemaEnv({\n      schema,\n      schemaId,\n      meta,\n      baseId,\n      localRefs\n    });\n    this._cache.set(sch.schema, sch);\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId);\n      this.refs[baseId] = sch;\n    }\n    if (validateSchema) this.validateSchema(schema, true);\n    return sch;\n  }\n  _checkUnique(id) {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n  }\n  _compileSchemaEnv(sch) {\n    if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\");\n    return sch.validate;\n  }\n  _compileMetaSchema(sch) {\n    const currentOpts = this.opts;\n    this.opts = this._metaOpts;\n    try {\n      compile_1.compileSchema.call(this, sch);\n    } finally {\n      this.opts = currentOpts;\n    }\n  }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg) {\n  let log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"error\";\n  for (const key in checkOpts) {\n    const opt = key;\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n  }\n}\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n  const optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n  for (const keyword in defs) {\n    const def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\nfunction getMetaSchemaOptions() {\n  const metaOpts = {\n    ...this.opts\n  };\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];\n  return metaOpts;\n}\nconst noLogs = {\n  log() {},\n  warn() {},\n  error() {}\n};\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n  const {\n    RULES\n  } = this;\n  (0, util_1.eachItem)(keyword, kwd => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n  });\n  if (!def) return;\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\nfunction addRule(keyword, definition, dataType) {\n  var _a;\n  const post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES\n  } = this;\n  let ruleGroup = post ? RULES.post : RULES.rules.find(_ref2 => {\n    let {\n      type: t\n    } = _ref2;\n    return t === dataType;\n  });\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  const rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    }\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(kwd => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n  const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(`rule ${before} is not defined`);\n  }\n}\nfunction keywordMetaschema(def) {\n  let {\n    metaSchema\n  } = def;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"sources":["../lib/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}