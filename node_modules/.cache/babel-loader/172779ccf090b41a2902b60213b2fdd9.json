{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\nvar ethers_1 = require(\"ethers\");\nvar utils_1 = require(\"ethers/lib/utils\");\nvar merkletreejs_1 = __importDefault(require(\"merkletreejs\"));\nvar hashIdentifier = function (identifier) {\n  return (0, utils_1.keccak256)(Buffer.from(ethers_1.BigNumber.from(identifier).toHexString().slice(2).padStart(64, \"0\"), \"hex\"));\n};\n/**\n * Simple wrapper over the MerkleTree in merkletreejs.\n * Handles hashing identifiers to be compatible with Seaport.\n */\nvar MerkleTree = /** @class */function () {\n  function MerkleTree(identifiers) {\n    this.tree = new merkletreejs_1.default(identifiers.map(hashIdentifier), utils_1.keccak256, {\n      sort: true\n    });\n  }\n  MerkleTree.prototype.getProof = function (identifier) {\n    return this.tree.getHexProof(hashIdentifier(identifier));\n  };\n  MerkleTree.prototype.getRoot = function () {\n    return this.tree.getRoot().toString(\"hex\") ? this.tree.getHexRoot() : \"0\";\n  };\n  return MerkleTree;\n}();\nexports.MerkleTree = MerkleTree;","map":{"version":3,"sources":["../../src/utils/merkletree.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AACA,IAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;AAEA,IAAM,cAAc,GAAG,UAAC,UAAkB,EAAA;EACxC,OAAA,CAAA,CAAA,EAAA,OAAA,CAAA,SAAS,EACP,MAAM,CAAC,IAAI,CACT,QAAA,CAAA,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,EACnE,KAAK,CACN,CACF;AALD,CAKC;AAEH;;;AAGG;AACH,IAAA,UAAA,GAAA,aAAA,YAAA;EAGE,SAAA,UAAA,CAAY,WAAqB,EAAA;IAC/B,IAAI,CAAC,IAAI,GAAG,IAAI,cAAA,CAAA,OAAY,CAAC,WAAW,CAAC,GAAG,CAAC,cAAc,CAAC,EAAE,OAAA,CAAA,SAAS,EAAE;MACvE,IAAI,EAAE;KACP,CAAC;EACJ;EAEA,UAAA,CAAA,SAAA,CAAA,QAAQ,GAAR,UAAS,UAAkB,EAAA;IACzB,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;EAC1D,CAAC;EAED,UAAA,CAAA,SAAA,CAAA,OAAO,GAAP,YAAA;IACE,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,GAAG;EAC3E,CAAC;EACH,OAAA,UAAC;AAAD,CAAC,EAAA;AAhBY,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nvar ethers_1 = require(\"ethers\");\nvar utils_1 = require(\"ethers/lib/utils\");\nvar merkletreejs_1 = __importDefault(require(\"merkletreejs\"));\nvar hashIdentifier = function (identifier) {\n    return (0, utils_1.keccak256)(Buffer.from(ethers_1.BigNumber.from(identifier).toHexString().slice(2).padStart(64, \"0\"), \"hex\"));\n};\n/**\n * Simple wrapper over the MerkleTree in merkletreejs.\n * Handles hashing identifiers to be compatible with Seaport.\n */\nvar MerkleTree = /** @class */ (function () {\n    function MerkleTree(identifiers) {\n        this.tree = new merkletreejs_1.default(identifiers.map(hashIdentifier), utils_1.keccak256, {\n            sort: true,\n        });\n    }\n    MerkleTree.prototype.getProof = function (identifier) {\n        return this.tree.getHexProof(hashIdentifier(identifier));\n    };\n    MerkleTree.prototype.getRoot = function () {\n        return this.tree.getRoot().toString(\"hex\") ? this.tree.getHexRoot() : \"0\";\n    };\n    return MerkleTree;\n}());\nexports.MerkleTree = MerkleTree;\n//# sourceMappingURL=merkletree.js.map"]},"metadata":{},"sourceType":"script"}