{"ast":null,"code":"import { isAddress } from '../../../utils';\nconst alwaysTrue = () => true;\n\n/** Creates a filter function that filters tokens that do not match the query. */\nexport function getTokenFilter(query) {\n  const searchingAddress = isAddress(query);\n  if (searchingAddress) {\n    const address = searchingAddress.toLowerCase();\n    return t => 'address' in t && address === t.address.toLowerCase();\n  }\n  const queryParts = query.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n  if (queryParts.length === 0) return alwaysTrue;\n  const match = s => {\n    const parts = s.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n    return queryParts.every(p => p.length === 0 || parts.some(sp => sp.startsWith(p) || sp.endsWith(p)));\n  };\n  return _ref => {\n    let {\n      name,\n      symbol\n    } = _ref;\n    return Boolean(symbol && match(symbol) || name && match(name));\n  };\n}","map":{"version":3,"names":["isAddress","alwaysTrue","getTokenFilter","query","searchingAddress","address","toLowerCase","t","queryParts","split","filter","s","length","match","parts","every","p","some","sp","startsWith","endsWith","name","symbol","Boolean"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useTokenList/filtering.ts"],"sourcesContent":["import { NativeCurrency, Token } from '@uniswap/sdk-core'\nimport { TokenInfo } from '@uniswap/token-lists'\n\nimport { isAddress } from '../../../utils'\n\nconst alwaysTrue = () => true\n\n/** Creates a filter function that filters tokens that do not match the query. */\nexport function getTokenFilter<T extends Token | TokenInfo>(query: string): (token: T | NativeCurrency) => boolean {\n  const searchingAddress = isAddress(query)\n\n  if (searchingAddress) {\n    const address = searchingAddress.toLowerCase()\n    return (t: T | NativeCurrency) => 'address' in t && address === t.address.toLowerCase()\n  }\n\n  const queryParts = query\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0)\n\n  if (queryParts.length === 0) return alwaysTrue\n\n  const match = (s: string): boolean => {\n    const parts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    return queryParts.every((p) => p.length === 0 || parts.some((sp) => sp.startsWith(p) || sp.endsWith(p)))\n  }\n\n  return ({ name, symbol }: T | NativeCurrency): boolean => Boolean((symbol && match(symbol)) || (name && match(name)))\n}\n"],"mappings":"AAGA,SAASA,SAAS,QAAQ,gBAAgB;AAE1C,MAAMC,UAAU,GAAG,MAAM,IAAI;;AAE7B;AACA,OAAO,SAASC,cAAc,CAA8BC,KAAa,EAA0C;EACjH,MAAMC,gBAAgB,GAAGJ,SAAS,CAACG,KAAK,CAAC;EAEzC,IAAIC,gBAAgB,EAAE;IACpB,MAAMC,OAAO,GAAGD,gBAAgB,CAACE,WAAW,EAAE;IAC9C,OAAQC,CAAqB,IAAK,SAAS,IAAIA,CAAC,IAAIF,OAAO,KAAKE,CAAC,CAACF,OAAO,CAACC,WAAW,EAAE;EACzF;EAEA,MAAME,UAAU,GAAGL,KAAK,CACrBG,WAAW,EAAE,CACbG,KAAK,CAAC,KAAK,CAAC,CACZC,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC;EAE9B,IAAIJ,UAAU,CAACI,MAAM,KAAK,CAAC,EAAE,OAAOX,UAAU;EAE9C,MAAMY,KAAK,GAAIF,CAAS,IAAc;IACpC,MAAMG,KAAK,GAAGH,CAAC,CACZL,WAAW,EAAE,CACbG,KAAK,CAAC,KAAK,CAAC,CACZC,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC;IAE9B,OAAOJ,UAAU,CAACO,KAAK,CAAEC,CAAC,IAAKA,CAAC,CAACJ,MAAM,KAAK,CAAC,IAAIE,KAAK,CAACG,IAAI,CAAEC,EAAE,IAAKA,EAAE,CAACC,UAAU,CAACH,CAAC,CAAC,IAAIE,EAAE,CAACE,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC;EAC1G,CAAC;EAED,OAAO;IAAA,IAAC;MAAEK,IAAI;MAAEC;IAA2B,CAAC;IAAA,OAAcC,OAAO,CAAED,MAAM,IAAIT,KAAK,CAACS,MAAM,CAAC,IAAMD,IAAI,IAAIR,KAAK,CAACQ,IAAI,CAAE,CAAC;EAAA;AACvH"},"metadata":{},"sourceType":"module"}