{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n  if (_sch) return _sch;\n  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  let _ValidationError;\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: (0, codegen_1.stringify)(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: (0, codegen_1._)`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n  try {\n    this._compilations.add(sch);\n    (0, validate_1.validateFunctionCode)(schemaCxt);\n    gen.optimize(this.opts.code.optimize);\n    // gen.optimize(1)\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n    }\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n  ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n  let _sch = resolve.call(this, root, ref);\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root,\n// information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root,\n// root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = this.opts.uriResolver.parse(ref);\n  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n  const id = (0, resolve_1.normalizeId)(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n  if (id === (0, resolve_1.normalizeId)(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n  return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\nfunction getJsonPointer(parsedRef, _ref) {\n  let {\n    baseId,\n    schema,\n    root\n  } = _ref;\n  var _a;\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return;\n    const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n    if (partSchema === undefined) return;\n    schema = partSchema;\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    }\n  }\n  let env;\n  if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"sources":["../../lib/compile/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}