{"ast":null,"code":"import _slicedToArray from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{usePoolDatas}from'data/pools/poolData';import{useTopPoolAddresses}from'data/pools/topPools';import{useEffect,useMemo}from'react';import{useActiveNetworkVersion}from'state/application/hooks';import{POOL_HIDE}from'../../constants';import{useAddPoolKeys,useAllPoolData,useUpdatePoolData}from'./hooks';export default function Updater(){// updaters\nvar _useActiveNetworkVers=useActiveNetworkVersion(),_useActiveNetworkVers2=_slicedToArray(_useActiveNetworkVers,1),currentNetwork=_useActiveNetworkVers2[0];var updatePoolData=useUpdatePoolData();var addPoolKeys=useAddPoolKeys();// data\nvar allPoolData=useAllPoolData();var _useTopPoolAddresses=useTopPoolAddresses(),loading=_useTopPoolAddresses.loading,error=_useTopPoolAddresses.error,addresses=_useTopPoolAddresses.addresses;// add top pools on first load\nuseEffect(function(){if(addresses&&!error&&!loading){addPoolKeys(addresses);}},[addPoolKeys,addresses,error,loading]);// load data for pools we need to hide\nuseEffect(function(){addPoolKeys(POOL_HIDE[currentNetwork.id]);},[addPoolKeys,currentNetwork.id]);// detect for which addresses we havent loaded pool data yet\nvar unfetchedPoolAddresses=useMemo(function(){return Object.keys(allPoolData).reduce(function(accum,key){var poolData=allPoolData[key];if(!poolData.data||!poolData.lastUpdated){accum.push(key);}return accum;},[]);},[allPoolData]);// update unloaded pool entries with fetched data\nvar _usePoolDatas=usePoolDatas(unfetchedPoolAddresses),poolDataError=_usePoolDatas.error,poolDataLoading=_usePoolDatas.loading,poolDatas=_usePoolDatas.data;useEffect(function(){if(poolDatas&&!poolDataError&&!poolDataLoading){updatePoolData(Object.values(poolDatas));}},[poolDataError,poolDataLoading,poolDatas,updatePoolData]);return null;}","map":{"version":3,"names":["usePoolDatas","useTopPoolAddresses","useEffect","useMemo","useActiveNetworkVersion","POOL_HIDE","useAddPoolKeys","useAllPoolData","useUpdatePoolData","Updater","currentNetwork","updatePoolData","addPoolKeys","allPoolData","loading","error","addresses","id","unfetchedPoolAddresses","Object","keys","reduce","accum","key","poolData","data","lastUpdated","push","poolDataError","poolDataLoading","poolDatas","values"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/pools/updater.ts"],"sourcesContent":["import { usePoolDatas } from 'data/pools/poolData'\nimport { useTopPoolAddresses } from 'data/pools/topPools'\nimport { useEffect, useMemo } from 'react'\nimport { useActiveNetworkVersion } from 'state/application/hooks'\n\nimport { POOL_HIDE } from '../../constants'\nimport { useAddPoolKeys, useAllPoolData, useUpdatePoolData } from './hooks'\n\nexport default function Updater(): null {\n  // updaters\n  const [currentNetwork] = useActiveNetworkVersion()\n  const updatePoolData = useUpdatePoolData()\n  const addPoolKeys = useAddPoolKeys()\n\n  // data\n  const allPoolData = useAllPoolData()\n  const { loading, error, addresses } = useTopPoolAddresses()\n\n  // add top pools on first load\n  useEffect(() => {\n    if (addresses && !error && !loading) {\n      addPoolKeys(addresses)\n    }\n  }, [addPoolKeys, addresses, error, loading])\n\n  // load data for pools we need to hide\n  useEffect(() => {\n    addPoolKeys(POOL_HIDE[currentNetwork.id])\n  }, [addPoolKeys, currentNetwork.id])\n\n  // detect for which addresses we havent loaded pool data yet\n  const unfetchedPoolAddresses = useMemo(() => {\n    return Object.keys(allPoolData).reduce((accum: string[], key) => {\n      const poolData = allPoolData[key]\n      if (!poolData.data || !poolData.lastUpdated) {\n        accum.push(key)\n      }\n      return accum\n    }, [])\n  }, [allPoolData])\n\n  // update unloaded pool entries with fetched data\n  const { error: poolDataError, loading: poolDataLoading, data: poolDatas } = usePoolDatas(unfetchedPoolAddresses)\n\n  useEffect(() => {\n    if (poolDatas && !poolDataError && !poolDataLoading) {\n      updatePoolData(Object.values(poolDatas))\n    }\n  }, [poolDataError, poolDataLoading, poolDatas, updatePoolData])\n\n  return null\n}\n"],"mappings":"4KAAA,OAASA,YAAY,KAAQ,qBAAqB,CAClD,OAASC,mBAAmB,KAAQ,qBAAqB,CACzD,OAASC,SAAS,CAAEC,OAAO,KAAQ,OAAO,CAC1C,OAASC,uBAAuB,KAAQ,yBAAyB,CAEjE,OAASC,SAAS,KAAQ,iBAAiB,CAC3C,OAASC,cAAc,CAAEC,cAAc,CAAEC,iBAAiB,KAAQ,SAAS,CAE3E,cAAe,SAASC,QAAO,EAAS,CACtC;AACA,0BAAyBL,uBAAuB,EAAE,gEAA3CM,cAAc,2BACrB,GAAMC,eAAc,CAAGH,iBAAiB,EAAE,CAC1C,GAAMI,YAAW,CAAGN,cAAc,EAAE,CAEpC;AACA,GAAMO,YAAW,CAAGN,cAAc,EAAE,CACpC,yBAAsCN,mBAAmB,EAAE,CAAnDa,OAAO,sBAAPA,OAAO,CAAEC,KAAK,sBAALA,KAAK,CAAEC,SAAS,sBAATA,SAAS,CAEjC;AACAd,SAAS,CAAC,UAAM,CACd,GAAIc,SAAS,EAAI,CAACD,KAAK,EAAI,CAACD,OAAO,CAAE,CACnCF,WAAW,CAACI,SAAS,CAAC,CACxB,CACF,CAAC,CAAE,CAACJ,WAAW,CAAEI,SAAS,CAAED,KAAK,CAAED,OAAO,CAAC,CAAC,CAE5C;AACAZ,SAAS,CAAC,UAAM,CACdU,WAAW,CAACP,SAAS,CAACK,cAAc,CAACO,EAAE,CAAC,CAAC,CAC3C,CAAC,CAAE,CAACL,WAAW,CAAEF,cAAc,CAACO,EAAE,CAAC,CAAC,CAEpC;AACA,GAAMC,uBAAsB,CAAGf,OAAO,CAAC,UAAM,CAC3C,MAAOgB,OAAM,CAACC,IAAI,CAACP,WAAW,CAAC,CAACQ,MAAM,CAAC,SAACC,KAAe,CAAEC,GAAG,CAAK,CAC/D,GAAMC,SAAQ,CAAGX,WAAW,CAACU,GAAG,CAAC,CACjC,GAAI,CAACC,QAAQ,CAACC,IAAI,EAAI,CAACD,QAAQ,CAACE,WAAW,CAAE,CAC3CJ,KAAK,CAACK,IAAI,CAACJ,GAAG,CAAC,CACjB,CACA,MAAOD,MAAK,CACd,CAAC,CAAE,EAAE,CAAC,CACR,CAAC,CAAE,CAACT,WAAW,CAAC,CAAC,CAEjB;AACA,kBAA4Eb,YAAY,CAACkB,sBAAsB,CAAC,CAAjGU,aAAa,eAApBb,KAAK,CAA0Bc,eAAe,eAAxBf,OAAO,CAAyBgB,SAAS,eAAfL,IAAI,CAE5DvB,SAAS,CAAC,UAAM,CACd,GAAI4B,SAAS,EAAI,CAACF,aAAa,EAAI,CAACC,eAAe,CAAE,CACnDlB,cAAc,CAACQ,MAAM,CAACY,MAAM,CAACD,SAAS,CAAC,CAAC,CAC1C,CACF,CAAC,CAAE,CAACF,aAAa,CAAEC,eAAe,CAAEC,SAAS,CAAEnB,cAAc,CAAC,CAAC,CAE/D,MAAO,KAAI,CACb"},"metadata":{},"sourceType":"module"}