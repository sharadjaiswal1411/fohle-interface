{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar color_1 = require(\"@vibrant/color\");\nvar vbox_1 = __importDefault(require(\"./vbox\"));\nvar pqueue_1 = __importDefault(require(\"./pqueue\"));\nvar fractByPopulations = 0.75;\nfunction _splitBoxes(pq, target) {\n  var lastSize = pq.size();\n  while (pq.size() < target) {\n    var vbox = pq.pop();\n    if (vbox && vbox.count() > 0) {\n      var _a = vbox.split(),\n        vbox1 = _a[0],\n        vbox2 = _a[1];\n      pq.push(vbox1);\n      if (vbox2 && vbox2.count() > 0) pq.push(vbox2);\n      // No more new boxes, converged\n      if (pq.size() === lastSize) {\n        break;\n      } else {\n        lastSize = pq.size();\n      }\n    } else {\n      break;\n    }\n  }\n}\nvar MMCQ = function MMCQ(pixels, opts) {\n  if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n    throw new Error('Wrong MMCQ parameters');\n  }\n  var vbox = vbox_1.default.build(pixels);\n  var colorCount = vbox.histogram.colorCount;\n  var pq = new pqueue_1.default(function (a, b) {\n    return a.count() - b.count();\n  });\n  pq.push(vbox);\n  // first set of colors, sorted by population\n  _splitBoxes(pq, fractByPopulations * opts.colorCount);\n  // Re-order\n  var pq2 = new pqueue_1.default(function (a, b) {\n    return a.count() * a.volume() - b.count() * b.volume();\n  });\n  pq2.contents = pq.contents;\n  // next set - generate the median cuts using the (npix * vol) sorting.\n  _splitBoxes(pq2, opts.colorCount - pq2.size());\n  // calculate the actual colors\n  return generateSwatches(pq2);\n};\nfunction generateSwatches(pq) {\n  var swatches = [];\n  while (pq.size()) {\n    var v = pq.pop();\n    var color = v.avg();\n    var r = color[0],\n      g = color[1],\n      b = color[2];\n    swatches.push(new color_1.Swatch(color, v.count()));\n  }\n  return swatches;\n}\nexports.default = MMCQ;","map":{"version":3,"sources":["../../../../packages/vibrant-quantizer-mmcq/src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar color_1 = require(\"@vibrant/color\");\nvar vbox_1 = __importDefault(require(\"./vbox\"));\nvar pqueue_1 = __importDefault(require(\"./pqueue\"));\nvar fractByPopulations = 0.75;\nfunction _splitBoxes(pq, target) {\n    var lastSize = pq.size();\n    while (pq.size() < target) {\n        var vbox = pq.pop();\n        if (vbox && vbox.count() > 0) {\n            var _a = vbox.split(), vbox1 = _a[0], vbox2 = _a[1];\n            pq.push(vbox1);\n            if (vbox2 && vbox2.count() > 0)\n                pq.push(vbox2);\n            // No more new boxes, converged\n            if (pq.size() === lastSize) {\n                break;\n            }\n            else {\n                lastSize = pq.size();\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nvar MMCQ = function (pixels, opts) {\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n        throw new Error('Wrong MMCQ parameters');\n    }\n    var vbox = vbox_1.default.build(pixels);\n    var colorCount = vbox.histogram.colorCount;\n    var pq = new pqueue_1.default(function (a, b) { return a.count() - b.count(); });\n    pq.push(vbox);\n    // first set of colors, sorted by population\n    _splitBoxes(pq, fractByPopulations * opts.colorCount);\n    // Re-order\n    var pq2 = new pqueue_1.default(function (a, b) { return a.count() * a.volume() - b.count() * b.volume(); });\n    pq2.contents = pq.contents;\n    // next set - generate the median cuts using the (npix * vol) sorting.\n    _splitBoxes(pq2, opts.colorCount - pq2.size());\n    // calculate the actual colors\n    return generateSwatches(pq2);\n};\nfunction generateSwatches(pq) {\n    var swatches = [];\n    while (pq.size()) {\n        var v = pq.pop();\n        var color = v.avg();\n        var r = color[0], g = color[1], b = color[2];\n        swatches.push(new color_1.Swatch(color, v.count()));\n    }\n    return swatches;\n}\nexports.default = MMCQ;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}