{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n\n/* Check whether a node is mergeable with adjacent nodes. */\nfunction mergeable(node) {\n  var start;\n  var end;\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n  start = node.position.start;\n  end = node.position.end;\n\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n  return start.line !== end.line || end.column - start.column === node.value.length;\n}\n\n/* Merge two text nodes: `node` into `prev`. */\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n  return prev;\n}\n\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n  prev.children = prev.children.concat(node.children);\n  return prev;\n}\n\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\nfunction factory(type) {\n  return tokenize;\n\n  /* Tokenizer for a bound `type`. */\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    /* Trim white space only lines. */\n    if (!value) {\n      return tokens;\n    }\n\n    /* Expose on `eat`. */\n    eat.now = now;\n    eat.file = self.file;\n\n    /* Sync initial offset. */\n    updatePosition('');\n\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n        if (method && ( /* istanbul ignore next */!method.onlyAtStart || self.atStart) && (!method.notInList || !self.inList) && (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n    self.eof = now();\n    return tokens;\n\n    /* Update line, column, and offset based on\n     * `value`. */\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n      return function () {\n        var last = line + 1;\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n        return indentation;\n      };\n    }\n\n    /* Get the current position. */\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    }\n\n    /* Store position information for a node. */\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(new Error('Incorrectly eaten value: please report this ' + 'warning on http://git.io/vg5Ft'), now());\n      }\n    }\n\n    /* Mark position and patch `node.position`. */\n    function position() {\n      var before = now();\n      return update;\n\n      /* Add the position to a node. */\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n        node.position = new Position(start);\n\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n            combined.push(before.column);\n          }\n          indent = combined.concat(indent);\n        }\n        node.position.indent = indent || [];\n        return node;\n      }\n    }\n\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n      if (prev && node.type === prev.type && node.type in MERGEABLE_NODES && mergeable(prev) && mergeable(node)) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n      if (node !== prev) {\n        children.push(node);\n      }\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n      return node;\n    }\n\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.substring(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply;\n\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      }\n\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n}","map":{"version":3,"names":["module","exports","factory","MERGEABLE_NODES","text","mergeText","blockquote","mergeBlockquote","mergeable","node","start","end","type","position","line","column","value","length","prev","options","commonmark","children","concat","tokenize","location","self","offset","tokens","methods","tokenizers","index","method","name","matched","valueLength","eat","now","file","updatePosition","onlyAtStart","atStart","notInList","inList","notInBlock","inBlock","notInLink","inLink","apply","fail","Error","eof","subvalue","lastIndex","indexOf","getOffset","indentation","pos","last","push","toOffset","Position","validateEat","substring","before","update","indent","combined","n","l","add","parent","call","exitStart","current","reset","test","arguments","result"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/remark-parse/lib/tokenizer.js"],"sourcesContent":["'use strict';\n\nmodule.exports = factory;\n\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n\n/* Check whether a node is mergeable with adjacent nodes. */\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n  return start.line !== end.line ||\n      end.column - start.column === node.value.length;\n}\n\n/* Merge two text nodes: `node` into `prev`. */\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n\n  return prev;\n}\n\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n\n  return prev;\n}\n\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\nfunction factory(type) {\n  return tokenize;\n\n  /* Tokenizer for a bound `type`. */\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    /* Trim white space only lines. */\n    if (!value) {\n      return tokens;\n    }\n\n    /* Expose on `eat`. */\n    eat.now = now;\n    eat.file = self.file;\n\n    /* Sync initial offset. */\n    updatePosition('');\n\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          (!method.notInList || !self.inList) &&\n          (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length;\n\n          method.apply(self, [eat, value]);\n\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n\n    return tokens;\n\n    /* Update line, column, and offset based on\n     * `value`. */\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n\n    /* Get the current position. */\n    function now() {\n      var pos = {line: line, column: column};\n\n      pos.offset = self.toOffset(pos);\n\n      return pos;\n    }\n\n    /* Store position information for a node. */\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this ' +\n            'warning on http://git.io/vg5Ft'\n          ),\n          now()\n        );\n      }\n    }\n\n    /* Mark position and patch `node.position`. */\n    function position() {\n      var before = now();\n\n      return update;\n\n      /* Add the position to a node. */\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n\n        node.position = new Position(start);\n\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n\n        return node;\n      }\n    }\n\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (\n        prev &&\n        node.type === prev.type &&\n        node.type in MERGEABLE_NODES &&\n        mergeable(prev) &&\n        mergeable(node)\n      ) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n\n      validateEat(subvalue);\n\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n\n      value = value.substring(subvalue.length);\n\n      updatePosition(subvalue);\n\n      indent = indent();\n\n      return apply;\n\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n      function reset() {\n        var node = apply.apply(null, arguments);\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return node;\n      }\n\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n      function test() {\n        var result = pos({});\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return result.position;\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}