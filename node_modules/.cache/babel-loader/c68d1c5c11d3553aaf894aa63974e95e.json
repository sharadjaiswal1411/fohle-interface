{"ast":null,"code":"var _s = $RefreshSig$();\nimport { Interface } from '@ethersproject/abi';\nimport { abi as STAKING_REWARDS_ABI } from '@uniswap/liquidity-staker/build/StakingRewards.json';\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport { Pair } from '@uniswap/v2-sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { SupportedChainId } from 'constants/chains';\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp';\nimport JSBI from 'jsbi';\nimport { NEVER_RELOAD, useMultipleContractSingleData } from 'lib/hooks/multicall';\nimport { useMemo } from 'react';\nimport { DAI, UNI, USDC_MAINNET, USDT, WBTC, WRAPPED_NATIVE_CURRENCY } from '../../constants/tokens';\nconst STAKING_REWARDS_INTERFACE = new Interface(STAKING_REWARDS_ABI);\nexport const STAKING_GENESIS = 1600387200;\nconst STAKING_REWARDS_INFO = {\n  1: [{\n    tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET], DAI],\n    stakingRewardAddress: '0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711'\n  }, {\n    tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET], USDC_MAINNET],\n    stakingRewardAddress: '0x7FBa4B8Dc5E7616e59622806932DBea72537A56b'\n  }, {\n    tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET], USDT],\n    stakingRewardAddress: '0x6C3e4cb2E96B01F4b866965A91ed4437839A121a'\n  }, {\n    tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET], WBTC],\n    stakingRewardAddress: '0xCA35e32e7926b96A9988f61d510E038108d8068e'\n  }]\n};\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(pairToFilterBy) {\n  _s();\n  const {\n    chainId,\n    account\n  } = useWeb3React();\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp();\n  const info = useMemo(() => {\n    var _STAKING_REWARDS_INFO, _STAKING_REWARDS_INFO2;\n    return chainId ? (_STAKING_REWARDS_INFO = (_STAKING_REWARDS_INFO2 = STAKING_REWARDS_INFO[chainId]) === null || _STAKING_REWARDS_INFO2 === void 0 ? void 0 : _STAKING_REWARDS_INFO2.filter(stakingRewardInfo => pairToFilterBy === undefined ? true : pairToFilterBy === null ? false : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]))) !== null && _STAKING_REWARDS_INFO !== void 0 ? _STAKING_REWARDS_INFO : [] : [];\n  }, [chainId, pairToFilterBy]);\n  const uni = chainId ? UNI[chainId] : undefined;\n  const rewardsAddresses = useMemo(() => info.map(_ref => {\n    let {\n      stakingRewardAddress\n    } = _ref;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (!chainId || !uni) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index];\n\n      // these get fetched regardless of account\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const periodFinishState = periodFinishes[index];\n      if (\n      // these may be undefined if not logged in\n      !(balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) && !(earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.loading) &&\n      // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateState && !rewardRateState.loading && periodFinishState && !periodFinishState.loading) {\n        var _balanceState$result$, _balanceState$result, _totalSupplyState$res, _rewardRateState$resu, _periodFinishState$re, _periodFinishState$re2, _earnedAmountState$re, _earnedAmountState$re2;\n        if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) || (earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.error) || totalSupplyState.error || rewardRateState.error || periodFinishState.error) {\n          console.error('Failed to load staking rewards info');\n          return memo;\n        }\n\n        // get the LP token\n        const tokens = info[index].tokens;\n        const dummyPair = new Pair(CurrencyAmount.fromRawAmount(tokens[0], '0'), CurrencyAmount.fromRawAmount(tokens[1], '0'));\n\n        // check for account, if no account set to 0\n\n        const stakedAmount = CurrencyAmount.fromRawAmount(dummyPair.liquidityToken, JSBI.BigInt((_balanceState$result$ = balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result = balanceState.result) === null || _balanceState$result === void 0 ? void 0 : _balanceState$result[0]) !== null && _balanceState$result$ !== void 0 ? _balanceState$result$ : 0));\n        const totalStakedAmount = CurrencyAmount.fromRawAmount(dummyPair.liquidityToken, JSBI.BigInt((_totalSupplyState$res = totalSupplyState.result) === null || _totalSupplyState$res === void 0 ? void 0 : _totalSupplyState$res[0]));\n        const totalRewardRate = CurrencyAmount.fromRawAmount(uni, JSBI.BigInt((_rewardRateState$resu = rewardRateState.result) === null || _rewardRateState$resu === void 0 ? void 0 : _rewardRateState$resu[0]));\n        const getHypotheticalRewardRate = (stakedAmount, totalStakedAmount, totalRewardRate) => {\n          return CurrencyAmount.fromRawAmount(uni, JSBI.greaterThan(totalStakedAmount.quotient, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(totalRewardRate.quotient, stakedAmount.quotient), totalStakedAmount.quotient) : JSBI.BigInt(0));\n        };\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, totalRewardRate);\n        const periodFinishSeconds = (_periodFinishState$re = periodFinishState.result) === null || _periodFinishState$re === void 0 ? void 0 : (_periodFinishState$re2 = _periodFinishState$re[0]) === null || _periodFinishState$re2 === void 0 ? void 0 : _periodFinishState$re2.toNumber();\n        const periodFinishMs = periodFinishSeconds * 1000;\n\n        // compare period end timestamp vs current block timestamp (in seconds)\n        const active = periodFinishSeconds && currentBlockTimestamp ? periodFinishSeconds > currentBlockTimestamp.toNumber() : true;\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: info[index].tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          earnedAmount: CurrencyAmount.fromRawAmount(uni, JSBI.BigInt((_earnedAmountState$re = earnedAmountState === null || earnedAmountState === void 0 ? void 0 : (_earnedAmountState$re2 = earnedAmountState.result) === null || _earnedAmountState$re2 === void 0 ? void 0 : _earnedAmountState$re2[0]) !== null && _earnedAmountState$re !== void 0 ? _earnedAmountState$re : 0)),\n          rewardRate: individualRewardRate,\n          totalRewardRate,\n          stakedAmount,\n          totalStakedAmount,\n          getHypotheticalRewardRate,\n          active\n        });\n      }\n      return memo;\n    }, []);\n  }, [balances, chainId, currentBlockTimestamp, earnedAmounts, info, periodFinishes, rewardRates, rewardsAddresses, totalSupplies, uni]);\n}\n_s(useStakingInfo, \"IyqqAFB9eT5TRnEU7WvSGrJvQxM=\", false, function () {\n  return [useWeb3React, useCurrentBlockTimestamp, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData];\n});","map":{"version":3,"names":["Interface","abi","STAKING_REWARDS_ABI","CurrencyAmount","Pair","useWeb3React","SupportedChainId","useCurrentBlockTimestamp","JSBI","NEVER_RELOAD","useMultipleContractSingleData","useMemo","DAI","UNI","USDC_MAINNET","USDT","WBTC","WRAPPED_NATIVE_CURRENCY","STAKING_REWARDS_INTERFACE","STAKING_GENESIS","STAKING_REWARDS_INFO","tokens","MAINNET","stakingRewardAddress","useStakingInfo","pairToFilterBy","chainId","account","currentBlockTimestamp","info","filter","stakingRewardInfo","undefined","involvesToken","uni","rewardsAddresses","map","accountArg","balances","earnedAmounts","totalSupplies","rewardRates","periodFinishes","reduce","memo","rewardsAddress","index","balanceState","earnedAmountState","totalSupplyState","rewardRateState","periodFinishState","loading","error","console","dummyPair","fromRawAmount","stakedAmount","liquidityToken","BigInt","result","totalStakedAmount","totalRewardRate","getHypotheticalRewardRate","greaterThan","quotient","divide","multiply","individualRewardRate","periodFinishSeconds","toNumber","periodFinishMs","active","push","periodFinish","Date","earnedAmount","rewardRate"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/stake/hooks.tsx"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { abi as STAKING_REWARDS_ABI } from '@uniswap/liquidity-staker/build/StakingRewards.json'\nimport { CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { SupportedChainId } from 'constants/chains'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\nimport JSBI from 'jsbi'\nimport { NEVER_RELOAD, useMultipleContractSingleData } from 'lib/hooks/multicall'\nimport { useMemo } from 'react'\n\nimport { DAI, UNI, USDC_MAINNET, USDT, WBTC, WRAPPED_NATIVE_CURRENCY } from '../../constants/tokens'\n\nconst STAKING_REWARDS_INTERFACE = new Interface(STAKING_REWARDS_ABI)\n\nexport const STAKING_GENESIS = 1600387200\n\nconst STAKING_REWARDS_INFO: {\n  [chainId: number]: {\n    tokens: [Token, Token]\n    stakingRewardAddress: string\n  }[]\n} = {\n  1: [\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET] as Token, DAI],\n      stakingRewardAddress: '0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711',\n    },\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET] as Token, USDC_MAINNET],\n      stakingRewardAddress: '0x7FBa4B8Dc5E7616e59622806932DBea72537A56b',\n    },\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET] as Token, USDT],\n      stakingRewardAddress: '0x6C3e4cb2E96B01F4b866965A91ed4437839A121a',\n    },\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[SupportedChainId.MAINNET] as Token, WBTC],\n      stakingRewardAddress: '0xCA35e32e7926b96A9988f61d510E038108d8068e',\n    },\n  ],\n}\n\ninterface StakingInfo {\n  // the address of the reward contract\n  stakingRewardAddress: string\n  // the tokens involved in this pair\n  tokens: [Token, Token]\n  // the amount of token currently staked, or undefined if no account\n  stakedAmount: CurrencyAmount<Token>\n  // the amount of reward token earned by the active account, or undefined if no account\n  earnedAmount: CurrencyAmount<Token>\n  // the total amount of token staked in the contract\n  totalStakedAmount: CurrencyAmount<Token>\n  // the amount of token distributed per second to all LPs, constant\n  totalRewardRate: CurrencyAmount<Token>\n  // the current amount of token distributed to the active account per second.\n  // equivalent to percent of total supply * reward rate\n  rewardRate: CurrencyAmount<Token>\n  // when the period ends\n  periodFinish: Date | undefined\n  // if pool is active\n  active: boolean\n  // calculates a hypothetical amount of token distributed to the active account per second.\n  getHypotheticalRewardRate: (\n    stakedAmount: CurrencyAmount<Token>,\n    totalStakedAmount: CurrencyAmount<Token>,\n    totalRewardRate: CurrencyAmount<Token>\n  ) => CurrencyAmount<Token>\n}\n\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(pairToFilterBy?: Pair | null): StakingInfo[] {\n  const { chainId, account } = useWeb3React()\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp()\n\n  const info = useMemo(\n    () =>\n      chainId\n        ? STAKING_REWARDS_INFO[chainId]?.filter((stakingRewardInfo) =>\n            pairToFilterBy === undefined\n              ? true\n              : pairToFilterBy === null\n              ? false\n              : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n                pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])\n          ) ?? []\n        : [],\n    [chainId, pairToFilterBy]\n  )\n\n  const uni = chainId ? UNI[chainId] : undefined\n\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n\n  const accountArg = useMemo(() => [account ?? undefined], [account])\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD\n  )\n  const periodFinishes = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'periodFinish',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  return useMemo(() => {\n    if (!chainId || !uni) return []\n\n    return rewardsAddresses.reduce<StakingInfo[]>((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index]\n      const earnedAmountState = earnedAmounts[index]\n\n      // these get fetched regardless of account\n      const totalSupplyState = totalSupplies[index]\n      const rewardRateState = rewardRates[index]\n      const periodFinishState = periodFinishes[index]\n\n      if (\n        // these may be undefined if not logged in\n        !balanceState?.loading &&\n        !earnedAmountState?.loading &&\n        // always need these\n        totalSupplyState &&\n        !totalSupplyState.loading &&\n        rewardRateState &&\n        !rewardRateState.loading &&\n        periodFinishState &&\n        !periodFinishState.loading\n      ) {\n        if (\n          balanceState?.error ||\n          earnedAmountState?.error ||\n          totalSupplyState.error ||\n          rewardRateState.error ||\n          periodFinishState.error\n        ) {\n          console.error('Failed to load staking rewards info')\n          return memo\n        }\n\n        // get the LP token\n        const tokens = info[index].tokens\n        const dummyPair = new Pair(\n          CurrencyAmount.fromRawAmount(tokens[0], '0'),\n          CurrencyAmount.fromRawAmount(tokens[1], '0')\n        )\n\n        // check for account, if no account set to 0\n\n        const stakedAmount = CurrencyAmount.fromRawAmount(\n          dummyPair.liquidityToken,\n          JSBI.BigInt(balanceState?.result?.[0] ?? 0)\n        )\n        const totalStakedAmount = CurrencyAmount.fromRawAmount(\n          dummyPair.liquidityToken,\n          JSBI.BigInt(totalSupplyState.result?.[0])\n        )\n        const totalRewardRate = CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(rewardRateState.result?.[0]))\n\n        const getHypotheticalRewardRate = (\n          stakedAmount: CurrencyAmount<Token>,\n          totalStakedAmount: CurrencyAmount<Token>,\n          totalRewardRate: CurrencyAmount<Token>\n        ): CurrencyAmount<Token> => {\n          return CurrencyAmount.fromRawAmount(\n            uni,\n            JSBI.greaterThan(totalStakedAmount.quotient, JSBI.BigInt(0))\n              ? JSBI.divide(JSBI.multiply(totalRewardRate.quotient, stakedAmount.quotient), totalStakedAmount.quotient)\n              : JSBI.BigInt(0)\n          )\n        }\n\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, totalRewardRate)\n\n        const periodFinishSeconds = periodFinishState.result?.[0]?.toNumber()\n        const periodFinishMs = periodFinishSeconds * 1000\n\n        // compare period end timestamp vs current block timestamp (in seconds)\n        const active =\n          periodFinishSeconds && currentBlockTimestamp ? periodFinishSeconds > currentBlockTimestamp.toNumber() : true\n\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: info[index].tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          earnedAmount: CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0)),\n          rewardRate: individualRewardRate,\n          totalRewardRate,\n          stakedAmount,\n          totalStakedAmount,\n          getHypotheticalRewardRate,\n          active,\n        })\n      }\n      return memo\n    }, [])\n  }, [\n    balances,\n    chainId,\n    currentBlockTimestamp,\n    earnedAmounts,\n    info,\n    periodFinishes,\n    rewardRates,\n    rewardsAddresses,\n    totalSupplies,\n    uni,\n  ])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}