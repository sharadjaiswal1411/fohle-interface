{"ast":null,"code":"import { Price } from '@uniswap/sdk-core';\nimport { encodeSqrtRatioX96, nearestUsableTick, priceToClosestTick, TICK_SPACINGS, TickMath } from '@uniswap/v3-sdk';\nimport JSBI from 'jsbi';\nexport function tryParsePrice(baseToken, quoteToken, value) {\n  var _fraction$length;\n  if (!baseToken || !quoteToken || !value) {\n    return undefined;\n  }\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined;\n  }\n  const [whole, fraction] = value.split('.');\n  const decimals = (_fraction$length = fraction === null || fraction === void 0 ? void 0 : fraction.length) !== null && _fraction$length !== void 0 ? _fraction$length : 0;\n  const withoutDecimals = JSBI.BigInt((whole !== null && whole !== void 0 ? whole : '') + (fraction !== null && fraction !== void 0 ? fraction : ''));\n  return new Price(baseToken, quoteToken, JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)), JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals)));\n}\nexport function tryParseTick(baseToken, quoteToken, feeAmount, value) {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined;\n  }\n  const price = tryParsePrice(baseToken, quoteToken, value);\n  if (!price) {\n    return undefined;\n  }\n  let tick;\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK;\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK;\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price);\n  }\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n}","map":{"version":3,"names":["Price","encodeSqrtRatioX96","nearestUsableTick","priceToClosestTick","TICK_SPACINGS","TickMath","JSBI","tryParsePrice","baseToken","quoteToken","value","undefined","match","whole","fraction","split","decimals","length","withoutDecimals","BigInt","multiply","tryParseTick","feeAmount","price","tick","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MAX_SQRT_RATIO","MAX_TICK","lessThanOrEqual","MIN_SQRT_RATIO","MIN_TICK"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/mint/v3/utils.ts"],"sourcesContent":["import { Price, Token } from '@uniswap/sdk-core'\nimport {\n  encodeSqrtRatioX96,\n  FeeAmount,\n  nearestUsableTick,\n  priceToClosestTick,\n  TICK_SPACINGS,\n  TickMath,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nexport function tryParsePrice(baseToken?: Token, quoteToken?: Token, value?: string) {\n  if (!baseToken || !quoteToken || !value) {\n    return undefined\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined\n  }\n\n  const [whole, fraction] = value.split('.')\n\n  const decimals = fraction?.length ?? 0\n  const withoutDecimals = JSBI.BigInt((whole ?? '') + (fraction ?? ''))\n\n  return new Price(\n    baseToken,\n    quoteToken,\n    JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)),\n    JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals))\n  )\n}\n\nexport function tryParseTick(\n  baseToken?: Token,\n  quoteToken?: Token,\n  feeAmount?: FeeAmount,\n  value?: string\n): number | undefined {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value)\n\n  if (!price) {\n    return undefined\n  }\n\n  let tick: number\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator)\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price)\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount])\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAe,mBAAmB;AAChD,SACEC,kBAAkB,EAElBC,iBAAiB,EACjBC,kBAAkB,EAClBC,aAAa,EACbC,QAAQ,QACH,iBAAiB;AACxB,OAAOC,IAAI,MAAM,MAAM;AAEvB,OAAO,SAASC,aAAa,CAACC,SAAiB,EAAEC,UAAkB,EAAEC,KAAc,EAAE;EAAA;EACnF,IAAI,CAACF,SAAS,IAAI,CAACC,UAAU,IAAI,CAACC,KAAK,EAAE;IACvC,OAAOC,SAAS;EAClB;EAEA,IAAI,CAACD,KAAK,CAACE,KAAK,CAAC,aAAa,CAAC,EAAE;IAC/B,OAAOD,SAAS;EAClB;EAEA,MAAM,CAACE,KAAK,EAAEC,QAAQ,CAAC,GAAGJ,KAAK,CAACK,KAAK,CAAC,GAAG,CAAC;EAE1C,MAAMC,QAAQ,uBAAGF,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEG,MAAM,+DAAI,CAAC;EACtC,MAAMC,eAAe,GAAGZ,IAAI,CAACa,MAAM,CAAC,CAACN,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,EAAE,KAAKC,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAI,EAAE,CAAC,CAAC;EAErE,OAAO,IAAId,KAAK,CACdQ,SAAS,EACTC,UAAU,EACVH,IAAI,CAACc,QAAQ,CAACd,IAAI,CAACa,MAAM,CAAC,EAAE,IAAIH,QAAQ,CAAC,EAAEV,IAAI,CAACa,MAAM,CAAC,EAAE,IAAIX,SAAS,CAACQ,QAAQ,CAAC,CAAC,EACjFV,IAAI,CAACc,QAAQ,CAACF,eAAe,EAAEZ,IAAI,CAACa,MAAM,CAAC,EAAE,IAAIV,UAAU,CAACO,QAAQ,CAAC,CAAC,CACvE;AACH;AAEA,OAAO,SAASK,YAAY,CAC1Bb,SAAiB,EACjBC,UAAkB,EAClBa,SAAqB,EACrBZ,KAAc,EACM;EACpB,IAAI,CAACF,SAAS,IAAI,CAACC,UAAU,IAAI,CAACa,SAAS,IAAI,CAACZ,KAAK,EAAE;IACrD,OAAOC,SAAS;EAClB;EAEA,MAAMY,KAAK,GAAGhB,aAAa,CAACC,SAAS,EAAEC,UAAU,EAAEC,KAAK,CAAC;EAEzD,IAAI,CAACa,KAAK,EAAE;IACV,OAAOZ,SAAS;EAClB;EAEA,IAAIa,IAAY;;EAEhB;EACA,MAAMC,YAAY,GAAGxB,kBAAkB,CAACsB,KAAK,CAACG,SAAS,EAAEH,KAAK,CAACI,WAAW,CAAC;EAE3E,IAAIrB,IAAI,CAACsB,kBAAkB,CAACH,YAAY,EAAEpB,QAAQ,CAACwB,cAAc,CAAC,EAAE;IAClEL,IAAI,GAAGnB,QAAQ,CAACyB,QAAQ;EAC1B,CAAC,MAAM,IAAIxB,IAAI,CAACyB,eAAe,CAACN,YAAY,EAAEpB,QAAQ,CAAC2B,cAAc,CAAC,EAAE;IACtER,IAAI,GAAGnB,QAAQ,CAAC4B,QAAQ;EAC1B,CAAC,MAAM;IACL;IACAT,IAAI,GAAGrB,kBAAkB,CAACoB,KAAK,CAAC;EAClC;EAEA,OAAOrB,iBAAiB,CAACsB,IAAI,EAAEpB,aAAa,CAACkB,SAAS,CAAC,CAAC;AAC1D"},"metadata":{},"sourceType":"module"}