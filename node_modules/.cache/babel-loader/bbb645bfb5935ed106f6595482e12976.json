{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _createForOfIteratorHelper = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\nvar _classCallCheck = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _createSuper = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\nvar buffer_1 = require(\"buffer\");\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nvar MerkleMountainRange = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleMountainRange, _Base_1$default);\n  var _super = _createSuper(MerkleMountainRange);\n  function MerkleMountainRange() {\n    var _this;\n    var hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    var leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    var peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    var hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n    _classCallCheck(this, MerkleMountainRange);\n    _this = _super.call(this);\n    _this.root = buffer_1.Buffer.alloc(0);\n    _this.size = 0;\n    _this.width = 0;\n    _this.hashes = {};\n    _this.data = {};\n    leaves = leaves.map(_this.bufferify);\n    _this.hashFn = _this.bufferifyFn(hashFn);\n    _this.hashLeafFn = hashLeafFn;\n    _this.peakBaggingFn = peakBaggingFn;\n    _this.hashBranchFn = hashBranchFn;\n    var _iterator = _createForOfIteratorHelper(leaves),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var leaf = _step.value;\n        _this.append(leaf);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return _this;\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n  _createClass(MerkleMountainRange, [{\n    key: \"append\",\n    value: function append(data) {\n      data = this.bufferify(data);\n      var dataHash = this.hashFn(data);\n      var dataHashHex = this.bufferToHex(dataHash);\n      if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n        this.data[dataHashHex] = data;\n      }\n      var leaf = this.hashLeaf(this.size + 1, dataHash);\n      this.hashes[this.size + 1] = leaf;\n      this.width += 1;\n      // find peaks for enlarged tree\n      var peakIndexes = this.getPeakIndexes(this.width);\n      // the right most peak's value is the new size of the updated tree\n      this.size = this.getSize(this.width);\n      // starting from the left-most peak, get all peak hashes\n      var peaks = [];\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n      }\n      // update the tree root hash\n      this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n  }, {\n    key: \"hashLeaf\",\n    value: function hashLeaf(index, dataHash) {\n      dataHash = this.bufferify(dataHash);\n      if (this.hashLeafFn) {\n        return this.bufferify(this.hashLeafFn(index, dataHash));\n      }\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n  }, {\n    key: \"hashBranch\",\n    value: function hashBranch(index, left, right) {\n      if (this.hashBranchFn) {\n        return this.bufferify(this.hashBranchFn(index, left, right));\n      }\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n  }, {\n    key: \"getPeaks\",\n    value: function getPeaks() {\n      var peakIndexes = this.getPeakIndexes(this.width);\n      var peaks = [];\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this.hashes[peakIndexes[i]];\n      }\n      return peaks;\n    }\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(width) {\n      if (width % 2 === 1) {\n        return this.getSize(width);\n      }\n      return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n  }, {\n    key: \"getPeakIndexes\",\n    value: function getPeakIndexes(width) {\n      var numPeaks = this.numOfPeaks(width);\n      var peakIndexes = [];\n      var count = 0;\n      var size = 0;\n      for (var i = 255; i > 0; i--) {\n        if ((width & 1 << i - 1) !== 0) {\n          // peak exists\n          size = size + (1 << i) - 1;\n          peakIndexes[count++] = size;\n          if (peakIndexes.length >= numPeaks) {\n            break;\n          }\n        }\n      }\n      if (count !== peakIndexes.length) {\n        throw new Error('invalid bit calculation');\n      }\n      return peakIndexes;\n    }\n  }, {\n    key: \"numOfPeaks\",\n    value: function numOfPeaks(width) {\n      var bits = width;\n      var num = 0;\n      while (bits > 0) {\n        if (bits % 2 === 1) {\n          num++;\n        }\n        bits = bits >> 1;\n      }\n      return num;\n    }\n  }, {\n    key: \"peakBagging\",\n    value: function peakBagging(width, peaks) {\n      var size = this.getSize(width);\n      if (this.numOfPeaks(width) !== peaks.length) {\n        throw new Error('received invalid number of peaks');\n      }\n      if (width === 0 && !peaks.length) {\n        return buffer_1.Buffer.alloc(0);\n      }\n      if (this.peakBaggingFn) {\n        return this.bufferify(this.peakBaggingFn(size, peaks));\n      }\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size)].concat(_toConsumableArray(peaks.map(this.bufferify)))));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize(width) {\n      return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.root;\n    }\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n  }, {\n    key: \"mountainHeight\",\n    value: function mountainHeight(size) {\n      var height = 1;\n      while (1 << height <= size + height) {\n        height++;\n      }\n      return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n  }, {\n    key: \"heightAt\",\n    value: function heightAt(index) {\n      var reducedIndex = index;\n      var peakIndex = 0;\n      var height = 0;\n      // if an index has a left mountain then subtract the mountain\n      while (reducedIndex > peakIndex) {\n        reducedIndex -= (1 << height) - 1;\n        height = this.mountainHeight(reducedIndex);\n        peakIndex = (1 << height) - 1;\n      }\n      // index is on the right slope\n      return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf(index) {\n      return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(index) {\n      var left = index - (1 << this.heightAt(index) - 1);\n      var right = index - 1;\n      if (left === right) {\n        throw new Error('not a parent');\n      }\n      return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n  }, {\n    key: \"getMerkleProof\",\n    value: function getMerkleProof(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n      if (!this.isLeaf(index)) {\n        throw new Error('not a leaf');\n      }\n      var root = this.root;\n      var width = this.width;\n      // find all peaks for bagging\n      var peaks = this.getPeakIndexes(this.width);\n      var peakBagging = [];\n      var cursor = 0;\n      for (var i = 0; i < peaks.length; i++) {\n        // collect the hash of all peaks\n        peakBagging[i] = this.hashes[peaks[i]];\n        // find the peak which includes the target index\n        if (peaks[i] >= index && cursor === 0) {\n          cursor = peaks[i];\n        }\n      }\n      var left = 0;\n      var right = 0;\n      // get hashes of the siblings in the mountain which the index belgons to.\n      // it moves the cursor from the summit of the mountain down to the target index\n      var height = this.heightAt(cursor);\n      var siblings = [];\n      while (cursor !== index) {\n        height--;\n        var _this$getChildren = this.getChildren(cursor);\n        var _this$getChildren2 = _slicedToArray(_this$getChildren, 2);\n        left = _this$getChildren2[0];\n        right = _this$getChildren2[1];\n        // move the cursor down to the left size or right size\n        cursor = index <= left ? left : right;\n        // remaining node is the sibling\n        siblings[height - 1] = this.hashes[index <= left ? right : left];\n      }\n      return {\n        root: root,\n        width: width,\n        peakBagging: peakBagging,\n        siblings: siblings\n      };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n  }, {\n    key: \"verify\",\n    value: function verify(root, width, index, value, peaks, siblings) {\n      value = this.bufferify(value);\n      var size = this.getSize(width);\n      if (size < index) {\n        throw new Error('index is out of range');\n      }\n      // check the root equals the peak bagging hash\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      }\n      // find the mountain where the target index belongs to\n      var cursor = 0;\n      var targetPeak;\n      var peakIndexes = this.getPeakIndexes(width);\n      for (var i = 0; i < peakIndexes.length; i++) {\n        if (peakIndexes[i] >= index) {\n          targetPeak = peaks[i];\n          cursor = peakIndexes[i];\n          break;\n        }\n      }\n      if (!targetPeak) {\n        throw new Error('target not found');\n      }\n      // find the path climbing down\n      var height = siblings.length + 1;\n      var path = new Array(height);\n      var left = 0;\n      var right = 0;\n      while (height > 0) {\n        // record the current cursor and climb down\n        path[--height] = cursor;\n        if (cursor === index) {\n          // on the leaf node. Stop climbing down\n          break;\n        } else {\n          // on the parent node. Go left or right\n          var _this$getChildren3 = this.getChildren(cursor);\n          var _this$getChildren4 = _slicedToArray(_this$getChildren3, 2);\n          left = _this$getChildren4[0];\n          right = _this$getChildren4[1];\n          cursor = index > left ? right : left;\n          continue;\n        }\n      }\n      // calculate the summit hash climbing up again\n      var node;\n      while (height < path.length) {\n        // move cursor\n        cursor = path[height];\n        if (height === 0) {\n          // cusor is on the leaf\n          node = this.hashLeaf(cursor, this.hashFn(value));\n        } else if (cursor - 1 === path[height - 1]) {\n          // cursor is on a parent and a siblings is on the left\n          node = this.hashBranch(cursor, siblings[height - 1], node);\n        } else {\n          // cursor is on a parent and a siblings is on the right\n          node = this.hashBranch(cursor, node, siblings[height - 1]);\n        }\n        // climb up\n        height++;\n      }\n      // computed hash value of the summit should equal to the target peak hash\n      if (!node.equals(targetPeak)) {\n        throw new Error('hashed peak is invalid');\n      }\n      return true;\n    }\n  }, {\n    key: \"peaksToPeakMap\",\n    value: function peaksToPeakMap(width, peaks) {\n      var peakMap = {};\n      var bitIndex = 0;\n      var peakRef = 0;\n      var count = peaks.length;\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n        peakRef = 1 << height - 1;\n        if ((width & peakRef) !== 0) {\n          peakMap[bitIndex] = peaks[--count];\n        } else {\n          peakMap[bitIndex] = 0;\n        }\n      }\n      if (count !== 0) {\n        throw new Error('invalid number of peaks');\n      }\n      return peakMap;\n    }\n  }, {\n    key: \"peakMapToPeaks\",\n    value: function peakMapToPeaks(width, peakMap) {\n      var arrLength = this.numOfPeaks(width);\n      var peaks = new Array(arrLength);\n      var count = 0;\n      for (var i = 0; i < 32; i++) {\n        if (peakMap[i] !== 0) {\n          peaks[count++] = peakMap[i];\n        }\n      }\n      if (count !== arrLength) {\n        throw new Error('invalid number of peaks');\n      }\n      return peaks;\n    }\n  }, {\n    key: \"peakUpdate\",\n    value: function peakUpdate(width, prevPeakMap, itemHash) {\n      var nextPeakMap = {};\n      var newWidth = width + 1;\n      var cursorIndex = this.getLeafIndex(newWidth);\n      var cursorNode = this.hashLeaf(cursorIndex, itemHash);\n      var bitIndex = 0;\n      var peakRef = 0;\n      var prevPeakExist = false;\n      var nextPeakExist = false;\n      var obtained = false;\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n        if (obtained) {\n          nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n        } else {\n          peakRef = 1 << height - 1;\n          prevPeakExist = (width & peakRef) !== 0;\n          nextPeakExist = (newWidth & peakRef) !== 0;\n          // get new cursor node with hashing the peak and the current cursor\n          cursorIndex++;\n          if (prevPeakExist) {\n            cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n          }\n          // if new peak exists for the bit index\n          if (nextPeakExist) {\n            // if prev peak exists for the bit index\n            if (prevPeakExist) {\n              nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            } else {\n              nextPeakMap[bitIndex] = cursorNode;\n            }\n            obtained = true;\n          } else {\n            nextPeakMap[bitIndex] = 0;\n          }\n        }\n      }\n      return nextPeakMap;\n    }\n  }, {\n    key: \"rollUp\",\n    value: function rollUp(root, width, peaks, itemHashes) {\n      // check the root equals the peak bagging hash\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      }\n      var tmpWidth = width;\n      var tmpPeakMap = this.peaksToPeakMap(width, peaks);\n      for (var i = 0; i < itemHashes.length; i++) {\n        tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n        tmpWidth++;\n      }\n      return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n  }, {\n    key: \"_getOrCreateNode\",\n    value: function _getOrCreateNode(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n      if (!this.hashes[index]) {\n        var _this$getChildren5 = this.getChildren(index),\n          _this$getChildren6 = _slicedToArray(_this$getChildren5, 2),\n          leftIndex = _this$getChildren6[0],\n          rightIndex = _this$getChildren6[1];\n        var leftHash = this._getOrCreateNode(leftIndex);\n        var rightHash = this._getOrCreateNode(rightIndex);\n        this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n      }\n      return this.hashes[index];\n    }\n  }]);\n  return MerkleMountainRange;\n}(Base_1.default);\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleMountainRange","buffer_1","require","sha256_1","Base_1","hashFn","default","leaves","hashLeafFn","peakBaggingFn","hashBranchFn","root","Buffer","alloc","size","width","hashes","data","map","bufferify","bufferifyFn","leaf","append","dataHash","dataHashHex","bufferToHex","hashLeaf","peakIndexes","getPeakIndexes","getSize","peaks","i","length","_getOrCreateNode","peakBagging","index","concat","left","right","numPeaks","numOfPeaks","count","Error","bits","num","getRoot","height","reducedIndex","peakIndex","mountainHeight","heightAt","isLeaf","cursor","siblings","getChildren","equals","targetPeak","path","Array","node","hashBranch","peakMap","bitIndex","peakRef","arrLength","prevPeakMap","itemHash","nextPeakMap","newWidth","cursorIndex","getLeafIndex","cursorNode","prevPeakExist","nextPeakExist","obtained","itemHashes","tmpWidth","tmpPeakMap","peaksToPeakMap","peakUpdate","peakMapToPeaks","leftIndex","rightIndex","leftHash","rightHash"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/merkletreejs/dist/MerkleMountainRange.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = require(\"buffer\");\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}