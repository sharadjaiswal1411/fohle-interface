{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _createForOfIteratorHelper = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\nvar _toConsumableArray = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _createSuper = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\nvar buffer_1 = require(\"buffer\");\nvar buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar treeify_1 = __importDefault(require(\"treeify\"));\nvar Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nvar MerkleTree = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleTree, _Base_1$default);\n  var _super = _createSuper(MerkleTree);\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  function MerkleTree(leaves) {\n    var _this;\n    var hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, MerkleTree);\n    _this = _super.call(this);\n    _this.duplicateOdd = false;\n    _this.hashLeaves = false;\n    _this.isBitcoinTree = false;\n    _this.leaves = [];\n    _this.layers = [];\n    _this.sortLeaves = false;\n    _this.sortPairs = false;\n    _this.sort = false;\n    _this.fillDefaultHash = null;\n    _this.isBitcoinTree = !!options.isBitcoinTree;\n    _this.hashLeaves = !!options.hashLeaves;\n    _this.sortLeaves = !!options.sortLeaves;\n    _this.sortPairs = !!options.sortPairs;\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        _this.fillDefaultHash = options.fillDefaultHash;\n      } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        _this.fillDefaultHash = function (idx, hashFn) {\n          return options.fillDefaultHash;\n        };\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n    _this.sort = !!options.sort;\n    if (_this.sort) {\n      _this.sortLeaves = true;\n      _this.sortPairs = true;\n    }\n    _this.duplicateOdd = !!options.duplicateOdd;\n    _this.hashFn = _this.bufferifyFn(hashFn);\n    _this.processLeaves(leaves);\n    return _this;\n  }\n  _createClass(MerkleTree, [{\n    key: \"processLeaves\",\n    value: function processLeaves(leaves) {\n      if (this.hashLeaves) {\n        leaves = leaves.map(this.hashFn);\n      }\n      this.leaves = leaves.map(this.bufferify);\n      if (this.sortLeaves) {\n        this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n      }\n      if (this.fillDefaultHash) {\n        for (var i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n          if (i >= this.leaves.length) {\n            this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n          }\n        }\n      }\n      this.layers = [this.leaves];\n      this._createHashes(this.leaves);\n    }\n  }, {\n    key: \"_createHashes\",\n    value: function _createHashes(nodes) {\n      while (nodes.length > 1) {\n        var layerIndex = this.layers.length;\n        this.layers.push([]);\n        for (var i = 0; i < nodes.length; i += 2) {\n          if (i + 1 === nodes.length) {\n            if (nodes.length % 2 === 1) {\n              var _data = nodes[nodes.length - 1];\n              var _hash = _data;\n              // is bitcoin tree\n              if (this.isBitcoinTree) {\n                // Bitcoin method of duplicating the odd ending nodes\n                _data = buffer_1.Buffer.concat([buffer_reverse_1.default(_data), buffer_reverse_1.default(_data)]);\n                _hash = this.hashFn(_data);\n                _hash = buffer_reverse_1.default(this.hashFn(_hash));\n                this.layers[layerIndex].push(_hash);\n                continue;\n              } else {\n                if (this.duplicateOdd) {\n                  // continue with creating layer\n                } else {\n                  // push copy of hash and continue iteration\n                  this.layers[layerIndex].push(nodes[i]);\n                  continue;\n                }\n              }\n            }\n          }\n          var left = nodes[i];\n          var right = i + 1 === nodes.length ? left : nodes[i + 1];\n          var data = null;\n          var combined = null;\n          if (this.isBitcoinTree) {\n            combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n          } else {\n            combined = [left, right];\n          }\n          if (this.sortPairs) {\n            combined.sort(buffer_1.Buffer.compare);\n          }\n          data = buffer_1.Buffer.concat(combined);\n          var hash = this.hashFn(data);\n          // double hash if bitcoin tree\n          if (this.isBitcoinTree) {\n            hash = buffer_reverse_1.default(this.hashFn(hash));\n          }\n          this.layers[layerIndex].push(hash);\n        }\n        nodes = this.layers[layerIndex];\n      }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n  }, {\n    key: \"addLeaf\",\n    value: function addLeaf(leaf) {\n      var shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (shouldHash) {\n        leaf = this.hashFn(leaf);\n      }\n      this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n  }, {\n    key: \"addLeaves\",\n    value: function addLeaves(leaves) {\n      var shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (shouldHash) {\n        leaves = leaves.map(this.hashFn);\n      }\n      this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(values) {\n      var _this2 = this;\n      if (Array.isArray(values)) {\n        if (this.hashLeaves) {\n          values = values.map(this.hashFn);\n          if (this.sortLeaves) {\n            values = values.sort(buffer_1.Buffer.compare);\n          }\n        }\n        return this.leaves.filter(function (leaf) {\n          return _this2._bufferIndexOf(values, leaf) !== -1;\n        });\n      }\n      return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n  }, {\n    key: \"getLeaf\",\n    value: function getLeaf(index) {\n      if (index < 0 || index > this.leaves.length - 1) {\n        return buffer_1.Buffer.from([]);\n      }\n      return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(target) {\n      target = this.bufferify(target);\n      var leaves = this.getLeaves();\n      for (var i = 0; i < leaves.length; i++) {\n        var leaf = leaves[i];\n        if (leaf.equals(target)) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n  }, {\n    key: \"getLeafCount\",\n    value: function getLeafCount() {\n      return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n  }, {\n    key: \"getHexLeaves\",\n    value: function getHexLeaves() {\n      var _this3 = this;\n      return this.leaves.map(function (leaf) {\n        return _this3.bufferToHex(leaf);\n      });\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n  }, {\n    key: \"getLayers\",\n    value:\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    function getLayers() {\n      return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n  }, {\n    key: \"getHexLayers\",\n    value: function getHexLayers() {\n      var _this4 = this;\n      return this.layers.reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.push(item.map(function (layer) {\n            return _this4.bufferToHex(layer);\n          }));\n        } else {\n          acc.push(item);\n        }\n        return acc;\n      }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n  }, {\n    key: \"getLayersFlat\",\n    value: function getLayersFlat() {\n      var layers = this.layers.reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.unshift.apply(acc, _toConsumableArray(item));\n        } else {\n          acc.unshift(item);\n        }\n        return acc;\n      }, []);\n      layers.unshift(buffer_1.Buffer.from([0]));\n      return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n  }, {\n    key: \"getHexLayersFlat\",\n    value: function getHexLayersFlat() {\n      var _this5 = this;\n      return this.getLayersFlat().map(function (layer) {\n        return _this5.bufferToHex(layer);\n      });\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n  }, {\n    key: \"getLayerCount\",\n    value: function getLayerCount() {\n      return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      if (this.layers.length === 0) {\n        return buffer_1.Buffer.from([]);\n      }\n      return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n  }, {\n    key: \"getProof\",\n    value: function getProof(leaf, index) {\n      if (typeof leaf === 'undefined') {\n        throw new Error('leaf is required');\n      }\n      leaf = this.bufferify(leaf);\n      var proof = [];\n      if (!Number.isInteger(index)) {\n        index = -1;\n        for (var i = 0; i < this.leaves.length; i++) {\n          if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n            index = i;\n          }\n        }\n      }\n      if (index <= -1) {\n        return [];\n      }\n      for (var _i = 0; _i < this.layers.length; _i++) {\n        var layer = this.layers[_i];\n        var isRightNode = index % 2;\n        var pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && _i < this.layers.length - 1\n        // Proof Generation for Bitcoin Trees\n        ? index\n        // Proof Generation for Non-Bitcoin Trees\n        : index + 1;\n        if (pairIndex < layer.length) {\n          proof.push({\n            position: isRightNode ? 'left' : 'right',\n            data: layer[pairIndex]\n          });\n        }\n        // set index to parent index\n        index = index / 2 | 0;\n      }\n      return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n  }, {\n    key: \"getHexProof\",\n    value: function getHexProof(leaf, index) {\n      var _this6 = this;\n      return this.getProof(leaf, index).map(function (item) {\n        return _this6.bufferToHex(item.data);\n      });\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n  }, {\n    key: \"getPositionalHexProof\",\n    value: function getPositionalHexProof(leaf, index) {\n      var _this7 = this;\n      return this.getProof(leaf, index).map(function (item) {\n        return [item.position === 'left' ? 0 : 1, _this7.bufferToHex(item.data)];\n      });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n  }, {\n    key: \"getProofIndices\",\n    value:\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    function getProofIndices(treeIndices, depth) {\n      var leafCount = Math.pow(2, depth);\n      var maximalIndices = new Set();\n      var _iterator = _createForOfIteratorHelper(treeIndices),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          var x = leafCount + index;\n          while (x > 1) {\n            maximalIndices.add(x ^ 1);\n            x = x / 2 | 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var a = treeIndices.map(function (index) {\n        return leafCount + index;\n      });\n      var b = Array.from(maximalIndices).sort(function (a, b) {\n        return a - b;\n      }).reverse();\n      maximalIndices = a.concat(b);\n      var redundantIndices = new Set();\n      var proof = [];\n      var _iterator2 = _createForOfIteratorHelper(maximalIndices),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _index = _step2.value;\n          if (!redundantIndices.has(_index)) {\n            proof.push(_index);\n            while (_index > 1) {\n              redundantIndices.add(_index);\n              if (!redundantIndices.has(_index ^ 1)) break;\n              _index = _index / 2 | 0;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return proof.filter(function (index) {\n        return !treeIndices.includes(index - leafCount);\n      });\n    }\n  }, {\n    key: \"getProofIndicesForUnevenTree\",\n    value: function getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n      var depth = Math.ceil(Math.log2(leavesCount));\n      var unevenLayers = [];\n      for (var index = 0; index < depth; index++) {\n        var unevenLayer = leavesCount % 2 !== 0;\n        if (unevenLayer) {\n          unevenLayers.push({\n            index: index,\n            leavesCount: leavesCount\n          });\n        }\n        leavesCount = Math.ceil(leavesCount / 2);\n      }\n      var proofIndices = [];\n      var layerNodes = sortedLeafIndices;\n      var _loop = function _loop(layerIndex) {\n        var siblingIndices = layerNodes.map(function (index) {\n          if (index % 2 === 0) {\n            return index + 1;\n          }\n          return index - 1;\n        });\n        var proofNodeIndices = siblingIndices.filter(function (index) {\n          return !layerNodes.includes(index);\n        });\n        var unevenLayer = unevenLayers.find(function (_ref) {\n          var index = _ref.index;\n          return index === layerIndex;\n        });\n        if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n          proofNodeIndices = proofNodeIndices.slice(0, -1);\n        }\n        proofIndices.push(proofNodeIndices);\n        layerNodes = _toConsumableArray(new Set(layerNodes.map(function (index) {\n          if (index % 2 === 0) {\n            return index / 2;\n          }\n          if (index % 2 === 0) {\n            return (index + 1) / 2;\n          }\n          return (index - 1) / 2;\n        })));\n      };\n      for (var layerIndex = 0; layerIndex < depth; layerIndex++) {\n        _loop(layerIndex);\n      }\n      return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n  }, {\n    key: \"getMultiProof\",\n    value: function getMultiProof(tree, indices) {\n      var _this8 = this;\n      if (!indices) {\n        indices = tree;\n        tree = this.getLayersFlat();\n      }\n      var isUneven = this.isUnevenTree();\n      if (isUneven) {\n        if (indices.every(Number.isInteger)) {\n          return this.getMultiProofForUnevenTree(indices);\n        }\n      }\n      if (!indices.every(Number.isInteger)) {\n        var els = indices;\n        if (this.sortPairs) {\n          els = els.sort(buffer_1.Buffer.compare);\n        }\n        var ids = els.map(function (el) {\n          return _this8._bufferIndexOf(_this8.leaves, el);\n        }).sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        });\n        if (!ids.every(function (idx) {\n          return idx !== -1;\n        })) {\n          throw new Error('Element does not exist in Merkle tree');\n        }\n        var hashes = [];\n        var proof = [];\n        var nextIds = [];\n        for (var i = 0; i < this.layers.length; i++) {\n          var layer = this.layers[i];\n          for (var j = 0; j < ids.length; j++) {\n            var idx = ids[j];\n            var pairElement = this._getPairNode(layer, idx);\n            hashes.push(layer[idx]);\n            if (pairElement) {\n              proof.push(pairElement);\n            }\n            nextIds.push(idx / 2 | 0);\n          }\n          ids = nextIds.filter(function (value, i, self) {\n            return self.indexOf(value) === i;\n          });\n          nextIds = [];\n        }\n        return proof.filter(function (value) {\n          return !hashes.includes(value);\n        });\n      }\n      return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map(function (index) {\n        return tree[index];\n      });\n    }\n  }, {\n    key: \"getMultiProofForUnevenTree\",\n    value: function getMultiProofForUnevenTree(tree, indices) {\n      if (!indices) {\n        indices = tree;\n        tree = this.getLayers();\n      }\n      var proofHashes = [];\n      var currentLayerIndices = indices;\n      var _iterator3 = _createForOfIteratorHelper(tree),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var treeLayer = _step3.value;\n          var siblings = [];\n          var _iterator4 = _createForOfIteratorHelper(currentLayerIndices),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var index = _step4.value;\n              if (index % 2 === 0) {\n                var _idx = index + 1;\n                if (!currentLayerIndices.includes(_idx)) {\n                  if (treeLayer[_idx]) {\n                    siblings.push(treeLayer[_idx]);\n                    continue;\n                  }\n                }\n              }\n              var idx = index - 1;\n              if (!currentLayerIndices.includes(idx)) {\n                if (treeLayer[idx]) {\n                  siblings.push(treeLayer[idx]);\n                  continue;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          proofHashes = proofHashes.concat(siblings);\n          var uniqueIndices = new Set();\n          var _iterator5 = _createForOfIteratorHelper(currentLayerIndices),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _index2 = _step5.value;\n              if (_index2 % 2 === 0) {\n                uniqueIndices.add(_index2 / 2);\n                continue;\n              }\n              if (_index2 % 2 === 0) {\n                uniqueIndices.add((_index2 + 1) / 2);\n                continue;\n              }\n              uniqueIndices.add((_index2 - 1) / 2);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          currentLayerIndices = Array.from(uniqueIndices);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n  }, {\n    key: \"getHexMultiProof\",\n    value: function getHexMultiProof(tree, indices) {\n      var _this9 = this;\n      return this.getMultiProof(tree, indices).map(function (x) {\n        return _this9.bufferToHex(x);\n      });\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n  }, {\n    key: \"getProofFlags\",\n    value: function getProofFlags(leaves, proofs) {\n      var _this10 = this;\n      if (!Array.isArray(leaves) || leaves.length <= 0) {\n        throw new Error('Invalid Inputs!');\n      }\n      var ids;\n      if (leaves.every(Number.isInteger)) {\n        ids = leaves.sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        }); // Indices where passed\n      } else {\n        ids = leaves.map(function (el) {\n          return _this10._bufferIndexOf(_this10.leaves, el);\n        }).sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        });\n      }\n      if (!ids.every(function (idx) {\n        return idx !== -1;\n      })) {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n      var _proofs = proofs.map(function (item) {\n        return _this10.bufferify(item);\n      });\n      var tested = [];\n      var flags = [];\n      var _loop2 = function _loop2(index) {\n        var layer = _this10.layers[index];\n        ids = ids.reduce(function (ids, idx) {\n          var skipped = tested.includes(layer[idx]);\n          if (!skipped) {\n            var pairElement = _this10._getPairNode(layer, idx);\n            var proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n            pairElement && flags.push(!proofUsed);\n            tested.push(layer[idx]);\n            tested.push(pairElement);\n          }\n          ids.push(idx / 2 | 0);\n          return ids;\n        }, []);\n      };\n      for (var index = 0; index < this.layers.length; index++) {\n        _loop2(index);\n      }\n      return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n  }, {\n    key: \"verify\",\n    value: function verify(proof, targetNode, root) {\n      var hash = this.bufferify(targetNode);\n      root = this.bufferify(root);\n      if (!Array.isArray(proof) || !targetNode || !root) {\n        return false;\n      }\n      for (var i = 0; i < proof.length; i++) {\n        var node = proof[i];\n        var data = null;\n        var isLeftNode = null;\n        // case for when proof is hex values only\n        if (typeof node === 'string') {\n          data = this.bufferify(node);\n          isLeftNode = true;\n        } else if (Array.isArray(node)) {\n          isLeftNode = node[0] === 0;\n          data = this.bufferify(node[1]);\n        } else if (buffer_1.Buffer.isBuffer(node)) {\n          data = node;\n          isLeftNode = true;\n        } else if (node instanceof Object) {\n          data = this.bufferify(node.data);\n          isLeftNode = node.position === 'left';\n        } else {\n          throw new Error('Expected node to be of type string or object');\n        }\n        var buffers = [];\n        if (this.isBitcoinTree) {\n          buffers.push(buffer_reverse_1.default(hash));\n          buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n          hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        } else {\n          if (this.sortPairs) {\n            if (buffer_1.Buffer.compare(hash, data) === -1) {\n              buffers.push(hash, data);\n              hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n            } else {\n              buffers.push(data, hash);\n              hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n            }\n          } else {\n            buffers.push(hash);\n            buffers[isLeftNode ? 'unshift' : 'push'](data);\n            hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n          }\n        }\n      }\n      return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n  }, {\n    key: \"verifyMultiProof\",\n    value: function verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n      var _this11 = this;\n      var isUneven = this.isUnevenTree();\n      if (isUneven) {\n        // TODO: combine these functions and simplify\n        return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n      }\n      var depth = Math.ceil(Math.log2(leavesCount));\n      root = this.bufferify(root);\n      proofLeaves = proofLeaves.map(function (leaf) {\n        return _this11.bufferify(leaf);\n      });\n      proof = proof.map(function (leaf) {\n        return _this11.bufferify(leaf);\n      });\n      var tree = {};\n      var _iterator6 = _createForOfIteratorHelper(this._zip(proofIndices, proofLeaves)),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n            _index3 = _step6$value[0],\n            leaf = _step6$value[1];\n          tree[Math.pow(2, depth) + _index3] = leaf;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      var _iterator7 = _createForOfIteratorHelper(this._zip(this.getProofIndices(proofIndices, depth), proof)),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n            _index4 = _step7$value[0],\n            proofitem = _step7$value[1];\n          tree[_index4] = proofitem;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var indexqueue = Object.keys(tree).map(function (value) {\n        return +value;\n      }).sort(function (a, b) {\n        return a - b;\n      });\n      indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n      var i = 0;\n      while (i < indexqueue.length) {\n        var index = indexqueue[i];\n        if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n          var pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n          if (this.sortPairs) {\n            pair = pair.sort(buffer_1.Buffer.compare);\n          }\n          var hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];\n          tree[index / 2 | 0] = hash;\n          indexqueue.push(index / 2 | 0);\n        }\n        i += 1;\n      }\n      return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n    }\n  }, {\n    key: \"verifyMultiProofWithFlags\",\n    value: function verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n      root = this.bufferify(root);\n      leaves = leaves.map(this.bufferify);\n      proofs = proofs.map(this.bufferify);\n      var leavesLen = leaves.length;\n      var totalHashes = proofFlag.length;\n      var hashes = [];\n      var leafPos = 0;\n      var hashPos = 0;\n      var proofPos = 0;\n      for (var i = 0; i < totalHashes; i++) {\n        var bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n        var bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n        var buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n        hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));\n      }\n      return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n  }, {\n    key: \"verifyMultiProofForUnevenTree\",\n    value: function verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n      var _this12 = this;\n      root = this.bufferify(root);\n      leaves = leaves.map(function (leaf) {\n        return _this12.bufferify(leaf);\n      });\n      proof = proof.map(function (leaf) {\n        return _this12.bufferify(leaf);\n      });\n      var computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n      return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n  }, {\n    key: \"getDepth\",\n    value: function getDepth() {\n      return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n  }, {\n    key: \"getLayersAsObject\",\n    value: function getLayersAsObject() {\n      var _this13 = this;\n      var layers = this.getLayers().map(function (layer) {\n        return layer.map(function (value) {\n          return _this13.bufferToHex(value, false);\n        });\n      });\n      var objs = [];\n      for (var i = 0; i < layers.length; i++) {\n        var arr = [];\n        for (var j = 0; j < layers[i].length; j++) {\n          var obj = _defineProperty({}, layers[i][j], null);\n          if (objs.length) {\n            obj[layers[i][j]] = {};\n            var a = objs.shift();\n            var akey = Object.keys(a)[0];\n            obj[layers[i][j]][akey] = a[akey];\n            if (objs.length) {\n              var b = objs.shift();\n              var bkey = Object.keys(b)[0];\n              obj[layers[i][j]][bkey] = b[bkey];\n            }\n          }\n          arr.push(obj);\n        }\n        objs.push.apply(objs, arr);\n      }\n      return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n  }, {\n    key: \"resetTree\",\n    value:\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    function resetTree() {\n      this.leaves = [];\n      this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n  }, {\n    key: \"_getPairNode\",\n    value: function _getPairNode(layer, idx) {\n      var pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n      if (pairIdx < layer.length) {\n        return layer[pairIdx];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n  }, {\n    key: \"_toTreeString\",\n    value: function _toTreeString() {\n      var obj = this.getLayersAsObject();\n      return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._toTreeString();\n    }\n  }, {\n    key: \"isUnevenTree\",\n    value: function isUnevenTree(treeLayers) {\n      var depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n      return !this.isPowOf2(depth);\n    }\n  }, {\n    key: \"isPowOf2\",\n    value: function isPowOf2(v) {\n      return v && !(v & v - 1);\n    }\n  }, {\n    key: \"calculateRootForUnevenTree\",\n    value: function calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n      var leafTuples = this._zip(leafIndices, leafHashes).sort(function (_ref2, _ref3) {\n        var _ref4 = _slicedToArray(_ref2, 1),\n          indexA = _ref4[0];\n        var _ref5 = _slicedToArray(_ref3, 1),\n          indexB = _ref5[0];\n        return indexA - indexB;\n      });\n      var leafTupleIndices = leafTuples.map(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 1),\n          index = _ref7[0];\n        return index;\n      });\n      var proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n      var nextSliceStart = 0;\n      var proofTuplesByLayers = [];\n      for (var i = 0; i < proofIndices.length; i++) {\n        var indices = proofIndices[i];\n        var sliceStart = nextSliceStart;\n        nextSliceStart += indices.length;\n        proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n      }\n      var tree = [leafTuples];\n      for (var layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n        var currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(function (_ref8, _ref9) {\n          var _ref10 = _slicedToArray(_ref8, 1),\n            indexA = _ref10[0];\n          var _ref11 = _slicedToArray(_ref9, 1),\n            indexB = _ref11[0];\n          return indexA - indexB;\n        }).map(function (_ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n            hash = _ref13[1];\n          return hash;\n        });\n        var s = tree[layerIndex].map(function (_ref14) {\n          var _ref15 = _slicedToArray(_ref14, 1),\n            layerIndex = _ref15[0];\n          return layerIndex;\n        });\n        var parentIndices = _toConsumableArray(new Set(s.map(function (index) {\n          if (index % 2 === 0) {\n            return index / 2;\n          }\n          if (index % 2 === 0) {\n            return (index + 1) / 2;\n          }\n          return (index - 1) / 2;\n        })));\n        var parentLayer = [];\n        for (var _i2 = 0; _i2 < parentIndices.length; _i2++) {\n          var parentNodeTreeIndex = parentIndices[_i2];\n          var bufA = currentLayer[_i2 * 2];\n          var bufB = currentLayer[_i2 * 2 + 1];\n          var hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;\n          parentLayer.push([parentNodeTreeIndex, hash]);\n        }\n        tree.push(parentLayer);\n      }\n      return tree[tree.length - 1][0][1];\n    }\n  }], [{\n    key: \"marshalLeaves\",\n    value: function marshalLeaves(leaves) {\n      return JSON.stringify(leaves.map(function (leaf) {\n        return MerkleTree.bufferToHex(leaf);\n      }), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n  }, {\n    key: \"unmarshalLeaves\",\n    value: function unmarshalLeaves(jsonStr) {\n      var parsed = null;\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n      if (!parsed) {\n        return [];\n      }\n      if (!Array.isArray(parsed)) {\n        throw new Error('Expected JSON string to be array');\n      }\n      return parsed.map(MerkleTree.bufferify);\n    }\n  }, {\n    key: \"marshalProof\",\n    value: function marshalProof(proof) {\n      var json = proof.map(function (item) {\n        if (typeof item === 'string') {\n          return item;\n        }\n        if (buffer_1.Buffer.isBuffer(item)) {\n          return MerkleTree.bufferToHex(item);\n        }\n        return {\n          position: item.position,\n          data: MerkleTree.bufferToHex(item.data)\n        };\n      });\n      return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n  }, {\n    key: \"unmarshalProof\",\n    value: function unmarshalProof(jsonStr) {\n      var parsed = null;\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n      if (!parsed) {\n        return [];\n      }\n      if (!Array.isArray(parsed)) {\n        throw new Error('Expected JSON string to be array');\n      }\n      return parsed.map(function (item) {\n        if (typeof item === 'string') {\n          return MerkleTree.bufferify(item);\n        } else if (item instanceof Object) {\n          return {\n            position: item.position,\n            data: MerkleTree.bufferify(item.data)\n          };\n        } else {\n          throw new Error('Expected item to be of type string or object');\n        }\n      });\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(proof, targetNode, root) {\n      var hashFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sha256_1.default;\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var tree = new MerkleTree([], hashFn, options);\n      return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n  }, {\n    key: \"getMultiProof\",\n    value: function getMultiProof(tree, indices) {\n      var t = new MerkleTree([]);\n      return t.getMultiProof(tree, indices);\n    }\n  }]);\n  return MerkleTree;\n}(Base_1.default);\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleTree","buffer_1","require","buffer_reverse_1","sha256_1","treeify_1","Base_1","leaves","hashFn","default","options","duplicateOdd","hashLeaves","isBitcoinTree","layers","sortLeaves","sortPairs","sort","fillDefaultHash","Buffer","isBuffer","idx","Error","bufferifyFn","processLeaves","map","bufferify","compare","i","Math","pow","ceil","log2","length","push","_createHashes","nodes","layerIndex","data","hash","concat","left","right","combined","leaf","shouldHash","values","Array","isArray","filter","_bufferIndexOf","index","from","target","getLeaves","equals","bufferToHex","reduce","acc","item","layer","unshift","getLayersFlat","getLayers","getRoot","proof","Number","isInteger","isRightNode","pairIndex","position","getProof","treeIndices","depth","leafCount","maximalIndices","Set","x","add","a","b","reverse","redundantIndices","has","includes","sortedLeafIndices","leavesCount","unevenLayers","unevenLayer","proofIndices","layerNodes","siblingIndices","proofNodeIndices","find","slice","tree","indices","isUneven","isUnevenTree","every","getMultiProofForUnevenTree","els","ids","el","hashes","nextIds","j","pairElement","_getPairNode","self","indexOf","getProofIndices","_log2","proofHashes","currentLayerIndices","treeLayer","siblings","uniqueIndices","getMultiProof","proofs","_proofs","tested","flags","skipped","proofUsed","targetNode","root","node","isLeftNode","buffers","proofLeaves","verifyMultiProofForUnevenTree","_zip","proofitem","indexqueue","keys","hasOwnProperty","call","pair","proofFlag","leavesLen","totalHashes","leafPos","hashPos","proofPos","bufA","bufB","computedRoot","calculateRootForUnevenTree","objs","arr","obj","shift","akey","bkey","pairIdx","getLayersAsObject","asTree","_toTreeString","treeLayers","getDepth","isPowOf2","v","leafIndices","leafHashes","totalLeavesCount","leafTuples","indexA","indexB","leafTupleIndices","getProofIndicesForUnevenTree","nextSliceStart","proofTuplesByLayers","sliceStart","currentLayer","s","parentIndices","parentLayer","parentNodeTreeIndex","JSON","stringify","jsonStr","parsed","parse","json","verify","t","window"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/merkletreejs/dist/MerkleTree.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nconst buffer_1 = require(\"buffer\");\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                if (i >= this.leaves.length) {\n                    this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n                }\n            }\n        }\n        this.layers = [this.leaves];\n        this._createHashes(this.leaves);\n    }\n    _createHashes(nodes) {\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        let data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            data = buffer_1.Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n                            hash = this.hashFn(data);\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let data = null;\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer_1.Buffer.compare);\n                }\n                data = buffer_1.Buffer.concat(combined);\n                let hash = this.hashFn(data);\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n    addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n    addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer_1.Buffer.compare);\n                }\n            }\n            return this.leaves.filter(leaf => this._bufferIndexOf(values, leaf) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n    getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n    getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for (let i = 0; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n    getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(leaf => this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(layer)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer_1.Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n    getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        if (this.layers.length === 0) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => {\n            return [\n                item.position === 'left' ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(item => {\n            if (typeof item === 'string') {\n                return item;\n            }\n            if (buffer_1.Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(item => {\n            if (typeof item === 'string') {\n                return MerkleTree.bufferify(item);\n            }\n            else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for (let index = 0; index < depth; index++) {\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({ index, leavesCount });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n            const siblingIndices = layerNodes.map((index) => {\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [...new Set(layerNodes.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n        }\n        return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                els = els.sort(buffer_1.Buffer.compare);\n            }\n            let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx) => idx !== -1)) {\n                throw new Error('Element does not exist in Merkle tree');\n            }\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                const layer = this.layers[i];\n                for (let j = 0; j < ids.length; j++) {\n                    const idx = ids[j];\n                    const pairElement = this._getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push((idx / 2) | 0);\n                }\n                ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                nextIds = [];\n            }\n            return proof.filter((value) => !hashes.includes(value));\n        }\n        return this.getProofIndices(indices, this._log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        let currentLayerIndices = indices;\n        for (const treeLayer of tree) {\n            const siblings = [];\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(item => this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this._getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (buffer_1.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (buffer_1.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                }\n            }\n        }\n        return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n    verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer_1.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];\n                tree[(index / 2) | 0] = hash;\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for (let i = 0; i < totalHashes; i++) {\n            const bufA = proofFlag[i] ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++]) : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n            hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));\n        }\n        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    _getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    _toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this._toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & (v - 1));\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);\n        const leafTupleIndices = leafTuples.map(([index]) => index);\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for (let i = 0; i < proofIndices.length; i++) {\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [leafTuples];\n        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB)\n                .map(([, hash]) => hash);\n            const s = tree[layerIndex].map(([layerIndex]) => layerIndex);\n            const parentIndices = [...new Set(s.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n            const parentLayer = [];\n            for (let i = 0; i < parentIndices.length; i++) {\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;\n                parentLayer.push([parentNodeTreeIndex, hash]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}