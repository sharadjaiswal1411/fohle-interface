{"ast":null,"code":"import { isAddress } from '@ethersproject/address';\nconst MAX_SEARCH_RESULTS = 6;\nconst NFT_API_URL = process.env.REACT_APP_TEMP_API_URL;\nexport const fetchSearchCollections = async function (addressOrName) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!NFT_API_URL) return Promise.resolve([]);\n  const url = `${NFT_API_URL}/nft/searchCollections`;\n  const isName = !isAddress(addressOrName.toLowerCase());\n  if (!isName && !recursive) {\n    try {\n      return await fetchSearchCollections(addressOrName.toLowerCase(), true);\n    } catch {\n      return [];\n    }\n  }\n  const filters = isName ? {\n    $or: [{\n      name: {\n        $regex: addressOrName,\n        $options: 'i'\n      }\n    }]\n  } : {\n    address: addressOrName\n  };\n  const payload = {\n    filters,\n    limit: 6,\n    fields: {\n      name: 1,\n      imageUrl: 1,\n      address: 1,\n      floorPrice: 1\n    },\n    offset: 0\n  };\n  const r = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  });\n  if (isName) {\n    const data = await r.json();\n    const formattedData = (data === null || data === void 0 ? void 0 : data.data) ? data.data.map(collection => {\n      return {\n        ...collection,\n        stats: {\n          ...collection.stats,\n          floor_price: collection.floorPrice\n        }\n      };\n    }) : [];\n    return formattedData.slice(0, MAX_SEARCH_RESULTS);\n  }\n  const data = await r.json();\n  return data.data ? [{\n    ...data.data[0],\n    stats: {\n      ...data.data[0].stats,\n      floor_price: data.data[0].floorPrice\n    }\n  }] : [];\n};","map":{"version":3,"names":["isAddress","MAX_SEARCH_RESULTS","NFT_API_URL","process","env","REACT_APP_TEMP_API_URL","fetchSearchCollections","addressOrName","recursive","Promise","resolve","url","isName","toLowerCase","filters","$or","name","$regex","$options","address","payload","limit","fields","imageUrl","floorPrice","offset","r","fetch","method","headers","body","JSON","stringify","data","json","formattedData","map","collection","stats","floor_price","slice"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/nft/queries/genie/SearchCollectionsFetcher.ts"],"sourcesContent":["import { isAddress } from '@ethersproject/address'\n\nimport { GenieCollection } from '../../types'\n\nconst MAX_SEARCH_RESULTS = 6\n\nconst NFT_API_URL = process.env.REACT_APP_TEMP_API_URL\nexport const fetchSearchCollections = async (addressOrName: string, recursive = false): Promise<GenieCollection[]> => {\n  if (!NFT_API_URL) return Promise.resolve([])\n  const url = `${NFT_API_URL}/nft/searchCollections`\n  const isName = !isAddress(addressOrName.toLowerCase())\n\n  if (!isName && !recursive) {\n    try {\n      return await fetchSearchCollections(addressOrName.toLowerCase(), true)\n    } catch {\n      return []\n    }\n  }\n\n  const filters = isName\n    ? {\n        $or: [{ name: { $regex: addressOrName, $options: 'i' } }],\n      }\n    : { address: addressOrName }\n\n  const payload = {\n    filters,\n    limit: 6,\n    fields: {\n      name: 1,\n      imageUrl: 1,\n      address: 1,\n      floorPrice: 1,\n    },\n    offset: 0,\n  }\n  const r = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(payload),\n  })\n  if (isName) {\n    const data = await r.json()\n    const formattedData = data?.data\n      ? data.data.map((collection: { stats: Record<string, unknown>; floorPrice: string }) => {\n          return {\n            ...collection,\n            stats: {\n              ...collection.stats,\n              floor_price: collection.floorPrice,\n            },\n          }\n        })\n      : []\n    return formattedData.slice(0, MAX_SEARCH_RESULTS)\n  }\n  const data = await r.json()\n\n  return data.data ? [{ ...data.data[0], stats: { ...data.data[0].stats, floor_price: data.data[0].floorPrice } }] : []\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,wBAAwB;AAIlD,MAAMC,kBAAkB,GAAG,CAAC;AAE5B,MAAMC,WAAW,GAAGC,OAAO,CAACC,GAAG,CAACC,sBAAsB;AACtD,OAAO,MAAMC,sBAAsB,GAAG,gBAAOC,aAAqB,EAAoD;EAAA,IAAlDC,SAAS,uEAAG,KAAK;EACnF,IAAI,CAACN,WAAW,EAAE,OAAOO,OAAO,CAACC,OAAO,CAAC,EAAE,CAAC;EAC5C,MAAMC,GAAG,GAAI,GAAET,WAAY,wBAAuB;EAClD,MAAMU,MAAM,GAAG,CAACZ,SAAS,CAACO,aAAa,CAACM,WAAW,EAAE,CAAC;EAEtD,IAAI,CAACD,MAAM,IAAI,CAACJ,SAAS,EAAE;IACzB,IAAI;MACF,OAAO,MAAMF,sBAAsB,CAACC,aAAa,CAACM,WAAW,EAAE,EAAE,IAAI,CAAC;IACxE,CAAC,CAAC,MAAM;MACN,OAAO,EAAE;IACX;EACF;EAEA,MAAMC,OAAO,GAAGF,MAAM,GAClB;IACEG,GAAG,EAAE,CAAC;MAAEC,IAAI,EAAE;QAAEC,MAAM,EAAEV,aAAa;QAAEW,QAAQ,EAAE;MAAI;IAAE,CAAC;EAC1D,CAAC,GACD;IAAEC,OAAO,EAAEZ;EAAc,CAAC;EAE9B,MAAMa,OAAO,GAAG;IACdN,OAAO;IACPO,KAAK,EAAE,CAAC;IACRC,MAAM,EAAE;MACNN,IAAI,EAAE,CAAC;MACPO,QAAQ,EAAE,CAAC;MACXJ,OAAO,EAAE,CAAC;MACVK,UAAU,EAAE;IACd,CAAC;IACDC,MAAM,EAAE;EACV,CAAC;EACD,MAAMC,CAAC,GAAG,MAAMC,KAAK,CAAChB,GAAG,EAAE;IACzBiB,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACP,cAAc,EAAE;IAClB,CAAC;IACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACZ,OAAO;EAC9B,CAAC,CAAC;EACF,IAAIR,MAAM,EAAE;IACV,MAAMqB,IAAI,GAAG,MAAMP,CAAC,CAACQ,IAAI,EAAE;IAC3B,MAAMC,aAAa,GAAG,CAAAF,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEA,IAAI,IAC5BA,IAAI,CAACA,IAAI,CAACG,GAAG,CAAEC,UAAkE,IAAK;MACpF,OAAO;QACL,GAAGA,UAAU;QACbC,KAAK,EAAE;UACL,GAAGD,UAAU,CAACC,KAAK;UACnBC,WAAW,EAAEF,UAAU,CAACb;QAC1B;MACF,CAAC;IACH,CAAC,CAAC,GACF,EAAE;IACN,OAAOW,aAAa,CAACK,KAAK,CAAC,CAAC,EAAEvC,kBAAkB,CAAC;EACnD;EACA,MAAMgC,IAAI,GAAG,MAAMP,CAAC,CAACQ,IAAI,EAAE;EAE3B,OAAOD,IAAI,CAACA,IAAI,GAAG,CAAC;IAAE,GAAGA,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC;IAAEK,KAAK,EAAE;MAAE,GAAGL,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAACK,KAAK;MAAEC,WAAW,EAAEN,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAACT;IAAW;EAAE,CAAC,CAAC,GAAG,EAAE;AACvH,CAAC"},"metadata":{},"sourceType":"module"}