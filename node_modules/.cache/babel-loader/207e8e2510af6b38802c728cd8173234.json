{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar react = require('react');\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[INTERRUPT_PROMISE];\n};\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = function interrupt() {\n      delete interruptablePromise[INTERRUPT_PROMISE];\n      resolve();\n    };\n    promise.then(resolve, reject);\n  });\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\n  };\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        atom = _step$value[0],\n        value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n      atomStateMap.set(atom, atomState);\n    }\n  }\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(atom, atomState, prevDependencies) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n    var isNewAtom = !atomStateMap.has(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, [prevDependencies, isNewAtom]);\n    }\n  };\n  var prepareNextAtomState = function prepareNextAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n    return [nextAtomState, (atomState == null ? void 0 : atomState.d) || new Map()];\n  };\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n    var _prepareNextAtomState = prepareNextAtomState(atom, dependencies),\n      atomState = _prepareNextAtomState[0],\n      prevDependencies = _prepareNextAtomState[1];\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n    atomState.c == null ? void 0 : atomState.c();\n    if ('e' in atomState || atomState.p || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++atomState.r;\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n    atomState.v = value;\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    setAtomState(atom, atomState, dependencies && prevDependencies);\n  };\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n    var _prepareNextAtomState2 = prepareNextAtomState(atom, dependencies),\n      atomState = _prepareNextAtomState2[0],\n      prevDependencies = _prepareNextAtomState2[1];\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    setAtomState(atom, atomState, prevDependencies);\n  };\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n    var _prepareNextAtomState3 = prepareNextAtomState(atom, dependencies),\n      atomState = _prepareNextAtomState3[0],\n      prevDependencies = _prepareNextAtomState3[1];\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    var interruptablePromise = createInterruptablePromise(promise);\n    atomState.p = interruptablePromise;\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    setAtomState(atom, atomState, prevDependencies);\n  };\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var _prepareNextAtomState4 = prepareNextAtomState(atom),\n      atomState = _prepareNextAtomState4[0];\n    atomState.i = atomState.r;\n    setAtomState(atom, atomState);\n  };\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(a);\n            } else {\n              var aState = getAtomState(a);\n              if (aState && !('e' in aState) && !aState.p && aState.r === aState.i) {\n                readAtomState(a, true);\n              }\n            }\n          }\n        });\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n            r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !('e' in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n          if (aState.p) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error('no atom init');\n      });\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\n              e.finally(function () {\n                return readAtomState(atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(atom, e, dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else {\n        error = errorOrPromise;\n      }\n    }\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n    return getAtomState(atom);\n  };\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n  var writeAtomState = function writeAtomState(atom, update) {\n    var writeGetter = function writeGetter(a, unstable_promise) {\n      if (unstable_promise === void 0) {\n        unstable_promise = false;\n      }\n      var aState = readAtomState(a);\n      if ('e' in aState) {\n        throw aState.e;\n      }\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          if (unstable_promise) {\n            console.info('promise option in getter is an experimental feature.', a);\n          } else {\n            console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n          }\n        }\n        if (unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, unstable_promise);\n          });\n        }\n        throw aState.p;\n      }\n      if ('v' in aState) {\n        return aState.v;\n      }\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n      throw new Error('no value found');\n    };\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('no atom init');\n        }\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e);\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n        invalidateDependents(a);\n        flushPending();\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n      return promiseOrVoid;\n    };\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    return promiseOrVoid;\n  };\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set(),\n      u: undefined\n    };\n    mountedMap.set(atom, mounted);\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n      mounted.u = atom.onMount(setAtom);\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.d.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.d.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        var dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n        _ref2$ = _ref2[1],\n        prevDependencies = _ref2$[0],\n        isNewAtom = _ref2$[1];\n      if (prevDependencies) {\n        var _atomState2 = getAtomState(atom);\n        if (_atomState2) {\n          mountDependencies(atom, _atomState2, prevDependencies);\n        }\n      }\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        stateListeners.forEach(function (l) {\n          return l(atom, isNewAtom);\n        });\n      }\n    });\n  };\n  var commitAtom = function commitAtom(_atom) {\n    flushPending();\n  };\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n        _atom2 = _step2$value[0],\n        _value = _step2$value[1];\n      if (hasInitialValue(_atom2)) {\n        setAtomValue(_atom2, _value);\n        invalidateDependents(_atom2);\n      }\n    }\n    flushPending();\n  };\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n    scope = _ref.scope,\n    children = _ref.children;\n  var scopeContainerRef = react.useRef();\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n    atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n    if (!mounted) {\n      return [];\n    }\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n  var _useState = react.useState([]),\n    atoms = _useState[0],\n    setAtoms = _useState[1];\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function (get) {\n      return get(config);\n    };\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n  var ScopeContext = getScopeContext(scope);\n  var store = react.useContext(ScopeContext).s;\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n    if (atomState.p) {\n      throw atomState.p;\n    }\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n    throw new Error('no atom value');\n  }, [store, atom]);\n  var _useReducer = react.useReducer(getAtomValue, undefined, getAtomValue),\n    value = _useReducer[0],\n    forceUpdate = _useReducer[1];\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;","map":{"version":3,"names":["Object","defineProperty","exports","value","react","require","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","TypeError","hasInitialValue","atom","IS_EQUAL_PROMISE","INTERRUPT_PROMISE","isInterruptablePromise","promise","createInterruptablePromise","interrupt","interruptablePromise","Promise","resolve","reject","then","p","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","_ref4","atomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","process","env","NODE_ENV","Set","_iterator","_step","_step$value","atomState","v","r","d","freeze","console","warn","set","getAtomState","get","setAtomState","prevDependencies","isNewAtom","has","prepareNextAtomState","dependencies","nextAtomState","map","a","_getAtomState$r","_getAtomState","setAtomValue","_atomState$p","_prepareNextAtomState","c","is","e","setAtomReadError","error","_atomState$p2","_prepareNextAtomState2","setAtomReadPromise","_atomState$p3","_prepareNextAtomState3","setAtomInvalidated","_prepareNextAtomState4","readAtomState","force","_atomState","forEach","_","aState","entries","every","_ref","promiseOrValue","read","add","init","Error","flushPending","catch","finally","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","size","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","writeGetter","unstable_promise","info","setter","promiseOrVoid","resolvedValue","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","u","undefined","onMount","setAtom","_mountedMap$get","onUnmount","delete","mountDependencies","keys","dependents","pending","clear","_ref2","_ref2$","_atomState2","listener","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_atom2","_value","_ref3","createScopeContainer","store","s","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","scopeContainerRef","useRef","current","useDebugState","ScopeContainerContext","createElement","atomToPrintable","debugLabel","stateToPrintable","atoms","fromEntries","flatMap","_store$DEV_GET_MOUNTE","_store$DEV_GET_ATOM_S","scopeContainer","_useState","useState","setAtoms","useEffect","_store$DEV_SUBSCRIBE_","_store$DEV_GET_MOUNTE2","unsubscribe","useDebugValue","keyCount","config","isWritable","useAtom","ScopeContext","useContext","getAtomValue","useCallback","_useReducer","useReducer","forceUpdate","SECRET_INTERNAL_getScopeContext"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/jotai/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\n\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[INTERRUPT_PROMISE];\n};\n\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = function interrupt() {\n      delete interruptablePromise[INTERRUPT_PROMISE];\n      resolve();\n    };\n\n    promise.then(resolve, reject);\n  });\n\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\n  };\n\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      atomStateMap.set(atom, atomState);\n    }\n  }\n\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(atom, atomState, prevDependencies) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    var isNewAtom = !atomStateMap.has(atom);\n    atomStateMap.set(atom, atomState);\n\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, [prevDependencies, isNewAtom]);\n    }\n  };\n\n  var prepareNextAtomState = function prepareNextAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n\n    return [nextAtomState, (atomState == null ? void 0 : atomState.d) || new Map()];\n  };\n\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n\n    var _prepareNextAtomState = prepareNextAtomState(atom, dependencies),\n        atomState = _prepareNextAtomState[0],\n        prevDependencies = _prepareNextAtomState[1];\n\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n\n    if ('e' in atomState || atomState.p || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++atomState.r;\n\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n\n    atomState.v = value;\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    setAtomState(atom, atomState, dependencies && prevDependencies);\n  };\n\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n\n    var _prepareNextAtomState2 = prepareNextAtomState(atom, dependencies),\n        atomState = _prepareNextAtomState2[0],\n        prevDependencies = _prepareNextAtomState2[1];\n\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    setAtomState(atom, atomState, prevDependencies);\n  };\n\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n\n    var _prepareNextAtomState3 = prepareNextAtomState(atom, dependencies),\n        atomState = _prepareNextAtomState3[0],\n        prevDependencies = _prepareNextAtomState3[1];\n\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    var interruptablePromise = createInterruptablePromise(promise);\n    atomState.p = interruptablePromise;\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    setAtomState(atom, atomState, prevDependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var _prepareNextAtomState4 = prepareNextAtomState(atom),\n        atomState = _prepareNextAtomState4[0];\n\n    atomState.i = atomState.r;\n    setAtomState(atom, atomState);\n  };\n\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(a);\n            } else {\n              var aState = getAtomState(a);\n\n              if (aState && !('e' in aState) && !aState.p && aState.r === aState.i) {\n                readAtomState(a, true);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !('e' in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n\n          if (aState.p) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\n              e.finally(function () {\n                return readAtomState(atom, true);\n              });\n            }\n\n            return e;\n          }\n\n          setAtomReadError(atom, e, dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else {\n        error = errorOrPromise;\n      }\n    }\n\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n\n    return getAtomState(atom);\n  };\n\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n\n  var writeAtomState = function writeAtomState(atom, update) {\n    var writeGetter = function writeGetter(a, unstable_promise) {\n      if (unstable_promise === void 0) {\n        unstable_promise = false;\n      }\n\n      var aState = readAtomState(a);\n\n      if ('e' in aState) {\n        throw aState.e;\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          if (unstable_promise) {\n            console.info('promise option in getter is an experimental feature.', a);\n          } else {\n            console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n          }\n        }\n\n        if (unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, unstable_promise);\n          });\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('no atom init');\n        }\n\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e);\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n\n        invalidateDependents(a);\n        flushPending();\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set(),\n      u: undefined\n    };\n    mountedMap.set(atom, mounted);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      mounted.u = atom.onMount(setAtom);\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.d.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        var dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          _ref2$ = _ref2[1],\n          prevDependencies = _ref2$[0],\n          isNewAtom = _ref2$[1];\n\n      if (prevDependencies) {\n        var _atomState2 = getAtomState(atom);\n\n        if (_atomState2) {\n          mountDependencies(atom, _atomState2, prevDependencies);\n        }\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        stateListeners.forEach(function (l) {\n          return l(atom, isNewAtom);\n        });\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom) {\n    flushPending();\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom2 = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom2)) {\n        setAtomValue(_atom2, _value);\n        invalidateDependents(_atom2);\n      }\n    }\n\n    flushPending();\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      children = _ref.children;\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n\n  var _useState = react.useState([]),\n      atoms = _useState[0],\n      setAtoms = _useState[1];\n\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n  var store = react.useContext(ScopeContext).s;\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n\n    if (atomState.p) {\n      throw atomState.p;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(getAtomValue, undefined, getAtomValue),\n      value = _useReducer[0],\n      forceUpdate = _useReducer[1];\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}