{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { ChainId } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { getHighestLiquidityV3NativePool, getHighestLiquidityV3USDPool, getL2ToL1GasUsed } from '../../../../util/gas-factory-helpers';\nimport { log } from '../../../../util/log';\nimport { buildSwapMethodParameters, buildTrade } from '../../../../util/methodParameters';\nimport { IOnChainGasModelFactory } from '../gas-model';\nimport { BASE_SWAP_COST, COST_PER_HOP, COST_PER_INIT_TICK, COST_PER_UNINIT_TICK } from './gas-costs';\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport var V3HeuristicGasModelFactory = /*#__PURE__*/function (_IOnChainGasModelFact) {\n  _inherits(V3HeuristicGasModelFactory, _IOnChainGasModelFact);\n  var _super = _createSuper(V3HeuristicGasModelFactory);\n  function V3HeuristicGasModelFactory() {\n    _classCallCheck(this, V3HeuristicGasModelFactory);\n    return _super.call(this);\n  }\n  _createClass(V3HeuristicGasModelFactory, [{\n    key: \"buildGasModel\",\n    value: function () {\n      var _buildGasModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n        var _this = this;\n        var chainId, gasPriceWei, poolProvider, token, l2GasDataProvider, l2GasData, usdPool, calculateL1GasFees, nativeCurrency, _estimateGasCost, nativePool, usdToken, estimateGasCost;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                chainId = _ref.chainId, gasPriceWei = _ref.gasPriceWei, poolProvider = _ref.v3poolProvider, token = _ref.token, l2GasDataProvider = _ref.l2GasDataProvider;\n                if (!l2GasDataProvider) {\n                  _context2.next = 7;\n                  break;\n                }\n                _context2.next = 4;\n                return l2GasDataProvider.getGasData();\n              case 4:\n                _context2.t0 = _context2.sent;\n                _context2.next = 8;\n                break;\n              case 7:\n                _context2.t0 = undefined;\n              case 8:\n                l2GasData = _context2.t0;\n                _context2.next = 11;\n                return getHighestLiquidityV3USDPool(chainId, poolProvider);\n              case 11:\n                usdPool = _context2.sent;\n                calculateL1GasFees = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(route) {\n                    var swapOptions, l1Used, l1FeeInWei, _this$calculateOptimi, _this$calculateOptimi2, _this$calculateArbitr, _this$calculateArbitr2, nativeCurrency, costNativeCurrency, nativeTokenPrice, gasCostL1USD, gasCostL1QuoteToken, _nativePool, _nativeTokenPrice;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            swapOptions = {\n                              recipient: '0x0000000000000000000000000000000000000001',\n                              deadline: 100,\n                              slippageTolerance: new Percent(5, 10000)\n                            };\n                            l1Used = BigNumber.from(0);\n                            l1FeeInWei = BigNumber.from(0);\n                            if (chainId == ChainId.OPTIMISM || chainId == ChainId.OPTIMISTIC_KOVAN) {\n                              _this$calculateOptimi = _this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);\n                              _this$calculateOptimi2 = _slicedToArray(_this$calculateOptimi, 2);\n                              l1Used = _this$calculateOptimi2[0];\n                              l1FeeInWei = _this$calculateOptimi2[1];\n                            } else if (chainId == ChainId.ARBITRUM_ONE || chainId == ChainId.ARBITRUM_RINKEBY) {\n                              _this$calculateArbitr = _this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);\n                              _this$calculateArbitr2 = _slicedToArray(_this$calculateArbitr, 2);\n                              l1Used = _this$calculateArbitr2[0];\n                              l1FeeInWei = _this$calculateArbitr2[1];\n                            }\n                            // wrap fee to native currency\n                            nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n                            costNativeCurrency = CurrencyAmount.fromRawAmount(nativeCurrency, l1FeeInWei.toString()); // convert fee into usd\n                            nativeTokenPrice = usdPool.token0.address == nativeCurrency.address ? usdPool.token0Price : usdPool.token1Price;\n                            gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);\n                            gasCostL1QuoteToken = costNativeCurrency; // if the inputted token is not in the native currency, quote a native/quote token pool to get the gas cost in terms of the quote token\n                            if (token.equals(nativeCurrency)) {\n                              _context.next = 14;\n                              break;\n                            }\n                            _context.next = 12;\n                            return getHighestLiquidityV3NativePool(token, poolProvider);\n                          case 12:\n                            _nativePool = _context.sent;\n                            if (!_nativePool) {\n                              log.info('Could not find a pool to convert the cost into the quote token');\n                              gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(token, 0);\n                            } else {\n                              _nativeTokenPrice = _nativePool.token0.address == nativeCurrency.address ? _nativePool.token0Price : _nativePool.token1Price;\n                              gasCostL1QuoteToken = _nativeTokenPrice.quote(costNativeCurrency);\n                            }\n                          case 14:\n                            return _context.abrupt(\"return\", {\n                              gasUsedL1: l1Used,\n                              gasCostL1USD: gasCostL1USD,\n                              gasCostL1QuoteToken: gasCostL1QuoteToken\n                            });\n                          case 15:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n                  return function calculateL1GasFees(_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }(); // If our quote token is WETH, we don't need to convert our gas use to be in terms\n                // of the quote token in order to produce a gas adjusted amount.\n                // We do return a gas use in USD however, so we still convert to usd.\n                nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n                if (!token.equals(nativeCurrency)) {\n                  _context2.next = 17;\n                  break;\n                }\n                _estimateGasCost = function _estimateGasCost(routeWithValidQuote) {\n                  var _this$estimateGas = _this.estimateGas(routeWithValidQuote, gasPriceWei, chainId),\n                    totalGasCostNativeCurrency = _this$estimateGas.totalGasCostNativeCurrency,\n                    baseGasUse = _this$estimateGas.baseGasUse;\n                  var token0 = usdPool.token0.address == nativeCurrency.address;\n                  var nativeTokenPrice = token0 ? usdPool.token0Price : usdPool.token1Price;\n                  var gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n                  return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: totalGasCostNativeCurrency,\n                    gasCostInUSD: gasCostInTermsOfUSD\n                  };\n                };\n                return _context2.abrupt(\"return\", {\n                  estimateGasCost: _estimateGasCost,\n                  calculateL1GasFees: calculateL1GasFees\n                });\n              case 17:\n                _context2.next = 19;\n                return getHighestLiquidityV3NativePool(token, poolProvider);\n              case 19:\n                nativePool = _context2.sent;\n                usdToken = usdPool.token0.address == nativeCurrency.address ? usdPool.token1 : usdPool.token0;\n                estimateGasCost = function estimateGasCost(routeWithValidQuote) {\n                  var _this$estimateGas2 = _this.estimateGas(routeWithValidQuote, gasPriceWei, chainId),\n                    totalGasCostNativeCurrency = _this$estimateGas2.totalGasCostNativeCurrency,\n                    baseGasUse = _this$estimateGas2.baseGasUse;\n                  if (!nativePool) {\n                    log.info(\"Unable to find \".concat(nativeCurrency.symbol, \" pool with the quote token, \").concat(token.symbol, \" to produce gas adjusted costs. Route will not account for gas.\"));\n                    return {\n                      gasEstimate: baseGasUse,\n                      gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                      gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0)\n                    };\n                  }\n                  var token0 = nativePool.token0.address == nativeCurrency.address;\n                  // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n                  var nativeTokenPrice = token0 ? nativePool.token0Price : nativePool.token1Price;\n                  var gasCostInTermsOfQuoteToken;\n                  try {\n                    // native token is base currency\n                    gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n                  } catch (err) {\n                    log.info({\n                      nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n                      nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n                      gasCostInEth: totalGasCostNativeCurrency.currency\n                    }, 'Debug eth price token issue');\n                    throw err;\n                  }\n                  // true if token0 is the native currency\n                  var token0USDPool = usdPool.token0.address == nativeCurrency.address;\n                  // gets the mid price of the pool in terms of the native token\n                  var nativeTokenPriceUSDPool = token0USDPool ? usdPool.token0Price : usdPool.token1Price;\n                  var gasCostInTermsOfUSD;\n                  try {\n                    gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);\n                  } catch (err) {\n                    log.info({\n                      usdT1: usdPool.token0.symbol,\n                      usdT2: usdPool.token1.symbol,\n                      gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol\n                    }, 'Failed to compute USD gas price');\n                    throw err;\n                  }\n                  return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: gasCostInTermsOfQuoteToken,\n                    gasCostInUSD: gasCostInTermsOfUSD\n                  };\n                };\n                return _context2.abrupt(\"return\", {\n                  estimateGasCost: estimateGasCost.bind(this),\n                  calculateL1GasFees: calculateL1GasFees\n                });\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function buildGasModel(_x) {\n        return _buildGasModel.apply(this, arguments);\n      }\n      return buildGasModel;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n      var totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList)));\n      var totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n      var hopsGasUse = COST_PER_HOP(chainId).mul(totalHops);\n      var tickGasUse = COST_PER_INIT_TICK(chainId).mul(totalInitializedTicksCrossed);\n      var uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n      // base estimate gas used based on chainId estimates for hops and ticks gas useage\n      var baseGasUse = BASE_SWAP_COST(chainId).add(hopsGasUse).add(tickGasUse).add(uninitializedTickGasUse);\n      var baseGasCostWei = gasPriceWei.mul(baseGasUse);\n      var wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n      var totalGasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());\n      return {\n        totalGasCostNativeCurrency: totalGasCostNativeCurrency,\n        totalInitializedTicksCrossed: totalInitializedTicksCrossed,\n        baseGasUse: baseGasUse\n      };\n    }\n    /**\n     * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,\n     * we replicate the gas cost accounting here.\n     */\n  }, {\n    key: \"calculateOptimismToL1SecurityFee\",\n    value: function calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {\n      var l1BaseFee = gasData.l1BaseFee,\n        scalar = gasData.scalar,\n        decimals = gasData.decimals,\n        overhead = gasData.overhead;\n      var route = routes[0];\n      var inputToken = route.tradeType == TradeType.EXACT_INPUT ? route.amount.currency : route.quote.currency;\n      var outputToken = route.tradeType == TradeType.EXACT_INPUT ? route.quote.currency : route.amount.currency;\n      // build trade for swap calldata\n      var trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n      var data = buildSwapMethodParameters(trade, swapConfig).calldata;\n      var l1GasUsed = getL2ToL1GasUsed(data, overhead);\n      // l1BaseFee is L1 Gas Price on etherscan\n      var l1Fee = l1GasUsed.mul(l1BaseFee);\n      var unscaled = l1Fee.mul(scalar);\n      // scaled = unscaled / (10 ** decimals)\n      var scaledConversion = BigNumber.from(10).pow(decimals);\n      var scaled = unscaled.div(scaledConversion);\n      return [l1GasUsed, scaled];\n    }\n  }, {\n    key: \"calculateArbitrumToL1SecurityFee\",\n    value: function calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {\n      var perL2TxFee = gasData.perL2TxFee,\n        perL1CalldataFee = gasData.perL1CalldataFee;\n      var route = routes[0];\n      var inputToken = route.tradeType == TradeType.EXACT_INPUT ? route.amount.currency : route.quote.currency;\n      var outputToken = route.tradeType == TradeType.EXACT_INPUT ? route.quote.currency : route.amount.currency;\n      // build trade for swap calldata\n      var trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n      var data = buildSwapMethodParameters(trade, swapConfig).calldata;\n      // calculates gas amounts based on bytes of calldata, use 0 as overhead.\n      var l1GasUsed = getL2ToL1GasUsed(data, BigNumber.from(0));\n      // multiply by the fee per calldata and add the flat l2 fee\n      var l1Fee = l1GasUsed.mul(perL1CalldataFee);\n      l1Fee = l1Fee.add(perL2TxFee);\n      return [l1GasUsed, l1Fee];\n    }\n  }]);\n  return V3HeuristicGasModelFactory;\n}(IOnChainGasModelFactory);","map":{"version":3,"sources":["../../../../../../src/routers/alpha-router/gas-models/v3/v3-heuristic-gas-model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { ChainId } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { getHighestLiquidityV3NativePool, getHighestLiquidityV3USDPool, getL2ToL1GasUsed, } from '../../../../util/gas-factory-helpers';\nimport { log } from '../../../../util/log';\nimport { buildSwapMethodParameters, buildTrade, } from '../../../../util/methodParameters';\nimport { IOnChainGasModelFactory, } from '../gas-model';\nimport { BASE_SWAP_COST, COST_PER_HOP, COST_PER_INIT_TICK, COST_PER_UNINIT_TICK, } from './gas-costs';\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport class V3HeuristicGasModelFactory extends IOnChainGasModelFactory {\n    constructor() {\n        super();\n    }\n    async buildGasModel({ chainId, gasPriceWei, v3poolProvider: poolProvider, token, l2GasDataProvider, }) {\n        const l2GasData = l2GasDataProvider\n            ? await l2GasDataProvider.getGasData()\n            : undefined;\n        const usdPool = await getHighestLiquidityV3USDPool(chainId, poolProvider);\n        const calculateL1GasFees = async (route) => {\n            const swapOptions = {\n                recipient: '0x0000000000000000000000000000000000000001',\n                deadline: 100,\n                slippageTolerance: new Percent(5, 10000),\n            };\n            let l1Used = BigNumber.from(0);\n            let l1FeeInWei = BigNumber.from(0);\n            if (chainId == ChainId.OPTIMISM || chainId == ChainId.OPTIMISTIC_KOVAN) {\n                [l1Used, l1FeeInWei] = this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);\n            }\n            else if (chainId == ChainId.ARBITRUM_ONE ||\n                chainId == ChainId.ARBITRUM_RINKEBY) {\n                [l1Used, l1FeeInWei] = this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);\n            }\n            // wrap fee to native currency\n            const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n            const costNativeCurrency = CurrencyAmount.fromRawAmount(nativeCurrency, l1FeeInWei.toString());\n            // convert fee into usd\n            const nativeTokenPrice = usdPool.token0.address == nativeCurrency.address\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            const gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);\n            let gasCostL1QuoteToken = costNativeCurrency;\n            // if the inputted token is not in the native currency, quote a native/quote token pool to get the gas cost in terms of the quote token\n            if (!token.equals(nativeCurrency)) {\n                const nativePool = await getHighestLiquidityV3NativePool(token, poolProvider);\n                if (!nativePool) {\n                    log.info('Could not find a pool to convert the cost into the quote token');\n                    gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(token, 0);\n                }\n                else {\n                    const nativeTokenPrice = nativePool.token0.address == nativeCurrency.address\n                        ? nativePool.token0Price\n                        : nativePool.token1Price;\n                    gasCostL1QuoteToken = nativeTokenPrice.quote(costNativeCurrency);\n                }\n            }\n            // gasUsedL1 is the gas units used calculated from the bytes of the calldata\n            // gasCostL1USD and gasCostL1QuoteToken is the cost of gas in each of those tokens\n            return {\n                gasUsedL1: l1Used,\n                gasCostL1USD,\n                gasCostL1QuoteToken,\n            };\n        };\n        // If our quote token is WETH, we don't need to convert our gas use to be in terms\n        // of the quote token in order to produce a gas adjusted amount.\n        // We do return a gas use in USD however, so we still convert to usd.\n        const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        if (token.equals(nativeCurrency)) {\n            const estimateGasCost = (routeWithValidQuote) => {\n                const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                const token0 = usdPool.token0.address == nativeCurrency.address;\n                const nativeTokenPrice = token0\n                    ? usdPool.token0Price\n                    : usdPool.token1Price;\n                const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n                return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: totalGasCostNativeCurrency,\n                    gasCostInUSD: gasCostInTermsOfUSD,\n                };\n            };\n            return {\n                estimateGasCost,\n                calculateL1GasFees,\n            };\n        }\n        // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n        // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n        const nativePool = await getHighestLiquidityV3NativePool(token, poolProvider);\n        const usdToken = usdPool.token0.address == nativeCurrency.address\n            ? usdPool.token1\n            : usdPool.token0;\n        const estimateGasCost = (routeWithValidQuote) => {\n            const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n            if (!nativePool) {\n                log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n                return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                    gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0),\n                };\n            }\n            const token0 = nativePool.token0.address == nativeCurrency.address;\n            // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n            const nativeTokenPrice = token0\n                ? nativePool.token0Price\n                : nativePool.token1Price;\n            let gasCostInTermsOfQuoteToken;\n            try {\n                // native token is base currency\n                gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n                    nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n                    gasCostInEth: totalGasCostNativeCurrency.currency,\n                }, 'Debug eth price token issue');\n                throw err;\n            }\n            // true if token0 is the native currency\n            const token0USDPool = usdPool.token0.address == nativeCurrency.address;\n            // gets the mid price of the pool in terms of the native token\n            const nativeTokenPriceUSDPool = token0USDPool\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            let gasCostInTermsOfUSD;\n            try {\n                gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    usdT1: usdPool.token0.symbol,\n                    usdT2: usdPool.token1.symbol,\n                    gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol,\n                }, 'Failed to compute USD gas price');\n                throw err;\n            }\n            return {\n                gasEstimate: baseGasUse,\n                gasCostInToken: gasCostInTermsOfQuoteToken,\n                gasCostInUSD: gasCostInTermsOfUSD,\n            };\n        };\n        return {\n            estimateGasCost: estimateGasCost.bind(this),\n            calculateL1GasFees,\n        };\n    }\n    estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n        const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList)));\n        const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n        const hopsGasUse = COST_PER_HOP(chainId).mul(totalHops);\n        const tickGasUse = COST_PER_INIT_TICK(chainId).mul(totalInitializedTicksCrossed);\n        const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n        // base estimate gas used based on chainId estimates for hops and ticks gas useage\n        const baseGasUse = BASE_SWAP_COST(chainId)\n            .add(hopsGasUse)\n            .add(tickGasUse)\n            .add(uninitializedTickGasUse);\n        const baseGasCostWei = gasPriceWei.mul(baseGasUse);\n        const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        const totalGasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());\n        return {\n            totalGasCostNativeCurrency,\n            totalInitializedTicksCrossed,\n            baseGasUse,\n        };\n    }\n    /**\n     * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,\n     * we replicate the gas cost accounting here.\n     */\n    calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {\n        const { l1BaseFee, scalar, decimals, overhead } = gasData;\n        const route = routes[0];\n        const inputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.amount.currency\n            : route.quote.currency;\n        const outputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.quote.currency\n            : route.amount.currency;\n        // build trade for swap calldata\n        const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n        const data = buildSwapMethodParameters(trade, swapConfig).calldata;\n        const l1GasUsed = getL2ToL1GasUsed(data, overhead);\n        // l1BaseFee is L1 Gas Price on etherscan\n        const l1Fee = l1GasUsed.mul(l1BaseFee);\n        const unscaled = l1Fee.mul(scalar);\n        // scaled = unscaled / (10 ** decimals)\n        const scaledConversion = BigNumber.from(10).pow(decimals);\n        const scaled = unscaled.div(scaledConversion);\n        return [l1GasUsed, scaled];\n    }\n    calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {\n        const { perL2TxFee, perL1CalldataFee } = gasData;\n        const route = routes[0];\n        const inputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.amount.currency\n            : route.quote.currency;\n        const outputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.quote.currency\n            : route.amount.currency;\n        // build trade for swap calldata\n        const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);\n        const data = buildSwapMethodParameters(trade, swapConfig).calldata;\n        // calculates gas amounts based on bytes of calldata, use 0 as overhead.\n        const l1GasUsed = getL2ToL1GasUsed(data, BigNumber.from(0));\n        // multiply by the fee per calldata and add the flat l2 fee\n        let l1Fee = l1GasUsed.mul(perL1CalldataFee);\n        l1Fee = l1Fee.add(perL2TxFee);\n        return [l1GasUsed, l1Fee];\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjMtaGV1cmlzdGljLWdhcy1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9nYXMtbW9kZWxzL3YzL3YzLWhldXJpc3RpYy1nYXMtbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFdkQsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBRXZCLE9BQU8sRUFBZSx1QkFBdUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUtuRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFDTCwrQkFBK0IsRUFDL0IsNEJBQTRCLEVBQzVCLGdCQUFnQixHQUNqQixNQUFNLHNDQUFzQyxDQUFDO0FBQzlDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzQyxPQUFPLEVBQ0wseUJBQXlCLEVBQ3pCLFVBQVUsR0FDWCxNQUFNLG1DQUFtQyxDQUFDO0FBRTNDLE9BQU8sRUFHTCx1QkFBdUIsR0FDeEIsTUFBTSxjQUFjLENBQUM7QUFFdEIsT0FBTyxFQUNMLGNBQWMsRUFDZCxZQUFZLEVBQ1osa0JBQWtCLEVBQ2xCLG9CQUFvQixHQUNyQixNQUFNLGFBQWEsQ0FBQztBQUVyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsdUJBQXVCO0lBQ3JFO1FBQ0UsS0FBSyxFQUFFLENBQUM7SUFDVixDQUFDO0lBRU0sS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUN6QixPQUFPLEVBQ1AsV0FBVyxFQUNYLGNBQWMsRUFBRSxZQUFZLEVBQzVC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"]},"metadata":{},"sourceType":"module"}