{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar replace = require('replace-ext');\nvar buffer = require('is-buffer');\nmodule.exports = VFile;\nvar own = {}.hasOwnProperty;\nvar proto = VFile.prototype;\nproto.toString = toString;\n\n/* Order of setting (least specific to most), we need this because\n * otherwise `{stem: 'a', path: '~/b.js'}` would throw, as a path\n * is needed before a stem can be set. */\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];\n\n/* Construct a new file. */\nfunction VFile(options) {\n  var prop;\n  var index;\n  var length;\n  if (!options) {\n    options = {};\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {\n      contents: options\n    };\n  } else if ('message' in options && 'messages' in options) {\n    return options;\n  }\n  if (!(this instanceof VFile)) {\n    return new VFile(options);\n  }\n  this.data = {};\n  this.messages = [];\n  this.history = [];\n  this.cwd = process.cwd();\n\n  /* Set path related properties in the correct order. */\n  index = -1;\n  length = order.length;\n  while (++index < length) {\n    prop = order[index];\n    if (own.call(options, prop)) {\n      this[prop] = options[prop];\n    }\n  }\n\n  /* Set non-path related properties. */\n  for (prop in options) {\n    if (order.indexOf(prop) === -1) {\n      this[prop] = options[prop];\n    }\n  }\n}\n\n/* Access full path (`~/index.min.js`). */\nObject.defineProperty(proto, 'path', {\n  get: function () {\n    return this.history[this.history.length - 1];\n  },\n  set: function (path) {\n    assertNonEmpty(path, 'path');\n    if (path !== this.path) {\n      this.history.push(path);\n    }\n  }\n});\n\n/* Access parent path (`~`). */\nObject.defineProperty(proto, 'dirname', {\n  get: function () {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined;\n  },\n  set: function (dirname) {\n    assertPath(this.path, 'dirname');\n    this.path = path.join(dirname || '', this.basename);\n  }\n});\n\n/* Access basename (`index.min.js`). */\nObject.defineProperty(proto, 'basename', {\n  get: function () {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined;\n  },\n  set: function (basename) {\n    assertNonEmpty(basename, 'basename');\n    assertPart(basename, 'basename');\n    this.path = path.join(this.dirname || '', basename);\n  }\n});\n\n/* Access extname (`.js`). */\nObject.defineProperty(proto, 'extname', {\n  get: function () {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined;\n  },\n  set: function (extname) {\n    var ext = extname || '';\n    assertPart(ext, 'extname');\n    assertPath(this.path, 'extname');\n    if (ext) {\n      if (ext.charAt(0) !== '.') {\n        throw new Error('`extname` must start with `.`');\n      }\n      if (ext.indexOf('.', 1) !== -1) {\n        throw new Error('`extname` cannot contain multiple dots');\n      }\n    }\n    this.path = replace(this.path, ext);\n  }\n});\n\n/* Access stem (`index.min`). */\nObject.defineProperty(proto, 'stem', {\n  get: function () {\n    return typeof this.path === 'string' ? path.basename(this.path, this.extname) : undefined;\n  },\n  set: function (stem) {\n    assertNonEmpty(stem, 'stem');\n    assertPart(stem, 'stem');\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''));\n  }\n});\n\n/* Get the value of the file. */\nfunction toString(encoding) {\n  var value = this.contents || '';\n  return buffer(value) ? value.toString(encoding) : String(value);\n}\n\n/* Assert that `part` is not a path (i.e., does\n * not contain `path.sep`). */\nfunction assertPart(part, name) {\n  if (part.indexOf(path.sep) !== -1) {\n    throw new Error('`' + name + '` cannot be a path: did not expect `' + path.sep + '`');\n  }\n}\n\n/* Assert that `part` is not empty. */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty');\n  }\n}\n\n/* Assert `path` exists. */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too');\n  }\n}","map":{"version":3,"names":["path","require","replace","buffer","module","exports","VFile","own","hasOwnProperty","proto","prototype","toString","order","options","prop","index","length","contents","data","messages","history","cwd","process","call","indexOf","Object","defineProperty","get","set","assertNonEmpty","push","dirname","undefined","assertPath","join","basename","assertPart","extname","ext","charAt","Error","stem","encoding","value","String","part","name","sep"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/vfile/core.js"],"sourcesContent":["'use strict';\n\nvar path = require('path');\nvar replace = require('replace-ext');\nvar buffer = require('is-buffer');\n\nmodule.exports = VFile;\n\nvar own = {}.hasOwnProperty;\nvar proto = VFile.prototype;\n\nproto.toString = toString;\n\n/* Order of setting (least specific to most), we need this because\n * otherwise `{stem: 'a', path: '~/b.js'}` would throw, as a path\n * is needed before a stem can be set. */\nvar order = [\n  'history',\n  'path',\n  'basename',\n  'stem',\n  'extname',\n  'dirname'\n];\n\n/* Construct a new file. */\nfunction VFile(options) {\n  var prop;\n  var index;\n  var length;\n\n  if (!options) {\n    options = {};\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {contents: options};\n  } else if ('message' in options && 'messages' in options) {\n    return options;\n  }\n\n  if (!(this instanceof VFile)) {\n    return new VFile(options);\n  }\n\n  this.data = {};\n  this.messages = [];\n  this.history = [];\n  this.cwd = process.cwd();\n\n  /* Set path related properties in the correct order. */\n  index = -1;\n  length = order.length;\n\n  while (++index < length) {\n    prop = order[index];\n\n    if (own.call(options, prop)) {\n      this[prop] = options[prop];\n    }\n  }\n\n  /* Set non-path related properties. */\n  for (prop in options) {\n    if (order.indexOf(prop) === -1) {\n      this[prop] = options[prop];\n    }\n  }\n}\n\n/* Access full path (`~/index.min.js`). */\nObject.defineProperty(proto, 'path', {\n  get: function () {\n    return this.history[this.history.length - 1];\n  },\n  set: function (path) {\n    assertNonEmpty(path, 'path');\n\n    if (path !== this.path) {\n      this.history.push(path);\n    }\n  }\n});\n\n/* Access parent path (`~`). */\nObject.defineProperty(proto, 'dirname', {\n  get: function () {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined;\n  },\n  set: function (dirname) {\n    assertPath(this.path, 'dirname');\n    this.path = path.join(dirname || '', this.basename);\n  }\n});\n\n/* Access basename (`index.min.js`). */\nObject.defineProperty(proto, 'basename', {\n  get: function () {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined;\n  },\n  set: function (basename) {\n    assertNonEmpty(basename, 'basename');\n    assertPart(basename, 'basename');\n    this.path = path.join(this.dirname || '', basename);\n  }\n});\n\n/* Access extname (`.js`). */\nObject.defineProperty(proto, 'extname', {\n  get: function () {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined;\n  },\n  set: function (extname) {\n    var ext = extname || '';\n\n    assertPart(ext, 'extname');\n    assertPath(this.path, 'extname');\n\n    if (ext) {\n      if (ext.charAt(0) !== '.') {\n        throw new Error('`extname` must start with `.`');\n      }\n\n      if (ext.indexOf('.', 1) !== -1) {\n        throw new Error('`extname` cannot contain multiple dots');\n      }\n    }\n\n    this.path = replace(this.path, ext);\n  }\n});\n\n/* Access stem (`index.min`). */\nObject.defineProperty(proto, 'stem', {\n  get: function () {\n    return typeof this.path === 'string' ? path.basename(this.path, this.extname) : undefined;\n  },\n  set: function (stem) {\n    assertNonEmpty(stem, 'stem');\n    assertPart(stem, 'stem');\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''));\n  }\n});\n\n/* Get the value of the file. */\nfunction toString(encoding) {\n  var value = this.contents || '';\n  return buffer(value) ? value.toString(encoding) : String(value);\n}\n\n/* Assert that `part` is not a path (i.e., does\n * not contain `path.sep`). */\nfunction assertPart(part, name) {\n  if (part.indexOf(path.sep) !== -1) {\n    throw new Error('`' + name + '` cannot be a path: did not expect `' + path.sep + '`');\n  }\n}\n\n/* Assert that `part` is not empty. */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty');\n  }\n}\n\n/* Assert `path` exists. */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}