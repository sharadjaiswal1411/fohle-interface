{"ast":null,"code":"import _objectSpread from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { _optionalChain } from './buildPolyfills';\nvar STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser() {\n  for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {\n    parsers[_key] = arguments[_key];\n  }\n  var sortedParsers = parsers.sort(function (a, b) {\n    return a[0] - b[0];\n  }).map(function (p) {\n    return p[1];\n  });\n  return function (stack) {\n    var skipFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var frames = [];\n    var _iterator = _createForOfIteratorHelper(stack.split('\\n').slice(skipFirst)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var line = _step.value;\n        // https://github.com/getsentry/sentry-javascript/issues/5459\n        // Remove webpack (error: *) wrappers\n        var cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n        var _iterator2 = _createForOfIteratorHelper(sortedParsers),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var parser = _step2.value;\n            var frame = parser(cleanedLine);\n            if (frame) {\n              frames.push(frame);\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser.apply(void 0, _toConsumableArray(stackParser));\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].function || '';\n  var lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.slice(0, STACKTRACE_LIMIT).map(function (frame) {\n    return _objectSpread(_objectSpread({}, frame), {}, {\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?'\n    });\n  }).reverse();\n}\nvar defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n// eslint-disable-next-line complexity\nfunction node(getModule) {\n  var FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  var FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return function (line) {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line\n      };\n    }\n    var lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n    var object;\n    var method;\n    var functionName;\n    var typeName;\n    var methodName;\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n      var methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n        // eslint-disable-next-line no-plusplus\n        methodStart--;\n      }\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        var objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? \"\".concat(typeName, \".\").concat(methodName) : methodName;\n    }\n    var filename = _optionalChain([lineMatch, 'access', function (_) {\n      return _[2];\n    }, 'optionalAccess', function (_2) {\n      return _2.startsWith;\n    }, 'call', function (_3) {\n      return _3('file://');\n    }]) ? lineMatch[2].substr(7) : lineMatch[2];\n    var isNative = lineMatch[5] === 'native';\n    var isInternal = isNative || filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1;\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n    return {\n      filename: filename,\n      module: _optionalChain([getModule, 'optionalCall', function (_4) {\n        return _4(filename);\n      }]),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app: in_app\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\nexport { createStackParser, getFunctionName, nodeStackLineParser, stackParserFromStackParserOptions, stripSentryFramesAndReverse };","map":{"version":3,"sources":["../../src/stacktrace.ts"],"names":[],"mappings":"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","sourcesContent":["import { StackFrame, StackLineParser, StackLineParserFn, StackParser } from '@sentry/types';\n\nconst STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirst: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n\n    for (const line of stack.split('\\n').slice(skipFirst)) {\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nexport function stackParserFromStackParserOptions(stackParser: StackParser | StackLineParser[]): StackParser {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].function || '';\n  const lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\ntype GetModuleFn = (filename: string | undefined) => string | undefined;\n\n// eslint-disable-next-line complexity\nfunction node(getModule?: GetModuleFn): StackLineParserFn {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return (line: string) => {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    const lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n\n    let object: string | undefined;\n    let method: string | undefined;\n    let functionName: string | undefined;\n    let typeName: string | undefined;\n    let methodName: string | undefined;\n\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n\n      let methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n        // eslint-disable-next-line no-plusplus\n        methodStart--;\n      }\n\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        const objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? `${typeName}.${methodName}` : methodName;\n    }\n\n    const filename = lineMatch[2]?.startsWith('file://') ? lineMatch[2].substr(7) : lineMatch[2];\n    const isNative = lineMatch[5] === 'native';\n    const isInternal =\n      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n    return {\n      filename,\n      module: getModule?.(filename),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app,\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nexport function nodeStackLineParser(getModule?: GetModuleFn): StackLineParser {\n  return [90, node(getModule)];\n}\n"]},"metadata":{},"sourceType":"module"}