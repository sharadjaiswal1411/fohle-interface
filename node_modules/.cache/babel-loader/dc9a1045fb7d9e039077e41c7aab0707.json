{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _ from 'lodash';\nimport { log } from '../../util/log';\n/**\n * Provider for getting V2 pools, with functionality for caching the results per block.\n *\n * @export\n * @class CachingV2PoolProvider\n */\nexport var CachingV2PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of CachingV3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param poolProvider The provider to use to get the pools when not in the cache.\n   * @param cache Cache instance to hold cached pools.\n   */\n  function CachingV2PoolProvider(chainId, poolProvider,\n  // Cache is block aware. For V2 pools we need to use the current blocks reserves values since\n  // we compute quotes off-chain.\n  // If no block is specified in the call to getPools we just return whatever is in the cache.\n  cache) {\n    _classCallCheck(this, CachingV2PoolProvider);\n    this.chainId = chainId;\n    this.poolProvider = poolProvider;\n    this.cache = cache;\n    this.POOL_KEY = function (chainId, address) {\n      return \"pool-\".concat(chainId, \"-\").concat(address);\n    };\n  }\n  _createClass(CachingV2PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n        var poolAddressSet, poolsToGetTokenPairs, poolsToGetAddresses, poolAddressToPool, blockNumber, _iterator, _step, _step$value, tokenA, tokenB, _this$getPoolAddress2, poolAddress, token0, token1, cachedPool, poolAccessor, _iterator2, _step2, address, pool;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                poolsToGetTokenPairs = [];\n                poolsToGetAddresses = [];\n                poolAddressToPool = {};\n                _context.next = 6;\n                return providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber;\n              case 6:\n                blockNumber = _context.sent;\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 8;\n                _iterator.s();\n              case 10:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 27;\n                  break;\n                }\n                _step$value = _slicedToArray(_step.value, 2), tokenA = _step$value[0], tokenB = _step$value[1];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB), poolAddress = _this$getPoolAddress2.poolAddress, token0 = _this$getPoolAddress2.token0, token1 = _this$getPoolAddress2.token1;\n                if (!poolAddressSet.has(poolAddress)) {\n                  _context.next = 15;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 25);\n              case 15:\n                poolAddressSet.add(poolAddress);\n                _context.next = 18;\n                return this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n              case 18:\n                cachedPool = _context.sent;\n                if (!cachedPool) {\n                  _context.next = 23;\n                  break;\n                }\n                if (!(!blockNumber || blockNumber && cachedPool.block == blockNumber)) {\n                  _context.next = 23;\n                  break;\n                }\n                poolAddressToPool[poolAddress] = cachedPool.pair;\n                return _context.abrupt(\"continue\", 25);\n              case 23:\n                poolsToGetTokenPairs.push([token0, token1]);\n                poolsToGetAddresses.push(poolAddress);\n              case 25:\n                _context.next = 10;\n                break;\n              case 27:\n                _context.next = 32;\n                break;\n              case 29:\n                _context.prev = 29;\n                _context.t0 = _context[\"catch\"](8);\n                _iterator.e(_context.t0);\n              case 32:\n                _context.prev = 32;\n                _iterator.f();\n                return _context.finish(32);\n              case 35:\n                log.info({\n                  poolsFound: _.map(Object.values(poolAddressToPool), function (p) {\n                    return p.token0.symbol + ' ' + p.token1.symbol;\n                  }),\n                  poolsToGetTokenPairs: _.map(poolsToGetTokenPairs, function (t) {\n                    return t[0].symbol + ' ' + t[1].symbol;\n                  })\n                }, \"Found \".concat(Object.keys(poolAddressToPool).length, \" V2 pools already in local cache for block \").concat(blockNumber, \". About to get reserves for \").concat(poolsToGetTokenPairs.length, \" pools.\"));\n                if (!(poolsToGetAddresses.length > 0)) {\n                  _context.next = 60;\n                  break;\n                }\n                _context.next = 39;\n                return this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n              case 39:\n                poolAccessor = _context.sent;\n                _iterator2 = _createForOfIteratorHelper(poolsToGetAddresses);\n                _context.prev = 41;\n                _iterator2.s();\n              case 43:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 52;\n                  break;\n                }\n                address = _step2.value;\n                pool = poolAccessor.getPoolByAddress(address);\n                if (!pool) {\n                  _context.next = 50;\n                  break;\n                }\n                poolAddressToPool[address] = pool;\n                _context.next = 50;\n                return this.cache.set(this.POOL_KEY(this.chainId, address), {\n                  pair: pool,\n                  block: blockNumber\n                });\n              case 50:\n                _context.next = 43;\n                break;\n              case 52:\n                _context.next = 57;\n                break;\n              case 54:\n                _context.prev = 54;\n                _context.t1 = _context[\"catch\"](41);\n                _iterator2.e(_context.t1);\n              case 57:\n                _context.prev = 57;\n                _iterator2.f();\n                return _context.finish(57);\n              case 60:\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB),\n                      poolAddress = _this$getPoolAddress.poolAddress;\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n              case 61:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 29, 32, 35], [41, 54, 57, 60]]);\n      }));\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB) {\n      return this.poolProvider.getPoolAddress(tokenA, tokenB);\n    }\n  }]);\n  return CachingV2PoolProvider;\n}();","map":{"version":3,"sources":["../../../../src/providers/v2/caching-pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from 'lodash';\nimport { log } from '../../util/log';\n/**\n * Provider for getting V2 pools, with functionality for caching the results per block.\n *\n * @export\n * @class CachingV2PoolProvider\n */\nexport class CachingV2PoolProvider {\n    /**\n     * Creates an instance of CachingV3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param poolProvider The provider to use to get the pools when not in the cache.\n     * @param cache Cache instance to hold cached pools.\n     */\n    constructor(chainId, poolProvider, \n    // Cache is block aware. For V2 pools we need to use the current blocks reserves values since\n    // we compute quotes off-chain.\n    // If no block is specified in the call to getPools we just return whatever is in the cache.\n    cache) {\n        this.chainId = chainId;\n        this.poolProvider = poolProvider;\n        this.cache = cache;\n        this.POOL_KEY = (chainId, address) => `pool-${chainId}-${address}`;\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const poolsToGetTokenPairs = [];\n        const poolsToGetAddresses = [];\n        const poolAddressToPool = {};\n        const blockNumber = await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber);\n        for (const [tokenA, tokenB] of tokenPairs) {\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n            if (cachedPool) {\n                // If a block was specified by the caller, ensure that the result in our cache matches the\n                // expected block number. If a block number is not specified, just return whatever is in the\n                // cache.\n                if (!blockNumber || (blockNumber && cachedPool.block == blockNumber)) {\n                    poolAddressToPool[poolAddress] = cachedPool.pair;\n                    continue;\n                }\n            }\n            poolsToGetTokenPairs.push([token0, token1]);\n            poolsToGetAddresses.push(poolAddress);\n        }\n        log.info({\n            poolsFound: _.map(Object.values(poolAddressToPool), (p) => p.token0.symbol + ' ' + p.token1.symbol),\n            poolsToGetTokenPairs: _.map(poolsToGetTokenPairs, (t) => t[0].symbol + ' ' + t[1].symbol),\n        }, `Found ${Object.keys(poolAddressToPool).length} V2 pools already in local cache for block ${blockNumber}. About to get reserves for ${poolsToGetTokenPairs.length} pools.`);\n        if (poolsToGetAddresses.length > 0) {\n            const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n            for (const address of poolsToGetAddresses) {\n                const pool = poolAccessor.getPoolByAddress(address);\n                if (pool) {\n                    poolAddressToPool[address] = pool;\n                    await this.cache.set(this.POOL_KEY(this.chainId, address), {\n                        pair: pool,\n                        block: blockNumber,\n                    });\n                }\n            }\n        }\n        return {\n            getPool: (tokenA, tokenB) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB) {\n        return this.poolProvider.getPoolAddress(tokenA, tokenB);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGluZy1wb29sLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy92Mi9jYWNoaW5nLXBvb2wtcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU1yQzs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxxQkFBcUI7SUFJaEM7Ozs7O09BS0c7SUFDSCxZQUNZLE9BQWdCLEVBQ2hCLFlBQTZCO0lBQ3ZDLDZGQUE2RjtJQUM3RiwrQkFBK0I7SUFDL0IsNEZBQTRGO0lBQ3BGLEtBQTZDO1FBTDNDLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsaUJBQVksR0FBWixZQUFZLENBQWlCO1FBSS9CLFVBQUssR0FBTCxLQUFLLENBQXdDO1FBZi9DLGFBQVEsR0FBRyxDQUFDLE9BQWdCLEVBQUUsT0FBZSxFQUFFLEVBQUUsQ0FDdkQsUUFBUSxPQUFPLElBQUksT0FBTyxFQUFFLENBQUM7SUFlNUIsQ0FBQztJQUVHLEtBQUssQ0FBQyxRQUFRLENBQ25CLFVBQTRCLEVBQzVCLGNBQStCO1FBRS9CLE1BQU0sY0FBYyxHQUFnQixJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3RELE1BQU0sb0JBQW9CLEdBQTBCLEVBQUUsQ0FBQztRQUN2RCxNQUFNLG1CQUFtQixHQUFhLEVBQUUsQ0FBQztRQUN6QyxNQUFNLGlCQUFpQixHQUFvQyxFQUFFLENBQUM7UUFFOUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFBLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRSxXQUFXLENBQUEsQ0FBQztRQUV0RCxLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQUksVUFBVSxFQUFFO1lBQ3pDLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQ3pELE1BQU0sRUFDTixNQUFNLENBQ1AsQ0FBQztZQUVGLElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDbkMsU0FBUzthQUNWO1lBRUQsY0FBYyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUVoQyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUNyQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQ3pDLENBQUM7WUFFRixJQUFJLFVBQVUsRUFBRTtnQkFDZCwwRkFBMEY7Z0JBQzFGLDRGQUE0RjtnQkFDNUYsU0FBUztnQkFDVCxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxJQUFJLFVBQVUsQ0FBQyxLQUFLLElBQUksV0FBVyxDQUFDLEVBQUU7b0JBQ3BFLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUM7b0JBQ2pELFNBQVM7aUJBQ1Y7YUFDRjtZQUVELG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzVDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN2QztRQUVELEdBQUcsQ0FBQyxJQUFJLENBQ047WUFDRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDZixNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQ2hDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQy9DO1lBQ0Qsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDekIsb0JBQW9CLEVBQ3BCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUN2QztTQUNGLEVBQ0QsU0FDRSxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsTUFDakMsOENBQThDLFdBQVcsK0JBQ3ZELG9CQUFvQixDQUFDLE1BQ3ZCLFNBQVMsQ0FDVixDQUFDO1FBRUYsSUFBSSxtQkFBbUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2xDLE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQ25ELG9CQUFvQixFQUNwQixjQUFjLENBQ2YsQ0FBQztZQUNGLEtBQUssTUFBTSxPQUFPLElBQUksbUJBQW1CLEVBQUU7Z0JBQ3pDLE1BQU0sSUFBSSxHQUFHLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxJQUFJLEVBQUU7b0JBQ1IsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDO29CQUNsQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRTt3QkFDekQsSUFBSSxFQUFFLElBQUk7d0JBQ1YsS0FBSyxFQUFFLFdBQVc7cUJBQ25CLENBQUMsQ0FBQztpQkFDSjthQUNGO1NBQ0Y7UUFFRCxPQUFPO1lBQ0wsT0FBTyxFQUFFLENBQUMsTUFBYSxFQUFFLE1BQWEsRUFBb0IsRUFBRTtnQkFDMUQsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM1RCxPQUFPLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3hDLENBQUM7WUFDRCxnQkFBZ0IsRUFBRSxDQUFDLE9BQWUsRUFBb0IsRUFBRSxDQUN0RCxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7WUFDNUIsV0FBVyxFQUFFLEdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUM7U0FDNUQsQ0FBQztJQUNKLENBQUM7SUFFTSxjQUFjLENBQ25CLE1BQWEsRUFDYixNQUFhO1FBRWIsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDMUQsQ0FBQztDQUNGIn0="]},"metadata":{},"sourceType":"module"}