{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useUpdatePoolData, useAllPoolData, useAddPoolKeys } from './hooks';\nimport { useEffect, useMemo } from 'react';\nimport { useTopPoolAddresses } from 'data/pools/topPools';\nimport { usePoolDatas } from 'data/pools/poolData';\nimport { POOL_HIDE } from '../../constants';\nimport { useActiveNetworkVersion } from 'state/application/hooks';\nexport default function Updater() {\n  _s();\n  // updaters\n  const [currentNetwork] = useActiveNetworkVersion();\n  const updatePoolData = useUpdatePoolData();\n  const addPoolKeys = useAddPoolKeys();\n\n  // data\n  const allPoolData = useAllPoolData();\n  const {\n    loading,\n    error,\n    addresses\n  } = useTopPoolAddresses();\n\n  // add top pools on first load\n  useEffect(() => {\n    if (addresses && !error && !loading) {\n      addPoolKeys(addresses);\n    }\n  }, [addPoolKeys, addresses, error, loading]);\n\n  // load data for pools we need to hide\n  useEffect(() => {\n    addPoolKeys(POOL_HIDE[currentNetwork.id]);\n  }, [addPoolKeys, currentNetwork.id]);\n\n  // detect for which addresses we havent loaded pool data yet\n  const unfetchedPoolAddresses = useMemo(() => {\n    return Object.keys(allPoolData).reduce((accum, key) => {\n      const poolData = allPoolData[key];\n      if (!poolData.data || !poolData.lastUpdated) {\n        accum.push(key);\n      }\n      return accum;\n    }, []);\n  }, [allPoolData]);\n\n  // update unloaded pool entries with fetched data\n  const {\n    error: poolDataError,\n    loading: poolDataLoading,\n    data: poolDatas\n  } = usePoolDatas(unfetchedPoolAddresses);\n  useEffect(() => {\n    if (poolDatas && !poolDataError && !poolDataLoading) {\n      updatePoolData(Object.values(poolDatas));\n    }\n  }, [poolDataError, poolDataLoading, poolDatas, updatePoolData]);\n  return null;\n}\n_s(Updater, \"SHByBGl+dUwVCmuN0r9m3qPxECM=\", false, function () {\n  return [useActiveNetworkVersion, useUpdatePoolData, useAddPoolKeys, useAllPoolData, useTopPoolAddresses, usePoolDatas];\n});\n_c = Updater;\nvar _c;\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"names":["useUpdatePoolData","useAllPoolData","useAddPoolKeys","useEffect","useMemo","useTopPoolAddresses","usePoolDatas","POOL_HIDE","useActiveNetworkVersion","Updater","currentNetwork","updatePoolData","addPoolKeys","allPoolData","loading","error","addresses","id","unfetchedPoolAddresses","Object","keys","reduce","accum","key","poolData","data","lastUpdated","push","poolDataError","poolDataLoading","poolDatas","values"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/pools/updater.ts"],"sourcesContent":["import { useUpdatePoolData, useAllPoolData, useAddPoolKeys } from './hooks'\nimport { useEffect, useMemo } from 'react'\nimport { useTopPoolAddresses } from 'data/pools/topPools'\nimport { usePoolDatas } from 'data/pools/poolData'\nimport { POOL_HIDE } from '../../constants'\nimport { useActiveNetworkVersion } from 'state/application/hooks'\n\nexport default function Updater(): null {\n  // updaters\n  const [currentNetwork] = useActiveNetworkVersion()\n  const updatePoolData = useUpdatePoolData()\n  const addPoolKeys = useAddPoolKeys()\n\n  // data\n  const allPoolData = useAllPoolData()\n  const { loading, error, addresses } = useTopPoolAddresses()\n\n  // add top pools on first load\n  useEffect(() => {\n    if (addresses && !error && !loading) {\n      addPoolKeys(addresses)\n    }\n  }, [addPoolKeys, addresses, error, loading])\n\n  // load data for pools we need to hide\n  useEffect(() => {\n    addPoolKeys(POOL_HIDE[currentNetwork.id])\n  }, [addPoolKeys, currentNetwork.id])\n\n  // detect for which addresses we havent loaded pool data yet\n  const unfetchedPoolAddresses = useMemo(() => {\n    return Object.keys(allPoolData).reduce((accum: string[], key) => {\n      const poolData = allPoolData[key]\n      if (!poolData.data || !poolData.lastUpdated) {\n        accum.push(key)\n      }\n      return accum\n    }, [])\n  }, [allPoolData])\n\n  // update unloaded pool entries with fetched data\n  const { error: poolDataError, loading: poolDataLoading, data: poolDatas } = usePoolDatas(unfetchedPoolAddresses)\n\n  useEffect(() => {\n    if (poolDatas && !poolDataError && !poolDataLoading) {\n      updatePoolData(Object.values(poolDatas))\n    }\n  }, [poolDataError, poolDataLoading, poolDatas, updatePoolData])\n\n  return null\n}"],"mappings":";AAAA,SAASA,iBAAiB,EAAEC,cAAc,EAAEC,cAAc,QAAQ,SAAS;AAC3E,SAASC,SAAS,EAAEC,OAAO,QAAQ,OAAO;AAC1C,SAASC,mBAAmB,QAAQ,qBAAqB;AACzD,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,uBAAuB,QAAQ,yBAAyB;AAEjE,eAAe,SAASC,OAAO,GAAS;EAAA;EACtC;EACA,MAAM,CAACC,cAAc,CAAC,GAAGF,uBAAuB,EAAE;EAClD,MAAMG,cAAc,GAAGX,iBAAiB,EAAE;EAC1C,MAAMY,WAAW,GAAGV,cAAc,EAAE;;EAEpC;EACA,MAAMW,WAAW,GAAGZ,cAAc,EAAE;EACpC,MAAM;IAAEa,OAAO;IAAEC,KAAK;IAAEC;EAAU,CAAC,GAAGX,mBAAmB,EAAE;;EAE3D;EACAF,SAAS,CAAC,MAAM;IACd,IAAIa,SAAS,IAAI,CAACD,KAAK,IAAI,CAACD,OAAO,EAAE;MACnCF,WAAW,CAACI,SAAS,CAAC;IACxB;EACF,CAAC,EAAE,CAACJ,WAAW,EAAEI,SAAS,EAAED,KAAK,EAAED,OAAO,CAAC,CAAC;;EAE5C;EACAX,SAAS,CAAC,MAAM;IACdS,WAAW,CAACL,SAAS,CAACG,cAAc,CAACO,EAAE,CAAC,CAAC;EAC3C,CAAC,EAAE,CAACL,WAAW,EAAEF,cAAc,CAACO,EAAE,CAAC,CAAC;;EAEpC;EACA,MAAMC,sBAAsB,GAAGd,OAAO,CAAC,MAAM;IAC3C,OAAOe,MAAM,CAACC,IAAI,CAACP,WAAW,CAAC,CAACQ,MAAM,CAAC,CAACC,KAAe,EAAEC,GAAG,KAAK;MAC/D,MAAMC,QAAQ,GAAGX,WAAW,CAACU,GAAG,CAAC;MACjC,IAAI,CAACC,QAAQ,CAACC,IAAI,IAAI,CAACD,QAAQ,CAACE,WAAW,EAAE;QAC3CJ,KAAK,CAACK,IAAI,CAACJ,GAAG,CAAC;MACjB;MACA,OAAOD,KAAK;IACd,CAAC,EAAE,EAAE,CAAC;EACR,CAAC,EAAE,CAACT,WAAW,CAAC,CAAC;;EAEjB;EACA,MAAM;IAAEE,KAAK,EAAEa,aAAa;IAAEd,OAAO,EAAEe,eAAe;IAAEJ,IAAI,EAAEK;EAAU,CAAC,GAAGxB,YAAY,CAACY,sBAAsB,CAAC;EAEhHf,SAAS,CAAC,MAAM;IACd,IAAI2B,SAAS,IAAI,CAACF,aAAa,IAAI,CAACC,eAAe,EAAE;MACnDlB,cAAc,CAACQ,MAAM,CAACY,MAAM,CAACD,SAAS,CAAC,CAAC;IAC1C;EACF,CAAC,EAAE,CAACF,aAAa,EAAEC,eAAe,EAAEC,SAAS,EAAEnB,cAAc,CAAC,CAAC;EAE/D,OAAO,IAAI;AACb;AAAC,GA3CuBF,OAAO;EAAA,QAEJD,uBAAuB,EACzBR,iBAAiB,EACpBE,cAAc,EAGdD,cAAc,EACII,mBAAmB,EA0BmBC,YAAY;AAAA;AAAA,KAlClEG,OAAO;AAAA;AAAA"},"metadata":{},"sourceType":"module"}