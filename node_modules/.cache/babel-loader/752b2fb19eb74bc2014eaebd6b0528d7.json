{"ast":null,"code":"var _s = $RefreshSig$();\nimport { ChainId, WETH } from '@kyberswap/ks-sdk-core';\nimport axios from 'axios';\nimport { getUnixTime, subHours } from 'date-fns';\nimport { useMemo } from 'react';\nimport useSWR from 'swr';\nimport { COINGECKO_API_URL } from 'constants/index';\nimport { useActiveWeb3React } from 'hooks';\nexport let LiveDataTimeframeEnum;\n(function (LiveDataTimeframeEnum) {\n  LiveDataTimeframeEnum[\"HOUR\"] = \"1H\";\n  LiveDataTimeframeEnum[\"FOUR_HOURS\"] = \"4H\";\n  LiveDataTimeframeEnum[\"DAY\"] = \"1D\";\n  LiveDataTimeframeEnum[\"WEEK\"] = \"1W\";\n  LiveDataTimeframeEnum[\"MONTH\"] = \"1M\";\n  LiveDataTimeframeEnum[\"SIX_MONTHS\"] = \"6M\";\n})(LiveDataTimeframeEnum || (LiveDataTimeframeEnum = {}));\nconst getTimeFrameHours = timeFrame => {\n  switch (timeFrame) {\n    case LiveDataTimeframeEnum.HOUR:\n      return 1;\n    case LiveDataTimeframeEnum.FOUR_HOURS:\n      return 4;\n    case LiveDataTimeframeEnum.DAY:\n      return 24;\n    case LiveDataTimeframeEnum.WEEK:\n      return 7 * 24;\n    case LiveDataTimeframeEnum.MONTH:\n      return 30 * 24;\n    case LiveDataTimeframeEnum.SIX_MONTHS:\n      return 180 * 24;\n    default:\n      return 7 * 24;\n  }\n};\nconst generateCoingeckoUrl = (chainId, address, timeFrame) => {\n  const timeTo = getUnixTime(new Date());\n  const timeFrom = timeFrame === 'live' ? timeTo - 1000 : getUnixTime(subHours(new Date(), getTimeFrameHours(timeFrame)));\n  return `${COINGECKO_API_URL}/coins/${NETWORKS_INFO[chainId || ChainId.MAINNET].coingeckoNetworkId}/contract/${address}/market_chart/range?vs_currency=usd&from=${timeFrom}&to=${timeTo}`;\n};\nconst getClosestPrice = (prices, time) => {\n  let closestIndex = 0;\n  prices.forEach((item, index) => {\n    if (Math.abs(item[0] - time) < Math.abs(prices[closestIndex][0] - time)) {\n      closestIndex = index;\n    }\n  });\n  return prices[closestIndex][0] - time > 10000000 ? 0 : prices[closestIndex][1];\n};\nconst liveDataApi = {\n  [ChainId.MAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/ethereum/tokens`,\n  [ChainId.BSCMAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/bsc/tokens`,\n  [ChainId.MATIC]: `${process.env.REACT_APP_AGGREGATOR_API}/polygon/tokens`,\n  [ChainId.AVAXMAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/avalanche/tokens`,\n  [ChainId.FANTOM]: `${process.env.REACT_APP_AGGREGATOR_API}/fantom/tokens`,\n  [ChainId.CRONOS]: `${process.env.REACT_APP_AGGREGATOR_API}/cronos/tokens`,\n  [ChainId.ARBITRUM]: `${process.env.REACT_APP_AGGREGATOR_API}/arbitrum/tokens`\n};\nconst fetchKyberDataSWR = async url => {\n  const res = await axios.get(url, {\n    timeout: 5000\n  });\n  if (res.status === 204) {\n    throw new Error('No content');\n  }\n  return res.data;\n};\nconst fetchKyberDataSWRWithHeader = async url => {\n  const res = await axios.get(url, {\n    timeout: 5000,\n    headers: {\n      'accept-version': 'Latest'\n    }\n  }).catch(error => {\n    throw error;\n  });\n  if (res.status === 204) {\n    throw new Error('No content');\n  }\n  return res.data;\n};\nconst fetchCoingeckoDataSWR = async (tokenAddresses, chainId, timeFrame) => {\n  return await Promise.all([tokenAddresses[0], tokenAddresses[1]].map(address => axios.get(generateCoingeckoUrl(chainId, address, timeFrame), {\n    timeout: 5000\n  }).then(res => {\n    if (res.status === 204) {\n      throw new Error('No content');\n    }\n    return res.data;\n  }).catch(error => {\n    throw error;\n  })));\n};\nexport default function useBasicChartData(tokens, timeFrame) {\n  _s();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const isReverse = useMemo(() => {\n    if (!tokens || !tokens[0] || !tokens[1] || tokens[0].equals(tokens[1])) return false;\n    const [token0] = tokens[0].sortsBefore(tokens[1]) ? [tokens[0], tokens[1]] : [tokens[1], tokens[0]];\n    return token0 !== tokens[0];\n  }, [tokens]);\n  const tokenAddresses = useMemo(() => tokens.filter(Boolean).map(token => {\n    var _ref;\n    return (_ref = (token === null || token === void 0 ? void 0 : token.isNative) ? WETH[chainId || ChainId.MAINNET].address : token === null || token === void 0 ? void 0 : token.address) === null || _ref === void 0 ? void 0 : _ref.toLowerCase();\n  }), [tokens, chainId]);\n  const {\n    data: coingeckoData,\n    error: coingeckoError,\n    isValidating: coingeckoLoading\n  } = useSWR(tokenAddresses[0] && tokenAddresses[1] && [tokenAddresses, chainId, timeFrame], fetchCoingeckoDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  });\n  const {\n    data: kyberData,\n    error: kyberError,\n    isValidating: kyberLoading\n  } = useSWR(coingeckoError && tokenAddresses[0] && tokenAddresses[1] ? `${process.env.REACT_APP_PRICE_CHART_API}/price-chart?chainId=${chainId}&timeWindow=${timeFrame.toLowerCase()}&tokenIn=${tokenAddresses[0]}&tokenOut=${tokenAddresses[1]}` : null, fetchKyberDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  });\n  const isKyberDataNotValid = useMemo(() => {\n    if (kyberError || kyberData === null) return true;\n    if (kyberData && kyberData.length === 0) return true;\n    if (kyberData && kyberData.length > 0 && kyberData.every(item => !item.token0Price || item.token0Price === '0')) return true;\n    return false;\n  }, [kyberError, kyberData]);\n  const chartData = useMemo(() => {\n    var _coingeckoData$, _coingeckoData$$price, _coingeckoData$2, _coingeckoData$2$pric;\n    if (!isKyberDataNotValid && kyberData && kyberData.length > 0) {\n      return kyberData.sort((a, b) => parseInt(a.timestamp) - parseInt(b.timestamp)).map(item => {\n        return {\n          time: parseInt(item.timestamp) * 1000,\n          value: !isReverse ? item.token0Price : item.token1Price || 0\n        };\n      });\n    } else if (coingeckoData && ((_coingeckoData$ = coingeckoData[0]) === null || _coingeckoData$ === void 0 ? void 0 : (_coingeckoData$$price = _coingeckoData$.prices) === null || _coingeckoData$$price === void 0 ? void 0 : _coingeckoData$$price.length) > 0 && ((_coingeckoData$2 = coingeckoData[1]) === null || _coingeckoData$2 === void 0 ? void 0 : (_coingeckoData$2$pric = _coingeckoData$2.prices) === null || _coingeckoData$2$pric === void 0 ? void 0 : _coingeckoData$2$pric.length) > 0) {\n      const [data1, data2] = coingeckoData;\n      return data1.prices.map(item => {\n        const closestPrice = getClosestPrice(data2.prices, item[0]);\n        return {\n          time: item[0],\n          value: closestPrice > 0 ? parseFloat((item[1] / closestPrice).toPrecision(6)) : 0\n        };\n      });\n    } else return [];\n  }, [kyberData, coingeckoData, isKyberDataNotValid, isReverse]);\n  const error = !!kyberError && !!coingeckoError || chartData.length === 0;\n  const {\n    data: liveKyberData\n  } = useSWR(!isKyberDataNotValid && kyberData && chainId ? liveDataApi[chainId] + `?ids=${tokenAddresses[0]},${tokenAddresses[1]}` : null, fetchKyberDataSWRWithHeader, {\n    refreshInterval: 60000,\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  });\n  const {\n    data: liveCoingeckoData\n  } = useSWR(isKyberDataNotValid && coingeckoData ? [tokenAddresses, chainId, 'live'] : null, fetchCoingeckoDataSWR, {\n    refreshInterval: 60000,\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  });\n  const latestData = useMemo(() => {\n    if (isKyberDataNotValid) {\n      if (liveCoingeckoData) {\n        var _data1$prices, _data2$prices;\n        const [data1, data2] = liveCoingeckoData;\n        if (((_data1$prices = data1.prices) === null || _data1$prices === void 0 ? void 0 : _data1$prices.length) > 0 && ((_data2$prices = data2.prices) === null || _data2$prices === void 0 ? void 0 : _data2$prices.length) > 0) {\n          const newValue = parseFloat((data1.prices[data1.prices.length - 1][1] / data2.prices[data2.prices.length - 1][1]).toPrecision(6));\n          return {\n            time: new Date().getTime(),\n            value: newValue\n          };\n        }\n      }\n    } else {\n      if (liveKyberData) {\n        var _liveKyberData$tokenA, _liveKyberData$tokenA2;\n        const value = liveKyberData && tokenAddresses[0] && tokenAddresses[1] ? ((_liveKyberData$tokenA = liveKyberData[tokenAddresses[0]]) === null || _liveKyberData$tokenA === void 0 ? void 0 : _liveKyberData$tokenA.price) / ((_liveKyberData$tokenA2 = liveKyberData[tokenAddresses[1]]) === null || _liveKyberData$tokenA2 === void 0 ? void 0 : _liveKyberData$tokenA2.price) : 0;\n        if (value) return {\n          time: new Date().getTime(),\n          value: value\n        };\n      }\n    }\n    return null;\n  }, [liveKyberData, liveCoingeckoData, isKyberDataNotValid, tokenAddresses]);\n  return {\n    data: useMemo(() => latestData ? [...chartData, latestData] : chartData, [latestData, chartData]),\n    error: error,\n    loading: !tokenAddresses[0] || !tokenAddresses[1] || kyberLoading || coingeckoLoading\n  };\n}\n_s(useBasicChartData, \"RSJGopREn3TTZXtl0RgEowdOQtE=\", false, function () {\n  return [useActiveWeb3React, useSWR, useSWR, useSWR, useSWR];\n});","map":{"version":3,"names":["ChainId","WETH","axios","getUnixTime","subHours","useMemo","useSWR","COINGECKO_API_URL","useActiveWeb3React","LiveDataTimeframeEnum","getTimeFrameHours","timeFrame","HOUR","FOUR_HOURS","DAY","WEEK","MONTH","SIX_MONTHS","generateCoingeckoUrl","chainId","address","timeTo","Date","timeFrom","NETWORKS_INFO","MAINNET","coingeckoNetworkId","getClosestPrice","prices","time","closestIndex","forEach","item","index","Math","abs","liveDataApi","process","env","REACT_APP_AGGREGATOR_API","BSCMAINNET","MATIC","AVAXMAINNET","FANTOM","CRONOS","ARBITRUM","fetchKyberDataSWR","url","res","get","timeout","status","Error","data","fetchKyberDataSWRWithHeader","headers","catch","error","fetchCoingeckoDataSWR","tokenAddresses","Promise","all","map","then","useBasicChartData","tokens","isReverse","equals","token0","sortsBefore","filter","Boolean","token","isNative","toLowerCase","coingeckoData","coingeckoError","isValidating","coingeckoLoading","shouldRetryOnError","revalidateOnFocus","revalidateIfStale","kyberData","kyberError","kyberLoading","REACT_APP_PRICE_CHART_API","isKyberDataNotValid","length","every","token0Price","chartData","sort","a","b","parseInt","timestamp","value","token1Price","data1","data2","closestPrice","parseFloat","toPrecision","liveKyberData","refreshInterval","liveCoingeckoData","latestData","newValue","getTime","price","loading"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useBasicChartData.ts"],"sourcesContent":["import { ChainId, Token, WETH } from '@kyberswap/ks-sdk-core'\nimport axios from 'axios'\nimport { getUnixTime, subHours } from 'date-fns'\nimport { useMemo } from 'react'\nimport useSWR from 'swr'\n\nimport { COINGECKO_API_URL } from 'constants/index'\nimport { useActiveWeb3React } from 'hooks'\n\nexport enum LiveDataTimeframeEnum {\n  HOUR = '1H',\n  FOUR_HOURS = '4H',\n  DAY = '1D',\n  WEEK = '1W',\n  MONTH = '1M',\n  SIX_MONTHS = '6M',\n}\n\nconst getTimeFrameHours = (timeFrame: LiveDataTimeframeEnum) => {\n  switch (timeFrame) {\n    case LiveDataTimeframeEnum.HOUR:\n      return 1\n    case LiveDataTimeframeEnum.FOUR_HOURS:\n      return 4\n    case LiveDataTimeframeEnum.DAY:\n      return 24\n    case LiveDataTimeframeEnum.WEEK:\n      return 7 * 24\n    case LiveDataTimeframeEnum.MONTH:\n      return 30 * 24\n    case LiveDataTimeframeEnum.SIX_MONTHS:\n      return 180 * 24\n    default:\n      return 7 * 24\n  }\n}\nconst generateCoingeckoUrl = (\n  chainId: ChainId,\n  address: string | undefined,\n  timeFrame: LiveDataTimeframeEnum | 'live',\n): string => {\n  const timeTo = getUnixTime(new Date())\n  const timeFrom =\n    timeFrame === 'live' ? timeTo - 1000 : getUnixTime(subHours(new Date(), getTimeFrameHours(timeFrame)))\n\n  return `${COINGECKO_API_URL}/coins/${\n    NETWORKS_INFO[chainId || ChainId.MAINNET].coingeckoNetworkId\n  }/contract/${address}/market_chart/range?vs_currency=usd&from=${timeFrom}&to=${timeTo}`\n}\nconst getClosestPrice = (prices: any[], time: number) => {\n  let closestIndex = 0\n  prices.forEach((item, index) => {\n    if (Math.abs(item[0] - time) < Math.abs(prices[closestIndex][0] - time)) {\n      closestIndex = index\n    }\n  })\n  return prices[closestIndex][0] - time > 10000000 ? 0 : prices[closestIndex][1]\n}\n\nexport interface ChartDataInfo {\n  readonly time: number\n  readonly value: number\n}\n\nconst liveDataApi: { [chainId in ChainId]?: string } = {\n  [ChainId.MAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/ethereum/tokens`,\n  [ChainId.BSCMAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/bsc/tokens`,\n  [ChainId.MATIC]: `${process.env.REACT_APP_AGGREGATOR_API}/polygon/tokens`,\n  [ChainId.AVAXMAINNET]: `${process.env.REACT_APP_AGGREGATOR_API}/avalanche/tokens`,\n  [ChainId.FANTOM]: `${process.env.REACT_APP_AGGREGATOR_API}/fantom/tokens`,\n  [ChainId.CRONOS]: `${process.env.REACT_APP_AGGREGATOR_API}/cronos/tokens`,\n  [ChainId.ARBITRUM]: `${process.env.REACT_APP_AGGREGATOR_API}/arbitrum/tokens`,\n}\n\nconst fetchKyberDataSWR = async (url: string) => {\n  const res = await axios.get(url, { timeout: 5000 })\n  if (res.status === 204) {\n    throw new Error('No content')\n  }\n  return res.data\n}\n\nconst fetchKyberDataSWRWithHeader = async (url: string) => {\n  const res = await axios\n    .get(url, {\n      timeout: 5000,\n      headers: {\n        'accept-version': 'Latest',\n      },\n    })\n    .catch(error => {\n      throw error\n    })\n\n  if (res.status === 204) {\n    throw new Error('No content')\n  }\n  return res.data\n}\n\nconst fetchCoingeckoDataSWR = async (tokenAddresses: any, chainId: any, timeFrame: any): Promise<any> => {\n  return await Promise.all(\n    [tokenAddresses[0], tokenAddresses[1]].map(address =>\n      axios\n        .get(generateCoingeckoUrl(chainId, address, timeFrame), { timeout: 5000 })\n        .then(res => {\n          if (res.status === 204) {\n            throw new Error('No content')\n          }\n          return res.data\n        })\n        .catch(error => {\n          throw error\n        }),\n    ),\n  )\n}\n\nexport default function useBasicChartData(tokens: (Token | null | undefined)[], timeFrame: LiveDataTimeframeEnum) {\n  const { chainId } = useActiveWeb3React()\n\n  const isReverse = useMemo(() => {\n    if (!tokens || !tokens[0] || !tokens[1] || tokens[0].equals(tokens[1])) return false\n    const [token0] = tokens[0].sortsBefore(tokens[1]) ? [tokens[0], tokens[1]] : [tokens[1], tokens[0]]\n    return token0 !== tokens[0]\n  }, [tokens])\n\n  const tokenAddresses = useMemo(\n    () =>\n      tokens\n        .filter(Boolean)\n        .map(token => (token?.isNative ? WETH[chainId || ChainId.MAINNET].address : token?.address)?.toLowerCase()),\n    [tokens, chainId],\n  )\n\n  const {\n    data: coingeckoData,\n    error: coingeckoError,\n    isValidating: coingeckoLoading,\n  } = useSWR(tokenAddresses[0] && tokenAddresses[1] && [tokenAddresses, chainId, timeFrame], fetchCoingeckoDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false,\n  })\n\n  const {\n    data: kyberData,\n    error: kyberError,\n    isValidating: kyberLoading,\n  } = useSWR(\n    coingeckoError && tokenAddresses[0] && tokenAddresses[1]\n      ? `${\n          process.env.REACT_APP_PRICE_CHART_API\n        }/price-chart?chainId=${chainId}&timeWindow=${timeFrame.toLowerCase()}&tokenIn=${tokenAddresses[0]}&tokenOut=${\n          tokenAddresses[1]\n        }`\n      : null,\n    fetchKyberDataSWR,\n    {\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    },\n  )\n\n  const isKyberDataNotValid = useMemo(() => {\n    if (kyberError || kyberData === null) return true\n    if (kyberData && kyberData.length === 0) return true\n    if (\n      kyberData &&\n      kyberData.length > 0 &&\n      kyberData.every((item: any) => !item.token0Price || item.token0Price === '0')\n    )\n      return true\n    return false\n  }, [kyberError, kyberData])\n\n  const chartData = useMemo(() => {\n    if (!isKyberDataNotValid && kyberData && kyberData.length > 0) {\n      return kyberData\n        .sort((a: any, b: any) => parseInt(a.timestamp) - parseInt(b.timestamp))\n        .map((item: any) => {\n          return {\n            time: parseInt(item.timestamp) * 1000,\n            value: !isReverse ? item.token0Price : item.token1Price || 0,\n          }\n        })\n    } else if (coingeckoData && coingeckoData[0]?.prices?.length > 0 && coingeckoData[1]?.prices?.length > 0) {\n      const [data1, data2] = coingeckoData\n      return data1.prices.map((item: number[]) => {\n        const closestPrice = getClosestPrice(data2.prices, item[0])\n        return { time: item[0], value: closestPrice > 0 ? parseFloat((item[1] / closestPrice).toPrecision(6)) : 0 }\n      })\n    } else return []\n  }, [kyberData, coingeckoData, isKyberDataNotValid, isReverse])\n\n  const error = (!!kyberError && !!coingeckoError) || chartData.length === 0\n\n  const { data: liveKyberData } = useSWR(\n    !isKyberDataNotValid && kyberData && chainId\n      ? liveDataApi[chainId] + `?ids=${tokenAddresses[0]},${tokenAddresses[1]}`\n      : null,\n    fetchKyberDataSWRWithHeader,\n    {\n      refreshInterval: 60000,\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    },\n  )\n\n  const { data: liveCoingeckoData } = useSWR(\n    isKyberDataNotValid && coingeckoData ? [tokenAddresses, chainId, 'live'] : null,\n    fetchCoingeckoDataSWR,\n    {\n      refreshInterval: 60000,\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    },\n  )\n\n  const latestData = useMemo(() => {\n    if (isKyberDataNotValid) {\n      if (liveCoingeckoData) {\n        const [data1, data2] = liveCoingeckoData\n        if (data1.prices?.length > 0 && data2.prices?.length > 0) {\n          const newValue = parseFloat(\n            (data1.prices[data1.prices.length - 1][1] / data2.prices[data2.prices.length - 1][1]).toPrecision(6),\n          )\n          return { time: new Date().getTime(), value: newValue }\n        }\n      }\n    } else {\n      if (liveKyberData) {\n        const value =\n          liveKyberData && tokenAddresses[0] && tokenAddresses[1]\n            ? liveKyberData[tokenAddresses[0]]?.price / liveKyberData[tokenAddresses[1]]?.price\n            : 0\n        if (value) return { time: new Date().getTime(), value: value }\n      }\n    }\n    return null\n  }, [liveKyberData, liveCoingeckoData, isKyberDataNotValid, tokenAddresses])\n\n  return {\n    data: useMemo(() => (latestData ? [...chartData, latestData] : chartData), [latestData, chartData]),\n    error: error,\n    loading: !tokenAddresses[0] || !tokenAddresses[1] || kyberLoading || coingeckoLoading,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}