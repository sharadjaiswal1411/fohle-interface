{"ast":null,"code":"import { validateTokenList } from '@uniswap/widgets';\nimport contenthashToUri from 'lib/utils/contenthashToUri';\nimport parseENSAddress from 'lib/utils/parseENSAddress';\nimport uriToHttp from 'lib/utils/uriToHttp';\nexport const DEFAULT_TOKEN_LIST = 'https://gateway.ipfs.io/ipns/tokens.uniswap.org';\nconst listCache = new Map();\n\n/** Fetches and validates a token list. */\nexport default async function fetchTokenList(listUrl, resolveENSContentHash, skipValidation) {\n  const cached = listCache === null || listCache === void 0 ? void 0 : listCache.get(listUrl); // avoid spurious re-fetches\n  if (cached) {\n    return cached;\n  }\n  let urls;\n  const parsedENS = parseENSAddress(listUrl);\n  if (parsedENS) {\n    var _parsedENS$ensPath;\n    let contentHashUri;\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName);\n    } catch (error) {\n      const message = `failed to resolve ENS name: ${parsedENS.ensName}`;\n      console.debug(message, error);\n      throw new Error(message);\n    }\n    let translatedUri;\n    try {\n      translatedUri = contenthashToUri(contentHashUri);\n    } catch (error) {\n      const message = `failed to translate contenthash to URI: ${contentHashUri}`;\n      console.debug(message, error);\n      throw new Error(message);\n    }\n    urls = uriToHttp(`${translatedUri}${(_parsedENS$ensPath = parsedENS.ensPath) !== null && _parsedENS$ensPath !== void 0 ? _parsedENS$ensPath : ''}`);\n  } else {\n    urls = uriToHttp(listUrl);\n  }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const isLast = i === urls.length - 1;\n    let response;\n    try {\n      response = await fetch(url, {\n        credentials: 'omit'\n      });\n    } catch (error) {\n      const message = `failed to fetch list: ${listUrl}`;\n      console.debug(message, error);\n      if (isLast) throw new Error(message);\n      continue;\n    }\n    if (!response.ok) {\n      const message = `failed to fetch list: ${listUrl}`;\n      console.debug(message, response.statusText);\n      if (isLast) throw new Error(message);\n      continue;\n    }\n    const json = await response.json();\n    const list = skipValidation ? json : await validateTokenList(json);\n    listCache === null || listCache === void 0 ? void 0 : listCache.set(listUrl, list);\n    return list;\n  }\n  throw new Error('Unrecognized list URL protocol.');\n}","map":{"version":3,"names":["validateTokenList","contenthashToUri","parseENSAddress","uriToHttp","DEFAULT_TOKEN_LIST","listCache","Map","fetchTokenList","listUrl","resolveENSContentHash","skipValidation","cached","get","urls","parsedENS","contentHashUri","ensName","error","message","console","debug","Error","translatedUri","ensPath","i","length","url","isLast","response","fetch","credentials","ok","statusText","json","list","set"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useTokenList/fetchTokenList.ts"],"sourcesContent":["import type { TokenList } from '@uniswap/token-lists'\nimport { validateTokenList } from '@uniswap/widgets'\nimport contenthashToUri from 'lib/utils/contenthashToUri'\nimport parseENSAddress from 'lib/utils/parseENSAddress'\nimport uriToHttp from 'lib/utils/uriToHttp'\n\nexport const DEFAULT_TOKEN_LIST = 'https://gateway.ipfs.io/ipns/tokens.uniswap.org'\n\nconst listCache = new Map<string, TokenList>()\n\n/** Fetches and validates a token list. */\nexport default async function fetchTokenList(\n  listUrl: string,\n  resolveENSContentHash: (ensName: string) => Promise<string>,\n  skipValidation?: boolean\n): Promise<TokenList> {\n  const cached = listCache?.get(listUrl) // avoid spurious re-fetches\n  if (cached) {\n    return cached\n  }\n\n  let urls: string[]\n  const parsedENS = parseENSAddress(listUrl)\n  if (parsedENS) {\n    let contentHashUri\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\n    } catch (error) {\n      const message = `failed to resolve ENS name: ${parsedENS.ensName}`\n      console.debug(message, error)\n      throw new Error(message)\n    }\n    let translatedUri\n    try {\n      translatedUri = contenthashToUri(contentHashUri)\n    } catch (error) {\n      const message = `failed to translate contenthash to URI: ${contentHashUri}`\n      console.debug(message, error)\n      throw new Error(message)\n    }\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\n  } else {\n    urls = uriToHttp(listUrl)\n  }\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url, { credentials: 'omit' })\n    } catch (error) {\n      const message = `failed to fetch list: ${listUrl}`\n      console.debug(message, error)\n      if (isLast) throw new Error(message)\n      continue\n    }\n\n    if (!response.ok) {\n      const message = `failed to fetch list: ${listUrl}`\n      console.debug(message, response.statusText)\n      if (isLast) throw new Error(message)\n      continue\n    }\n\n    const json = await response.json()\n    const list = skipValidation ? json : await validateTokenList(json)\n    listCache?.set(listUrl, list)\n    return list\n  }\n\n  throw new Error('Unrecognized list URL protocol.')\n}\n"],"mappings":"AACA,SAASA,iBAAiB,QAAQ,kBAAkB;AACpD,OAAOC,gBAAgB,MAAM,4BAA4B;AACzD,OAAOC,eAAe,MAAM,2BAA2B;AACvD,OAAOC,SAAS,MAAM,qBAAqB;AAE3C,OAAO,MAAMC,kBAAkB,GAAG,iDAAiD;AAEnF,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAqB;;AAE9C;AACA,eAAe,eAAeC,cAAc,CAC1CC,OAAe,EACfC,qBAA2D,EAC3DC,cAAwB,EACJ;EACpB,MAAMC,MAAM,GAAGN,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEO,GAAG,CAACJ,OAAO,CAAC,EAAC;EACvC,IAAIG,MAAM,EAAE;IACV,OAAOA,MAAM;EACf;EAEA,IAAIE,IAAc;EAClB,MAAMC,SAAS,GAAGZ,eAAe,CAACM,OAAO,CAAC;EAC1C,IAAIM,SAAS,EAAE;IAAA;IACb,IAAIC,cAAc;IAClB,IAAI;MACFA,cAAc,GAAG,MAAMN,qBAAqB,CAACK,SAAS,CAACE,OAAO,CAAC;IACjE,CAAC,CAAC,OAAOC,KAAK,EAAE;MACd,MAAMC,OAAO,GAAI,+BAA8BJ,SAAS,CAACE,OAAQ,EAAC;MAClEG,OAAO,CAACC,KAAK,CAACF,OAAO,EAAED,KAAK,CAAC;MAC7B,MAAM,IAAII,KAAK,CAACH,OAAO,CAAC;IAC1B;IACA,IAAII,aAAa;IACjB,IAAI;MACFA,aAAa,GAAGrB,gBAAgB,CAACc,cAAc,CAAC;IAClD,CAAC,CAAC,OAAOE,KAAK,EAAE;MACd,MAAMC,OAAO,GAAI,2CAA0CH,cAAe,EAAC;MAC3EI,OAAO,CAACC,KAAK,CAACF,OAAO,EAAED,KAAK,CAAC;MAC7B,MAAM,IAAII,KAAK,CAACH,OAAO,CAAC;IAC1B;IACAL,IAAI,GAAGV,SAAS,CAAE,GAAEmB,aAAc,yBAAER,SAAS,CAACS,OAAO,mEAAI,EAAG,EAAC,CAAC;EAChE,CAAC,MAAM;IACLV,IAAI,GAAGV,SAAS,CAACK,OAAO,CAAC;EAC3B;EAEA,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACY,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,MAAME,GAAG,GAAGb,IAAI,CAACW,CAAC,CAAC;IACnB,MAAMG,MAAM,GAAGH,CAAC,KAAKX,IAAI,CAACY,MAAM,GAAG,CAAC;IACpC,IAAIG,QAAQ;IACZ,IAAI;MACFA,QAAQ,GAAG,MAAMC,KAAK,CAACH,GAAG,EAAE;QAAEI,WAAW,EAAE;MAAO,CAAC,CAAC;IACtD,CAAC,CAAC,OAAOb,KAAK,EAAE;MACd,MAAMC,OAAO,GAAI,yBAAwBV,OAAQ,EAAC;MAClDW,OAAO,CAACC,KAAK,CAACF,OAAO,EAAED,KAAK,CAAC;MAC7B,IAAIU,MAAM,EAAE,MAAM,IAAIN,KAAK,CAACH,OAAO,CAAC;MACpC;IACF;IAEA,IAAI,CAACU,QAAQ,CAACG,EAAE,EAAE;MAChB,MAAMb,OAAO,GAAI,yBAAwBV,OAAQ,EAAC;MAClDW,OAAO,CAACC,KAAK,CAACF,OAAO,EAAEU,QAAQ,CAACI,UAAU,CAAC;MAC3C,IAAIL,MAAM,EAAE,MAAM,IAAIN,KAAK,CAACH,OAAO,CAAC;MACpC;IACF;IAEA,MAAMe,IAAI,GAAG,MAAML,QAAQ,CAACK,IAAI,EAAE;IAClC,MAAMC,IAAI,GAAGxB,cAAc,GAAGuB,IAAI,GAAG,MAAMjC,iBAAiB,CAACiC,IAAI,CAAC;IAClE5B,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE8B,GAAG,CAAC3B,OAAO,EAAE0B,IAAI,CAAC;IAC7B,OAAOA,IAAI;EACb;EAEA,MAAM,IAAIb,KAAK,CAAC,iCAAiC,CAAC;AACpD"},"metadata":{},"sourceType":"module"}