{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { Trans } from \"@lingui/react\";\nimport { sendAnalyticsEvent } from '@uniswap/analytics';\nimport { EventName } from '@uniswap/analytics-events';\nimport { useWeb3React } from '@web3-react/core';\nimport useNativeCurrency from 'lib/hooks/useNativeCurrency';\nimport { formatToDecimal, getTokenAddress } from 'lib/utils/analytics';\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount';\nimport { useMemo, useState } from 'react';\nimport { WRAPPED_NATIVE_CURRENCY } from '../constants/tokens';\nimport { useCurrencyBalance } from '../state/connection/hooks';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { TransactionType } from '../state/transactions/types';\nimport { useWETHContract } from './useContract';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport let WrapType;\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\nvar WrapInputError;\n(function (WrapInputError) {\n  WrapInputError[WrapInputError[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n  WrapInputError[WrapInputError[\"ENTER_NATIVE_AMOUNT\"] = 1] = \"ENTER_NATIVE_AMOUNT\";\n  WrapInputError[WrapInputError[\"ENTER_WRAPPED_AMOUNT\"] = 2] = \"ENTER_WRAPPED_AMOUNT\";\n  WrapInputError[WrapInputError[\"INSUFFICIENT_NATIVE_BALANCE\"] = 3] = \"INSUFFICIENT_NATIVE_BALANCE\";\n  WrapInputError[WrapInputError[\"INSUFFICIENT_WRAPPED_BALANCE\"] = 4] = \"INSUFFICIENT_WRAPPED_BALANCE\";\n})(WrapInputError || (WrapInputError = {}));\nexport function WrapErrorText(_ref) {\n  _s();\n  let {\n    wrapInputError\n  } = _ref;\n  const native = useNativeCurrency();\n  const wrapped = native === null || native === void 0 ? void 0 : native.wrapped;\n  switch (wrapInputError) {\n    case WrapInputError.NO_ERROR:\n      return null;\n    case WrapInputError.ENTER_NATIVE_AMOUNT:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Enter {0} amount\",\n        values: {\n          0: native === null || native === void 0 ? void 0 : native.symbol\n        }\n      }, void 0, false, void 0, this);\n    case WrapInputError.ENTER_WRAPPED_AMOUNT:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Enter {0} amount\",\n        values: {\n          0: wrapped === null || wrapped === void 0 ? void 0 : wrapped.symbol\n        }\n      }, void 0, false, void 0, this);\n    case WrapInputError.INSUFFICIENT_NATIVE_BALANCE:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Insufficient {0} balance\",\n        values: {\n          0: native === null || native === void 0 ? void 0 : native.symbol\n        }\n      }, void 0, false, void 0, this);\n    case WrapInputError.INSUFFICIENT_WRAPPED_BALANCE:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Insufficient {0} balance\",\n        values: {\n          0: wrapped === null || wrapped === void 0 ? void 0 : wrapped.symbol\n        }\n      }, void 0, false, void 0, this);\n  }\n}\n\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n_s(WrapErrorText, \"QsWYL7Ih8CW8sWAfMsAE0MB2Juk=\", false, function () {\n  return [useNativeCurrency];\n});\n_c = WrapErrorText;\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  _s2();\n  const {\n    chainId,\n    account\n  } = useWeb3React();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined);\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseCurrencyAmount(typedValue, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n\n  // This allows an async error to propagate within the React lifecycle.\n  // Without rethrowing it here, it would not show up in the UI - only the dev console.\n  const [error, setError] = useState();\n  if (error) throw error;\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n    if (!weth) return NOT_APPLICABLE;\n    const hasInputAmount = Boolean(inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.greaterThan('0'));\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n    const eventProperties = {\n      token_in_address: getTokenAddress(inputCurrency),\n      token_out_address: getTokenAddress(outputCurrency),\n      token_in_symbol: inputCurrency.symbol,\n      token_out_symbol: outputCurrency.symbol,\n      chain_id: inputCurrency.chainId,\n      amount: inputAmount ? formatToDecimal(inputAmount, inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.currency.decimals) : undefined\n    };\n    if (inputCurrency.isNative && weth.equals(outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            var _WRAPPED_NATIVE_CURRE;\n            const network = await wethContract.provider.getNetwork();\n            if (network.chainId !== chainId || wethContract.address !== ((_WRAPPED_NATIVE_CURRE = WRAPPED_NATIVE_CURRENCY[network.chainId]) === null || _WRAPPED_NATIVE_CURRE === void 0 ? void 0 : _WRAPPED_NATIVE_CURRE.address)) {\n              sendAnalyticsEvent(EventName.WRAP_TOKEN_TXN_INVALIDATED, {\n                ...eventProperties,\n                contract_address: wethContract.address,\n                contract_chain_id: network.chainId,\n                type: WrapType.WRAP\n              });\n              const error = new Error(`Invalid WETH contract\nPlease file a bug detailing how this happened - https://github.com/Uniswap/interface/issues/new?labels=bug&template=bug-report.md&title=Invalid%20WETH%20contract`);\n              setError(error);\n              throw error;\n            }\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.quotient.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              type: TransactionType.WRAP,\n              unwrapped: false,\n              currencyAmountRaw: inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.quotient.toString(),\n              chainId\n            });\n            sendAnalyticsEvent(EventName.WRAP_TOKEN_TXN_SUBMITTED, {\n              ...eventProperties,\n              type: WrapType.WRAP\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : hasInputAmount ? WrapInputError.INSUFFICIENT_NATIVE_BALANCE : WrapInputError.ENTER_NATIVE_AMOUNT\n      };\n    } else if (weth.equals(inputCurrency) && outputCurrency.isNative) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.quotient.toString(16)}`);\n            addTransaction(txReceipt, {\n              type: TransactionType.WRAP,\n              unwrapped: true,\n              currencyAmountRaw: inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.quotient.toString(),\n              chainId\n            });\n            sendAnalyticsEvent(EventName.WRAP_TOKEN_TXN_SUBMITTED, {\n              ...eventProperties,\n              type: WrapType.UNWRAP\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : hasInputAmount ? WrapInputError.INSUFFICIENT_WRAPPED_BALANCE : WrapInputError.ENTER_WRAPPED_AMOUNT\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}\n_s2(useWrapCallback, \"sTJo6WR2f6jyzl9bOs1Ww+FUUAU=\", false, function () {\n  return [useWeb3React, useWETHContract, useCurrencyBalance, useTransactionAdder];\n});\nvar _c;\n$RefreshReg$(_c, \"WrapErrorText\");","map":{"version":3,"names":["sendAnalyticsEvent","EventName","useWeb3React","useNativeCurrency","formatToDecimal","getTokenAddress","tryParseCurrencyAmount","useMemo","useState","WRAPPED_NATIVE_CURRENCY","useCurrencyBalance","useTransactionAdder","TransactionType","useWETHContract","WrapType","NOT_APPLICABLE","wrapType","WrapInputError","WrapErrorText","wrapInputError","native","wrapped","NO_ERROR","ENTER_NATIVE_AMOUNT","symbol","ENTER_WRAPPED_AMOUNT","INSUFFICIENT_NATIVE_BALANCE","INSUFFICIENT_WRAPPED_BALANCE","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","error","setError","weth","hasInputAmount","Boolean","greaterThan","sufficientBalance","lessThan","eventProperties","token_in_address","token_out_address","token_in_symbol","token_out_symbol","chain_id","amount","currency","decimals","isNative","equals","WRAP","execute","network","provider","getNetwork","address","WRAP_TOKEN_TXN_INVALIDATED","contract_address","contract_chain_id","type","Error","txReceipt","deposit","value","quotient","toString","unwrapped","currencyAmountRaw","WRAP_TOKEN_TXN_SUBMITTED","console","inputError","UNWRAP","withdraw"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useWrapCallback.tsx"],"sourcesContent":["import { Trans } from '@lingui/macro'\nimport { sendAnalyticsEvent } from '@uniswap/analytics'\nimport { EventName } from '@uniswap/analytics-events'\nimport { Currency } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport useNativeCurrency from 'lib/hooks/useNativeCurrency'\nimport { formatToDecimal, getTokenAddress } from 'lib/utils/analytics'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { useMemo, useState } from 'react'\n\nimport { WRAPPED_NATIVE_CURRENCY } from '../constants/tokens'\nimport { useCurrencyBalance } from '../state/connection/hooks'\nimport { useTransactionAdder } from '../state/transactions/hooks'\nimport { TransactionType } from '../state/transactions/types'\nimport { useWETHContract } from './useContract'\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP,\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\n\nenum WrapInputError {\n  NO_ERROR, // must be equal to 0 so all other errors are truthy\n  ENTER_NATIVE_AMOUNT,\n  ENTER_WRAPPED_AMOUNT,\n  INSUFFICIENT_NATIVE_BALANCE,\n  INSUFFICIENT_WRAPPED_BALANCE,\n}\n\nexport function WrapErrorText({ wrapInputError }: { wrapInputError: WrapInputError }) {\n  const native = useNativeCurrency()\n  const wrapped = native?.wrapped\n\n  switch (wrapInputError) {\n    case WrapInputError.NO_ERROR:\n      return null\n    case WrapInputError.ENTER_NATIVE_AMOUNT:\n      return <Trans>Enter {native?.symbol} amount</Trans>\n    case WrapInputError.ENTER_WRAPPED_AMOUNT:\n      return <Trans>Enter {wrapped?.symbol} amount</Trans>\n\n    case WrapInputError.INSUFFICIENT_NATIVE_BALANCE:\n      return <Trans>Insufficient {native?.symbol} balance</Trans>\n    case WrapInputError.INSUFFICIENT_WRAPPED_BALANCE:\n      return <Trans>Insufficient {wrapped?.symbol} balance</Trans>\n  }\n}\n\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined | null,\n  outputCurrency: Currency | undefined | null,\n  typedValue: string | undefined\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: WrapInputError } {\n  const { chainId, account } = useWeb3React()\n  const wethContract = useWETHContract()\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency ?? undefined)\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(\n    () => tryParseCurrencyAmount(typedValue, inputCurrency ?? undefined),\n    [inputCurrency, typedValue]\n  )\n  const addTransaction = useTransactionAdder()\n\n  // This allows an async error to propagate within the React lifecycle.\n  // Without rethrowing it here, it would not show up in the UI - only the dev console.\n  const [error, setError] = useState<Error>()\n  if (error) throw error\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\n    const weth = WRAPPED_NATIVE_CURRENCY[chainId]\n    if (!weth) return NOT_APPLICABLE\n\n    const hasInputAmount = Boolean(inputAmount?.greaterThan('0'))\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\n\n    const eventProperties = {\n      token_in_address: getTokenAddress(inputCurrency),\n      token_out_address: getTokenAddress(outputCurrency),\n      token_in_symbol: inputCurrency.symbol,\n      token_out_symbol: outputCurrency.symbol,\n      chain_id: inputCurrency.chainId,\n      amount: inputAmount ? formatToDecimal(inputAmount, inputAmount?.currency.decimals) : undefined,\n    }\n\n    if (inputCurrency.isNative && weth.equals(outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const network = await wethContract.provider.getNetwork()\n                  if (\n                    network.chainId !== chainId ||\n                    wethContract.address !== WRAPPED_NATIVE_CURRENCY[network.chainId]?.address\n                  ) {\n                    sendAnalyticsEvent(EventName.WRAP_TOKEN_TXN_INVALIDATED, {\n                      ...eventProperties,\n                      contract_address: wethContract.address,\n                      contract_chain_id: network.chainId,\n                      type: WrapType.WRAP,\n                    })\n                    const error = new Error(`Invalid WETH contract\nPlease file a bug detailing how this happened - https://github.com/Uniswap/interface/issues/new?labels=bug&template=bug-report.md&title=Invalid%20WETH%20contract`)\n                    setError(error)\n                    throw error\n                  }\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.quotient.toString(16)}` })\n                  addTransaction(txReceipt, {\n                    type: TransactionType.WRAP,\n                    unwrapped: false,\n                    currencyAmountRaw: inputAmount?.quotient.toString(),\n                    chainId,\n                  })\n                  sendAnalyticsEvent(EventName.WRAP_TOKEN_TXN_SUBMITTED, { ...eventProperties, type: WrapType.WRAP })\n                } catch (error) {\n                  console.error('Could not deposit', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance\n          ? undefined\n          : hasInputAmount\n          ? WrapInputError.INSUFFICIENT_NATIVE_BALANCE\n          : WrapInputError.ENTER_NATIVE_AMOUNT,\n      }\n    } else if (weth.equals(inputCurrency) && outputCurrency.isNative) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.quotient.toString(16)}`)\n                  addTransaction(txReceipt, {\n                    type: TransactionType.WRAP,\n                    unwrapped: true,\n                    currencyAmountRaw: inputAmount?.quotient.toString(),\n                    chainId,\n                  })\n                  sendAnalyticsEvent(EventName.WRAP_TOKEN_TXN_SUBMITTED, { ...eventProperties, type: WrapType.UNWRAP })\n                } catch (error) {\n                  console.error('Could not withdraw', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance\n          ? undefined\n          : hasInputAmount\n          ? WrapInputError.INSUFFICIENT_WRAPPED_BALANCE\n          : WrapInputError.ENTER_WRAPPED_AMOUNT,\n      }\n    } else {\n      return NOT_APPLICABLE\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}