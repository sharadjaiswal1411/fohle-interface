{"ast":null,"code":"import { CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core';\n// This file is lazy-loaded, so the import of smart-order-router is intentional.\n// eslint-disable-next-line no-restricted-imports\n\nimport { SupportedChainId } from 'constants/chains';\nimport JSBI from 'jsbi';\nimport { transformSwapRouteToGetQuoteResult } from 'utils/transformSwapRouteToGetQuoteResult';\nexport function toSupportedChainId(chainId) {\n  const numericChainId = chainId;\n  if (SupportedChainId[numericChainId]) return numericChainId;\n  return undefined;\n}\nexport function isSupportedChainId(chainId) {\n  if (chainId === undefined) return false;\n  return toSupportedChainId(chainId) !== undefined;\n}\nasync function getQuote(_ref, router, config) {\n  let {\n    type,\n    tokenIn,\n    tokenOut,\n    amount: amountRaw\n  } = _ref;\n  const currencyIn = new Token(tokenIn.chainId, tokenIn.address, tokenIn.decimals, tokenIn.symbol);\n  const currencyOut = new Token(tokenOut.chainId, tokenOut.address, tokenOut.decimals, tokenOut.symbol);\n  const baseCurrency = type === 'exactIn' ? currencyIn : currencyOut;\n  const quoteCurrency = type === 'exactIn' ? currencyOut : currencyIn;\n  const amount = CurrencyAmount.fromRawAmount(baseCurrency, JSBI.BigInt(amountRaw));\n  const swapRoute = await router.route(amount, quoteCurrency, type === 'exactIn' ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT, /*swapConfig=*/undefined, config);\n  if (!swapRoute) throw new Error('Failed to generate client side quote');\n  return {\n    data: transformSwapRouteToGetQuoteResult(type, amount, swapRoute)\n  };\n}\nexport async function getClientSideQuote(_ref2, router, config) {\n  let {\n    tokenInAddress,\n    tokenInChainId,\n    tokenInDecimals,\n    tokenInSymbol,\n    tokenOutAddress,\n    tokenOutChainId,\n    tokenOutDecimals,\n    tokenOutSymbol,\n    amount,\n    type\n  } = _ref2;\n  return getQuote({\n    type,\n    tokenIn: {\n      address: tokenInAddress,\n      chainId: tokenInChainId,\n      decimals: tokenInDecimals,\n      symbol: tokenInSymbol\n    },\n    tokenOut: {\n      address: tokenOutAddress,\n      chainId: tokenOutChainId,\n      decimals: tokenOutDecimals,\n      symbol: tokenOutSymbol\n    },\n    amount\n  }, router, config);\n}","map":{"version":3,"names":["CurrencyAmount","Token","TradeType","SupportedChainId","JSBI","transformSwapRouteToGetQuoteResult","toSupportedChainId","chainId","numericChainId","undefined","isSupportedChainId","getQuote","router","config","type","tokenIn","tokenOut","amount","amountRaw","currencyIn","address","decimals","symbol","currencyOut","baseCurrency","quoteCurrency","fromRawAmount","BigInt","swapRoute","route","EXACT_INPUT","EXACT_OUTPUT","Error","data","getClientSideQuote","tokenInAddress","tokenInChainId","tokenInDecimals","tokenInSymbol","tokenOutAddress","tokenOutChainId","tokenOutDecimals","tokenOutSymbol"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/routing/clientSideSmartOrderRouter.ts"],"sourcesContent":["import { BigintIsh, CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core'\n// This file is lazy-loaded, so the import of smart-order-router is intentional.\n// eslint-disable-next-line no-restricted-imports\nimport { AlphaRouter, AlphaRouterConfig, ChainId } from '@uniswap/smart-order-router'\nimport { SupportedChainId } from 'constants/chains'\nimport JSBI from 'jsbi'\nimport { GetQuoteResult } from 'state/routing/types'\nimport { transformSwapRouteToGetQuoteResult } from 'utils/transformSwapRouteToGetQuoteResult'\n\nexport function toSupportedChainId(chainId: ChainId): SupportedChainId | undefined {\n  const numericChainId: number = chainId\n  if (SupportedChainId[numericChainId]) return numericChainId\n  return undefined\n}\nexport function isSupportedChainId(chainId: ChainId | undefined): boolean {\n  if (chainId === undefined) return false\n  return toSupportedChainId(chainId) !== undefined\n}\n\nasync function getQuote(\n  {\n    type,\n    tokenIn,\n    tokenOut,\n    amount: amountRaw,\n  }: {\n    type: 'exactIn' | 'exactOut'\n    tokenIn: { address: string; chainId: number; decimals: number; symbol?: string }\n    tokenOut: { address: string; chainId: number; decimals: number; symbol?: string }\n    amount: BigintIsh\n  },\n  router: AlphaRouter,\n  config: Partial<AlphaRouterConfig>\n): Promise<{ data: GetQuoteResult; error?: unknown }> {\n  const currencyIn = new Token(tokenIn.chainId, tokenIn.address, tokenIn.decimals, tokenIn.symbol)\n  const currencyOut = new Token(tokenOut.chainId, tokenOut.address, tokenOut.decimals, tokenOut.symbol)\n\n  const baseCurrency = type === 'exactIn' ? currencyIn : currencyOut\n  const quoteCurrency = type === 'exactIn' ? currencyOut : currencyIn\n  const amount = CurrencyAmount.fromRawAmount(baseCurrency, JSBI.BigInt(amountRaw))\n\n  const swapRoute = await router.route(\n    amount,\n    quoteCurrency,\n    type === 'exactIn' ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT,\n    /*swapConfig=*/ undefined,\n    config\n  )\n\n  if (!swapRoute) throw new Error('Failed to generate client side quote')\n\n  return { data: transformSwapRouteToGetQuoteResult(type, amount, swapRoute) }\n}\n\ninterface QuoteArguments {\n  tokenInAddress: string\n  tokenInChainId: ChainId\n  tokenInDecimals: number\n  tokenInSymbol?: string\n  tokenOutAddress: string\n  tokenOutChainId: ChainId\n  tokenOutDecimals: number\n  tokenOutSymbol?: string\n  amount: string\n  type: 'exactIn' | 'exactOut'\n}\n\nexport async function getClientSideQuote(\n  {\n    tokenInAddress,\n    tokenInChainId,\n    tokenInDecimals,\n    tokenInSymbol,\n    tokenOutAddress,\n    tokenOutChainId,\n    tokenOutDecimals,\n    tokenOutSymbol,\n    amount,\n    type,\n  }: QuoteArguments,\n  router: AlphaRouter,\n  config: Partial<AlphaRouterConfig>\n) {\n  return getQuote(\n    {\n      type,\n      tokenIn: {\n        address: tokenInAddress,\n        chainId: tokenInChainId,\n        decimals: tokenInDecimals,\n        symbol: tokenInSymbol,\n      },\n      tokenOut: {\n        address: tokenOutAddress,\n        chainId: tokenOutChainId,\n        decimals: tokenOutDecimals,\n        symbol: tokenOutSymbol,\n      },\n      amount,\n    },\n    router,\n    config\n  )\n}\n"],"mappings":"AAAA,SAAoBA,cAAc,EAAEC,KAAK,EAAEC,SAAS,QAAQ,mBAAmB;AAC/E;AACA;;AAEA,SAASC,gBAAgB,QAAQ,kBAAkB;AACnD,OAAOC,IAAI,MAAM,MAAM;AAEvB,SAASC,kCAAkC,QAAQ,0CAA0C;AAE7F,OAAO,SAASC,kBAAkB,CAACC,OAAgB,EAAgC;EACjF,MAAMC,cAAsB,GAAGD,OAAO;EACtC,IAAIJ,gBAAgB,CAACK,cAAc,CAAC,EAAE,OAAOA,cAAc;EAC3D,OAAOC,SAAS;AAClB;AACA,OAAO,SAASC,kBAAkB,CAACH,OAA4B,EAAW;EACxE,IAAIA,OAAO,KAAKE,SAAS,EAAE,OAAO,KAAK;EACvC,OAAOH,kBAAkB,CAACC,OAAO,CAAC,KAAKE,SAAS;AAClD;AAEA,eAAeE,QAAQ,OAYrBC,MAAmB,EACnBC,MAAkC,EACkB;EAAA,IAbpD;IACEC,IAAI;IACJC,OAAO;IACPC,QAAQ;IACRC,MAAM,EAAEC;EAMV,CAAC;EAID,MAAMC,UAAU,GAAG,IAAIlB,KAAK,CAACc,OAAO,CAACR,OAAO,EAAEQ,OAAO,CAACK,OAAO,EAAEL,OAAO,CAACM,QAAQ,EAAEN,OAAO,CAACO,MAAM,CAAC;EAChG,MAAMC,WAAW,GAAG,IAAItB,KAAK,CAACe,QAAQ,CAACT,OAAO,EAAES,QAAQ,CAACI,OAAO,EAAEJ,QAAQ,CAACK,QAAQ,EAAEL,QAAQ,CAACM,MAAM,CAAC;EAErG,MAAME,YAAY,GAAGV,IAAI,KAAK,SAAS,GAAGK,UAAU,GAAGI,WAAW;EAClE,MAAME,aAAa,GAAGX,IAAI,KAAK,SAAS,GAAGS,WAAW,GAAGJ,UAAU;EACnE,MAAMF,MAAM,GAAGjB,cAAc,CAAC0B,aAAa,CAACF,YAAY,EAAEpB,IAAI,CAACuB,MAAM,CAACT,SAAS,CAAC,CAAC;EAEjF,MAAMU,SAAS,GAAG,MAAMhB,MAAM,CAACiB,KAAK,CAClCZ,MAAM,EACNQ,aAAa,EACbX,IAAI,KAAK,SAAS,GAAGZ,SAAS,CAAC4B,WAAW,GAAG5B,SAAS,CAAC6B,YAAY,EACnE,eAAgBtB,SAAS,EACzBI,MAAM,CACP;EAED,IAAI,CAACe,SAAS,EAAE,MAAM,IAAII,KAAK,CAAC,sCAAsC,CAAC;EAEvE,OAAO;IAAEC,IAAI,EAAE5B,kCAAkC,CAACS,IAAI,EAAEG,MAAM,EAAEW,SAAS;EAAE,CAAC;AAC9E;AAeA,OAAO,eAAeM,kBAAkB,QAatCtB,MAAmB,EACnBC,MAAkC,EAClC;EAAA,IAdA;IACEsB,cAAc;IACdC,cAAc;IACdC,eAAe;IACfC,aAAa;IACbC,eAAe;IACfC,eAAe;IACfC,gBAAgB;IAChBC,cAAc;IACdzB,MAAM;IACNH;EACc,CAAC;EAIjB,OAAOH,QAAQ,CACb;IACEG,IAAI;IACJC,OAAO,EAAE;MACPK,OAAO,EAAEe,cAAc;MACvB5B,OAAO,EAAE6B,cAAc;MACvBf,QAAQ,EAAEgB,eAAe;MACzBf,MAAM,EAAEgB;IACV,CAAC;IACDtB,QAAQ,EAAE;MACRI,OAAO,EAAEmB,eAAe;MACxBhC,OAAO,EAAEiC,eAAe;MACxBnB,QAAQ,EAAEoB,gBAAgB;MAC1BnB,MAAM,EAAEoB;IACV,CAAC;IACDzB;EACF,CAAC,EACDL,MAAM,EACNC,MAAM,CACP;AACH"},"metadata":{},"sourceType":"module"}