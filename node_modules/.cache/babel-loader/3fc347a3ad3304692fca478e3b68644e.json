{"ast":null,"code":"import _ from 'lodash';\nimport { ITokenValidator__factory } from '../types/other/factories/ITokenValidator__factory';\nimport { log, WRAPPED_NATIVE_CURRENCY } from '../util';\nconst DEFAULT_ALLOWLIST = new Set([\n// RYOSHI. Does not allow transfers between contracts so fails validation.\n'0x777E2ae845272a2F540ebf6a3D03734A5a8f618e'.toLowerCase()]);\nexport var TokenValidationResult;\n(function (TokenValidationResult) {\n  TokenValidationResult[TokenValidationResult[\"UNKN\"] = 0] = \"UNKN\";\n  TokenValidationResult[TokenValidationResult[\"FOT\"] = 1] = \"FOT\";\n  TokenValidationResult[TokenValidationResult[\"STF\"] = 2] = \"STF\";\n})(TokenValidationResult || (TokenValidationResult = {}));\nconst TOKEN_VALIDATOR_ADDRESS = '0xb5ee1690b7dcc7859771148d0889be838fe108e0';\nconst AMOUNT_TO_FLASH_BORROW = '1000';\nconst GAS_LIMIT_PER_VALIDATE = 1000000;\nexport class TokenValidatorProvider {\n  constructor(chainId, multicall2Provider, tokenValidationCache) {\n    let tokenValidatorAddress = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_VALIDATOR_ADDRESS;\n    let gasLimitPerCall = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : GAS_LIMIT_PER_VALIDATE;\n    let amountToFlashBorrow = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : AMOUNT_TO_FLASH_BORROW;\n    let allowList = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_ALLOWLIST;\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.tokenValidationCache = tokenValidationCache;\n    this.tokenValidatorAddress = tokenValidatorAddress;\n    this.gasLimitPerCall = gasLimitPerCall;\n    this.amountToFlashBorrow = amountToFlashBorrow;\n    this.allowList = allowList;\n    this.CACHE_KEY = (chainId, address) => `token-${chainId}-${address}`;\n    this.BASES = [WRAPPED_NATIVE_CURRENCY[this.chainId].address];\n  }\n  async validateTokens(tokens, providerConfig) {\n    const tokenAddressToToken = _.keyBy(tokens, 'address');\n    const addressesRaw = _(tokens).map(token => token.address).uniq().value();\n    const addresses = [];\n    const tokenToResult = {};\n    // Check if we have cached token validation results for any tokens.\n    for (const address of addressesRaw) {\n      if (await this.tokenValidationCache.has(this.CACHE_KEY(this.chainId, address))) {\n        tokenToResult[address.toLowerCase()] = await this.tokenValidationCache.get(this.CACHE_KEY(this.chainId, address));\n      } else {\n        addresses.push(address);\n      }\n    }\n    log.info(`Got token validation results for ${addressesRaw.length - addresses.length} tokens from cache. Getting ${addresses.length} on-chain.`);\n    const functionParams = _(addresses).map(address => [address, this.BASES, this.amountToFlashBorrow]).value();\n    // We use the validate function instead of batchValidate to avoid poison pill problem.\n    // One token that consumes too much gas could cause the entire batch to fail.\n    const multicallResult = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n      address: this.tokenValidatorAddress,\n      contractInterface: ITokenValidator__factory.createInterface(),\n      functionName: 'validate',\n      functionParams: functionParams,\n      providerConfig,\n      additionalConfig: {\n        gasLimitPerCallOverride: this.gasLimitPerCall\n      }\n    });\n    for (let i = 0; i < multicallResult.results.length; i++) {\n      const resultWrapper = multicallResult.results[i];\n      const tokenAddress = addresses[i];\n      const token = tokenAddressToToken[tokenAddress];\n      if (this.allowList.has(token.address.toLowerCase())) {\n        tokenToResult[token.address.toLowerCase()] = TokenValidationResult.UNKN;\n        await this.tokenValidationCache.set(this.CACHE_KEY(this.chainId, token.address.toLowerCase()), tokenToResult[token.address.toLowerCase()]);\n        continue;\n      }\n      // Could happen if the tokens transfer consumes too much gas so we revert. Just\n      // drop the token in that case.\n      if (!resultWrapper.success) {\n        log.info({\n          result: resultWrapper\n        }, `Failed to validate token ${token.symbol}`);\n        continue;\n      }\n      const validationResult = resultWrapper.result[0];\n      tokenToResult[token.address.toLowerCase()] = validationResult;\n      await this.tokenValidationCache.set(this.CACHE_KEY(this.chainId, token.address.toLowerCase()), tokenToResult[token.address.toLowerCase()]);\n    }\n    return {\n      getValidationByToken: token => tokenToResult[token.address.toLowerCase()]\n    };\n  }\n}","map":{"version":3,"sources":["../../../src/providers/token-validator-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from 'lodash';\nimport { ITokenValidator__factory } from '../types/other/factories/ITokenValidator__factory';\nimport { log, WRAPPED_NATIVE_CURRENCY } from '../util';\nconst DEFAULT_ALLOWLIST = new Set([\n    // RYOSHI. Does not allow transfers between contracts so fails validation.\n    '0x777E2ae845272a2F540ebf6a3D03734A5a8f618e'.toLowerCase(),\n]);\nexport var TokenValidationResult;\n(function (TokenValidationResult) {\n    TokenValidationResult[TokenValidationResult[\"UNKN\"] = 0] = \"UNKN\";\n    TokenValidationResult[TokenValidationResult[\"FOT\"] = 1] = \"FOT\";\n    TokenValidationResult[TokenValidationResult[\"STF\"] = 2] = \"STF\";\n})(TokenValidationResult || (TokenValidationResult = {}));\nconst TOKEN_VALIDATOR_ADDRESS = '0xb5ee1690b7dcc7859771148d0889be838fe108e0';\nconst AMOUNT_TO_FLASH_BORROW = '1000';\nconst GAS_LIMIT_PER_VALIDATE = 1000000;\nexport class TokenValidatorProvider {\n    constructor(chainId, multicall2Provider, tokenValidationCache, tokenValidatorAddress = TOKEN_VALIDATOR_ADDRESS, gasLimitPerCall = GAS_LIMIT_PER_VALIDATE, amountToFlashBorrow = AMOUNT_TO_FLASH_BORROW, allowList = DEFAULT_ALLOWLIST) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.tokenValidationCache = tokenValidationCache;\n        this.tokenValidatorAddress = tokenValidatorAddress;\n        this.gasLimitPerCall = gasLimitPerCall;\n        this.amountToFlashBorrow = amountToFlashBorrow;\n        this.allowList = allowList;\n        this.CACHE_KEY = (chainId, address) => `token-${chainId}-${address}`;\n        this.BASES = [WRAPPED_NATIVE_CURRENCY[this.chainId].address];\n    }\n    async validateTokens(tokens, providerConfig) {\n        const tokenAddressToToken = _.keyBy(tokens, 'address');\n        const addressesRaw = _(tokens)\n            .map((token) => token.address)\n            .uniq()\n            .value();\n        const addresses = [];\n        const tokenToResult = {};\n        // Check if we have cached token validation results for any tokens.\n        for (const address of addressesRaw) {\n            if (await this.tokenValidationCache.has(this.CACHE_KEY(this.chainId, address))) {\n                tokenToResult[address.toLowerCase()] =\n                    (await this.tokenValidationCache.get(this.CACHE_KEY(this.chainId, address)));\n            }\n            else {\n                addresses.push(address);\n            }\n        }\n        log.info(`Got token validation results for ${addressesRaw.length - addresses.length} tokens from cache. Getting ${addresses.length} on-chain.`);\n        const functionParams = _(addresses)\n            .map((address) => [address, this.BASES, this.amountToFlashBorrow])\n            .value();\n        // We use the validate function instead of batchValidate to avoid poison pill problem.\n        // One token that consumes too much gas could cause the entire batch to fail.\n        const multicallResult = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n            address: this.tokenValidatorAddress,\n            contractInterface: ITokenValidator__factory.createInterface(),\n            functionName: 'validate',\n            functionParams: functionParams,\n            providerConfig,\n            additionalConfig: {\n                gasLimitPerCallOverride: this.gasLimitPerCall,\n            },\n        });\n        for (let i = 0; i < multicallResult.results.length; i++) {\n            const resultWrapper = multicallResult.results[i];\n            const tokenAddress = addresses[i];\n            const token = tokenAddressToToken[tokenAddress];\n            if (this.allowList.has(token.address.toLowerCase())) {\n                tokenToResult[token.address.toLowerCase()] = TokenValidationResult.UNKN;\n                await this.tokenValidationCache.set(this.CACHE_KEY(this.chainId, token.address.toLowerCase()), tokenToResult[token.address.toLowerCase()]);\n                continue;\n            }\n            // Could happen if the tokens transfer consumes too much gas so we revert. Just\n            // drop the token in that case.\n            if (!resultWrapper.success) {\n                log.info({ result: resultWrapper }, `Failed to validate token ${token.symbol}`);\n                continue;\n            }\n            const validationResult = resultWrapper.result[0];\n            tokenToResult[token.address.toLowerCase()] =\n                validationResult;\n            await this.tokenValidationCache.set(this.CACHE_KEY(this.chainId, token.address.toLowerCase()), tokenToResult[token.address.toLowerCase()]);\n        }\n        return {\n            getValidationByToken: (token) => tokenToResult[token.address.toLowerCase()],\n        };\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4tdmFsaWRhdG9yLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy90b2tlbi12YWxpZGF0b3ItcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBRXZCLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQzdGLE9BQU8sRUFBVyxHQUFHLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFNaEUsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsQ0FBUztJQUN4QywwRUFBMEU7SUFDMUUsNENBQTRDLENBQUMsV0FBVyxFQUFFO0NBQzNELENBQUMsQ0FBQztBQUVILE1BQU0sQ0FBTixJQUFZLHFCQUlYO0FBSkQsV0FBWSxxQkFBcUI7SUFDL0IsaUVBQVEsQ0FBQTtJQUNSLCtEQUFPLENBQUE7SUFDUCwrREFBTyxDQUFBO0FBQ1QsQ0FBQyxFQUpXLHFCQUFxQixLQUFyQixxQkFBcUIsUUFJaEM7QUFNRCxNQUFNLHVCQUF1QixHQUFHLDRDQUE0QyxDQUFDO0FBQzdFLE1BQU0sc0JBQXNCLEdBQUcsTUFBTSxDQUFDO0FBQ3RDLE1BQU0sc0JBQXNCLEdBQUcsT0FBUyxDQUFDO0FBc0J6QyxNQUFNLE9BQU8sc0JBQXNCO0lBTWpDLFlBQ1ksT0FBZ0IsRUFDaEIsa0JBQXNDLEVBQ3hDLG9CQUFtRCxFQUNuRCx3QkFBd0IsdUJBQXVCLEVBQy9DLGtCQUFrQixzQkFBc0IsRUFDeEMsc0JBQXNCLHNCQUFzQixFQUM1QyxZQUFZLGlCQUFpQjtRQU4zQixZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQ2hCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFDeEMseUJBQW9CLEdBQXBCLG9CQUFvQixDQUErQjtRQUNuRCwwQkFBcUIsR0FBckIscUJBQXFCLENBQTBCO1FBQy9DLG9CQUFlLEdBQWYsZUFBZSxD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"]},"metadata":{},"sourceType":"module"}