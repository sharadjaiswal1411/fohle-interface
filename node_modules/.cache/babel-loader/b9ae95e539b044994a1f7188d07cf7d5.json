{"ast":null,"code":"import { forEachEnvelopeItem, envelopeItemTypeToDataCategory, isRateLimited, resolvedSyncPromise, createEnvelope, serializeEnvelope, logger, updateRateLimits, SentryError, makePromiseBuffer } from '@sentry/utils';\nvar DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(options, makeRequest) {\n  var buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);\n  var rateLimits = {};\n  var flush = function flush(timeout) {\n    return buffer.drain(timeout);\n  };\n  function send(envelope) {\n    var filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, function (item, type) {\n      var envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);\n\n    // Creates client report for each item in an envelope\n    var recordEnvelopeLoss = function recordEnvelopeLoss(reason) {\n      forEachEnvelopeItem(filteredEnvelope, function (_, type) {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n    var requestTask = function requestTask() {\n      return makeRequest({\n        body: serializeEnvelope(filteredEnvelope, options.textEncoder)\n      }).then(function (response) {\n        // We don't want to throw on NOK responses, but we want to at least log them\n        if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"Sentry responded with status code \".concat(response.statusCode, \" to sent event.\"));\n        }\n        rateLimits = updateRateLimits(rateLimits, response);\n      }, function (error) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Failed while sending event:', error);\n        recordEnvelopeLoss('network_error');\n      });\n    };\n    return buffer.add(requestTask).then(function (result) {\n      return result;\n    }, function (error) {\n      if (error instanceof SentryError) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Skipped sending event because buffer is full.');\n        recordEnvelopeLoss('queue_overflow');\n        return resolvedSyncPromise();\n      } else {\n        throw error;\n      }\n    });\n  }\n  return {\n    send: send,\n    flush: flush\n  };\n}\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport };","map":{"version":3,"sources":["../../../src/transports/base.ts"],"names":[],"mappings":";AAuBA,IAAA,6BAAA,GAAA,EAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,eAAA,CACA,OAAA,EACA,WAAA,EAEA;EAAA,IADA,MAAA,uEAAA,iBAAA,CAAA,OAAA,CAAA,UAAA,IAAA,6BAAA,CAAA;EAEA,IAAA,UAAA,GAAA,CAAA,CAAA;EAEA,IAAA,KAAA,GAAA,SAAA,KAAA,CAAA,OAAA;IAAA,OAAA,MAAA,CAAA,KAAA,CAAA,OAAA,CAAA;EAAA;EAEA,SAAA,IAAA,CAAA,QAAA,EAAA;IACA,IAAA,qBAAA,GAAA,EAAA;;IAEA;IACA,mBAAA,CAAA,QAAA,EAAA,UAAA,IAAA,EAAA,IAAA,EAAA;MACA,IAAA,wBAAA,GAAA,8BAAA,CAAA,IAAA,CAAA;MACA,IAAA,aAAA,CAAA,UAAA,EAAA,wBAAA,CAAA,EAAA;QACA,OAAA,CAAA,kBAAA,CAAA,mBAAA,EAAA,wBAAA,CAAA;MACA,CAAA,MAAA;QACA,qBAAA,CAAA,IAAA,CAAA,IAAA,CAAA;MACA;IACA,CAAA,CAAA;;IAEA;IACA,IAAA,qBAAA,CAAA,MAAA,KAAA,CAAA,EAAA;MACA,OAAA,mBAAA,EAAA;IACA;;IAEA;IACA,IAAA,gBAAA,GAAA,cAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EAAA,qBAAA,CAAA;;IAEA;IACA,IAAA,kBAAA,GAAA,SAAA,kBAAA,CAAA,MAAA,EAAA;MACA,mBAAA,CAAA,gBAAA,EAAA,UAAA,CAAA,EAAA,IAAA,EAAA;QACA,OAAA,CAAA,kBAAA,CAAA,MAAA,EAAA,8BAAA,CAAA,IAAA,CAAA,CAAA;MACA,CAAA,CAAA;IACA,CAAA;IAEA,IAAA,WAAA,GAAA,SAAA,WAAA;MAAA,OACA,WAAA,CAAA;QAAA,IAAA,EAAA,iBAAA,CAAA,gBAAA,EAAA,OAAA,CAAA,WAAA;MAAA,CAAA,CAAA,CAAA,IAAA,CACA,UAAA,QAAA,EAAA;QACA;QACA,IAAA,QAAA,CAAA,UAAA,KAAA,SAAA,KAAA,QAAA,CAAA,UAAA,GAAA,GAAA,IAAA,QAAA,CAAA,UAAA,IAAA,GAAA,CAAA,EAAA;UACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,IAAA,6CAAA,QAAA,CAAA,UAAA,qBAAA;QACA;QAEA,UAAA,GAAA,gBAAA,CAAA,UAAA,EAAA,QAAA,CAAA;MACA,CAAA,EACA,UAAA,KAAA,EAAA;QACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,KAAA,CAAA,6BAAA,EAAA,KAAA,CAAA;QACA,kBAAA,CAAA,eAAA,CAAA;MACA,CAAA,CACA;IAAA;IAEA,OAAA,MAAA,CAAA,GAAA,CAAA,WAAA,CAAA,CAAA,IAAA,CACA,UAAA,MAAA;MAAA,OAAA,MAAA;IAAA,GACA,UAAA,KAAA,EAAA;MACA,IAAA,KAAA,YAAA,WAAA,EAAA;QACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,KAAA,CAAA,+CAAA,CAAA;QACA,kBAAA,CAAA,gBAAA,CAAA;QACA,OAAA,mBAAA,EAAA;MACA,CAAA,MAAA;QACA,MAAA,KAAA;MACA;IACA,CAAA,CACA;EACA;EAEA,OAAA;IACA,IAAA,EAAA,IAAA;IACA,KAAA,EAAA;EACA,CAAA;AACA","sourcesContent":["import {\n  Envelope,\n  EnvelopeItem,\n  EventDropReason,\n  InternalBaseTransportOptions,\n  Transport,\n  TransportRequestExecutor,\n} from '@sentry/types';\nimport {\n  createEnvelope,\n  envelopeItemTypeToDataCategory,\n  forEachEnvelopeItem,\n  isRateLimited,\n  logger,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  resolvedSyncPromise,\n  SentryError,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<void> = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n): Transport {\n  let rateLimits: RateLimits = {};\n\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<void> {\n    const filteredEnvelopeItems: EnvelopeItem[] = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const filteredEnvelope: Envelope = createEnvelope(envelope[0], filteredEnvelopeItems as any);\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason: EventDropReason): void => {\n      forEachEnvelopeItem(filteredEnvelope, (_, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    const requestTask = (): PromiseLike<void> =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            __DEBUG_BUILD__ && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n        },\n        error => {\n          __DEBUG_BUILD__ && logger.error('Failed while sending event:', error);\n          recordEnvelopeLoss('network_error');\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error instanceof SentryError) {\n          __DEBUG_BUILD__ && logger.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return resolvedSyncPromise();\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}