{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useWeb3React } from '@web3-react/core';\nimport useBlockNumber from 'lib/hooks/useBlockNumber';\nimport { useEffect, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from '../hooks';\nimport { fetchedLogs, fetchedLogsError, fetchingLogs } from './slice';\nimport { isHistoricalLog, keyToFilter } from './utils';\nexport default function Updater() {\n  _s();\n  const dispatch = useAppDispatch();\n  const state = useAppSelector(state => state.logs);\n  const {\n    chainId,\n    provider\n  } = useWeb3React();\n  const blockNumber = useBlockNumber();\n  const filtersNeedFetch = useMemo(() => {\n    if (!chainId || typeof blockNumber !== 'number') return [];\n    const active = state[chainId];\n    if (!active) return [];\n    return Object.keys(active).filter(key => {\n      const {\n        fetchingBlockNumber,\n        results,\n        listeners\n      } = active[key];\n      if (listeners === 0) return false;\n      if (typeof fetchingBlockNumber === 'number' && fetchingBlockNumber >= blockNumber) return false;\n      if (results && typeof results.blockNumber === 'number' && results.blockNumber >= blockNumber) return false;\n      // this condition ensures that if a log is historical, and it's already fetched, we don't re-fetch it\n      if (isHistoricalLog(keyToFilter(key), blockNumber) && (results === null || results === void 0 ? void 0 : results.logs) !== undefined) return false;\n      return true;\n    }).map(key => keyToFilter(key));\n  }, [blockNumber, chainId, state]);\n  useEffect(() => {\n    if (!provider || !chainId || typeof blockNumber !== 'number' || filtersNeedFetch.length === 0) return;\n    dispatch(fetchingLogs({\n      chainId,\n      filters: filtersNeedFetch,\n      blockNumber\n    }));\n    filtersNeedFetch.forEach(filter => {\n      var _filter$fromBlock, _filter$toBlock;\n      // provide defaults if {from,to}Block are missing\n      let fromBlock = (_filter$fromBlock = filter.fromBlock) !== null && _filter$fromBlock !== void 0 ? _filter$fromBlock : 0;\n      let toBlock = (_filter$toBlock = filter.toBlock) !== null && _filter$toBlock !== void 0 ? _filter$toBlock : blockNumber;\n      if (typeof fromBlock === 'string') fromBlock = Number.parseInt(fromBlock);\n      if (typeof toBlock === 'string') toBlock = Number.parseInt(toBlock);\n      provider.getLogs({\n        ...filter,\n        fromBlock,\n        toBlock\n      }).then(logs => {\n        dispatch(fetchedLogs({\n          chainId,\n          filter,\n          results: {\n            logs,\n            blockNumber\n          }\n        }));\n      }).catch(error => {\n        console.error('Failed to get logs', filter, error);\n        dispatch(fetchedLogsError({\n          chainId,\n          filter,\n          blockNumber\n        }));\n      });\n    });\n  }, [blockNumber, chainId, dispatch, filtersNeedFetch, provider]);\n  return null;\n}\n_s(Updater, \"hi0lOMI4WCQWcyf/ogP1gOzT5cI=\", false, function () {\n  return [useAppDispatch, useAppSelector, useWeb3React, useBlockNumber];\n});\n_c = Updater;\nvar _c;\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"names":["useWeb3React","useBlockNumber","useEffect","useMemo","useAppDispatch","useAppSelector","fetchedLogs","fetchedLogsError","fetchingLogs","isHistoricalLog","keyToFilter","Updater","dispatch","state","logs","chainId","provider","blockNumber","filtersNeedFetch","active","Object","keys","filter","key","fetchingBlockNumber","results","listeners","undefined","map","length","filters","forEach","fromBlock","toBlock","Number","parseInt","getLogs","then","catch","error","console"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/logs/updater.ts"],"sourcesContent":["import type { Filter } from '@ethersproject/providers'\nimport { useWeb3React } from '@web3-react/core'\nimport useBlockNumber from 'lib/hooks/useBlockNumber'\nimport { useEffect, useMemo } from 'react'\n\nimport { useAppDispatch, useAppSelector } from '../hooks'\nimport { fetchedLogs, fetchedLogsError, fetchingLogs } from './slice'\nimport { isHistoricalLog, keyToFilter } from './utils'\n\nexport default function Updater(): null {\n  const dispatch = useAppDispatch()\n  const state = useAppSelector((state) => state.logs)\n  const { chainId, provider } = useWeb3React()\n\n  const blockNumber = useBlockNumber()\n\n  const filtersNeedFetch: Filter[] = useMemo(() => {\n    if (!chainId || typeof blockNumber !== 'number') return []\n\n    const active = state[chainId]\n    if (!active) return []\n\n    return Object.keys(active)\n      .filter((key) => {\n        const { fetchingBlockNumber, results, listeners } = active[key]\n        if (listeners === 0) return false\n        if (typeof fetchingBlockNumber === 'number' && fetchingBlockNumber >= blockNumber) return false\n        if (results && typeof results.blockNumber === 'number' && results.blockNumber >= blockNumber) return false\n        // this condition ensures that if a log is historical, and it's already fetched, we don't re-fetch it\n        if (isHistoricalLog(keyToFilter(key), blockNumber) && results?.logs !== undefined) return false\n        return true\n      })\n      .map((key) => keyToFilter(key))\n  }, [blockNumber, chainId, state])\n\n  useEffect(() => {\n    if (!provider || !chainId || typeof blockNumber !== 'number' || filtersNeedFetch.length === 0) return\n\n    dispatch(fetchingLogs({ chainId, filters: filtersNeedFetch, blockNumber }))\n    filtersNeedFetch.forEach((filter) => {\n      // provide defaults if {from,to}Block are missing\n      let fromBlock = filter.fromBlock ?? 0\n      let toBlock = filter.toBlock ?? blockNumber\n      if (typeof fromBlock === 'string') fromBlock = Number.parseInt(fromBlock)\n      if (typeof toBlock === 'string') toBlock = Number.parseInt(toBlock)\n      provider\n        .getLogs({\n          ...filter,\n          fromBlock,\n          toBlock,\n        })\n        .then((logs) => {\n          dispatch(\n            fetchedLogs({\n              chainId,\n              filter,\n              results: { logs, blockNumber },\n            })\n          )\n        })\n        .catch((error) => {\n          console.error('Failed to get logs', filter, error)\n          dispatch(\n            fetchedLogsError({\n              chainId,\n              filter,\n              blockNumber,\n            })\n          )\n        })\n    })\n  }, [blockNumber, chainId, dispatch, filtersNeedFetch, provider])\n\n  return null\n}\n"],"mappings":";AACA,SAASA,YAAY,QAAQ,kBAAkB;AAC/C,OAAOC,cAAc,MAAM,0BAA0B;AACrD,SAASC,SAAS,EAAEC,OAAO,QAAQ,OAAO;AAE1C,SAASC,cAAc,EAAEC,cAAc,QAAQ,UAAU;AACzD,SAASC,WAAW,EAAEC,gBAAgB,EAAEC,YAAY,QAAQ,SAAS;AACrE,SAASC,eAAe,EAAEC,WAAW,QAAQ,SAAS;AAEtD,eAAe,SAASC,OAAO,GAAS;EAAA;EACtC,MAAMC,QAAQ,GAAGR,cAAc,EAAE;EACjC,MAAMS,KAAK,GAAGR,cAAc,CAAEQ,KAAK,IAAKA,KAAK,CAACC,IAAI,CAAC;EACnD,MAAM;IAAEC,OAAO;IAAEC;EAAS,CAAC,GAAGhB,YAAY,EAAE;EAE5C,MAAMiB,WAAW,GAAGhB,cAAc,EAAE;EAEpC,MAAMiB,gBAA0B,GAAGf,OAAO,CAAC,MAAM;IAC/C,IAAI,CAACY,OAAO,IAAI,OAAOE,WAAW,KAAK,QAAQ,EAAE,OAAO,EAAE;IAE1D,MAAME,MAAM,GAAGN,KAAK,CAACE,OAAO,CAAC;IAC7B,IAAI,CAACI,MAAM,EAAE,OAAO,EAAE;IAEtB,OAAOC,MAAM,CAACC,IAAI,CAACF,MAAM,CAAC,CACvBG,MAAM,CAAEC,GAAG,IAAK;MACf,MAAM;QAAEC,mBAAmB;QAAEC,OAAO;QAAEC;MAAU,CAAC,GAAGP,MAAM,CAACI,GAAG,CAAC;MAC/D,IAAIG,SAAS,KAAK,CAAC,EAAE,OAAO,KAAK;MACjC,IAAI,OAAOF,mBAAmB,KAAK,QAAQ,IAAIA,mBAAmB,IAAIP,WAAW,EAAE,OAAO,KAAK;MAC/F,IAAIQ,OAAO,IAAI,OAAOA,OAAO,CAACR,WAAW,KAAK,QAAQ,IAAIQ,OAAO,CAACR,WAAW,IAAIA,WAAW,EAAE,OAAO,KAAK;MAC1G;MACA,IAAIR,eAAe,CAACC,WAAW,CAACa,GAAG,CAAC,EAAEN,WAAW,CAAC,IAAI,CAAAQ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEX,IAAI,MAAKa,SAAS,EAAE,OAAO,KAAK;MAC/F,OAAO,IAAI;IACb,CAAC,CAAC,CACDC,GAAG,CAAEL,GAAG,IAAKb,WAAW,CAACa,GAAG,CAAC,CAAC;EACnC,CAAC,EAAE,CAACN,WAAW,EAAEF,OAAO,EAAEF,KAAK,CAAC,CAAC;EAEjCX,SAAS,CAAC,MAAM;IACd,IAAI,CAACc,QAAQ,IAAI,CAACD,OAAO,IAAI,OAAOE,WAAW,KAAK,QAAQ,IAAIC,gBAAgB,CAACW,MAAM,KAAK,CAAC,EAAE;IAE/FjB,QAAQ,CAACJ,YAAY,CAAC;MAAEO,OAAO;MAAEe,OAAO,EAAEZ,gBAAgB;MAAED;IAAY,CAAC,CAAC,CAAC;IAC3EC,gBAAgB,CAACa,OAAO,CAAET,MAAM,IAAK;MAAA;MACnC;MACA,IAAIU,SAAS,wBAAGV,MAAM,CAACU,SAAS,iEAAI,CAAC;MACrC,IAAIC,OAAO,sBAAGX,MAAM,CAACW,OAAO,6DAAIhB,WAAW;MAC3C,IAAI,OAAOe,SAAS,KAAK,QAAQ,EAAEA,SAAS,GAAGE,MAAM,CAACC,QAAQ,CAACH,SAAS,CAAC;MACzE,IAAI,OAAOC,OAAO,KAAK,QAAQ,EAAEA,OAAO,GAAGC,MAAM,CAACC,QAAQ,CAACF,OAAO,CAAC;MACnEjB,QAAQ,CACLoB,OAAO,CAAC;QACP,GAAGd,MAAM;QACTU,SAAS;QACTC;MACF,CAAC,CAAC,CACDI,IAAI,CAAEvB,IAAI,IAAK;QACdF,QAAQ,CACNN,WAAW,CAAC;UACVS,OAAO;UACPO,MAAM;UACNG,OAAO,EAAE;YAAEX,IAAI;YAAEG;UAAY;QAC/B,CAAC,CAAC,CACH;MACH,CAAC,CAAC,CACDqB,KAAK,CAAEC,KAAK,IAAK;QAChBC,OAAO,CAACD,KAAK,CAAC,oBAAoB,EAAEjB,MAAM,EAAEiB,KAAK,CAAC;QAClD3B,QAAQ,CACNL,gBAAgB,CAAC;UACfQ,OAAO;UACPO,MAAM;UACNL;QACF,CAAC,CAAC,CACH;MACH,CAAC,CAAC;IACN,CAAC,CAAC;EACJ,CAAC,EAAE,CAACA,WAAW,EAAEF,OAAO,EAAEH,QAAQ,EAAEM,gBAAgB,EAAEF,QAAQ,CAAC,CAAC;EAEhE,OAAO,IAAI;AACb;AAAC,GAjEuBL,OAAO;EAAA,QACZP,cAAc,EACjBC,cAAc,EACEL,YAAY,EAEtBC,cAAc;AAAA;AAAA,KALZU,OAAO;AAAA;AAAA"},"metadata":{},"sourceType":"module"}