{"ast":null,"code":"import { addNonEnumerableProperty } from './object.js';\nimport { snipLine } from './string.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nfunction uuid4() {\n  const gbl = GLOBAL_OBJ;\n  const crypto = gbl.crypto || gbl.msCrypto;\n  if (crypto && crypto.randomUUID) {\n    return crypto.randomUUID().replace(/-/g, '');\n  }\n  const getRandomByte = crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n  // eslint-disable-next-line no-bitwise\n  (c ^ (getRandomByte() & 15) >> c / 4).toString(16));\n}\nfunction getFirstException(event) {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const {\n    message,\n    event_id: eventId\n  } = event;\n  if (message) {\n    return message;\n  }\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  const exception = event.exception = event.exception || {};\n  const values = exception.values = exception.values || [];\n  const firstException = values[0] = values[0] || {};\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n  const defaultMechanism = {\n    type: 'generic',\n    handled: true\n  };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = {\n    ...defaultMechanism,\n    ...currentMechanism,\n    ...newMechanism\n  };\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = {\n      ...(currentMechanism && currentMechanism.data),\n      ...newMechanism.data\n    };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = parseInt(match[1], 10);\n  const minor = parseInt(match[2], 10);\n  const patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4]\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame) {\n  let linesOfContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  const lineno = frame.lineno || 0;\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n  frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map(line => snipLine(line, 0));\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n  frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map(line => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (exception && exception.__sentry_captured__) {\n    return true;\n  }\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception, '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nfunction arrayify(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\nexport { addContextToFrame, addExceptionMechanism, addExceptionTypeValue, arrayify, checkOrSetAlreadyCaught, getEventDescription, parseSemver, uuid4 };","map":{"version":3,"sources":["../../src/misc.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Event, Exception, Mechanism, StackFrame } from '@sentry/types';\n\nimport { addNonEnumerableProperty } from './object';\nimport { snipLine } from './string';\nimport { GLOBAL_OBJ } from './worldwide';\n\ninterface CryptoInternal {\n  getRandomValues(array: Uint8Array): Uint8Array;\n  randomUUID?(): string;\n}\n\n/** An interface for common properties on global */\ninterface CryptoGlobal {\n  msCrypto?: CryptoInternal;\n  crypto?: CryptoInternal;\n}\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */\nexport function uuid4(): string {\n  const gbl = GLOBAL_OBJ as typeof GLOBAL_OBJ & CryptoGlobal;\n  const crypto = gbl.crypto || gbl.msCrypto;\n\n  if (crypto && crypto.randomUUID) {\n    return crypto.randomUUID().replace(/-/g, '');\n  }\n\n  const getRandomByte =\n    crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n  return (([1e7] as unknown as string) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>\n    // eslint-disable-next-line no-bitwise\n    ((c as unknown as number) ^ ((getRandomByte() & 15) >> ((c as unknown as number) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event: Event): Exception | undefined {\n  return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nexport function getEventDescription(event: Event): string {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nexport function addExceptionTypeValue(event: Event, value?: string, type?: string): void {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nexport function addExceptionMechanism(event: Event, newMechanism?: Partial<Mechanism>): void {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\ninterface SemVer {\n  major?: number;\n  minor?: number;\n  patch?: number;\n  prerelease?: string;\n  buildmetadata?: string;\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nexport function parseSemver(input: string): SemVer {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = parseInt(match[1], 10);\n  const minor = parseInt(match[2], 10);\n  const patch = parseInt(match[3], 10);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nexport function addContextToFrame(lines: string[], frame: StackFrame, linesOfContext: number = 5): void {\n  const lineno = frame.lineno || 0;\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line: string) => snipLine(line, 0));\n\n  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line: string) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nexport function checkOrSetAlreadyCaught(exception: unknown): boolean {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (exception && (exception as any).__sentry_captured__) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception as { [key: string]: unknown }, '__sentry_captured__', true);\n  } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */\nexport function arrayify<T = unknown>(maybeArray: T | T[]): T[] {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n"]},"metadata":{},"sourceType":"module"}