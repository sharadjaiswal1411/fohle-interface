{"ast":null,"code":"import _objectSpread from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _taggedTemplateLiteral from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";import _asyncToGenerator from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";var _templateObject,_templateObject2;import{Token}from'@uniswap/sdk-core';import{TickMath,tickToPrice}from'@uniswap/v3-sdk';import gql from'graphql-tag';import JSBI from'jsbi';import keyBy from'lodash.keyby';var PRICE_FIXED_DIGITS=4;var DEFAULT_SURROUNDING_TICKS=300;var FEE_TIER_TO_TICK_SPACING=function FEE_TIER_TO_TICK_SPACING(feeTier){switch(feeTier){case'10000':return 200;case'3000':return 60;case'500':return 10;case'100':return 1;default:throw Error(\"Tick spacing for fee tier \".concat(feeTier,\" undefined.\"));}};var fetchInitializedTicks=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(poolAddress,tickIdxLowerBound,tickIdxUpperBound,client){var tickQuery,surroundingTicks,surroundingTicksResult,skip,_yield$client$query,data,error,loading;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:tickQuery=gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n    query surroundingTicks(\\n      $poolAddress: String!\\n      $tickIdxLowerBound: BigInt!\\n      $tickIdxUpperBound: BigInt!\\n      $skip: Int!\\n    ) {\\n      ticks(\\n        subgraphError: allow\\n        first: 1000\\n        skip: $skip\\n        where: { poolAddress: $poolAddress, tickIdx_lte: $tickIdxUpperBound, tickIdx_gte: $tickIdxLowerBound }\\n      ) {\\n        tickIdx\\n        liquidityGross\\n        liquidityNet\\n        price0\\n        price1\\n      }\\n    }\\n  \"])));surroundingTicks=[];surroundingTicksResult=[];skip=0;case 4:_context.next=6;return client.query({query:tickQuery,fetchPolicy:'cache-first',variables:{poolAddress:poolAddress,tickIdxLowerBound:tickIdxLowerBound,tickIdxUpperBound:tickIdxUpperBound,skip:skip}});case 6:_yield$client$query=_context.sent;data=_yield$client$query.data;error=_yield$client$query.error;loading=_yield$client$query.loading;if(!loading){_context.next=12;break;}return _context.abrupt(\"continue\",17);case 12:if(!error){_context.next=14;break;}return _context.abrupt(\"return\",{error:Boolean(error),loading:loading,ticks:surroundingTicksResult});case 14:surroundingTicks=data.ticks;surroundingTicksResult=surroundingTicksResult.concat(surroundingTicks);skip+=1000;case 17:if(surroundingTicks.length>0){_context.next=4;break;}case 18:return _context.abrupt(\"return\",{ticks:surroundingTicksResult,loading:false,error:false});case 19:case\"end\":return _context.stop();}}},_callee);}));return function fetchInitializedTicks(_x,_x2,_x3,_x4){return _ref.apply(this,arguments);};}();var poolQuery=gql(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"\\n  query pool($poolAddress: String!) {\\n    pool(id: $poolAddress) {\\n      tick\\n      token0 {\\n        symbol\\n        id\\n        decimals\\n      }\\n      token1 {\\n        symbol\\n        id\\n        decimals\\n      }\\n      feeTier\\n      sqrtPrice\\n      liquidity\\n    }\\n  }\\n\"])));export var fetchTicksSurroundingPrice=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(poolAddress,client){var numSurroundingTicks,_yield$client$query2,poolResult,error,loading,_poolResult$pool,poolCurrentTick,feeTier,liquidity,_poolResult$pool$toke,token0Address,token0Decimals,_poolResult$pool$toke2,token1Address,token1Decimals,poolCurrentTickIdx,tickSpacing,activeTickIdx,tickIdxLowerBound,tickIdxUpperBound,initializedTicksResult,initializedTicks,tickIdxToInitializedTick,token0,token1,activeTickIdxForPrice,activeTickProcessed,activeTick,Direction,computeSurroundingTicks,subsequentTicks,previousTicks,ticksProcessed,_args2=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:numSurroundingTicks=_args2.length>2&&_args2[2]!==undefined?_args2[2]:DEFAULT_SURROUNDING_TICKS;_context2.next=3;return client.query({query:poolQuery,variables:{poolAddress:poolAddress}});case 3:_yield$client$query2=_context2.sent;poolResult=_yield$client$query2.data;error=_yield$client$query2.error;loading=_yield$client$query2.loading;if(!(loading||error||!poolResult)){_context2.next=9;break;}return _context2.abrupt(\"return\",{loading:loading,error:Boolean(error),data:undefined});case 9:_poolResult$pool=poolResult.pool,poolCurrentTick=_poolResult$pool.tick,feeTier=_poolResult$pool.feeTier,liquidity=_poolResult$pool.liquidity,_poolResult$pool$toke=_poolResult$pool.token0,token0Address=_poolResult$pool$toke.id,token0Decimals=_poolResult$pool$toke.decimals,_poolResult$pool$toke2=_poolResult$pool.token1,token1Address=_poolResult$pool$toke2.id,token1Decimals=_poolResult$pool$toke2.decimals;poolCurrentTickIdx=parseInt(poolCurrentTick);tickSpacing=FEE_TIER_TO_TICK_SPACING(feeTier);// The pools current tick isn't necessarily a tick that can actually be initialized.\n// Find the nearest valid tick given the tick spacing.\nactiveTickIdx=Math.floor(poolCurrentTickIdx/tickSpacing)*tickSpacing;// Our search bounds must take into account fee spacing. i.e. for fee tier 1%, only\n// ticks with index 200, 400, 600, etc can be active.\ntickIdxLowerBound=activeTickIdx-numSurroundingTicks*tickSpacing;tickIdxUpperBound=activeTickIdx+numSurroundingTicks*tickSpacing;_context2.next=17;return fetchInitializedTicks(poolAddress,tickIdxLowerBound,tickIdxUpperBound,client);case 17:initializedTicksResult=_context2.sent;if(!(initializedTicksResult.error||initializedTicksResult.loading)){_context2.next=20;break;}return _context2.abrupt(\"return\",{error:initializedTicksResult.error,loading:initializedTicksResult.loading});case 20:initializedTicks=initializedTicksResult.ticks;tickIdxToInitializedTick=keyBy(initializedTicks,'tickIdx');token0=new Token(1,token0Address,parseInt(token0Decimals));token1=new Token(1,token1Address,parseInt(token1Decimals));// console.log({ activeTickIdx, poolCurrentTickIdx }, 'Active ticks')\n// If the pool's tick is MIN_TICK (-887272), then when we find the closest\n// initializable tick to its left, the value would be smaller than MIN_TICK.\n// In this case we must ensure that the prices shown never go below/above.\n// what actual possible from the protocol.\nactiveTickIdxForPrice=activeTickIdx;if(activeTickIdxForPrice<TickMath.MIN_TICK){activeTickIdxForPrice=TickMath.MIN_TICK;}if(activeTickIdxForPrice>TickMath.MAX_TICK){activeTickIdxForPrice=TickMath.MAX_TICK;}activeTickProcessed={liquidityActive:JSBI.BigInt(liquidity),tickIdx:activeTickIdx,liquidityNet:JSBI.BigInt(0),price0:tickToPrice(token0,token1,activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),price1:tickToPrice(token1,token0,activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),liquidityGross:JSBI.BigInt(0)};// If our active tick happens to be initialized (i.e. there is a position that starts or\n// ends at that tick), ensure we set the gross and net.\n// correctly.\nactiveTick=tickIdxToInitializedTick[activeTickIdx];if(activeTick){activeTickProcessed.liquidityGross=JSBI.BigInt(activeTick.liquidityGross);activeTickProcessed.liquidityNet=JSBI.BigInt(activeTick.liquidityNet);}(function(Direction){Direction[Direction[\"ASC\"]=0]=\"ASC\";Direction[Direction[\"DESC\"]=1]=\"DESC\";})(Direction||(Direction={}));// Computes the numSurroundingTicks above or below the active tick.\ncomputeSurroundingTicks=function computeSurroundingTicks(activeTickProcessed,tickSpacing,numSurroundingTicks,direction){var previousTickProcessed=_objectSpread({},activeTickProcessed);// Iterate outwards (either up or down depending on 'Direction') from the active tick,\n// building active liquidity for every tick.\nvar processedTicks=[];for(var i=0;i<numSurroundingTicks;i++){var currentTickIdx=direction==Direction.ASC?previousTickProcessed.tickIdx+tickSpacing:previousTickProcessed.tickIdx-tickSpacing;if(currentTickIdx<TickMath.MIN_TICK||currentTickIdx>TickMath.MAX_TICK){break;}var currentTickProcessed={liquidityActive:previousTickProcessed.liquidityActive,tickIdx:currentTickIdx,liquidityNet:JSBI.BigInt(0),price0:tickToPrice(token0,token1,currentTickIdx).toFixed(PRICE_FIXED_DIGITS),price1:tickToPrice(token1,token0,currentTickIdx).toFixed(PRICE_FIXED_DIGITS),liquidityGross:JSBI.BigInt(0)};// Check if there is an initialized tick at our current tick.\n// If so copy the gross and net liquidity from the initialized tick.\nvar currentInitializedTick=tickIdxToInitializedTick[currentTickIdx.toString()];if(currentInitializedTick){currentTickProcessed.liquidityGross=JSBI.BigInt(currentInitializedTick.liquidityGross);currentTickProcessed.liquidityNet=JSBI.BigInt(currentInitializedTick.liquidityNet);}// Update the active liquidity.\n// If we are iterating ascending and we found an initialized tick we immediately apply\n// it to the current processed tick we are building.\n// If we are iterating descending, we don't want to apply the net liquidity until the following tick.\nif(direction==Direction.ASC&&currentInitializedTick){currentTickProcessed.liquidityActive=JSBI.add(previousTickProcessed.liquidityActive,JSBI.BigInt(currentInitializedTick.liquidityNet));}else if(direction==Direction.DESC&&JSBI.notEqual(previousTickProcessed.liquidityNet,JSBI.BigInt(0))){// We are iterating descending, so look at the previous tick and apply any net liquidity.\ncurrentTickProcessed.liquidityActive=JSBI.subtract(previousTickProcessed.liquidityActive,previousTickProcessed.liquidityNet);}processedTicks.push(currentTickProcessed);previousTickProcessed=currentTickProcessed;}if(direction==Direction.DESC){processedTicks=processedTicks.reverse();}return processedTicks;};subsequentTicks=computeSurroundingTicks(activeTickProcessed,tickSpacing,numSurroundingTicks,Direction.ASC);previousTicks=computeSurroundingTicks(activeTickProcessed,tickSpacing,numSurroundingTicks,Direction.DESC);ticksProcessed=previousTicks.concat(activeTickProcessed).concat(subsequentTicks);return _context2.abrupt(\"return\",{data:{ticksProcessed:ticksProcessed,feeTier:feeTier,tickSpacing:tickSpacing,activeTickIdx:activeTickIdx}});case 36:case\"end\":return _context2.stop();}}},_callee2);}));return function fetchTicksSurroundingPrice(_x5,_x6){return _ref2.apply(this,arguments);};}();","map":{"version":3,"names":["Token","TickMath","tickToPrice","gql","JSBI","keyBy","PRICE_FIXED_DIGITS","DEFAULT_SURROUNDING_TICKS","FEE_TIER_TO_TICK_SPACING","feeTier","Error","fetchInitializedTicks","poolAddress","tickIdxLowerBound","tickIdxUpperBound","client","tickQuery","surroundingTicks","surroundingTicksResult","skip","query","fetchPolicy","variables","data","error","loading","Boolean","ticks","concat","length","poolQuery","fetchTicksSurroundingPrice","numSurroundingTicks","poolResult","undefined","pool","poolCurrentTick","tick","liquidity","token0","token0Address","id","token0Decimals","decimals","token1","token1Address","token1Decimals","poolCurrentTickIdx","parseInt","tickSpacing","activeTickIdx","Math","floor","initializedTicksResult","initializedTicks","tickIdxToInitializedTick","activeTickIdxForPrice","MIN_TICK","MAX_TICK","activeTickProcessed","liquidityActive","BigInt","tickIdx","liquidityNet","price0","toFixed","price1","liquidityGross","activeTick","Direction","computeSurroundingTicks","direction","previousTickProcessed","processedTicks","i","currentTickIdx","ASC","currentTickProcessed","currentInitializedTick","toString","add","DESC","notEqual","subtract","push","reverse","subsequentTicks","previousTicks","ticksProcessed"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/data/pools/tickData.ts"],"sourcesContent":["import { ApolloClient, NormalizedCacheObject } from '@apollo/client'\nimport { Token } from '@uniswap/sdk-core'\nimport { TickMath, tickToPrice } from '@uniswap/v3-sdk'\nimport gql from 'graphql-tag'\nimport JSBI from 'jsbi'\nimport keyBy from 'lodash.keyby'\n\nconst PRICE_FIXED_DIGITS = 4\nconst DEFAULT_SURROUNDING_TICKS = 300\nconst FEE_TIER_TO_TICK_SPACING = (feeTier: string): number => {\n  switch (feeTier) {\n    case '10000':\n      return 200\n    case '3000':\n      return 60\n    case '500':\n      return 10\n    case '100':\n      return 1\n    default:\n      throw Error(`Tick spacing for fee tier ${feeTier} undefined.`)\n  }\n}\n\ninterface TickPool {\n  tick: string\n  feeTier: string\n  token0: {\n    symbol: string\n    id: string\n    decimals: string\n  }\n  token1: {\n    symbol: string\n    id: string\n    decimals: string\n  }\n  sqrtPrice: string\n  liquidity: string\n}\n\ninterface PoolResult {\n  pool: TickPool\n}\n\n// Raw tick returned from GQL\ninterface Tick {\n  tickIdx: string\n  liquidityGross: string\n  liquidityNet: string\n  price0: string\n  price1: string\n}\n\ninterface SurroundingTicksResult {\n  ticks: Tick[]\n}\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\nexport interface TickProcessed {\n  liquidityGross: JSBI\n  liquidityNet: JSBI\n  tickIdx: number\n  liquidityActive: JSBI\n  price0: string\n  price1: string\n}\n\nconst fetchInitializedTicks = async (\n  poolAddress: string,\n  tickIdxLowerBound: number,\n  tickIdxUpperBound: number,\n  client: ApolloClient<NormalizedCacheObject>\n): Promise<{ loading?: boolean; error?: boolean; ticks?: Tick[] }> => {\n  const tickQuery = gql`\n    query surroundingTicks(\n      $poolAddress: String!\n      $tickIdxLowerBound: BigInt!\n      $tickIdxUpperBound: BigInt!\n      $skip: Int!\n    ) {\n      ticks(\n        subgraphError: allow\n        first: 1000\n        skip: $skip\n        where: { poolAddress: $poolAddress, tickIdx_lte: $tickIdxUpperBound, tickIdx_gte: $tickIdxLowerBound }\n      ) {\n        tickIdx\n        liquidityGross\n        liquidityNet\n        price0\n        price1\n      }\n    }\n  `\n\n  let surroundingTicks: Tick[] = []\n  let surroundingTicksResult: Tick[] = []\n  let skip = 0\n  do {\n    const { data, error, loading } = await client.query<SurroundingTicksResult>({\n      query: tickQuery,\n      fetchPolicy: 'cache-first',\n      variables: {\n        poolAddress,\n        tickIdxLowerBound,\n        tickIdxUpperBound,\n        skip,\n      },\n    })\n\n    // console.log({ data, error, loading }, 'Result. Skip: ' + skip)\n\n    if (loading) {\n      continue\n    }\n\n    if (error) {\n      return { error: Boolean(error), loading, ticks: surroundingTicksResult }\n    }\n\n    surroundingTicks = data.ticks\n    surroundingTicksResult = surroundingTicksResult.concat(surroundingTicks)\n    skip += 1000\n  } while (surroundingTicks.length > 0)\n\n  return { ticks: surroundingTicksResult, loading: false, error: false }\n}\n\nexport interface PoolTickData {\n  ticksProcessed: TickProcessed[]\n  feeTier: string\n  tickSpacing: number\n  activeTickIdx: number\n}\n\nconst poolQuery = gql`\n  query pool($poolAddress: String!) {\n    pool(id: $poolAddress) {\n      tick\n      token0 {\n        symbol\n        id\n        decimals\n      }\n      token1 {\n        symbol\n        id\n        decimals\n      }\n      feeTier\n      sqrtPrice\n      liquidity\n    }\n  }\n`\n\nexport const fetchTicksSurroundingPrice = async (\n  poolAddress: string,\n  client: ApolloClient<NormalizedCacheObject>,\n  numSurroundingTicks = DEFAULT_SURROUNDING_TICKS\n): Promise<{\n  loading?: boolean\n  error?: boolean\n  data?: PoolTickData\n}> => {\n  const {\n    data: poolResult,\n    error,\n    loading,\n  } = await client.query<PoolResult>({\n    query: poolQuery,\n    variables: {\n      poolAddress,\n    },\n  })\n\n  if (loading || error || !poolResult) {\n    return {\n      loading,\n      error: Boolean(error),\n      data: undefined,\n    }\n  }\n\n  const {\n    pool: {\n      tick: poolCurrentTick,\n      feeTier,\n      liquidity,\n      token0: { id: token0Address, decimals: token0Decimals },\n      token1: { id: token1Address, decimals: token1Decimals },\n    },\n  } = poolResult\n\n  const poolCurrentTickIdx = parseInt(poolCurrentTick)\n  const tickSpacing = FEE_TIER_TO_TICK_SPACING(feeTier)\n\n  // The pools current tick isn't necessarily a tick that can actually be initialized.\n  // Find the nearest valid tick given the tick spacing.\n  const activeTickIdx = Math.floor(poolCurrentTickIdx / tickSpacing) * tickSpacing\n\n  // Our search bounds must take into account fee spacing. i.e. for fee tier 1%, only\n  // ticks with index 200, 400, 600, etc can be active.\n  const tickIdxLowerBound = activeTickIdx - numSurroundingTicks * tickSpacing\n  const tickIdxUpperBound = activeTickIdx + numSurroundingTicks * tickSpacing\n\n  const initializedTicksResult = await fetchInitializedTicks(poolAddress, tickIdxLowerBound, tickIdxUpperBound, client)\n  if (initializedTicksResult.error || initializedTicksResult.loading) {\n    return {\n      error: initializedTicksResult.error,\n      loading: initializedTicksResult.loading,\n    }\n  }\n\n  const { ticks: initializedTicks } = initializedTicksResult\n\n  const tickIdxToInitializedTick = keyBy(initializedTicks, 'tickIdx')\n\n  const token0 = new Token(1, token0Address, parseInt(token0Decimals))\n  const token1 = new Token(1, token1Address, parseInt(token1Decimals))\n\n  // console.log({ activeTickIdx, poolCurrentTickIdx }, 'Active ticks')\n\n  // If the pool's tick is MIN_TICK (-887272), then when we find the closest\n  // initializable tick to its left, the value would be smaller than MIN_TICK.\n  // In this case we must ensure that the prices shown never go below/above.\n  // what actual possible from the protocol.\n  let activeTickIdxForPrice = activeTickIdx\n  if (activeTickIdxForPrice < TickMath.MIN_TICK) {\n    activeTickIdxForPrice = TickMath.MIN_TICK\n  }\n  if (activeTickIdxForPrice > TickMath.MAX_TICK) {\n    activeTickIdxForPrice = TickMath.MAX_TICK\n  }\n\n  const activeTickProcessed: TickProcessed = {\n    liquidityActive: JSBI.BigInt(liquidity),\n    tickIdx: activeTickIdx,\n    liquidityNet: JSBI.BigInt(0),\n    price0: tickToPrice(token0, token1, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),\n    price1: tickToPrice(token1, token0, activeTickIdxForPrice).toFixed(PRICE_FIXED_DIGITS),\n    liquidityGross: JSBI.BigInt(0),\n  }\n\n  // If our active tick happens to be initialized (i.e. there is a position that starts or\n  // ends at that tick), ensure we set the gross and net.\n  // correctly.\n  const activeTick = tickIdxToInitializedTick[activeTickIdx]\n  if (activeTick) {\n    activeTickProcessed.liquidityGross = JSBI.BigInt(activeTick.liquidityGross)\n    activeTickProcessed.liquidityNet = JSBI.BigInt(activeTick.liquidityNet)\n  }\n\n  enum Direction {\n    ASC,\n    DESC,\n  }\n\n  // Computes the numSurroundingTicks above or below the active tick.\n  const computeSurroundingTicks = (\n    activeTickProcessed: TickProcessed,\n    tickSpacing: number,\n    numSurroundingTicks: number,\n    direction: Direction\n  ) => {\n    let previousTickProcessed: TickProcessed = {\n      ...activeTickProcessed,\n    }\n\n    // Iterate outwards (either up or down depending on 'Direction') from the active tick,\n    // building active liquidity for every tick.\n    let processedTicks: TickProcessed[] = []\n    for (let i = 0; i < numSurroundingTicks; i++) {\n      const currentTickIdx =\n        direction == Direction.ASC\n          ? previousTickProcessed.tickIdx + tickSpacing\n          : previousTickProcessed.tickIdx - tickSpacing\n\n      if (currentTickIdx < TickMath.MIN_TICK || currentTickIdx > TickMath.MAX_TICK) {\n        break\n      }\n\n      const currentTickProcessed: TickProcessed = {\n        liquidityActive: previousTickProcessed.liquidityActive,\n        tickIdx: currentTickIdx,\n        liquidityNet: JSBI.BigInt(0),\n        price0: tickToPrice(token0, token1, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),\n        price1: tickToPrice(token1, token0, currentTickIdx).toFixed(PRICE_FIXED_DIGITS),\n        liquidityGross: JSBI.BigInt(0),\n      }\n\n      // Check if there is an initialized tick at our current tick.\n      // If so copy the gross and net liquidity from the initialized tick.\n      const currentInitializedTick = tickIdxToInitializedTick[currentTickIdx.toString()]\n      if (currentInitializedTick) {\n        currentTickProcessed.liquidityGross = JSBI.BigInt(currentInitializedTick.liquidityGross)\n        currentTickProcessed.liquidityNet = JSBI.BigInt(currentInitializedTick.liquidityNet)\n      }\n\n      // Update the active liquidity.\n      // If we are iterating ascending and we found an initialized tick we immediately apply\n      // it to the current processed tick we are building.\n      // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n      if (direction == Direction.ASC && currentInitializedTick) {\n        currentTickProcessed.liquidityActive = JSBI.add(\n          previousTickProcessed.liquidityActive,\n          JSBI.BigInt(currentInitializedTick.liquidityNet)\n        )\n      } else if (direction == Direction.DESC && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n        // We are iterating descending, so look at the previous tick and apply any net liquidity.\n        currentTickProcessed.liquidityActive = JSBI.subtract(\n          previousTickProcessed.liquidityActive,\n          previousTickProcessed.liquidityNet\n        )\n      }\n\n      processedTicks.push(currentTickProcessed)\n      previousTickProcessed = currentTickProcessed\n    }\n\n    if (direction == Direction.DESC) {\n      processedTicks = processedTicks.reverse()\n    }\n\n    return processedTicks\n  }\n\n  const subsequentTicks: TickProcessed[] = computeSurroundingTicks(\n    activeTickProcessed,\n    tickSpacing,\n    numSurroundingTicks,\n    Direction.ASC\n  )\n\n  const previousTicks: TickProcessed[] = computeSurroundingTicks(\n    activeTickProcessed,\n    tickSpacing,\n    numSurroundingTicks,\n    Direction.DESC\n  )\n\n  const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)\n\n  return {\n    data: {\n      ticksProcessed,\n      feeTier,\n      tickSpacing,\n      activeTickIdx,\n    },\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}