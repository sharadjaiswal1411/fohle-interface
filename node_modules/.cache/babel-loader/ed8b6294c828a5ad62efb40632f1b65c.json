{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);\n    }\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: (0, codegen_1.stringify)(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n};\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n  function callSyncRef() {\n    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n  }\n  function addErrorsFrom(source) {\n    const errs = (0, codegen_1._)`${source}.errors`;\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n    gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n  }\n  function addEvaluatedFrom(source) {\n    var _a;\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", (0, codegen_1._)`${source}.evaluated.props`);\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", (0, codegen_1._)`${source}.evaluated.items`);\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/core/ref.ts"],"names":[],"mappings":";;;;;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAEA,MAAM,GAAG,GAA0B;EACjC,OAAO,EAAE,MAAM;EACf,UAAU,EAAE,QAAQ;EACpB,IAAI,CAAC,GAAe,EAAA;IAClB,MAAM;MAAC,GAAG;MAAE,MAAM,EAAE,IAAI;MAAE;IAAE,CAAC,GAAG,GAAG;IACnC,MAAM;MAAC,MAAM;MAAE,SAAS,EAAE,GAAG;MAAE,YAAY;MAAE,IAAI;MAAE;IAAI,CAAC,GAAG,EAAE;IAC7D,MAAM;MAAC;IAAI,CAAC,GAAG,GAAG;IAClB,IAAI,CAAC,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE,OAAO,WAAW,EAAE;IACnF,MAAM,QAAQ,GAAG,SAAA,CAAA,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC;IAC1D,IAAI,QAAQ,KAAK,SAAS,EAAE,MAAM,IAAI,WAAA,CAAA,OAAe,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,CAAC;IACxF,IAAI,QAAQ,YAAY,SAAA,CAAA,SAAS,EAAE,OAAO,YAAY,CAAC,QAAQ,CAAC;IAChE,OAAO,eAAe,CAAC,QAAQ,CAAC;IAEhC,SAAS,WAAW,GAAA;MAClB,IAAI,GAAG,KAAK,IAAI,EAAE,OAAO,OAAO,CAAC,GAAG,EAAE,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC;MACpE,MAAM,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE;QAAC,GAAG,EAAE;MAAI,CAAC,CAAC;MACpD,OAAO,OAAO,CAAC,GAAG,EAAE,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,QAAQ,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC;IACjE;IAEA,SAAS,YAAY,CAAC,GAAc,EAAA;MAClC,MAAM,CAAC,GAAG,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC;MAC/B,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC;IAClC;IAEA,SAAS,eAAe,CAAC,GAAc,EAAA;MACrC,MAAM,OAAO,GAAG,GAAG,CAAC,UAAU,CAC5B,QAAQ,EACR,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,IAAI,GAAG;QAAC,GAAG,EAAE,GAAG;QAAE,IAAI,EAAE,CAAA,CAAA,EAAA,SAAA,CAAA,SAAS,EAAC,GAAG;MAAC,CAAC,GAAG;QAAC,GAAG,EAAE;MAAG,CAAC,CAC1E;MACD,MAAM,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;MAC/B,MAAM,MAAM,GAAG,GAAG,CAAC,SAAS,CAC1B;QACE,MAAM,EAAE,GAAG;QACX,SAAS,EAAE,EAAE;QACb,UAAU,EAAE,SAAA,CAAA,GAAG;QACf,YAAY,EAAE,OAAO;QACrB,aAAa,EAAE;OAChB,EACD,KAAK,CACN;MACD,GAAG,CAAC,cAAc,CAAC,MAAM,CAAC;MAC1B,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC;IACf;EACF;CACD;AAED,SAAgB,WAAW,CAAC,GAAe,EAAE,GAAc,EAAA;EACzD,MAAM;IAAC;EAAG,CAAC,GAAG,GAAG;EACjB,OAAO,GAAG,CAAC,QAAQ,GACf,GAAG,CAAC,UAAU,CAAC,UAAU,EAAE;IAAC,GAAG,EAAE,GAAG,CAAC;EAAQ,CAAC,CAAC,GAC/C,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,GAAG,CAAC,UAAU,CAAC,SAAS,EAAE;IAAC,GAAG,EAAE;EAAG,CAAC,CAAC,WAAW;AAC1D;AALA,OAAA,CAAA,WAAA,GAAA,WAAA;AAOA,SAAgB,OAAO,CAAC,GAAe,EAAE,CAAO,EAAE,GAAe,EAAE,MAAgB,EAAA;EACjF,MAAM;IAAC,GAAG;IAAE;EAAE,CAAC,GAAG,GAAG;EACrB,MAAM;IAAC,SAAS;IAAE,SAAS,EAAE,GAAG;IAAE;EAAI,CAAC,GAAG,EAAE;EAC5C,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,GAAG,OAAA,CAAA,OAAC,CAAC,IAAI,GAAG,SAAA,CAAA,GAAG;EAC/C,IAAI,MAAM,EAAE,YAAY,EAAE,CAAA,KACrB,WAAW,EAAE;EAElB,SAAS,YAAY,GAAA;IACnB,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC;IAC1E,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC;IAC9B,GAAG,CAAC,GAAG,CACL,MAAK;MACH,GAAG,CAAC,IAAI,CAAC,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,SAAS,CAAA,CAAA,EAAA,MAAA,CAAA,gBAAgB,EAAC,GAAG,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC;MACvD,gBAAgB,CAAC,CAAC,CAAC,CAAA,CAAC;MACpB,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC;IACzC,CAAC,EACA,CAAC,IAAI;MACJ,GAAG,CAAC,EAAE,CAAC,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,KAAK,CAAC,eAAe,EAAE,CAAC,eAAuB,GAAG,EAAE,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;MAC/E,aAAa,CAAC,CAAC,CAAC;MAChB,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC;IAC1C,CAAC,CACF;IACD,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC;EACf;EAEA,SAAS,WAAW,GAAA;IAClB,GAAG,CAAC,MAAM,CACR,CAAA,CAAA,EAAA,MAAA,CAAA,gBAAgB,EAAC,GAAG,EAAE,CAAC,EAAE,OAAO,CAAC,EACjC,MAAM,gBAAgB,CAAC,CAAC,CAAC,EACzB,MAAM,aAAa,CAAC,CAAC,CAAC,CACvB;EACH;EAEA,SAAS,aAAa,CAAC,MAAY,EAAA;IACjC,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,MAAM,SAAS;IAChC,GAAG,CAAC,MAAM,CAAC,OAAA,CAAA,OAAC,CAAC,OAAO,EAAE,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,OAAA,CAAA,OAAC,CAAC,OAAO,eAAe,IAAI,MAAM,OAAA,CAAA,OAAC,CAAC,OAAO,WAAW,IAAI,GAAG,CAAC,CAAA,CAAC;IACzF,GAAG,CAAC,MAAM,CAAC,OAAA,CAAA,OAAC,CAAC,MAAM,EAAE,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,OAAA,CAAA,OAAC,CAAC,OAAO,SAAS,CAAC;EAC9C;EAEA,SAAS,gBAAgB,CAAC,MAAY,EAAA;;IACpC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,EAAE;IAC1B,MAAM,YAAY,GAAG,CAAA,EAAA,GAAA,GAAG,KAAA,IAAA,IAAH,GAAG,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAH,GAAG,CAAE,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,SAAS;IAC7C;IACA,IAAI,EAAE,CAAC,KAAK,KAAK,IAAI,EAAE;MACrB,IAAI,YAAY,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;QAC9C,IAAI,YAAY,CAAC,KAAK,KAAK,SAAS,EAAE;UACpC,EAAE,CAAC,KAAK,GAAG,MAAA,CAAA,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,YAAY,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC;QACnE;OACF,MAAM;QACL,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,EAAE,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,MAAM,kBAAkB,CAAC;QAC5D,EAAE,CAAC,KAAK,GAAG,MAAA,CAAA,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,KAAK,EAAE,SAAA,CAAA,IAAI,CAAC;MAC5D;IACF;IACD,IAAI,EAAE,CAAC,KAAK,KAAK,IAAI,EAAE;MACrB,IAAI,YAAY,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE;QAC9C,IAAI,YAAY,CAAC,KAAK,KAAK,SAAS,EAAE;UACpC,EAAE,CAAC,KAAK,GAAG,MAAA,CAAA,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,YAAY,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC;QACnE;OACF,MAAM;QACL,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,EAAE,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,MAAM,kBAAkB,CAAC;QAC5D,EAAE,CAAC,KAAK,GAAG,MAAA,CAAA,cAAc,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,KAAK,EAAE,SAAA,CAAA,IAAI,CAAC;MAC5D;IACF;EACH;AACF;AAhEA,OAAA,CAAA,OAAA,GAAA,OAAA;AAkEA,OAAA,CAAA,OAAA,GAAe,GAAG","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map"]},"metadata":{},"sourceType":"script"}