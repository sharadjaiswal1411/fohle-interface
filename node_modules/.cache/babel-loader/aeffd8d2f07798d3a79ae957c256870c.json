{"ast":null,"code":"import _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { encodeMixedRouteToPath, MixedRouteSDK, Protocol } from '@uniswap/router-sdk';\nimport { encodeRouteToPath } from '@uniswap/v3-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport stats from 'stats-lite';\nimport { V2Route } from '../routers/router';\nimport { IMixedRouteQuoterV1__factory } from '../types/other/factories/IMixedRouteQuoterV1__factory';\nimport { IQuoterV2__factory } from '../types/v3/factories/IQuoterV2__factory';\nimport { ChainId, metric, MetricLoggerUnit } from '../util';\nimport { MIXED_ROUTE_QUOTER_V1_ADDRESSES, QUOTER_V2_ADDRESSES } from '../util/addresses';\nimport { log } from '../util/log';\nimport { routeToString } from '../util/routes';\nexport var BlockConflictError = /*#__PURE__*/function (_Error) {\n  _inherits(BlockConflictError, _Error);\n  var _super = _createSuper(BlockConflictError);\n  function BlockConflictError() {\n    var _this;\n    _classCallCheck(this, BlockConflictError);\n    _this = _super.apply(this, arguments);\n    _this.name = 'BlockConflictError';\n    return _this;\n  }\n  return _createClass(BlockConflictError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var SuccessRateError = /*#__PURE__*/function (_Error2) {\n  _inherits(SuccessRateError, _Error2);\n  var _super2 = _createSuper(SuccessRateError);\n  function SuccessRateError() {\n    var _this2;\n    _classCallCheck(this, SuccessRateError);\n    _this2 = _super2.apply(this, arguments);\n    _this2.name = 'SuccessRateError';\n    return _this2;\n  }\n  return _createClass(SuccessRateError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var ProviderBlockHeaderError = /*#__PURE__*/function (_Error3) {\n  _inherits(ProviderBlockHeaderError, _Error3);\n  var _super3 = _createSuper(ProviderBlockHeaderError);\n  function ProviderBlockHeaderError() {\n    var _this3;\n    _classCallCheck(this, ProviderBlockHeaderError);\n    _this3 = _super3.apply(this, arguments);\n    _this3.name = 'ProviderBlockHeaderError';\n    return _this3;\n  }\n  return _createClass(ProviderBlockHeaderError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var ProviderTimeoutError = /*#__PURE__*/function (_Error4) {\n  _inherits(ProviderTimeoutError, _Error4);\n  var _super4 = _createSuper(ProviderTimeoutError);\n  function ProviderTimeoutError() {\n    var _this4;\n    _classCallCheck(this, ProviderTimeoutError);\n    _this4 = _super4.apply(this, arguments);\n    _this4.name = 'ProviderTimeoutError';\n    return _this4;\n  }\n  return _createClass(ProviderTimeoutError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * This error typically means that the gas used by the multicall has\n * exceeded the total call gas limit set by the node provider.\n *\n * This can be resolved by modifying BatchParams to request fewer\n * quotes per call, or to set a lower gas limit per quote.\n *\n * @export\n * @class ProviderGasError\n */\nexport var ProviderGasError = /*#__PURE__*/function (_Error5) {\n  _inherits(ProviderGasError, _Error5);\n  var _super5 = _createSuper(ProviderGasError);\n  function ProviderGasError() {\n    var _this5;\n    _classCallCheck(this, ProviderGasError);\n    _this5 = _super5.apply(this, arguments);\n    _this5.name = 'ProviderGasError';\n    return _this5;\n  }\n  return _createClass(ProviderGasError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar DEFAULT_BATCH_RETRIES = 2;\n/**\n * Computes on chain quotes for swaps. For pure V3 routes, quotes are computed on-chain using\n * the 'QuoterV2' smart contract. For exactIn mixed and V2 routes, quotes are computed using the 'MixedRouteQuoterV1' contract\n * This is because computing quotes off-chain would require fetching all the tick data for each pool, which is a lot of data.\n *\n * To minimize the number of requests for quotes we use a Multicall contract. Generally\n * the number of quotes to fetch exceeds the maximum we can fit in a single multicall\n * while staying under gas limits, so we also batch these quotes across multiple multicalls.\n *\n * The biggest challenge with the quote provider is dealing with various gas limits.\n * Each provider sets a limit on the amount of gas a call can consume (on Infura this\n * is approximately 10x the block max size), so we must ensure each multicall does not\n * exceed this limit. Additionally, each quote on V3 can consume a large number of gas if\n * the pool lacks liquidity and the swap would cause all the ticks to be traversed.\n *\n * To ensure we don't exceed the node's call limit, we limit the gas used by each quote to\n * a specific value, and we limit the number of quotes in each multicall request. Users of this\n * class should set BatchParams such that multicallChunk * gasLimitPerCall is less than their node\n * providers total gas limit per call.\n *\n * @export\n * @class OnChainQuoteProvider\n */\nexport var OnChainQuoteProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of OnChainQuoteProvider.\n   *\n   * @param chainId The chain to get quotes for.\n   * @param provider The web 3 provider.\n   * @param multicall2Provider The multicall provider to use to get the quotes on-chain.\n   * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.\n   * @param retryOptions The retry options for each call to the multicall.\n   * @param batchParams The parameters for each batched call to the multicall.\n   * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.\n   * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.\n   * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.\n   * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.\n   */\n  function OnChainQuoteProvider(chainId, provider,\n  // Only supports Uniswap Multicall as it needs the gas limitting functionality.\n  multicall2Provider) {\n    var retryOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      retries: DEFAULT_BATCH_RETRIES,\n      minTimeout: 25,\n      maxTimeout: 250\n    };\n    var batchParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      multicallChunk: 150,\n      gasLimitPerCall: 1000000,\n      quoteMinSuccessRate: 0.2\n    };\n    var gasErrorFailureOverride = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n      gasLimitOverride: 1500000,\n      multicallChunk: 100\n    };\n    var successRateFailureOverrides = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {\n      gasLimitOverride: 1300000,\n      multicallChunk: 110\n    };\n    var blockNumberConfig = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {\n      baseBlockOffset: 0,\n      rollback: {\n        enabled: false\n      }\n    };\n    var quoterAddressOverride = arguments.length > 8 ? arguments[8] : undefined;\n    _classCallCheck(this, OnChainQuoteProvider);\n    this.chainId = chainId;\n    this.provider = provider;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    this.batchParams = batchParams;\n    this.gasErrorFailureOverride = gasErrorFailureOverride;\n    this.successRateFailureOverrides = successRateFailureOverrides;\n    this.blockNumberConfig = blockNumberConfig;\n    this.quoterAddressOverride = quoterAddressOverride;\n  }\n  _createClass(OnChainQuoteProvider, [{\n    key: \"getQuoterAddress\",\n    value: function getQuoterAddress(useMixedRouteQuoter) {\n      if (this.quoterAddressOverride) {\n        return this.quoterAddressOverride;\n      }\n      var quoterAddress = useMixedRouteQuoter ? MIXED_ROUTE_QUOTER_V1_ADDRESSES[this.chainId] : QUOTER_V2_ADDRESSES[this.chainId];\n      if (!quoterAddress) {\n        throw new Error(\"No address for the quoter contract on chain id: \".concat(this.chainId));\n      }\n      return quoterAddress;\n    }\n  }, {\n    key: \"getQuotesManyExactIn\",\n    value: function () {\n      var _getQuotesManyExactIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(amountIns, routes, providerConfig) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.getQuotesManyData(amountIns, routes, 'quoteExactInput', providerConfig));\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getQuotesManyExactIn(_x, _x2, _x3) {\n        return _getQuotesManyExactIn.apply(this, arguments);\n      }\n      return getQuotesManyExactIn;\n    }()\n  }, {\n    key: \"getQuotesManyExactOut\",\n    value: function () {\n      var _getQuotesManyExactOut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(amountOuts, routes, providerConfig) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.getQuotesManyData(amountOuts, routes, 'quoteExactOutput', providerConfig));\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function getQuotesManyExactOut(_x4, _x5, _x6) {\n        return _getQuotesManyExactOut.apply(this, arguments);\n      }\n      return getQuotesManyExactOut;\n    }()\n  }, {\n    key: \"getQuotesManyData\",\n    value: function () {\n      var _getQuotesManyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(amounts, routes, functionName, _providerConfig) {\n        var _this6 = this;\n        var _a, useMixedRouteQuoter, multicallChunk, gasLimitOverride, _this$blockNumberConf, baseBlockOffset, rollback, originalBlockNumber, providerConfig, inputs, normalizedChunk, inputsChunked, quoteStates, haveRetriedForSuccessRate, haveRetriedForBlockHeader, blockHeaderRetryAttemptNumber, haveIncrementedBlockHeaderFailureCounter, blockHeaderRolledBack, haveRetriedForBlockConflictError, haveRetriedForOutOfGas, haveRetriedForTimeout, haveRetriedForUnknownReason, finalAttemptNumber, expectedCallsMade, totalCallsMade, _yield$retry, quoteResults, blockNumber, approxGasUsedPerSuccessCall, routesQuotes, _$flatMap$partition$v, _$flatMap$partition$v2, successfulQuotes, failedQuotes;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                useMixedRouteQuoter = routes.some(function (route) {\n                  return route.protocol === Protocol.V2;\n                }) || routes.some(function (route) {\n                  return route.protocol === Protocol.MIXED;\n                }); /// Validate that there are no incorrect routes / function combinations\n                this.validateRoutes(routes, functionName, useMixedRouteQuoter);\n                multicallChunk = this.batchParams.multicallChunk;\n                gasLimitOverride = this.batchParams.gasLimitPerCall;\n                _this$blockNumberConf = this.blockNumberConfig, baseBlockOffset = _this$blockNumberConf.baseBlockOffset, rollback = _this$blockNumberConf.rollback; // Apply the base block offset if provided\n                _context5.next = 7;\n                return this.provider.getBlockNumber();\n              case 7:\n                originalBlockNumber = _context5.sent;\n                providerConfig = _objectSpread(_objectSpread({}, _providerConfig), {}, {\n                  blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset\n                });\n                inputs = _(routes).flatMap(function (route) {\n                  var encodedRoute = route.protocol === Protocol.V3 ? encodeRouteToPath(route, functionName == 'quoteExactOutput' // For exactOut must be true to ensure the routes are reversed.\n                  ) : encodeMixedRouteToPath(route instanceof V2Route ? new MixedRouteSDK(route.pairs, route.input, route.output) : route);\n                  var routeInputs = amounts.map(function (amount) {\n                    return [encodedRoute, \"0x\".concat(amount.quotient.toString(16))];\n                  });\n                  return routeInputs;\n                }).value();\n                normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                inputsChunked = _.chunk(inputs, normalizedChunk);\n                quoteStates = _.map(inputsChunked, function (inputChunk) {\n                  return {\n                    status: 'pending',\n                    inputs: inputChunk\n                  };\n                });\n                _context5.t0 = log;\n                _context5.t1 = \"About to get \".concat(inputs.length, \" quotes in chunks of \").concat(normalizedChunk, \" [\").concat(_.map(inputsChunked, function (i) {\n                  return i.length;\n                }).join(','), \"] \").concat(gasLimitOverride ? \"with a gas limit override of \".concat(gasLimitOverride) : '', \" and block number: \");\n                _context5.next = 17;\n                return providerConfig.blockNumber;\n              case 17:\n                _context5.t2 = _context5.sent;\n                _context5.t3 = _context5.t1.concat.call(_context5.t1, _context5.t2, \" [Original before offset: \").concat(originalBlockNumber, \"].\");\n                _context5.t0.info.call(_context5.t0, _context5.t3);\n                haveRetriedForSuccessRate = false;\n                haveRetriedForBlockHeader = false;\n                blockHeaderRetryAttemptNumber = 0;\n                haveIncrementedBlockHeaderFailureCounter = false;\n                blockHeaderRolledBack = false;\n                haveRetriedForBlockConflictError = false;\n                haveRetriedForOutOfGas = false;\n                haveRetriedForTimeout = false;\n                haveRetriedForUnknownReason = false;\n                finalAttemptNumber = 1;\n                expectedCallsMade = quoteStates.length;\n                totalCallsMade = 0;\n                _context5.next = 34;\n                return retry( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_bail, attemptNumber) {\n                    var _this6$partitionQuote, _this6$partitionQuote2, success, failed, pending, _this6$partitionQuote3, _this6$partitionQuote4, successfulQuoteStates, failedQuoteStates, pendingQuoteStates, retryAll, blockNumberError, reasonForFailureStr, _iterator, _step, failedQuoteState, error, rollbackBlockOffset, attemptsBeforeRollback, _normalizedChunk, _inputsChunked, callResults;\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            haveIncrementedBlockHeaderFailureCounter = false;\n                            finalAttemptNumber = attemptNumber;\n                            _this6$partitionQuote = _this6.partitionQuotes(quoteStates), _this6$partitionQuote2 = _slicedToArray(_this6$partitionQuote, 3), success = _this6$partitionQuote2[0], failed = _this6$partitionQuote2[1], pending = _this6$partitionQuote2[2];\n                            log.info(\"Starting attempt: \".concat(attemptNumber, \".\\n          Currently \").concat(success.length, \" success, \").concat(failed.length, \" failed, \").concat(pending.length, \" pending.\\n          Gas limit override: \").concat(gasLimitOverride, \" Block number override: \").concat(providerConfig.blockNumber, \".\"));\n                            _context4.next = 6;\n                            return Promise.all(_.map(quoteStates, /*#__PURE__*/function () {\n                              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(quoteState, idx) {\n                                var inputs, results, successRateError;\n                                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                                  while (1) {\n                                    switch (_context3.prev = _context3.next) {\n                                      case 0:\n                                        if (!(quoteState.status == 'success')) {\n                                          _context3.next = 2;\n                                          break;\n                                        }\n                                        return _context3.abrupt(\"return\", quoteState);\n                                      case 2:\n                                        // QuoteChunk is pending or failed, so we try again\n                                        inputs = quoteState.inputs;\n                                        _context3.prev = 3;\n                                        totalCallsMade = totalCallsMade + 1;\n                                        _context3.next = 7;\n                                        return _this6.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n                                          address: _this6.getQuoterAddress(useMixedRouteQuoter),\n                                          contractInterface: useMixedRouteQuoter ? IMixedRouteQuoterV1__factory.createInterface() : IQuoterV2__factory.createInterface(),\n                                          functionName: functionName,\n                                          functionParams: inputs,\n                                          providerConfig: providerConfig,\n                                          additionalConfig: {\n                                            gasLimitPerCallOverride: gasLimitOverride\n                                          }\n                                        });\n                                      case 7:\n                                        results = _context3.sent;\n                                        successRateError = _this6.validateSuccessRate(results.results, haveRetriedForSuccessRate);\n                                        if (!successRateError) {\n                                          _context3.next = 11;\n                                          break;\n                                        }\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: successRateError,\n                                          results: results\n                                        });\n                                      case 11:\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'success',\n                                          inputs: inputs,\n                                          results: results\n                                        });\n                                      case 14:\n                                        _context3.prev = 14;\n                                        _context3.t0 = _context3[\"catch\"](3);\n                                        if (!_context3.t0.message.includes('header not found')) {\n                                          _context3.next = 18;\n                                          break;\n                                        }\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new ProviderBlockHeaderError(_context3.t0.message.slice(0, 500))\n                                        });\n                                      case 18:\n                                        if (!_context3.t0.message.includes('timeout')) {\n                                          _context3.next = 20;\n                                          break;\n                                        }\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new ProviderTimeoutError(\"Req \".concat(idx, \"/\").concat(quoteStates.length, \". Request had \").concat(inputs.length, \" inputs. \").concat(_context3.t0.message.slice(0, 500)))\n                                        });\n                                      case 20:\n                                        if (!_context3.t0.message.includes('out of gas')) {\n                                          _context3.next = 22;\n                                          break;\n                                        }\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new ProviderGasError(_context3.t0.message.slice(0, 500))\n                                        });\n                                      case 22:\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new Error(\"Unknown error from provider: \".concat(_context3.t0.message.slice(0, 500)))\n                                        });\n                                      case 23:\n                                      case \"end\":\n                                        return _context3.stop();\n                                    }\n                                  }\n                                }, _callee3, null, [[3, 14]]);\n                              }));\n                              return function (_x13, _x14) {\n                                return _ref2.apply(this, arguments);\n                              };\n                            }()));\n                          case 6:\n                            quoteStates = _context4.sent;\n                            _this6$partitionQuote3 = _this6.partitionQuotes(quoteStates), _this6$partitionQuote4 = _slicedToArray(_this6$partitionQuote3, 3), successfulQuoteStates = _this6$partitionQuote4[0], failedQuoteStates = _this6$partitionQuote4[1], pendingQuoteStates = _this6$partitionQuote4[2];\n                            if (!(pendingQuoteStates.length > 0)) {\n                              _context4.next = 10;\n                              break;\n                            }\n                            throw new Error('Pending quote after waiting for all promises.');\n                          case 10:\n                            retryAll = false;\n                            blockNumberError = _this6.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride); // If there is a block number conflict we retry all the quotes.\n                            if (blockNumberError) {\n                              retryAll = true;\n                            }\n                            reasonForFailureStr = _.map(failedQuoteStates, function (failedQuoteState) {\n                              return failedQuoteState.reason.name;\n                            }).join(', ');\n                            if (!(failedQuoteStates.length > 0)) {\n                              _context4.next = 64;\n                              break;\n                            }\n                            log.info(\"On attempt \".concat(attemptNumber, \": \").concat(failedQuoteStates.length, \"/\").concat(quoteStates.length, \" quotes failed. Reasons: \").concat(reasonForFailureStr));\n                            _iterator = _createForOfIteratorHelper(failedQuoteStates);\n                            _context4.prev = 17;\n                            _iterator.s();\n                          case 19:\n                            if ((_step = _iterator.n()).done) {\n                              _context4.next = 56;\n                              break;\n                            }\n                            failedQuoteState = _step.value;\n                            error = failedQuoteState.reason;\n                            log.info({\n                              error: error\n                            }, \"[QuoteFetchError] Attempt \".concat(attemptNumber, \". \").concat(error.message));\n                            if (!(error instanceof BlockConflictError)) {\n                              _context4.next = 28;\n                              break;\n                            }\n                            if (!haveRetriedForBlockConflictError) {\n                              metric.putMetric('QuoteBlockConflictErrorRetry', 1, MetricLoggerUnit.Count);\n                              haveRetriedForBlockConflictError = true;\n                            }\n                            retryAll = true;\n                            _context4.next = 54;\n                            break;\n                          case 28:\n                            if (!(error instanceof ProviderBlockHeaderError)) {\n                              _context4.next = 53;\n                              break;\n                            }\n                            if (!haveRetriedForBlockHeader) {\n                              metric.putMetric('QuoteBlockHeaderNotFoundRetry', 1, MetricLoggerUnit.Count);\n                              haveRetriedForBlockHeader = true;\n                            }\n                            // Ensure that if multiple calls fail due to block header in the current pending batch,\n                            // we only count once.\n                            if (!haveIncrementedBlockHeaderFailureCounter) {\n                              blockHeaderRetryAttemptNumber = blockHeaderRetryAttemptNumber + 1;\n                              haveIncrementedBlockHeaderFailureCounter = true;\n                            }\n                            if (!rollback.enabled) {\n                              _context4.next = 51;\n                              break;\n                            }\n                            rollbackBlockOffset = rollback.rollbackBlockOffset, attemptsBeforeRollback = rollback.attemptsBeforeRollback;\n                            if (!(blockHeaderRetryAttemptNumber >= attemptsBeforeRollback && !blockHeaderRolledBack)) {\n                              _context4.next = 51;\n                              break;\n                            }\n                            log.info(\"Attempt \".concat(attemptNumber, \". Have failed due to block header \").concat(blockHeaderRetryAttemptNumber - 1, \" times. Rolling back block number by \").concat(rollbackBlockOffset, \" for next retry\"));\n                            if (!providerConfig.blockNumber) {\n                              _context4.next = 43;\n                              break;\n                            }\n                            _context4.next = 38;\n                            return providerConfig.blockNumber;\n                          case 38:\n                            _context4.t1 = _context4.sent;\n                            _context4.t2 = rollbackBlockOffset;\n                            _context4.t0 = _context4.t1 + _context4.t2;\n                            _context4.next = 48;\n                            break;\n                          case 43:\n                            _context4.next = 45;\n                            return _this6.provider.getBlockNumber();\n                          case 45:\n                            _context4.t3 = _context4.sent;\n                            _context4.t4 = rollbackBlockOffset;\n                            _context4.t0 = _context4.t3 + _context4.t4;\n                          case 48:\n                            providerConfig.blockNumber = _context4.t0;\n                            retryAll = true;\n                            blockHeaderRolledBack = true;\n                          case 51:\n                            _context4.next = 54;\n                            break;\n                          case 53:\n                            if (error instanceof ProviderTimeoutError) {\n                              if (!haveRetriedForTimeout) {\n                                metric.putMetric('QuoteTimeoutRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForTimeout = true;\n                              }\n                            } else if (error instanceof ProviderGasError) {\n                              if (!haveRetriedForOutOfGas) {\n                                metric.putMetric('QuoteOutOfGasExceptionRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForOutOfGas = true;\n                              }\n                              gasLimitOverride = _this6.gasErrorFailureOverride.gasLimitOverride;\n                              multicallChunk = _this6.gasErrorFailureOverride.multicallChunk;\n                              retryAll = true;\n                            } else if (error instanceof SuccessRateError) {\n                              if (!haveRetriedForSuccessRate) {\n                                metric.putMetric('QuoteSuccessRateRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForSuccessRate = true;\n                                // Low success rate can indicate too little gas given to each call.\n                                gasLimitOverride = _this6.successRateFailureOverrides.gasLimitOverride;\n                                multicallChunk = _this6.successRateFailureOverrides.multicallChunk;\n                                retryAll = true;\n                              }\n                            } else {\n                              if (!haveRetriedForUnknownReason) {\n                                metric.putMetric('QuoteUnknownReasonRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForUnknownReason = true;\n                              }\n                            }\n                          case 54:\n                            _context4.next = 19;\n                            break;\n                          case 56:\n                            _context4.next = 61;\n                            break;\n                          case 58:\n                            _context4.prev = 58;\n                            _context4.t5 = _context4[\"catch\"](17);\n                            _iterator.e(_context4.t5);\n                          case 61:\n                            _context4.prev = 61;\n                            _iterator.f();\n                            return _context4.finish(61);\n                          case 64:\n                            if (retryAll) {\n                              log.info(\"Attempt \".concat(attemptNumber, \". Resetting all requests to pending for next attempt.\"));\n                              _normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                              _inputsChunked = _.chunk(inputs, _normalizedChunk);\n                              quoteStates = _.map(_inputsChunked, function (inputChunk) {\n                                return {\n                                  status: 'pending',\n                                  inputs: inputChunk\n                                };\n                              });\n                            }\n                            if (!(failedQuoteStates.length > 0)) {\n                              _context4.next = 70;\n                              break;\n                            }\n                            if (!((_this6.chainId == ChainId.ARBITRUM_ONE || _this6.chainId == ChainId.ARBITRUM_RINKEBY) && _.every(failedQuoteStates, function (failedQuoteState) {\n                              return failedQuoteState.reason instanceof ProviderGasError;\n                            }) && attemptNumber == _this6.retryOptions.retries)) {\n                              _context4.next = 69;\n                              break;\n                            }\n                            log.error(\"Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.\");\n                            return _context4.abrupt(\"return\", {\n                              results: [],\n                              blockNumber: BigNumber.from(0),\n                              approxGasUsedPerSuccessCall: 0\n                            });\n                          case 69:\n                            throw new Error(\"Failed to get \".concat(failedQuoteStates.length, \" quotes. Reasons: \").concat(reasonForFailureStr));\n                          case 70:\n                            callResults = _.map(successfulQuoteStates, function (quoteState) {\n                              return quoteState.results;\n                            });\n                            return _context4.abrupt(\"return\", {\n                              results: _.flatMap(callResults, function (result) {\n                                return result.results;\n                              }),\n                              blockNumber: BigNumber.from(callResults[0].blockNumber),\n                              approxGasUsedPerSuccessCall: stats.percentile(_.map(callResults, function (result) {\n                                return result.approxGasUsedPerSuccessCall;\n                              }), 100)\n                            });\n                          case 72:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, null, [[17, 58, 61, 64]]);\n                  }));\n                  return function (_x11, _x12) {\n                    return _ref.apply(this, arguments);\n                  };\n                }(), _objectSpread({\n                  retries: DEFAULT_BATCH_RETRIES\n                }, this.retryOptions));\n              case 34:\n                _yield$retry = _context5.sent;\n                quoteResults = _yield$retry.results;\n                blockNumber = _yield$retry.blockNumber;\n                approxGasUsedPerSuccessCall = _yield$retry.approxGasUsedPerSuccessCall;\n                routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);\n                metric.putMetric('QuoteApproxGasUsedPerSuccessfulCall', approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteNumRetryLoops', finalAttemptNumber - 1, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteTotalCallsToProvider', totalCallsMade, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteExpectedCallsToProvider', expectedCallsMade, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteNumRetriedCalls', totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);\n                _$flatMap$partition$v = _(routesQuotes).flatMap(function (routeWithQuotes) {\n                  return routeWithQuotes[1];\n                }).partition(function (quote) {\n                  return quote.quote != null;\n                }).value(), _$flatMap$partition$v2 = _slicedToArray(_$flatMap$partition$v, 2), successfulQuotes = _$flatMap$partition$v2[0], failedQuotes = _$flatMap$partition$v2[1];\n                log.info(\"Got \".concat(successfulQuotes.length, \" successful quotes, \").concat(failedQuotes.length, \" failed quotes. Took \").concat(finalAttemptNumber - 1, \" attempt loops. Total calls made to provider: \").concat(totalCallsMade, \". Have retried for timeout: \").concat(haveRetriedForTimeout));\n                return _context5.abrupt(\"return\", {\n                  routesWithQuotes: routesQuotes,\n                  blockNumber: blockNumber\n                });\n              case 47:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getQuotesManyData(_x7, _x8, _x9, _x10) {\n        return _getQuotesManyData.apply(this, arguments);\n      }\n      return getQuotesManyData;\n    }()\n  }, {\n    key: \"partitionQuotes\",\n    value: function partitionQuotes(quoteStates) {\n      var successfulQuoteStates = _.filter(quoteStates, function (quoteState) {\n        return quoteState.status == 'success';\n      });\n      var failedQuoteStates = _.filter(quoteStates, function (quoteState) {\n        return quoteState.status == 'failed';\n      });\n      var pendingQuoteStates = _.filter(quoteStates, function (quoteState) {\n        return quoteState.status == 'pending';\n      });\n      return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];\n    }\n  }, {\n    key: \"processQuoteResults\",\n    value: function processQuoteResults(quoteResults, routes, amounts) {\n      var routesQuotes = [];\n      var quotesResultsByRoute = _.chunk(quoteResults, amounts.length);\n      var debugFailedQuotes = [];\n      var _loop = function _loop(i) {\n        var route = routes[i];\n        var quoteResults = quotesResultsByRoute[i];\n        var quotes = _.map(quoteResults, function (quoteResult, index) {\n          var amount = amounts[index];\n          if (!quoteResult.success) {\n            var percent = 100 / amounts.length * (index + 1);\n            var amountStr = amount.toFixed(Math.min(amount.currency.decimals, 2));\n            var routeStr = routeToString(route);\n            debugFailedQuotes.push({\n              route: routeStr,\n              percent: percent,\n              amount: amountStr\n            });\n            return {\n              amount: amount,\n              quote: null,\n              sqrtPriceX96AfterList: null,\n              gasEstimate: null,\n              initializedTicksCrossedList: null\n            };\n          }\n          return {\n            amount: amount,\n            quote: quoteResult.result[0],\n            sqrtPriceX96AfterList: quoteResult.result[1],\n            initializedTicksCrossedList: quoteResult.result[2],\n            gasEstimate: quoteResult.result[3]\n          };\n        });\n        routesQuotes.push([route, quotes]);\n      };\n      for (var i = 0; i < quotesResultsByRoute.length; i++) {\n        _loop(i);\n      }\n      // For routes and amounts that we failed to get a quote for, group them by route\n      // and batch them together before logging to minimize number of logs.\n      var debugChunk = 80;\n      _.forEach(_.chunk(debugFailedQuotes, debugChunk), function (quotes, idx) {\n        var failedQuotesByRoute = _.groupBy(quotes, function (q) {\n          return q.route;\n        });\n        var failedFlat = _.mapValues(failedQuotesByRoute, function (f) {\n          return _(f).map(function (f) {\n            return \"\".concat(f.percent, \"%[\").concat(f.amount, \"]\");\n          }).join(',');\n        });\n        log.info({\n          failedQuotes: _.map(failedFlat, function (amounts, routeStr) {\n            return \"\".concat(routeStr, \" : \").concat(amounts);\n          })\n        }, \"Failed on chain quotes for routes Part \".concat(idx, \"/\").concat(Math.ceil(debugFailedQuotes.length / debugChunk)));\n      });\n      return routesQuotes;\n    }\n  }, {\n    key: \"validateBlockNumbers\",\n    value: function validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {\n      if (successfulQuoteStates.length <= 1) {\n        return null;\n      }\n      var results = _.map(successfulQuoteStates, function (quoteState) {\n        return quoteState.results;\n      });\n      var blockNumbers = _.map(results, function (result) {\n        return result.blockNumber;\n      });\n      var uniqBlocks = _(blockNumbers).map(function (blockNumber) {\n        return blockNumber.toNumber();\n      }).uniq().value();\n      if (uniqBlocks.length == 1) {\n        return null;\n      }\n      /* if (\n        uniqBlocks.length == 2 &&\n        Math.abs(uniqBlocks[0]! - uniqBlocks[1]!) <= 1\n      ) {\n        return null;\n      } */\n      return new BlockConflictError(\"Quotes returned from different blocks. \".concat(uniqBlocks, \". \").concat(totalCalls, \" calls were made with gas limit \").concat(gasLimitOverride));\n    }\n  }, {\n    key: \"validateSuccessRate\",\n    value: function validateSuccessRate(allResults, haveRetriedForSuccessRate) {\n      var numResults = allResults.length;\n      var numSuccessResults = allResults.filter(function (result) {\n        return result.success;\n      }).length;\n      var successRate = 1.0 * numSuccessResults / numResults;\n      var quoteMinSuccessRate = this.batchParams.quoteMinSuccessRate;\n      if (successRate < quoteMinSuccessRate) {\n        if (haveRetriedForSuccessRate) {\n          log.info(\"Quote success rate still below threshold despite retry. Continuing. \".concat(quoteMinSuccessRate, \": \").concat(successRate));\n          return;\n        }\n        return new SuccessRateError(\"Quote success rate below threshold of \".concat(quoteMinSuccessRate, \": \").concat(successRate));\n      }\n    }\n    /**\n     * Throw an error for incorrect routes / function combinations\n     * @param routes Any combination of V3, V2, and Mixed routes.\n     * @param functionName\n     * @param useMixedRouteQuoter true if there are ANY V2Routes or MixedRoutes in the routes parameter\n     */\n  }, {\n    key: \"validateRoutes\",\n    value: function validateRoutes(routes, functionName, useMixedRouteQuoter) {\n      /// We do not send any V3Routes to new qutoer becuase it is not deployed on chains besides mainnet\n      if (routes.some(function (route) {\n        return route.protocol === Protocol.V3;\n      }) && useMixedRouteQuoter) {\n        throw new Error(\"Cannot use mixed route quoter with V3 routes\");\n      }\n      /// We cannot call quoteExactOutput with V2 or Mixed routes\n      if (functionName === 'quoteExactOutput' && useMixedRouteQuoter) {\n        throw new Error('Cannot call quoteExactOutput with V2 or Mixed routes');\n      }\n    }\n  }]);\n  return OnChainQuoteProvider;\n}();","map":{"version":3,"sources":["../../../src/providers/on-chain-quote-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { encodeMixedRouteToPath, MixedRouteSDK, Protocol, } from '@uniswap/router-sdk';\nimport { encodeRouteToPath } from '@uniswap/v3-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport stats from 'stats-lite';\nimport { V2Route } from '../routers/router';\nimport { IMixedRouteQuoterV1__factory } from '../types/other/factories/IMixedRouteQuoterV1__factory';\nimport { IQuoterV2__factory } from '../types/v3/factories/IQuoterV2__factory';\nimport { ChainId, metric, MetricLoggerUnit } from '../util';\nimport { MIXED_ROUTE_QUOTER_V1_ADDRESSES, QUOTER_V2_ADDRESSES, } from '../util/addresses';\nimport { log } from '../util/log';\nimport { routeToString } from '../util/routes';\nexport class BlockConflictError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BlockConflictError';\n    }\n}\nexport class SuccessRateError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SuccessRateError';\n    }\n}\nexport class ProviderBlockHeaderError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderBlockHeaderError';\n    }\n}\nexport class ProviderTimeoutError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderTimeoutError';\n    }\n}\n/**\n * This error typically means that the gas used by the multicall has\n * exceeded the total call gas limit set by the node provider.\n *\n * This can be resolved by modifying BatchParams to request fewer\n * quotes per call, or to set a lower gas limit per quote.\n *\n * @export\n * @class ProviderGasError\n */\nexport class ProviderGasError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderGasError';\n    }\n}\nconst DEFAULT_BATCH_RETRIES = 2;\n/**\n * Computes on chain quotes for swaps. For pure V3 routes, quotes are computed on-chain using\n * the 'QuoterV2' smart contract. For exactIn mixed and V2 routes, quotes are computed using the 'MixedRouteQuoterV1' contract\n * This is because computing quotes off-chain would require fetching all the tick data for each pool, which is a lot of data.\n *\n * To minimize the number of requests for quotes we use a Multicall contract. Generally\n * the number of quotes to fetch exceeds the maximum we can fit in a single multicall\n * while staying under gas limits, so we also batch these quotes across multiple multicalls.\n *\n * The biggest challenge with the quote provider is dealing with various gas limits.\n * Each provider sets a limit on the amount of gas a call can consume (on Infura this\n * is approximately 10x the block max size), so we must ensure each multicall does not\n * exceed this limit. Additionally, each quote on V3 can consume a large number of gas if\n * the pool lacks liquidity and the swap would cause all the ticks to be traversed.\n *\n * To ensure we don't exceed the node's call limit, we limit the gas used by each quote to\n * a specific value, and we limit the number of quotes in each multicall request. Users of this\n * class should set BatchParams such that multicallChunk * gasLimitPerCall is less than their node\n * providers total gas limit per call.\n *\n * @export\n * @class OnChainQuoteProvider\n */\nexport class OnChainQuoteProvider {\n    /**\n     * Creates an instance of OnChainQuoteProvider.\n     *\n     * @param chainId The chain to get quotes for.\n     * @param provider The web 3 provider.\n     * @param multicall2Provider The multicall provider to use to get the quotes on-chain.\n     * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.\n     * @param retryOptions The retry options for each call to the multicall.\n     * @param batchParams The parameters for each batched call to the multicall.\n     * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.\n     * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.\n     * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.\n     * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.\n     */\n    constructor(chainId, provider, \n    // Only supports Uniswap Multicall as it needs the gas limitting functionality.\n    multicall2Provider, retryOptions = {\n        retries: DEFAULT_BATCH_RETRIES,\n        minTimeout: 25,\n        maxTimeout: 250,\n    }, batchParams = {\n        multicallChunk: 150,\n        gasLimitPerCall: 1000000,\n        quoteMinSuccessRate: 0.2,\n    }, gasErrorFailureOverride = {\n        gasLimitOverride: 1500000,\n        multicallChunk: 100,\n    }, successRateFailureOverrides = {\n        gasLimitOverride: 1300000,\n        multicallChunk: 110,\n    }, blockNumberConfig = {\n        baseBlockOffset: 0,\n        rollback: { enabled: false },\n    }, quoterAddressOverride) {\n        this.chainId = chainId;\n        this.provider = provider;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        this.batchParams = batchParams;\n        this.gasErrorFailureOverride = gasErrorFailureOverride;\n        this.successRateFailureOverrides = successRateFailureOverrides;\n        this.blockNumberConfig = blockNumberConfig;\n        this.quoterAddressOverride = quoterAddressOverride;\n    }\n    getQuoterAddress(useMixedRouteQuoter) {\n        if (this.quoterAddressOverride) {\n            return this.quoterAddressOverride;\n        }\n        const quoterAddress = useMixedRouteQuoter\n            ? MIXED_ROUTE_QUOTER_V1_ADDRESSES[this.chainId]\n            : QUOTER_V2_ADDRESSES[this.chainId];\n        if (!quoterAddress) {\n            throw new Error(`No address for the quoter contract on chain id: ${this.chainId}`);\n        }\n        return quoterAddress;\n    }\n    async getQuotesManyExactIn(amountIns, routes, providerConfig) {\n        return this.getQuotesManyData(amountIns, routes, 'quoteExactInput', providerConfig);\n    }\n    async getQuotesManyExactOut(amountOuts, routes, providerConfig) {\n        return this.getQuotesManyData(amountOuts, routes, 'quoteExactOutput', providerConfig);\n    }\n    async getQuotesManyData(amounts, routes, functionName, _providerConfig) {\n        var _a;\n        const useMixedRouteQuoter = routes.some((route) => route.protocol === Protocol.V2) ||\n            routes.some((route) => route.protocol === Protocol.MIXED);\n        /// Validate that there are no incorrect routes / function combinations\n        this.validateRoutes(routes, functionName, useMixedRouteQuoter);\n        let multicallChunk = this.batchParams.multicallChunk;\n        let gasLimitOverride = this.batchParams.gasLimitPerCall;\n        const { baseBlockOffset, rollback } = this.blockNumberConfig;\n        // Apply the base block offset if provided\n        const originalBlockNumber = await this.provider.getBlockNumber();\n        const providerConfig = {\n            ..._providerConfig,\n            blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset,\n        };\n        const inputs = _(routes)\n            .flatMap((route) => {\n            const encodedRoute = route.protocol === Protocol.V3\n                ? encodeRouteToPath(route, functionName == 'quoteExactOutput' // For exactOut must be true to ensure the routes are reversed.\n                )\n                : encodeMixedRouteToPath(route instanceof V2Route\n                    ? new MixedRouteSDK(route.pairs, route.input, route.output)\n                    : route);\n            const routeInputs = amounts.map((amount) => [\n                encodedRoute,\n                `0x${amount.quotient.toString(16)}`,\n            ]);\n            return routeInputs;\n        })\n            .value();\n        const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n        const inputsChunked = _.chunk(inputs, normalizedChunk);\n        let quoteStates = _.map(inputsChunked, (inputChunk) => {\n            return {\n                status: 'pending',\n                inputs: inputChunk,\n            };\n        });\n        log.info(`About to get ${inputs.length} quotes in chunks of ${normalizedChunk} [${_.map(inputsChunked, (i) => i.length).join(',')}] ${gasLimitOverride\n            ? `with a gas limit override of ${gasLimitOverride}`\n            : ''} and block number: ${await providerConfig.blockNumber} [Original before offset: ${originalBlockNumber}].`);\n        let haveRetriedForSuccessRate = false;\n        let haveRetriedForBlockHeader = false;\n        let blockHeaderRetryAttemptNumber = 0;\n        let haveIncrementedBlockHeaderFailureCounter = false;\n        let blockHeaderRolledBack = false;\n        let haveRetriedForBlockConflictError = false;\n        let haveRetriedForOutOfGas = false;\n        let haveRetriedForTimeout = false;\n        let haveRetriedForUnknownReason = false;\n        let finalAttemptNumber = 1;\n        const expectedCallsMade = quoteStates.length;\n        let totalCallsMade = 0;\n        const { results: quoteResults, blockNumber, approxGasUsedPerSuccessCall, } = await retry(async (_bail, attemptNumber) => {\n            haveIncrementedBlockHeaderFailureCounter = false;\n            finalAttemptNumber = attemptNumber;\n            const [success, failed, pending] = this.partitionQuotes(quoteStates);\n            log.info(`Starting attempt: ${attemptNumber}.\n          Currently ${success.length} success, ${failed.length} failed, ${pending.length} pending.\n          Gas limit override: ${gasLimitOverride} Block number override: ${providerConfig.blockNumber}.`);\n            quoteStates = await Promise.all(_.map(quoteStates, async (quoteState, idx) => {\n                if (quoteState.status == 'success') {\n                    return quoteState;\n                }\n                // QuoteChunk is pending or failed, so we try again\n                const { inputs } = quoteState;\n                try {\n                    totalCallsMade = totalCallsMade + 1;\n                    const results = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n                        address: this.getQuoterAddress(useMixedRouteQuoter),\n                        contractInterface: useMixedRouteQuoter\n                            ? IMixedRouteQuoterV1__factory.createInterface()\n                            : IQuoterV2__factory.createInterface(),\n                        functionName,\n                        functionParams: inputs,\n                        providerConfig,\n                        additionalConfig: {\n                            gasLimitPerCallOverride: gasLimitOverride,\n                        },\n                    });\n                    const successRateError = this.validateSuccessRate(results.results, haveRetriedForSuccessRate);\n                    if (successRateError) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: successRateError,\n                            results,\n                        };\n                    }\n                    return {\n                        status: 'success',\n                        inputs,\n                        results,\n                    };\n                }\n                catch (err) {\n                    // Error from providers have huge messages that include all the calldata and fill the logs.\n                    // Catch them and rethrow with shorter message.\n                    if (err.message.includes('header not found')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderBlockHeaderError(err.message.slice(0, 500)),\n                        };\n                    }\n                    if (err.message.includes('timeout')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderTimeoutError(`Req ${idx}/${quoteStates.length}. Request had ${inputs.length} inputs. ${err.message.slice(0, 500)}`),\n                        };\n                    }\n                    if (err.message.includes('out of gas')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderGasError(err.message.slice(0, 500)),\n                        };\n                    }\n                    return {\n                        status: 'failed',\n                        inputs,\n                        reason: new Error(`Unknown error from provider: ${err.message.slice(0, 500)}`),\n                    };\n                }\n            }));\n            const [successfulQuoteStates, failedQuoteStates, pendingQuoteStates] = this.partitionQuotes(quoteStates);\n            if (pendingQuoteStates.length > 0) {\n                throw new Error('Pending quote after waiting for all promises.');\n            }\n            let retryAll = false;\n            const blockNumberError = this.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride);\n            // If there is a block number conflict we retry all the quotes.\n            if (blockNumberError) {\n                retryAll = true;\n            }\n            const reasonForFailureStr = _.map(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason.name).join(', ');\n            if (failedQuoteStates.length > 0) {\n                log.info(`On attempt ${attemptNumber}: ${failedQuoteStates.length}/${quoteStates.length} quotes failed. Reasons: ${reasonForFailureStr}`);\n                for (const failedQuoteState of failedQuoteStates) {\n                    const { reason: error } = failedQuoteState;\n                    log.info({ error }, `[QuoteFetchError] Attempt ${attemptNumber}. ${error.message}`);\n                    if (error instanceof BlockConflictError) {\n                        if (!haveRetriedForBlockConflictError) {\n                            metric.putMetric('QuoteBlockConflictErrorRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForBlockConflictError = true;\n                        }\n                        retryAll = true;\n                    }\n                    else if (error instanceof ProviderBlockHeaderError) {\n                        if (!haveRetriedForBlockHeader) {\n                            metric.putMetric('QuoteBlockHeaderNotFoundRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForBlockHeader = true;\n                        }\n                        // Ensure that if multiple calls fail due to block header in the current pending batch,\n                        // we only count once.\n                        if (!haveIncrementedBlockHeaderFailureCounter) {\n                            blockHeaderRetryAttemptNumber =\n                                blockHeaderRetryAttemptNumber + 1;\n                            haveIncrementedBlockHeaderFailureCounter = true;\n                        }\n                        if (rollback.enabled) {\n                            const { rollbackBlockOffset, attemptsBeforeRollback } = rollback;\n                            if (blockHeaderRetryAttemptNumber >= attemptsBeforeRollback &&\n                                !blockHeaderRolledBack) {\n                                log.info(`Attempt ${attemptNumber}. Have failed due to block header ${blockHeaderRetryAttemptNumber - 1} times. Rolling back block number by ${rollbackBlockOffset} for next retry`);\n                                providerConfig.blockNumber = providerConfig.blockNumber\n                                    ? (await providerConfig.blockNumber) + rollbackBlockOffset\n                                    : (await this.provider.getBlockNumber()) +\n                                        rollbackBlockOffset;\n                                retryAll = true;\n                                blockHeaderRolledBack = true;\n                            }\n                        }\n                    }\n                    else if (error instanceof ProviderTimeoutError) {\n                        if (!haveRetriedForTimeout) {\n                            metric.putMetric('QuoteTimeoutRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForTimeout = true;\n                        }\n                    }\n                    else if (error instanceof ProviderGasError) {\n                        if (!haveRetriedForOutOfGas) {\n                            metric.putMetric('QuoteOutOfGasExceptionRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForOutOfGas = true;\n                        }\n                        gasLimitOverride = this.gasErrorFailureOverride.gasLimitOverride;\n                        multicallChunk = this.gasErrorFailureOverride.multicallChunk;\n                        retryAll = true;\n                    }\n                    else if (error instanceof SuccessRateError) {\n                        if (!haveRetriedForSuccessRate) {\n                            metric.putMetric('QuoteSuccessRateRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForSuccessRate = true;\n                            // Low success rate can indicate too little gas given to each call.\n                            gasLimitOverride =\n                                this.successRateFailureOverrides.gasLimitOverride;\n                            multicallChunk =\n                                this.successRateFailureOverrides.multicallChunk;\n                            retryAll = true;\n                        }\n                    }\n                    else {\n                        if (!haveRetriedForUnknownReason) {\n                            metric.putMetric('QuoteUnknownReasonRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForUnknownReason = true;\n                        }\n                    }\n                }\n            }\n            if (retryAll) {\n                log.info(`Attempt ${attemptNumber}. Resetting all requests to pending for next attempt.`);\n                const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                const inputsChunked = _.chunk(inputs, normalizedChunk);\n                quoteStates = _.map(inputsChunked, (inputChunk) => {\n                    return {\n                        status: 'pending',\n                        inputs: inputChunk,\n                    };\n                });\n            }\n            if (failedQuoteStates.length > 0) {\n                // TODO: Work with Arbitrum to find a solution for making large multicalls with gas limits that always\n                // successfully.\n                //\n                // On Arbitrum we can not set a gas limit for every call in the multicall and guarantee that\n                // we will not run out of gas on the node. This is because they have a different way of accounting\n                // for gas, that seperates storage and compute gas costs, and we can not cover both in a single limit.\n                //\n                // To work around this and avoid throwing errors when really we just couldn't get a quote, we catch this\n                // case and return 0 quotes found.\n                if ((this.chainId == ChainId.ARBITRUM_ONE ||\n                    this.chainId == ChainId.ARBITRUM_RINKEBY) &&\n                    _.every(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason instanceof ProviderGasError) &&\n                    attemptNumber == this.retryOptions.retries) {\n                    log.error(`Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.`);\n                    return {\n                        results: [],\n                        blockNumber: BigNumber.from(0),\n                        approxGasUsedPerSuccessCall: 0,\n                    };\n                }\n                throw new Error(`Failed to get ${failedQuoteStates.length} quotes. Reasons: ${reasonForFailureStr}`);\n            }\n            const callResults = _.map(successfulQuoteStates, (quoteState) => quoteState.results);\n            return {\n                results: _.flatMap(callResults, (result) => result.results),\n                blockNumber: BigNumber.from(callResults[0].blockNumber),\n                approxGasUsedPerSuccessCall: stats.percentile(_.map(callResults, (result) => result.approxGasUsedPerSuccessCall), 100),\n            };\n        }, {\n            retries: DEFAULT_BATCH_RETRIES,\n            ...this.retryOptions,\n        });\n        const routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);\n        metric.putMetric('QuoteApproxGasUsedPerSuccessfulCall', approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteNumRetryLoops', finalAttemptNumber - 1, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteTotalCallsToProvider', totalCallsMade, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteExpectedCallsToProvider', expectedCallsMade, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteNumRetriedCalls', totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);\n        const [successfulQuotes, failedQuotes] = _(routesQuotes)\n            .flatMap((routeWithQuotes) => routeWithQuotes[1])\n            .partition((quote) => quote.quote != null)\n            .value();\n        log.info(`Got ${successfulQuotes.length} successful quotes, ${failedQuotes.length} failed quotes. Took ${finalAttemptNumber - 1} attempt loops. Total calls made to provider: ${totalCallsMade}. Have retried for timeout: ${haveRetriedForTimeout}`);\n        return { routesWithQuotes: routesQuotes, blockNumber };\n    }\n    partitionQuotes(quoteStates) {\n        const successfulQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'success');\n        const failedQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'failed');\n        const pendingQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'pending');\n        return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];\n    }\n    processQuoteResults(quoteResults, routes, amounts) {\n        const routesQuotes = [];\n        const quotesResultsByRoute = _.chunk(quoteResults, amounts.length);\n        const debugFailedQuotes = [];\n        for (let i = 0; i < quotesResultsByRoute.length; i++) {\n            const route = routes[i];\n            const quoteResults = quotesResultsByRoute[i];\n            const quotes = _.map(quoteResults, (quoteResult, index) => {\n                const amount = amounts[index];\n                if (!quoteResult.success) {\n                    const percent = (100 / amounts.length) * (index + 1);\n                    const amountStr = amount.toFixed(Math.min(amount.currency.decimals, 2));\n                    const routeStr = routeToString(route);\n                    debugFailedQuotes.push({\n                        route: routeStr,\n                        percent,\n                        amount: amountStr,\n                    });\n                    return {\n                        amount,\n                        quote: null,\n                        sqrtPriceX96AfterList: null,\n                        gasEstimate: null,\n                        initializedTicksCrossedList: null,\n                    };\n                }\n                return {\n                    amount,\n                    quote: quoteResult.result[0],\n                    sqrtPriceX96AfterList: quoteResult.result[1],\n                    initializedTicksCrossedList: quoteResult.result[2],\n                    gasEstimate: quoteResult.result[3],\n                };\n            });\n            routesQuotes.push([route, quotes]);\n        }\n        // For routes and amounts that we failed to get a quote for, group them by route\n        // and batch them together before logging to minimize number of logs.\n        const debugChunk = 80;\n        _.forEach(_.chunk(debugFailedQuotes, debugChunk), (quotes, idx) => {\n            const failedQuotesByRoute = _.groupBy(quotes, (q) => q.route);\n            const failedFlat = _.mapValues(failedQuotesByRoute, (f) => _(f)\n                .map((f) => `${f.percent}%[${f.amount}]`)\n                .join(','));\n            log.info({\n                failedQuotes: _.map(failedFlat, (amounts, routeStr) => `${routeStr} : ${amounts}`),\n            }, `Failed on chain quotes for routes Part ${idx}/${Math.ceil(debugFailedQuotes.length / debugChunk)}`);\n        });\n        return routesQuotes;\n    }\n    validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {\n        if (successfulQuoteStates.length <= 1) {\n            return null;\n        }\n        const results = _.map(successfulQuoteStates, (quoteState) => quoteState.results);\n        const blockNumbers = _.map(results, (result) => result.blockNumber);\n        const uniqBlocks = _(blockNumbers)\n            .map((blockNumber) => blockNumber.toNumber())\n            .uniq()\n            .value();\n        if (uniqBlocks.length == 1) {\n            return null;\n        }\n        /* if (\n          uniqBlocks.length == 2 &&\n          Math.abs(uniqBlocks[0]! - uniqBlocks[1]!) <= 1\n        ) {\n          return null;\n        } */\n        return new BlockConflictError(`Quotes returned from different blocks. ${uniqBlocks}. ${totalCalls} calls were made with gas limit ${gasLimitOverride}`);\n    }\n    validateSuccessRate(allResults, haveRetriedForSuccessRate) {\n        const numResults = allResults.length;\n        const numSuccessResults = allResults.filter((result) => result.success).length;\n        const successRate = (1.0 * numSuccessResults) / numResults;\n        const { quoteMinSuccessRate } = this.batchParams;\n        if (successRate < quoteMinSuccessRate) {\n            if (haveRetriedForSuccessRate) {\n                log.info(`Quote success rate still below threshold despite retry. Continuing. ${quoteMinSuccessRate}: ${successRate}`);\n                return;\n            }\n            return new SuccessRateError(`Quote success rate below threshold of ${quoteMinSuccessRate}: ${successRate}`);\n        }\n    }\n    /**\n     * Throw an error for incorrect routes / function combinations\n     * @param routes Any combination of V3, V2, and Mixed routes.\n     * @param functionName\n     * @param useMixedRouteQuoter true if there are ANY V2Routes or MixedRoutes in the routes parameter\n     */\n    validateRoutes(routes, functionName, useMixedRouteQuoter) {\n        /// We do not send any V3Routes to new qutoer becuase it is not deployed on chains besides mainnet\n        if (routes.some((route) => route.protocol === Protocol.V3) &&\n            useMixedRouteQuoter) {\n            throw new Error(`Cannot use mixed route quoter with V3 routes`);\n        }\n        /// We cannot call quoteExactOutput with V2 or Mixed routes\n        if (functionName === 'quoteExactOutput' && useMixedRouteQuoter) {\n            throw new Error('Cannot call quoteExactOutput with V2 or Mixed routes');\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib24tY2hhaW4tcXVvdGUtcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJvdmlkZXJzL29uLWNoYWluLXF1b3RlLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUVyRCxPQUFPLEVBQ0wsc0JBQXNCLEVBQ3RCLGFBQWEsRUFDYixRQUFRLEdBQ1QsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEtBQWtDLE1BQU0sYUFBYSxDQUFDO0FBQzdELE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxZQUFZLENBQUM7QUFFL0IsT0FBTyxFQUFjLE9BQU8sRUFBVyxNQUFNLG1CQUFtQixDQUFDO0FBQ2pFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLHVEQUF1RCxDQUFDO0FBQ3JHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQzVELE9BQU8sRUFDTCwrQkFBK0IsRUFDL0IsbUJBQW1CLEdBQ3BCLE1BQU0sbUJBQW1CLENBQUM7QUFFM0IsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNsQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUE4Qi9DLE1BQU0sT0FBTyxrQkFBbUIsU0FBUSxLQUFLO0lBQTdDOztRQUNTLFNBQUksR0FBRyxvQkFBb0IsQ0FBQztJQUNyQyxDQUFDO0NBQUE7QUFDRCxNQUFNLE9BQU8sZ0JBQWlCLFNBQVEsS0FBSztJQUEzQzs7UUFDUyxTQUFJLEdBQUcsa0JBQWtCLENBQUM7SUFDbkMsQ0FBQztD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"]},"metadata":{},"sourceType":"module"}