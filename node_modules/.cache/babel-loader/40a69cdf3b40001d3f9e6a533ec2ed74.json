{"ast":null,"code":"import { initialCollectionFilterState, SortByPointers } from 'nft/hooks';\nimport qs from 'query-string';\nconst trimTraitStr = trait => {\n  return trait.substring(1, trait.length - 1);\n};\nconst urlParamsUtils = {\n  removeDefaults: query => {\n    const clonedQuery = {\n      ...query\n    };\n\n    // Leveraging default values & not showing them on URL\n    for (const key in clonedQuery) {\n      const valueInQuery = clonedQuery[key];\n      const initialValue = initialCollectionFilterState[key];\n      if (JSON.stringify(valueInQuery) === JSON.stringify(initialValue)) {\n        delete clonedQuery[key];\n      }\n    }\n\n    // Doing this one manually due to name mismatch - \"all\" in url, \"buyNow\" in state\n    if (clonedQuery['all'] !== initialCollectionFilterState.buyNow) {\n      delete clonedQuery['all'];\n    }\n    const defaultSortByPointer = SortByPointers[initialCollectionFilterState.sortBy];\n    if (clonedQuery['sort'] === defaultSortByPointer) {\n      delete clonedQuery['sort'];\n    }\n    return clonedQuery;\n  },\n  // Making values in our URL more state-friendly\n  buildQuery: (query, collectionStats) => {\n    const clonedQuery = {\n      ...query\n    };\n    const filters = ['traits', 'markets'];\n    filters.forEach(key => {\n      if (!clonedQuery[key]) {\n        clonedQuery[key] = [];\n      }\n\n      /* \n        query-string package treats arrays with one value as a string.\n        Here we're making sure that we have an array, not a string. Example:\n          const foo = 'hey' // => ['hey']\n      */\n      if (clonedQuery[key] && typeof clonedQuery[key] === 'string') {\n        clonedQuery[key] = [clonedQuery[key]];\n      }\n    });\n    try {\n      const {\n        buyNow: initialBuyNow,\n        search: initialSearchText\n      } = initialCollectionFilterState;\n      Object.entries(SortByPointers).forEach(_ref => {\n        let [key, value] = _ref;\n        if (value === clonedQuery['sort']) {\n          clonedQuery['sortBy'] = Number(key);\n        }\n      });\n      clonedQuery['buyNow'] = !(clonedQuery['all'] === undefined ? !initialBuyNow : clonedQuery['all']);\n      clonedQuery['search'] = clonedQuery['search'] === undefined ? initialSearchText : String(clonedQuery['search']);\n\n      /*\n        Handling an edge case caused by query-string's bad array parsing, when user\n        only selects one trait and reloads the page.\n        Here's the general data-structure for our traits in URL: \n          `traits=(\"trait_type\",\"trait_value\"),(\"trait_type\",\"trait_value\")`\n         Expected behavior: When user selects one trait, there should be an array\n        containing one element.\n         Actual behavior: It creates an array with two elements, first element being\n        trait_type & the other trait_value. This causes confusion since we don't know\n        whether user has selected two traits (cause we have two elements in our array)\n        or it's only one.\n         Using this block of code, we'll identify if that's the case.\n      */\n\n      if (clonedQuery['traits'].length === 2) {\n        const [trait_type, trait_value] = clonedQuery['traits'];\n        const fullTrait = `${trait_type}${trait_value}`;\n        if (!fullTrait.includes(',')) {\n          if (trait_type.startsWith('(') && !trait_type.endsWith(')') && trait_value.endsWith(')') && !trait_value.startsWith('(')) clonedQuery['traits'] = [`${trait_type},${trait_value}`];\n        }\n      }\n      clonedQuery['traits'] = clonedQuery['traits'].map(queryTrait => {\n        const modifiedTrait = trimTraitStr(queryTrait.replace(/(\")/g, ''));\n        const [trait_type, trait_value] = modifiedTrait.split(',');\n        const traitInStats = collectionStats.traits && collectionStats.traits[trait_type].find(trait => trait.trait_value === trait_value);\n\n        /*\n          For most cases, `traitInStats` is assigned. In case the trait\n          does not exist in our store, e.g \"Number of traits\", we have to\n          manually create an object for it.\n        */\n        const trait = traitInStats !== null && traitInStats !== void 0 ? traitInStats : {\n          trait_type,\n          trait_value,\n          trait_count: 0\n        };\n        return trait;\n      });\n    } catch (err) {\n      clonedQuery['traits'] = [];\n    }\n    return clonedQuery;\n  }\n};\nexport const syncLocalFiltersWithURL = state => {\n  const urlFilterItems = ['markets', 'maxPrice', 'maxRarity', 'minPrice', 'minRarity', 'traits', 'all', 'search', 'sort'];\n  const query = {};\n  urlFilterItems.forEach(key => {\n    switch (key) {\n      case 'traits':\n        {\n          const traits = state.traits.map(_ref2 => {\n            let {\n              trait_type,\n              trait_value\n            } = _ref2;\n            return `(\"${trait_type}\",\"${trait_value}\")`;\n          });\n          query['traits'] = traits;\n          break;\n        }\n      case 'all':\n        query['all'] = !state.buyNow;\n        break;\n      case 'sort':\n        query['sort'] = SortByPointers[state.sortBy];\n        break;\n      default:\n        query[key] = state[key];\n        break;\n    }\n  });\n  const modifiedQuery = urlParamsUtils.removeDefaults(query);\n\n  // Applying local state changes to URL\n  const url = window.location.href.split('?')[0];\n  const stringifiedQuery = qs.stringify(modifiedQuery, {\n    arrayFormat: 'comma'\n  });\n\n  // Using window.history directly on purpose here. router.push() will trigger re-renders & API calls.\n  window.history.replaceState({}, ``, `${url}${stringifiedQuery && `?${stringifiedQuery}`}`);\n};\nexport const applyFiltersFromURL = (location, collectionStats) => {\n  if (!location.search) return;\n  const query = qs.parse(location.search, {\n    arrayFormat: 'comma',\n    parseNumbers: true,\n    parseBooleans: true\n  });\n  const modifiedQuery = urlParamsUtils.buildQuery(query, collectionStats);\n  return modifiedQuery;\n};","map":{"version":3,"names":["initialCollectionFilterState","SortByPointers","qs","trimTraitStr","trait","substring","length","urlParamsUtils","removeDefaults","query","clonedQuery","key","valueInQuery","initialValue","JSON","stringify","buyNow","defaultSortByPointer","sortBy","buildQuery","collectionStats","filters","forEach","initialBuyNow","search","initialSearchText","Object","entries","value","Number","undefined","String","trait_type","trait_value","fullTrait","includes","startsWith","endsWith","map","queryTrait","modifiedTrait","replace","split","traitInStats","traits","find","trait_count","err","syncLocalFiltersWithURL","state","urlFilterItems","modifiedQuery","url","window","location","href","stringifiedQuery","arrayFormat","history","replaceState","applyFiltersFromURL","parse","parseNumbers","parseBooleans"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/nft/utils/urlParams.ts"],"sourcesContent":["import { CollectionFilters, initialCollectionFilterState, SortByPointers, Trait } from 'nft/hooks'\nimport { GenieCollection } from 'nft/types'\nimport qs from 'query-string'\nimport { Location } from 'react-router-dom'\n\nconst trimTraitStr = (trait: string) => {\n  return trait.substring(1, trait.length - 1)\n}\n\nconst urlParamsUtils = {\n  removeDefaults: (query: Record<string, any>) => {\n    const clonedQuery: Record<string, any> = { ...query }\n\n    // Leveraging default values & not showing them on URL\n    for (const key in clonedQuery) {\n      const valueInQuery = clonedQuery[key]\n      const initialValue = initialCollectionFilterState[key as keyof typeof initialCollectionFilterState]\n\n      if (JSON.stringify(valueInQuery) === JSON.stringify(initialValue)) {\n        delete clonedQuery[key]\n      }\n    }\n\n    // Doing this one manually due to name mismatch - \"all\" in url, \"buyNow\" in state\n    if (clonedQuery['all'] !== initialCollectionFilterState.buyNow) {\n      delete clonedQuery['all']\n    }\n\n    const defaultSortByPointer = SortByPointers[initialCollectionFilterState.sortBy]\n    if (clonedQuery['sort'] === defaultSortByPointer) {\n      delete clonedQuery['sort']\n    }\n\n    return clonedQuery\n  },\n\n  // Making values in our URL more state-friendly\n  buildQuery: (query: Record<string, any>, collectionStats: GenieCollection) => {\n    const clonedQuery: Record<string, any> = { ...query }\n    const filters = ['traits', 'markets']\n\n    filters.forEach((key) => {\n      if (!clonedQuery[key]) {\n        clonedQuery[key] = []\n      }\n\n      /* \n        query-string package treats arrays with one value as a string.\n        Here we're making sure that we have an array, not a string. Example:\n          const foo = 'hey' // => ['hey']\n      */\n      if (clonedQuery[key] && typeof clonedQuery[key] === 'string') {\n        clonedQuery[key] = [clonedQuery[key]]\n      }\n    })\n\n    try {\n      const { buyNow: initialBuyNow, search: initialSearchText } = initialCollectionFilterState\n\n      Object.entries(SortByPointers).forEach(([key, value]) => {\n        if (value === clonedQuery['sort']) {\n          clonedQuery['sortBy'] = Number(key)\n        }\n      })\n\n      clonedQuery['buyNow'] = !(clonedQuery['all'] === undefined ? !initialBuyNow : clonedQuery['all'])\n      clonedQuery['search'] = clonedQuery['search'] === undefined ? initialSearchText : String(clonedQuery['search'])\n\n      /*\n        Handling an edge case caused by query-string's bad array parsing, when user\n        only selects one trait and reloads the page.\n        Here's the general data-structure for our traits in URL: \n          `traits=(\"trait_type\",\"trait_value\"),(\"trait_type\",\"trait_value\")`\n\n        Expected behavior: When user selects one trait, there should be an array\n        containing one element.\n\n        Actual behavior: It creates an array with two elements, first element being\n        trait_type & the other trait_value. This causes confusion since we don't know\n        whether user has selected two traits (cause we have two elements in our array)\n        or it's only one.\n\n        Using this block of code, we'll identify if that's the case.\n      */\n\n      if (clonedQuery['traits'].length === 2) {\n        const [trait_type, trait_value] = clonedQuery['traits'] as [string, string]\n        const fullTrait = `${trait_type}${trait_value}`\n        if (!fullTrait.includes(',')) {\n          if (\n            trait_type.startsWith('(') &&\n            !trait_type.endsWith(')') &&\n            trait_value.endsWith(')') &&\n            !trait_value.startsWith('(')\n          )\n            clonedQuery['traits'] = [`${trait_type},${trait_value}`]\n        }\n      }\n\n      clonedQuery['traits'] = clonedQuery['traits'].map((queryTrait: string) => {\n        const modifiedTrait = trimTraitStr(queryTrait.replace(/(\")/g, ''))\n        const [trait_type, trait_value] = modifiedTrait.split(',')\n        const traitInStats =\n          collectionStats.traits &&\n          collectionStats.traits[trait_type].find((trait) => trait.trait_value === trait_value)\n\n        /*\n          For most cases, `traitInStats` is assigned. In case the trait\n          does not exist in our store, e.g \"Number of traits\", we have to\n          manually create an object for it.\n        */\n        const trait = traitInStats ?? { trait_type, trait_value, trait_count: 0 }\n\n        return trait as Trait\n      })\n    } catch (err) {\n      clonedQuery['traits'] = []\n    }\n\n    return clonedQuery\n  },\n}\n\nexport const syncLocalFiltersWithURL = (state: CollectionFilters) => {\n  const urlFilterItems = [\n    'markets',\n    'maxPrice',\n    'maxRarity',\n    'minPrice',\n    'minRarity',\n    'traits',\n    'all',\n    'search',\n    'sort',\n  ] as const\n\n  const query: Record<string, any> = {}\n  urlFilterItems.forEach((key) => {\n    switch (key) {\n      case 'traits': {\n        const traits = state.traits.map(({ trait_type, trait_value }) => `(\"${trait_type}\",\"${trait_value}\")`)\n        query['traits'] = traits\n        break\n      }\n      case 'all':\n        query['all'] = !state.buyNow\n        break\n\n      case 'sort':\n        query['sort'] = SortByPointers[state.sortBy]\n        break\n\n      default:\n        query[key] = state[key]\n        break\n    }\n  })\n\n  const modifiedQuery = urlParamsUtils.removeDefaults(query)\n\n  // Applying local state changes to URL\n  const url = window.location.href.split('?')[0]\n  const stringifiedQuery = qs.stringify(modifiedQuery, { arrayFormat: 'comma' })\n\n  // Using window.history directly on purpose here. router.push() will trigger re-renders & API calls.\n  window.history.replaceState({}, ``, `${url}${stringifiedQuery && `?${stringifiedQuery}`}`)\n}\n\nexport const applyFiltersFromURL = (location: Location, collectionStats: GenieCollection) => {\n  if (!location.search) return\n\n  const query = qs.parse(location.search, {\n    arrayFormat: 'comma',\n    parseNumbers: true,\n    parseBooleans: true,\n  }) as {\n    maxPrice: string\n    maxRarity: string\n    minPrice: string\n    minRarity: string\n    search: string\n    sort: string\n    sortBy: number\n    all: boolean\n    buyNow: boolean\n    traits: string[]\n    markets: string[]\n  }\n  const modifiedQuery = urlParamsUtils.buildQuery(query, collectionStats)\n\n  return modifiedQuery\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}