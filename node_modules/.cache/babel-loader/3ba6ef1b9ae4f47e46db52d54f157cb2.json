{"ast":null,"code":"import React from 'react';\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar GestureFlag;\n(function (GestureFlag) {\n  GestureFlag[\"OnStart\"] = \"start\";\n  GestureFlag[\"OnChange\"] = \"change\";\n  GestureFlag[\"OnEnd\"] = \"end\";\n})(GestureFlag || (GestureFlag = {}));\n\n// blank function\nvar noop = function noop() {}; // returns a function that chains all functions given as parameters\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n}; // vector add\n\nvar addV = function addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n}; // vector substract\n\nvar subV = function subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n};\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var type = _ref[0],\n        fn = _ref[1];\n      return el[action](type, fn, options);\n    });\n  };\n};\nvar addListeners = /*#__PURE__*/\nsetListeners(true);\nvar removeListeners = /*#__PURE__*/\nsetListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n    altKey = event.altKey,\n    metaKey = event.metaKey,\n    ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets scroll event data\r\n * @param event\r\n * @returns scroll event data\r\n */\n\nfunction getScrollEventData(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n    scrollX = _event$currentTarget.scrollX,\n    scrollY = _event$currentTarget.scrollY,\n    scrollLeft = _event$currentTarget.scrollLeft,\n    scrollTop = _event$currentTarget.scrollTop;\n  return _extends({\n    xy: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets wheel event data\r\n * @param event\r\n * @returns wheel event data\r\n */\n\nfunction getWheelEventData(event) {\n  var deltaX = event.deltaX,\n    deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return _extends({\n    xy: [deltaX, deltaY]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets pointer event data\r\n * @param event\r\n * @returns pointer event data\r\n */\n\nfunction getPointerEventData(event) {\n  var touches = event.touches,\n    buttons = event.buttons,\n    changedTouches = event.changedTouches;\n  var touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n    clientX = _ref2.clientX,\n    clientY = _ref2.clientY;\n  var down = touchEvents && touchEvents.length > 0 || buttons > 0;\n  return _extends({\n    xy: [clientX, clientY],\n    touches: touchEvents && touchEvents.length || 0,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return _extends({\n    da: da,\n    origin: origin,\n    touches: 2,\n    down: touches.length > 0\n  }, getModifierKeys(event));\n}\n/**\r\n * Calculates velocity\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @param len the length of the delta vector\r\n * @returns velocity\r\n */\n\nfunction calculateVelocity(delta, delta_t, len) {\n  len = len || Math.hypot.apply(Math, delta);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @returns velocities vector\r\n */\n\nfunction calculateVelocities(delta, delta_t) {\n  return delta_t ? delta.map(function (v) {\n    return v / delta_t;\n  }) : Array(delta.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param delta\r\n * @param len\r\n * @returns direction\r\n */\n\nfunction calculateDirection(delta, len) {\n  len = len || Math.hypot.apply(Math, delta) || 1;\n  return delta.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\nfunction calculateAllKinematics(movement, delta, delta_t) {\n  var len = Math.hypot.apply(Math, delta);\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len)\n  };\n}\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\nfunction gestureEventSupported() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\r\n * Some gestures might use the state key from another gesture (i.e. hover)\r\n * so mappedKeys is a commodity object to get the state key and handler key\r\n * for every gesture\r\n */\n\nvar mappedKeys = {\n  drag: {\n    stateKey: 'drag',\n    handlerKey: 'onDrag'\n  },\n  pinch: {\n    stateKey: 'pinch',\n    handlerKey: 'onPinch'\n  },\n  move: {\n    stateKey: 'move',\n    handlerKey: 'onMove'\n  },\n  scroll: {\n    stateKey: 'scroll',\n    handlerKey: 'onScroll'\n  },\n  wheel: {\n    stateKey: 'wheel',\n    handlerKey: 'onWheel'\n  },\n  hover: {\n    stateKey: 'move',\n    handlerKey: 'onHover'\n  }\n}; // default config (will extend user config)\n\nvar defaultConfig = {\n  domTarget: undefined,\n  event: {\n    passive: true,\n    capture: false\n  },\n  window: typeof window !== 'undefined' ? window : undefined,\n  dragDelay: false,\n  passiveEvents: true,\n  pointerEvents: false,\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true\n}; // common initial state for all gestures\n\nvar initialCommon = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  delta: [0, 0],\n  movement: [0, 0],\n  offset: [0, 0],\n  direction: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined\n}; // initial state for coordinates-based gestures\n\nvar initialCoordinates = {\n  xy: [0, 0],\n  vxvy: [0, 0],\n  velocity: 0,\n  distance: 0\n}; // xy coordinates\n// initial state for distance and angle-based gestures (pinch)\n\nvar initialDistanceAngle = {\n  da: [0, 0],\n  vdva: [0, 0],\n  origin: undefined,\n  turns: 0\n}; // distance and angle\n// initial state object (used by the gesture controller)\n\nvar initialState = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  },\n  move: /*#__PURE__*/\n  _extends({}, initialCommon, {}, initialCoordinates),\n  drag: /*#__PURE__*/\n  _extends({}, initialCommon, {}, initialCoordinates),\n  scroll: /*#__PURE__*/\n  _extends({}, initialCommon, {}, initialCoordinates),\n  wheel: /*#__PURE__*/\n  _extends({}, initialCommon, {}, initialCoordinates),\n  pinch: /*#__PURE__*/\n  _extends({}, initialCommon, {}, initialDistanceAngle)\n}; // generic end state for all gestures\n\nvar genericEndState = {\n  first: false,\n  last: true,\n  active: false\n};\n\n/**\r\n * Recognizer abstract class\r\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\nvar Recognizer = /*#__PURE__*/\nfunction () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param gestureKey drag, move, hover, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(gestureKey, controller, args) {\n    var _this = this;\n    if (args === void 0) {\n      args = [];\n    }\n    this.gestureKey = gestureKey;\n    this.controller = controller;\n    this.args = args;\n    /**\r\n     * Continuous gestures are scroll or wheel, where the next gesture continues the previous one.\r\n     * In other words, these gestures also start with a delta.\r\n     */\n\n    this.continuousGesture = false; // convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n      if (ms === void 0) {\n        ms = 140;\n      }\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // convenience method to clear a timeout for a given gesture\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    }; // convenience method to add window listeners for a given gesture\n\n    this.addWindowListeners = function (listeners) {\n      _this.controller.addWindowListeners(_this.stateKey, listeners);\n    }; // convenience method to remove window listeners for a given gesture\n\n    this.removeWindowListeners = function () {\n      _this.controller.removeWindowListeners(_this.stateKey);\n    };\n    /**\r\n     * convenience method to update the controller state for a given gesture\r\n     * @param sharedState shared partial state object\r\n     * @param gestureState partial state object for the gesture handled by the recognizer\r\n     * @param [gestureFlag] if set, will also fire the gesture handler set by the user\r\n     */\n\n    this.updateState = function (sharedState, gestureState) {\n      _this.controller.updateState(sharedState, gestureState, _this.stateKey);\n    };\n    this.fireGestureHandler = function (gestureFlag) {\n      _this.controller.fireGestureHandler(_this.gestureKey, gestureFlag);\n    }; // generic onStart function\n\n    this.onStart = function (event, payload) {\n      var _this$getPayloadFromE = _this.getPayloadFromEvent(event),\n        values = _this$getPayloadFromE.values,\n        gesturePayload = _this$getPayloadFromE.gesturePayload,\n        sharedPayload = _this$getPayloadFromE.sharedPayload; // TODO probably needs some rework, initialState and resetState should be different\n\n      var startState = _extends({}, initialState[_this.stateKey], {\n        values: values,\n        event: event,\n        first: true,\n        active: true,\n        time: event.timeStamp,\n        args: _this.args\n      });\n      var _this$state = _this.state,\n        prevValues = _this$state.values,\n        offset = _this$state.offset;\n      if (_this.continuousGesture) {\n        startState.initial = startState.previous = prevValues;\n        startState.delta = startState.movement = subV(values, prevValues);\n        startState.offset = values;\n        Object.assign(startState, calculateAllKinematics(startState.movement, startState.delta, 0));\n      } else {\n        startState.initial = startState.previous = values;\n        startState.offset = offset;\n      }\n      _this.updateState(_extends({}, _this.sharedStartState, {}, sharedPayload), _extends({}, startState, {}, gesturePayload, {}, payload));\n      _this.fireGestureHandler(GestureFlag.OnStart);\n    }; // generic onChange function\n\n    this.onChange = function (event, payload) {\n      var _this$getPayloadFromE2 = _this.getPayloadFromEvent(event),\n        values = _this$getPayloadFromE2.values,\n        gesturePayload = _this$getPayloadFromE2.gesturePayload,\n        sharedPayload = _this$getPayloadFromE2.sharedPayload;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateState(_extends({}, sharedPayload), _extends({\n        first: false\n      }, kinematics, {}, gesturePayload, {}, payload));\n      _this.fireGestureHandler(GestureFlag.OnChange);\n    }; // generic onEnd function\n\n    this.onEnd = function (event, payload) {\n      if (!_this.state.active) return;\n      _this.removeWindowListeners();\n      _this.updateState(_this.sharedEndState, _extends({\n        event: event\n      }, genericEndState, {}, payload));\n      _this.fireGestureHandler(GestureFlag.OnEnd);\n    }; // generic cancel function\n\n    this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    }; // generic gesture handler for timeout-based gestures\n\n    this.timeoutHandler = function (event) {\n      if (!_this.enabled) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onEnd);\n      if (!_this.state.active) _this.onStart(event);else _this.onChange(event);\n    }; // mapping this.stateKey to the state key the gesture handles\n    // (ie hover actually deals with the move gesture state)\n\n    this.stateKey = mappedKeys[gestureKey].stateKey;\n  } // is the gesture enabled\n\n  _createClass(Recognizer, [{\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.controller.config[this.gestureKey];\n    } // get the controller state for a given gesture\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    }\n  }]);\n  return Recognizer;\n}();\n\n/**\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\nvar CoordinatesRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = CoordinatesRecognizer.prototype;\n  _proto.getKinematics = function getKinematics(values, event) {\n    // we get the gesture specific state\n    var _this$state = this.state,\n      xy = _this$state.values,\n      initial = _this$state.initial,\n      offset = _this$state.offset,\n      time = _this$state.time; // offset is the difference between the current and initial value vectors\n\n    var movement = subV(values, initial); // delta is the difference between the current and previous value vectors\n\n    var delta = subV(values, xy);\n    var delta_t = event.timeStamp - time;\n    var _calculateAllKinemati = calculateAllKinematics(movement, delta, delta_t),\n      velocity = _calculateAllKinemati.velocity,\n      velocities = _calculateAllKinemati.velocities,\n      distance = _calculateAllKinemati.distance,\n      direction = _calculateAllKinemati.direction;\n    return {\n      event: event,\n      values: values,\n      movement: movement,\n      offset: addV(offset, delta),\n      delta: delta,\n      velocity: velocity,\n      vxvy: velocities,\n      distance: distance,\n      direction: direction,\n      previous: xy,\n      time: event.timeStamp\n    };\n  };\n  return CoordinatesRecognizer;\n}(Recognizer);\nvar DEFAULT_DRAG_DELAY = 180;\nvar DragRecognizer = /*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n  function DragRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n    _this.sharedStartState = {\n      dragging: true,\n      down: true\n    };\n    _this.sharedEndState = {\n      dragging: false,\n      down: false,\n      buttons: 0,\n      touches: 0\n    };\n    _this.delayedEvent = false;\n    _this.onDragStart = function (event) {\n      if (!_this.enabled) return; // making sure we're not dragging the element when more than one finger press the screen\n\n      var _getPointerEventData = getPointerEventData(event),\n        touches = _getPointerEventData.touches;\n      if (touches > 1) return;\n      var currentTarget = event.currentTarget,\n        pointerId = event.pointerId;\n      if (_this.controller.config.pointerEvents) {\n        // if pointers events\n        currentTarget && currentTarget.setPointerCapture(pointerId);\n      } else {\n        _this.removeWindowListeners();\n        var dragListeners = [['mousemove', _this.onDragChange], ['touchmove', _this.onDragChange], ['mouseup', _this.onDragEnd], ['touchend', _this.onDragEnd], ['touchcancel', _this.onDragEnd]];\n        _this.addWindowListeners(dragListeners);\n      }\n      if (_this.controller.config.dragDelay) {\n        var dragDelay = typeof _this.controller.config.dragDelay === 'number' ? _this.controller.config.dragDelay : DEFAULT_DRAG_DELAY;\n        if (typeof event.persist === 'function') event.persist();\n        _this.delayedEvent = true;\n        _this.setTimeout(function () {\n          return _this.startDrag(event);\n        }, dragDelay);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n    _this.startDrag = function (event) {\n      var currentTarget = event.currentTarget,\n        pointerId = event.pointerId;\n      _this.onStart(event, {\n        currentTarget: currentTarget,\n        pointerId: pointerId,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n      _this.delayedEvent = false;\n    };\n    _this.onDragChange = function (event) {\n      var _this$state = _this.state,\n        canceled = _this$state.canceled,\n        active = _this$state.active;\n      if (canceled) return;\n      if (!active) {\n        if (_this.delayedEvent) {\n          _this.clearTimeout();\n          _this.startDrag(event);\n        }\n        return;\n      }\n      var _getPointerEventData2 = getPointerEventData(event),\n        buttons = _getPointerEventData2.buttons,\n        touches = _getPointerEventData2.touches;\n      if (buttons === 0 && touches === 0) {\n        _this.onEnd(event);\n        return;\n      }\n      _this.onChange(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n    _this.onDragEnd = function (event) {\n      _this.clearTimeout();\n      _this.delayedEvent = false;\n      if (!_this.state.active) return;\n      var _this$state2 = _this.state,\n        currentTarget = _this$state2.currentTarget,\n        pointerId = _this$state2.pointerId;\n      if (currentTarget && _this.controller.config.pointerEvents) currentTarget.releasePointerCapture(pointerId);\n      _this.onEnd(event);\n    };\n    return _this;\n  }\n  var _proto = DragRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getPointerEventData3 = getPointerEventData(event),\n      xy = _getPointerEventData3.xy,\n      sharedPayload = _objectWithoutPropertiesLoose(_getPointerEventData3, [\"xy\"]);\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerDown', this.onDragStart], ['onPointerMove', this.onDragChange], [['onPointerUp'], this.onDragEnd]];\n    }\n    return [[['onMouseDown', 'onTouchStart'], this.onDragStart]];\n  };\n  return DragRecognizer;\n}(CoordinatesRecognizer);\nvar ScrollRecognizer = /*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n  function ScrollRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n    _this.sharedStartState = {\n      scrolling: true\n    };\n    _this.sharedEndState = {\n      scrolling: false,\n      velocity: 0,\n      vxvy: [0, 0]\n    };\n    _this.continuousGesture = true;\n    return _this;\n  }\n  var _proto = ScrollRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getScrollEventData = getScrollEventData(event),\n      xy = _getScrollEventData.xy,\n      sharedPayload = _objectWithoutPropertiesLoose(_getScrollEventData, [\"xy\"]);\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onScroll', this.timeoutHandler]];\n  };\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\nvar WheelRecognizer = /*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n  function WheelRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n    _this.sharedStartState = {\n      wheeling: true\n    };\n    _this.sharedEndState = {\n      wheeling: false,\n      velocity: 0,\n      vxvy: [0, 0]\n    };\n    _this.continuousGesture = true;\n    _this.onWheel = function (event) {\n      if (event.ctrlKey && _this.controller.actions.has('onPinch')) return;\n      _this.timeoutHandler(event);\n    };\n    return _this;\n  }\n  var _proto = WheelRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var prevXY = this.state.xy;\n    var _getWheelEventData = getWheelEventData(event),\n      xy = _getWheelEventData.xy,\n      sharedPayload = _objectWithoutPropertiesLoose(_getWheelEventData, [\"xy\"]);\n    var values = addV(xy, prevXY);\n    return {\n      values: values,\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onWheel]];\n  };\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\nvar MoveRecognizer = /*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n  function MoveRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n    _this.sharedStartState = {\n      moving: true\n    };\n    _this.sharedEndState = {\n      moving: false,\n      velocity: 0,\n      vxvy: [0, 0]\n    };\n    return _this;\n  }\n  var _proto = MoveRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getPointerEventData = getPointerEventData(event),\n      xy = _getPointerEventData.xy,\n      sharedPayload = _objectWithoutPropertiesLoose(_getPointerEventData, [\"xy\"]);\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerMove', this.timeoutHandler]];\n    }\n    return [['onMouseMove', this.timeoutHandler]];\n  };\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\nvar HoverRecognizer = /*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(HoverRecognizer, _CoordinatesRecognize);\n  function HoverRecognizer(controller, args) {\n    var _this;\n    _this = _CoordinatesRecognize.call(this, 'hover', controller, args) || this;\n    _this.onPointerEnter = function (event) {\n      if (!_this.enabled) return;\n      var _this$getPayloadFromE = _this.getPayloadFromEvent(event),\n        values = _this$getPayloadFromE.values,\n        sharedPayload = _this$getPayloadFromE.sharedPayload;\n      _this.updateState(_extends({\n        hovering: true\n      }, sharedPayload), {\n        values: values,\n        event: event,\n        args: _this.args\n      });\n      _this.fireGestureHandler(GestureFlag.OnChange);\n    };\n    _this.onPointerLeave = function (event) {\n      if (!_this.enabled) return;\n      var _this$getPayloadFromE2 = _this.getPayloadFromEvent(event),\n        values = _this$getPayloadFromE2.values,\n        sharedPayload = _this$getPayloadFromE2.sharedPayload;\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateState(_extends({\n        hovering: false,\n        moving: false\n      }, sharedPayload), _extends({}, kinematics, {}, genericEndState, {\n        velocity: 0,\n        vxvy: [0, 0]\n      })); // when the mouse leaves the element, we also fire the move handler\n      // without waiting for move to end with debounce\n\n      _this.controller.fireGestureHandler('move', GestureFlag.OnEnd);\n      _this.controller.fireGestureHandler('hover', GestureFlag.OnChange);\n    };\n    return _this;\n  }\n  var _proto = HoverRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getPointerEventData = getPointerEventData(event),\n      xy = _getPointerEventData.xy,\n      sharedPayload = _objectWithoutPropertiesLoose(_getPointerEventData, [\"xy\"]);\n    return {\n      values: xy,\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerEnter', this.onPointerEnter], ['onPointerLeave', this.onPointerLeave]];\n    }\n    return [['onMouseEnter', this.onPointerEnter], ['onMouseLeave', this.onPointerLeave]];\n  };\n  return HoverRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\nvar DistanceAngleRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n  function DistanceAngleRecognizer(gestureKey, controller, args) {\n    if (args === void 0) {\n      args = [];\n    }\n    return _Recognizer.call(this, gestureKey, controller, args) || this;\n  }\n  var _proto = DistanceAngleRecognizer.prototype;\n  _proto.getKinematics = function getKinematics(_ref, event) {\n    var d = _ref[0],\n      a = _ref[1];\n    var _this$state = this.state,\n      da = _this$state.values,\n      turns = _this$state.turns,\n      initial = _this$state.initial,\n      offset = _this$state.offset,\n      time = _this$state.time; // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n\n    a = a !== void 0 ? a : da[1];\n    var delta_d = d - da[0];\n    var delta_a = a - da[1];\n    /**\r\n     * The angle value might jump from 179deg to -179deg when we actually want to\r\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\r\n     */\n\n    var newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns; // we update the angle difference to its corrected value\n\n    delta_a -= 360 * (newTurns - turns);\n    var delta = [delta_d, delta_a];\n    var movement_d = d - initial[0];\n    var movement_a = a - 360 * newTurns - initial[1];\n    var movement = [movement_d, movement_a];\n    var delta_t = event.timeStamp - time;\n    var vdva = calculateVelocities(delta, delta_t);\n    var direction = calculateDirection(delta);\n    return {\n      event: event,\n      values: [d, a],\n      movement: movement,\n      delta: delta,\n      offset: addV(offset, delta),\n      vdva: vdva,\n      direction: direction,\n      turns: newTurns,\n      previous: da,\n      time: event.timeStamp\n    };\n  };\n  return DistanceAngleRecognizer;\n}(Recognizer);\nvar PinchRecognizer = /*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n  function PinchRecognizer(controller, args) {\n    var _this;\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.sharedStartState = {\n      pinching: true\n    };\n    _this.sharedEndState = {\n      pinching: false,\n      down: false,\n      touches: 0\n    };\n    _this.onPinchStart = function (event) {\n      if (!_this.enabled || event.touches.length !== 2) return;\n      _this.onStart(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n        canceled = _this$state.canceled,\n        active = _this$state.active,\n        time = _this$state.time;\n      if (canceled || !active || event.touches.length !== 2 || event.timeStamp === time) return;\n      _this.onChange(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n    return _this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n      da = _getTwoTouchesEventDa.da,\n      origin = _getTwoTouchesEventDa.origin,\n      sharedPayload = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, [\"da\", \"origin\"]);\n    return {\n      values: da,\n      gesturePayload: {\n        origin: origin\n      },\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onTouchStart', this.onPinchStart], ['onTouchMove', this.onPinchChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];\n  };\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\nvar PinchWheelRecognizer = /*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWheelRecognizer, _DistanceAngleRecogni);\n  function PinchWheelRecognizer(controller, args) {\n    var _this;\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.sharedStartState = {\n      pinching: true\n    };\n    _this.sharedEndState = {\n      pinching: false\n    };\n    _this.onWheel = function (event) {\n      if (!event.ctrlKey) return;\n      if (!_this.controller.config.passiveEvents) event.preventDefault();else if (process.env.NODE_ENV === 'development') console.warn('To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.');\n      _this.timeoutHandler(event);\n    };\n    return _this;\n  }\n  var _proto = PinchWheelRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    var _getWheelEventData = getWheelEventData(event),\n      _getWheelEventData$xy = _getWheelEventData.xy,\n      delta_d = _getWheelEventData$xy[1],\n      sharedPayload = _objectWithoutPropertiesLoose(_getWheelEventData, [\"xy\"]);\n    var _this$state$da = this.state.da,\n      prev_d = _this$state$da[0],\n      prev_a = _this$state$da[1];\n    var d = prev_d - delta_d;\n    var a = prev_a !== void 0 ? prev_a : 0;\n    var origin = [event.clientX, event.clientY];\n    return {\n      values: [d, a],\n      gesturePayload: {\n        origin: origin\n      },\n      sharedPayload: sharedPayload\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onWheel]];\n  };\n  return PinchWheelRecognizer;\n}(DistanceAngleRecognizer);\nvar SCALE_FACTOR = 260;\nvar PinchWebKitGestureRecognizer = /*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWebKitGestureRecognizer, _DistanceAngleRecogni);\n  function PinchWebKitGestureRecognizer(controller, args) {\n    var _this;\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.sharedStartState = {\n      pinching: true,\n      down: true,\n      touches: 2\n    };\n    _this.sharedEndState = {\n      pinching: false,\n      down: false,\n      touches: 0\n    };\n    _this.onPinchStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n      var origin = _this.origin ? _this.origin : [event.clientX, event.clientY];\n      _this.onStart(event, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n        canceled = _this$state.canceled,\n        active = _this$state.active;\n      if (canceled || !active) return;\n      event.preventDefault();\n      _this.onChange(event, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      });\n    };\n    _this.onGestureEnd = function (event) {\n      _this.onEnd(event);\n      event.preventDefault();\n      _this.origin = undefined;\n    };\n    _this.updateTouchData = function (event) {\n      if (!_this.enabled || event.touches.length !== 2) return;\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n        origin = _getTwoTouchesEventDa.origin;\n      _this.origin = origin;\n    };\n    return _this;\n  }\n  var _proto = PinchWebKitGestureRecognizer.prototype;\n  _proto.getPayloadFromEvent = function getPayloadFromEvent(event) {\n    return {\n      values: [event.scale * SCALE_FACTOR, event.rotation]\n    };\n  };\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onGestureStart', this.onPinchStart], ['onGestureChange', this.onPinchChange], [['onGestureEnd', 'onTouchCancel'], this.onGestureEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];\n  };\n  return PinchWebKitGestureRecognizer;\n}(DistanceAngleRecognizer);\n\n/**\r\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\r\n * and keep track of the state for all gestures\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\nvar GestureController = function GestureController(handlers, config) {\n  var _this = this;\n  this.handlers = handlers;\n  this.config = config;\n  this.state = initialState; // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  /**\r\n   * Function run on component unmount\r\n   * Cleans timeouts and removes dom listeners set by the bind function\r\n   */\n\n  this.clean = function () {\n    _this.cleanOnBind();\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render)\r\n   * Reset the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n  this.cleanOnBind = function () {\n    _this.bindings = {};\n    var domTarget = _this.config.domTarget;\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.event);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Commodity function to let gesture recognizer update global state\r\n   * @param sharedState shared partial state object\r\n   * @param gestureState partial gesture specific state object\r\n   * @param stateKey the state key ('drag', 'move'...)\r\n   */\n\n  this.updateState = function (sharedState, gestureState, stateKey) {\n    var _extends2;\n    var newGestureState = _extends({}, _this.state[stateKey], {}, gestureState);\n    if ('da' in newGestureState) newGestureState.da = newGestureState.values;else if ('xy' in newGestureState) newGestureState.xy = newGestureState.values;\n    _this.state = _extends({}, _this.state, (_extends2 = {\n      shared: _extends({}, _this.state.shared, {}, sharedState)\n    }, _extends2[stateKey] = newGestureState, _extends2));\n  }; // fire the gesture handler defined by the user\n\n  this.fireGestureHandler = function (gestureKey, gestureFlag) {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    var _mappedKeys$gestureKe = mappedKeys[gestureKey],\n      stateKey = _mappedKeys$gestureKe.stateKey,\n      handlerKey = _mappedKeys$gestureKe.handlerKey;\n    var state = _extends({}, _this.state.shared, {}, _this.state[stateKey]);\n    if (state.event) state.event.gesture = gestureKey;\n    if (gestureFlag === GestureFlag.OnStart) {\n      var handlerStart = handlerKey + \"Start\";\n      var _handler = _this.handlers[handlerStart];\n      _handler && _handler(state);\n    } // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n\n    var handler = _this.handlers[handlerKey];\n    if (handler) {\n      var newMemo = handler(state);\n      _this.state[stateKey].memo = newMemo !== void 0 ? newMemo : _this.state[stateKey].memo;\n    }\n    if (gestureFlag === GestureFlag.OnEnd) {\n      var handlerEnd = handlerKey + \"End\";\n      var _handler2 = _this.handlers[handlerEnd];\n      _handler2 && _handler2(state);\n    }\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window\r\n   * @param stateKey\r\n   * @param listeners\r\n   */\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.event);\n  }; // commodity function to let recognizers simply remove listeners from config.window\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.event);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * Adds a recognizer to this.bindings\r\n   * @param recognizer\r\n   */\n\n  this.addRecognizer = function (recognizer) {\n    recognizer.getEventBindings().map(_this.addEventBindings);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n  this.addEventBindings = function (_ref) {\n    var eventNames = _ref[0],\n      fn = _ref[1];\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      _this.bindings[eventName] = _this.bindings[eventName] ? [].concat(_this.bindings[eventName], [fn]) : [fn];\n    });\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n  this.addDomTargetListeners = function () {\n    var domTarget = _this.config.domTarget; // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n        fns = _ref2[1];\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(domTarget, _this.domListeners, _this.config.event);\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with\r\n   */\n\n  this.getBindings = function () {\n    var output = {};\n    var captureString = _this.config.event.capture ? 'Capture' : '';\n    Object.entries(_this.bindings).forEach(function (_ref3) {\n      var event = _ref3[0],\n        fns = _ref3[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      output[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return output;\n  };\n  this.bind = function () {\n    var domTarget = _this.config.domTarget;\n    var genuineHandlers = _extends({}, _this.handlers); // cleaning before adding\n\n    _this.cleanOnBind();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (_this.actions.has('onDrag')) {\n      _this.addRecognizer(new DragRecognizer(_this, args));\n      delete genuineHandlers.onDrag;\n      delete genuineHandlers.onDragStart;\n      delete genuineHandlers.onDragEnd;\n    }\n    if (_this.actions.has('onScroll')) {\n      _this.addRecognizer(new ScrollRecognizer(_this, args));\n      delete genuineHandlers.onScroll;\n      delete genuineHandlers.onScrollStart;\n      delete genuineHandlers.onScrollEnd;\n    }\n    if (_this.actions.has('onWheel')) {\n      _this.addRecognizer(new WheelRecognizer(_this, args));\n      delete genuineHandlers.onWheel;\n      delete genuineHandlers.onWheelStart;\n      delete genuineHandlers.onWheelEnd;\n    }\n    if (_this.actions.has('onMove')) {\n      _this.addRecognizer(new MoveRecognizer(_this, args));\n      delete genuineHandlers.onMove;\n      delete genuineHandlers.onMoveStart;\n      delete genuineHandlers.onMoveEnd;\n    }\n    if (_this.actions.has('onHover')) {\n      _this.addRecognizer(new HoverRecognizer(_this, args));\n      delete genuineHandlers.onHover;\n    }\n    if (_this.actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && gestureEventSupported()) {\n        _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));\n      } else {\n        _this.addRecognizer(new PinchRecognizer(_this, args));\n        _this.addRecognizer(new PinchWheelRecognizer(_this, args));\n      }\n      delete genuineHandlers.onPinch;\n      delete genuineHandlers.onPinchStart;\n      delete genuineHandlers.onPinchEnd;\n    } // we also add event bindings for genuine handlers\n\n    Object.entries(genuineHandlers).map(function (_ref4) {\n      var event = _ref4[0],\n        fn = _ref4[1];\n\n      // we're cheating when it comes to event type :(\n      _this.addEventBindings([event, fn]);\n    }); // if config.domTarget is set we add event listeners to it and return the clean function\n\n    if (domTarget) {\n      _this.addDomTargetListeners();\n      return _this.clean;\n    } // if not, we return an object that contains gesture handlers mapped to react handler event keys\n\n    return _this.getBindings();\n  }; // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n  // actions will include 'onDrag' and 'onMove'\n\n  this.actions = new Set(Object.keys(this.handlers).map(function (k) {\n    return k.replace(/End|Start/, '');\n  }));\n};\nfunction useGesture(handlers, config) {\n  // the gesture controller will keep track of all gesture states\n  var gestureController = React.useRef();\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(handlers, getDerivedConfig(config));\n  }\n  React.useEffect(function () {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current.config = getDerivedConfig(config);\n    gestureController.current.handlers = handlers;\n  }, [handlers, config]); // when the user component unmounts, we run our gesture controller clean function\n\n  React.useEffect(function () {\n    return gestureController.current.clean;\n  }, []); // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n\n  return gestureController.current.bind;\n}\n/* SHORTHAND HANDLERS */\n\nvar useDrag = function useDrag(handler, config) {\n  return useGesture({\n    onDrag: handler\n  }, config);\n};\nvar useMove = function useMove(handler, config) {\n  return useGesture({\n    onMove: handler\n  }, config);\n};\nvar useHover = function useHover(handler, config) {\n  return useGesture({\n    onHover: handler\n  }, config);\n};\nvar useScroll = function useScroll(handler, config) {\n  return useGesture({\n    onScroll: handler\n  }, config);\n};\nvar useWheel = function useWheel(handler, config) {\n  return useGesture({\n    onWheel: handler\n  }, config);\n};\nvar usePinch = function usePinch(handler, config) {\n  return useGesture({\n    onPinch: handler\n  }, config);\n};\nfunction getDerivedConfig(config) {\n  var derivedConfig = _extends({}, defaultConfig, {}, config);\n  var domTarget = derivedConfig.domTarget;\n  var realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  derivedConfig.domTarget = realDomTarget;\n  var passive = derivedConfig.event.passive !== void 0 ? derivedConfig.event.passive : true; // TODO make test to check if passive is correctly passed to config\n  // if there isn't a domtarget or if event.passive is true, then passiveEvents is true\n\n  derivedConfig.passiveEvents = !derivedConfig.domTarget || passive;\n  return derivedConfig;\n}\nexport { addV, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"sources":["../src/types.ts","../src/utils.ts","../src/defaults.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/recognizers/ScrollRecognizer.ts","../src/recognizers/WheelRecognizer.ts","../src/recognizers/MoveRecognizer.ts","../src/recognizers/HoverRecognizer.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/recognizers/PinchWheelRecognizer.ts","../src/recognizers/PinchWebKitGestureRecognizer.ts","../src/controllers/GestureController.ts","../src/hooks.ts"],"names":["GestureFlag","noop","chainFns","fns","args","forEach","fn","addV","v1","v2","map","v","i","subV","setListeners","add","el","listeners","options","action","type","addListeners","removeListeners","getModifierKeys","event","shiftKey","altKey","metaKey","ctrlKey","getScrollEventData","scrollX","scrollY","scrollLeft","scrollTop","currentTarget","xy","getWheelEventData","deltaX","deltaY","getPointerEventData","touches","buttons","changedTouches","touchEvents","length","clientX","clientY","down","getTwoTouchesEventData","dx","dy","da","Math","hypot","atan2","PI","origin","calculateVelocity","delta","delta_t","len","calculateVelocities","Array","fill","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","gestureEventSupported","GestureEvent","e","mappedKeys","drag","stateKey","handlerKey","pinch","move","scroll","wheel","hover","defaultConfig","domTarget","undefined","passive","capture","window","dragDelay","passiveEvents","pointerEvents","enabled","initialCommon","pointerId","values","offset","initial","previous","first","last","active","time","cancel","canceled","memo","initialCoordinates","vxvy","initialDistanceAngle","vdva","turns","initialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","genericEndState","Recognizer","gestureKey","controller","config","state","callback","ms","timeouts","setTimeout","clearTimeout","addWindowListeners","removeWindowListeners","sharedState","gestureState","updateState","gestureFlag","fireGestureHandler","payload","gesturePayload","sharedPayload","getPayloadFromEvent","startState","timeStamp","prevValues","continuousGesture","Object","assign","sharedStartState","OnStart","kinematics","getKinematics","OnChange","sharedEndState","OnEnd","requestAnimationFrame","onEnd","onStart","onChange","CoordinatesRecognizer","DEFAULT_DRAG_DELAY","DragRecognizer","setPointerCapture","dragListeners","onDragChange","onDragEnd","persist","delayedEvent","startDrag","onCancel","releasePointerCapture","getEventBindings","onDragStart","ScrollRecognizer","timeoutHandler","WheelRecognizer","prevXY","actions","has","onWheel","MoveRecognizer","HoverRecognizer","onPointerEnter","onPointerLeave","DistanceAngleRecognizer","d","a","delta_d","delta_a","newTurns","abs","sign","movement_d","movement_a","PinchRecognizer","onPinchStart","onPinchChange","PinchWheelRecognizer","prev_d","prev_a","preventDefault","process","env","NODE_ENV","console","warn","SCALE_FACTOR","PinchWebKitGestureRecognizer","scale","rotation","onGestureEnd","updateTouchData","GestureController","Set","keys","handlers","k","replace","cleanOnBind","windowListeners","bindings","domListeners","newGestureState","gesture","handlerStart","handler","newMemo","handlerEnd","recognizer","addEventBindings","eventNames","eventNamesArray","isArray","eventName","entries","push","substr","toLowerCase","output","captureString","fnsArray","key","genuineHandlers","addRecognizer","onDrag","onScroll","onScrollStart","onScrollEnd","onWheelStart","onWheelEnd","onMove","onMoveStart","onMoveEnd","onHover","onPinch","onPinchEnd","addDomTargetListeners","clean","getBindings","useGesture","gestureController","React","useRef","current","getDerivedConfig","useEffect","bind","useDrag","useMove","useHover","useScroll","useWheel","usePinch","derivedConfig","realDomTarget"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,IAAYA,WAAZ;AAAA,CAAA,UAAYA,WAAAA,EAAAA;EACVA,WAAAA,CAAAA,SAAAA,CAAAA,GAAAA,OAAAA;EACAA,WAAAA,CAAAA,UAAAA,CAAAA,GAAAA,QAAAA;EACAA,WAAAA,CAAAA,OAAAA,CAAAA,GAAAA,KAAAA;CAHF,EAAYA,WAAW,KAAXA,WAAW,GAAA,CAAA,CAAA,CAAvB,CAAA;;ACvBA;AACO,IAAMC,IAAI,GAAG,SAAPA,IAAO,GAAA,CAAA,CAAb,CAAA,CAAA;;AAGA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,GAAA;oCAAIC,GAAJ,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;IAAIA,GAAJ,CAAA,IAAA,CAAA,GAAA,SAAA,CAAA,IAAA,CAAA;;SAAsB,YAAA;uCAAIC,IAAJ,GAAA,IAAA,KAAA,CAAA,KAAA,CAAA,EAAA,KAAA,GAAA,CAAA,EAAA,KAAA,GAAA,KAAA,EAAA,KAAA,EAAA,EAAA;MAAIA,IAAJ,CAAA,KAAA,CAAA,GAAA,SAAA,CAAA,KAAA,CAAA;;WAAoB,GAAG,CAACC,OAAJ,CAAY,UAAA,EAAE,EAAA;aAAIC,EAAE,CAAA,KAAFA,CAAAA,KAAAA,CAAAA,EAAMF,IAANE,CAAJ;KAAd,CAApB;GAAtB;CAAjB,CAAA,CAAA;;AAGP,IAAaC,IAAI,GAAG,SAAPA,IAAO,CAAqBC,EAArB,EAA4BC,EAA5B,EAAA;SAA4C,EAAE,CAACC,GAAH,CAAO,UAACC,CAAD,EAAIC,CAAJ,EAAA;WAAUD,CAAC,GAAGF,EAAE,CAACG,CAAD,CAAhB;GAAP,CAA5C;CAAb,CAAA,CAAA;;AAGP,IAAaC,IAAI,GAAG,SAAPA,IAAO,CAAqBL,EAArB,EAA4BC,EAA5B,EAAA;SAA4C,EAAE,CAACC,GAAH,CAAO,UAACC,CAAD,EAAIC,CAAJ,EAAA;WAAUD,CAAC,GAAGF,EAAE,CAACG,CAAD,CAAhB;GAAP,CAA5C;CAAb;AAEP,IAAME,YAAY,GAAG,SAAfA,YAAe,CAACC,GAAD,EAAA;SAAkB,UAACC,EAAD,EAAkBC,SAAlB,EAA6CC,OAA7C,EAAA;QAC/BC,MAAM,GAAGJ,GAAG,GAAG,kBAAH,GAAwB,qBAA1C;IACAE,SAAS,CAACZ,OAAVY,CAAkB,UAAA,IAAA,EAAA;UAAEG,IAAF,GAAA,IAAA,CAAA,CAAA,CAAA;QAAQd,EAAR,GAAA,IAAA,CAAA,CAAA,CAAA;aAAgBU,EAAE,CAACG,MAAD,CAAFH,CAAWI,IAAXJ,EAAiBV,EAAjBU,EAAqBE,OAArBF,CAAhB;KAAlBC,CAAAA;GAFmB;CAArB;AAKO,IAAMI,YAAY,G;AAAGP,YAAY,CAAC,IAAD,CAAjC;AACA,IAAMQ,eAAe,G;AAAGR,YAAY,CAAC,KAAD,CAApC;;;;;;;AAcP,SAAgBS,eAAAA,CAAgBC,KAAAA,EAAAA;MACtBC,QAAAA,GAAuCD,KAAAA,CAAvCC,QAAAA;IAAUC,MAAAA,GAA6BF,KAAAA,CAA7BE,MAAAA;IAAQC,OAAAA,GAAqBH,KAAAA,CAArBG,OAAAA;IAASC,OAAAA,GAAYJ,KAAAA,CAAZI,OAAAA;SAC5B;IAAEH,QAAQ,EAARA,QAAF;IAAYC,MAAM,EAANA,MAAZ;IAAoBC,OAAO,EAAPA,OAApB;IAA6BC,OAAO,EAAPA;GAApC;;;;;;;;AASF,SAAgBC,kBAAAA,CAAmBL,KAAAA,EAAAA;;;6BAGqCA,KAAK,CAACU,aAAAA;IAApEJ,OAAAA,GAAAA,oBAAAA,CAAAA,OAAAA;IAASC,OAAAA,GAAAA,oBAAAA,CAAAA,OAAAA;IAASC,UAAAA,GAAAA,oBAAAA,CAAAA,UAAAA;IAAYC,SAAAA,GAAAA,oBAAAA,CAAAA,SAAAA;;IAC7BE,EAAE,EAAE,CAACL,OAAO,IAAIE,UAAXF,IAAyB,CAA1B,EAA6BC,OAAO,IAAIE,SAAXF,IAAwB,CAArD;KAA4DR,eAAe,CAACC,KAAD,CAAxF,CAAA;;;;;;;;AAUF,SAAgBY,iBAAAA,CAAkBZ,KAAAA,EAAAA;MACxBa,MAAAA,GAAmBb,KAAAA,CAAnBa,MAAAA;IAAQC,MAAAA,GAAWd,KAAAA,CAAXc,MAAAA,CAAAA,CAAAA;;;;IAGPH,EAAE,EAAE,CAACE,MAAD,EAASC,MAAT;KAAqBf,eAAe,CAACC,KAAD,CAAjD,CAAA;;;;;;;;AASF,SAAgBe,mBAAAA,CAAoBf,KAAAA,EAAAA;MAC1BgB,OAAAA,GAAqChB,KAAAA,CAArCgB,OAAAA;IAASC,OAAAA,GAA4BjB,KAAAA,CAA5BiB,OAAAA;IAASC,cAAAA,GAAmBlB,KAAAA,CAAnBkB,cAAAA;MACpBC,WAAW,GAAGH,OAAO,IAAIA,OAAO,CAACI,MAARJ,GAAiB,CAA5BA,GAAgCA,OAAhCA,GAA0CE,cAAc,IAAIA,cAAc,CAACE,MAAfF,GAAwB,CAA1CA,GAA8CA,cAA9CA,GAA+D,IAA7H;cAC6BC,WAAW,GAAGA,WAAW,CAAC,CAAD,CAAd,GAAoBnB,KAAAA;IAApDqB,OAAAA,GAAAA,KAAAA,CAAAA,OAAAA;IAASC,OAAAA,GAAAA,KAAAA,CAAAA,OAAAA;MACXC,IAAI,GAAIJ,WAAW,IAAIA,WAAW,CAACC,MAAZD,GAAqB,CAArC,IAA2CF,OAAO,GAAG,CAAlE;;IAEEN,EAAE,EAAE,CAACU,OAAD,EAAUC,OAAV,CADN;IAEEN,OAAO,EAAGG,WAAW,IAAIA,WAAW,CAACC,MAA5B,IAAuC,CAFlD;IAGEG,IAAI,EAAJA,IAHF;IAIEN,OAAO,EAAPA;KACGlB,eAAe,CAACC,KAAD,CALpB,CAAA;;;;;;;;AAgBF,SAAgBwB,sBAAAA,CAAuBxB,KAAAA,EAAAA;MAC7BgB,OAAAA,GAAYhB,KAAAA,CAAZgB,OAAAA;MACFS,EAAE,GAAGT,OAAO,CAAC,CAAD,CAAPA,CAAWK,OAAXL,GAAqBA,OAAO,CAAC,CAAD,CAAPA,CAAWK,OAA3C;MACMK,EAAE,GAAGV,OAAO,CAAC,CAAD,CAAPA,CAAWM,OAAXN,GAAqBA,OAAO,CAAC,CAAD,CAAPA,CAAWM,OAA3C;MAEMK,EAAE,GAAY,CAACC,IAAI,CAACC,KAALD,CAAWH,EAAXG,EAAeF,EAAfE,CAAD,EAAqB,EAAEA,IAAI,CAACE,KAALF,CAAWH,EAAXG,EAAeF,EAAfE,CAAAA,GAAqB,GAAvB,CAAA,GAA8BA,IAAI,CAACG,EAAxD,CAApB;MACMC,MAAM,GAAY,CAAC,CAAChB,OAAO,CAAC,CAAD,CAAPA,CAAWK,OAAXL,GAAqBA,OAAO,CAAC,CAAD,CAAPA,CAAWK,OAAjC,IAA4C,CAA7C,EAAgD,CAACL,OAAO,CAAC,CAAD,CAAPA,CAAWM,OAAXN,GAAqBA,OAAO,CAAC,CAAD,CAAPA,CAAWM,OAAjC,IAA4C,CAA5F,CAAxB;;IAESK,EAAE,EAAFA,EAAT;IAAaK,MAAM,EAANA,MAAb;IAAqBhB,OAAO,EAAE,CAA9B;IAAiCO,IAAI,EAAEP,OAAO,CAACI,MAARJ,GAAiB;KAAMjB,eAAe,CAACC,KAAD,CAA7E,CAAA;;;;;;;;;;AAUF,SAAgBiC,iBAAAA,CAAkBC,KAAAA,EAAiBC,OAAAA,EAAiBC,GAAAA,EAAAA;EAClEA,GAAG,GAAGA,GAAG,IAAIR,IAAI,CAACC,KAALD,CAAAA,KAAAA,CAAAA,IAAI,EAAUM,KAAV,CAAjBE;SACOD,OAAO,GAAGC,GAAG,GAAGD,OAAT,GAAmB,CAAjC;;;;;;;;;;AAUF,SAAgBE,mBAAAA,CAAwCH,KAAAA,EAAUC,OAAAA,EAAAA;SACzDA,OAAO,GAAM,KAAK,CAACjD,GAAN,CAAU,UAAA,CAAC,EAAA;WAAIC,CAAC,GAAGgD,OAAR;GAAX,CAAN,GAAuCG,KAAK,CAACJ,KAAK,CAACd,MAAP,CAALkB,CAAoBC,IAApBD,CAAyB,CAAzBA,CAArD;;;;;;;;AAQF,SAAgBE,iBAAAA,CAAkBC,QAAAA,EAAAA;SACzBb,IAAI,CAACC,KAALD,CAAAA,KAAAA,CAAAA,IAAI,EAAUa,QAAV,CAAX;;;;;;;;;;AAUF,SAAgBC,kBAAAA,CAAuCR,KAAAA,EAAUE,GAAAA,EAAAA;EAC/DA,GAAG,GAAGA,GAAG,IAAIR,IAAI,CAACC,KAALD,CAAAA,KAAAA,CAAAA,IAAI,EAAUM,KAAV,CAAXE,IAA+B,CAArCA;SACU,KAAK,CAAClD,GAAN,CAAU,UAAA,CAAC,EAAA;WAAIC,CAAC,GAAGiD,GAAR;GAAX,CAAV;;;;;;;;;;;AAkBF,SAAgBO,sBAAAA,CAA2CF,QAAAA,EAAaP,KAAAA,EAAUC,OAAAA,EAAAA;MAC1EC,GAAG,GAAGR,IAAI,CAACC,KAALD,CAAAA,KAAAA,CAAAA,IAAI,EAAUM,KAAV,CAAhB;SAEO;IACLU,UAAU,EAAEP,mBAAmB,CAACH,KAAD,EAAQC,OAAR,CAD1B;IAELU,QAAQ,EAAEZ,iBAAiB,CAACC,KAAD,EAAQC,OAAR,EAAiBC,GAAjB,CAFtB;IAGLU,QAAQ,EAAEN,iBAAiB,CAACC,QAAD,CAHtB;IAILM,SAAS,EAAEL,kBAAkB,CAACR,KAAD,EAAQE,GAAR;GAJ/B;;;;;;;AAYF,SAAgBY,qBAAAA,GAAAA;MACV;;;WAGK,aAAA,IAAiBC,YAAxB;GAHF,CAIE,OAAOC,CAAP,EAAU;WACH,KAAP;;;;ACpLJ;;;;;;AAKO,IAAMC,UAAU,GAAe;EACpCC,IAAI,EAAE;IAAEC,QAAQ,EAAE,MAAZ;IAAoBC,UAAU,EAAE;GADF;EAEpCC,KAAK,EAAE;IAAEF,QAAQ,EAAE,OAAZ;IAAqBC,UAAU,EAAE;GAFJ;EAGpCE,IAAI,EAAE;IAAEH,QAAQ,EAAE,MAAZ;IAAoBC,UAAU,EAAE;GAHF;EAIpCG,MAAM,EAAE;IAAEJ,QAAQ,EAAE,QAAZ;IAAsBC,UAAU,EAAE;GAJN;EAKpCI,KAAK,EAAE;IAAEL,QAAQ,EAAE,OAAZ;IAAqBC,UAAU,EAAE;GALJ;EAMpCK,KAAK,EAAE;IAAEN,QAAQ,EAAE,MAAZ;IAAoBC,UAAU,EAAE;;CANlC,CAAA,CAAA;;AAUA,IAAMM,aAAa,GAAkB;EAC1CC,SAAS,EAAEC,SAD+B;EAE1C9D,KAAK,EAAE;IAAE+D,OAAO,EAAE,IAAX;IAAiBC,OAAO,EAAE;GAFS;EAG1CC,MAAM,EAAE,OAAOA,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyCH,SAHP;EAI1CI,SAAS,EAAE,KAJ+B;EAK1CC,aAAa,EAAE,IAL2B;EAM1CC,aAAa,EAAE,KAN2B;EAO1CC,OAAO,EAAE,IAPiC;EAQ1CjB,IAAI,EAAE,IARoC;EAS1CG,KAAK,EAAE,IATmC;EAU1CE,MAAM,EAAE,IAVkC;EAW1CC,KAAK,EAAE,IAXmC;EAY1CC,KAAK,EAAE,IAZmC;EAa1CH,IAAI,EAAE;CAbD,CAAA,CAAA;;AAiBA,IAAMc,aAAa,GAAuB;EAC/CtE,KAAK,EAAE8D,SADwC;EAE/CpD,aAAa,EAAEoD,SAFgC;EAG/CS,SAAS,EAAET,SAHoC;EAI/CU,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,CAJuC;EAK/CtC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,CALwC;EAM/CO,QAAQ,EAAE,CAAC,CAAD,EAAI,CAAJ,CANqC;EAO/CgC,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,CAPuC;EAQ/C1B,SAAS,EAAE,CAAC,CAAD,EAAI,CAAJ,CARoC;EAS/C2B,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,CATsC;EAU/CC,QAAQ,EAAE,CAAC,CAAD,EAAI,CAAJ,CAVqC;EAW/CC,KAAK,EAAE,KAXwC;EAY/CC,IAAI,EAAE,KAZyC;EAa/CC,MAAM,EAAE,KAbuC;EAc/CC,IAAI,EAAEjB,SAdyC;EAe/CkB,MAAM,EAAEvG,IAfuC;EAgB/CwG,QAAQ,EAAE,KAhBqC;EAiB/CC,IAAI,EAAEpB,SAjByC;EAkB/ClF,IAAI,EAAEkF;CAlBD,CAAA,CAAA;;AAsBP,IAAMqB,kBAAkB,GAAgB;EAAExE,EAAE,EAAE,CAAC,CAAD,EAAI,CAAJ,CAAN;EAAcyE,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,CAApB;EAA4BvC,QAAQ,EAAE,CAAtC;EAAyCC,QAAQ,EAAE;CAA3F,CAAA,CAAA;;;AAGA,IAAMuC,oBAAoB,GAAkB;EAAE1D,EAAE,EAAE,CAAC,CAAD,EAAI,CAAJ,CAAN;EAAc2D,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,CAApB;EAA4BtD,MAAM,EAAE8B,SAApC;EAA+CyB,KAAK,EAAE;CAAlG,CAAA,CAAA;;;AAGO,IAAMC,YAAY,GAAgB;EACvCC,MAAM,EAAE;IACNC,QAAQ,EAAE,KADJ;IAENC,SAAS,EAAE,KAFL;IAGNC,QAAQ,EAAE,KAHJ;IAINC,QAAQ,EAAE,KAJJ;IAKNC,MAAM,EAAE,KALF;IAMNC,QAAQ,EAAE,KANJ;IAON/E,OAAO,EAAE,CAPH;IAQNC,OAAO,EAAE,CARH;IASNM,IAAI,EAAE,KATA;IAUNtB,QAAQ,EAAE,KAVJ;IAWNC,MAAM,EAAE,KAXF;IAYNC,OAAO,EAAE,KAZH;IAaNC,OAAO,EAAE;GAd4B;EAgBvCoD,IAAI,E;eAAOc,aAAP,EAAA,CAAA,CAAA,EAAyBa,kBAAzB,CAhBmC;EAiBvC/B,IAAI,E;eAAOkB,aAAP,EAAA,CAAA,CAAA,EAAyBa,kBAAzB,CAjBmC;EAkBvC1B,MAAM,E;eAAOa,aAAP,EAAA,CAAA,CAAA,EAAyBa,kBAAzB,CAlBiC;EAmBvCzB,KAAK,E;eAAOY,aAAP,EAAA,CAAA,CAAA,EAAyBa,kBAAzB,CAnBkC;EAoBvC5B,KAAK,E;eAAOe,aAAP,EAAA,CAAA,CAAA,EAAyBe,oBAAzB;CApBA,CAAA,CAAA;;AAwBA,IAAMW,eAAe,GAAgC;EAAEpB,KAAK,EAAE,KAAT;EAAgBC,IAAI,EAAE,IAAtB;EAA4BC,MAAM,EAAE;CAAzF;;AClEP;;;;;IAI8BmB,UAAAA,G;;;;;;;;sBAkBP,UADrB,EAEqB,UAFrB,EAGqBrH,IAHrB,EAAA;;QAGqBA,IAAAA,KAAAA,KAAAA,CAAAA,EAAAA;MAAAA,IAAAA,GAAc,EAAA;;mBAFd,GAAA,UAAA;mBACA,GAAA,UAAA;aACAA,GAAAA,IAAAA;;;;;;0BAXX,GAAoB,KAApB,CAAA,CAAA;;mBA4BA,GAAa,UAAC0H,QAAD,EAAqCC,EAArC,EAAA;;UAAqCA,EAAAA,KAAAA,KAAAA,CAAAA,EAAAA;QAAAA,EAAAA,GAAa,GAAA;;wCAAQ3H,IAAAA,GAAAA,IAAAA,KAAAA,CAAAA,IAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,IAAAA,GAAAA,CAAAA,EAAAA,IAAAA,GAAAA,IAAAA,EAAAA,IAAAA,EAAAA,EAAAA;QAAAA,IAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,IAAAA,CAAAA;;MAC/E,KAAI,CAACuH,UAAL,CAAgBK,QAAhB,CAAyB,KAAI,CAACnD,QAA9B,CAAA,GAA0C,CAAA,OAAA,GAAA,MAAM,EAACoD,UAAP,CAAA,KAAA,CAAA,OAAA,EAAA,CAAkBH,QAAlB,EAA4BC,EAA5B,CAAA,CAAA,MAAA,CAAmC3H,IAAnC,CAAA,CAA1C;KADQ,CAAA,CAAA;;qBAKA,GAAe,YAAA;MACvB8H,YAAY,CAAC,KAAI,CAACP,UAAL,CAAgBK,QAAhB,CAAyB,KAAI,CAACnD,QAA9B,CAAD,CAAZqD;KADQ,CAAA,CAAA;;2BAKA,GAAqB,UAACjH,SAAD,EAAA;MAC7B,KAAI,CAAC0G,UAAL,CAAgBQ,kBAAhB,CAAmC,KAAI,CAACtD,QAAxC,EAAkD5D,SAAlD,CAAA;KADQ,CAAA,CAAA;;8BAKA,GAAwB,YAAA;MAChC,KAAI,CAAC0G,UAAL,CAAgBS,qBAAhB,CAAsC,KAAI,CAACvD,QAA3C,CAAA;KADQ;;;;;;;;oBAuBA,GAAc,UAACwD,WAAD,EAAkDC,YAAlD,EAAA;MACtB,KAAI,CAACX,UAAL,CAAgBY,WAAhB,CAA4BF,WAA5B,EAAyCC,YAAzC,EAAuD,KAAI,CAACzD,QAA5D,CAAA;KADQ;2BAIA,GAAqB,UAAC2D,WAAD,EAAA;MAC7B,KAAI,CAACb,UAAL,CAAgBc,kBAAhB,CAAmC,KAAI,CAACf,UAAxC,EAAoDc,WAApD,CAAA;KADQ,CAAA,CAAA;;gBAKA,GAAU,UAAChH,KAAD,EAAyBkH,OAAzB,EAAA;kCACgC,KAAI,CAACG,mBAAL,CAAyBrH,KAAzB,CAAA;QAA1CwE,MAAAA,GAAAA,qBAAAA,CAAAA,MAAAA;QAAQ2C,cAAAA,GAAAA,qBAAAA,CAAAA,cAAAA;QAAgBC,aAAAA,GAAAA,qBAAAA,CAAAA,aAAAA,CAAAA,CAAAA;;UAI1BE,UAAU,GAAA,QAAA,CAAA,CAAA,CAAA,EACV9B,YAAY,CAAC,KAAI,CAACnC,QAAN,CADF,EAAA;QAEdmB,MAAM,EAANA,MAFc;QAGdxE,KAAK,EAALA,KAHc;QAId4E,KAAK,EAAE,IAJO;QAKdE,MAAM,EAAE,IALM;QAMdC,IAAI,EAAE/E,KAAK,CAACuH,SANE;QAOd3I,IAAI,EAAE,KAAI,CAACA;QAPb;wBAUuC,KAAI,CAACyH,KAAAA;QAA5BmB,UAAAA,GAAAA,WAAAA,CAARhD,MAAAA;QAAoBC,MAAAA,GAAAA,WAAAA,CAAAA,MAAAA;UAExB,KAAI,CAACgD,iBAAT,EAA4B;QAC1BH,UAAU,CAAC5C,OAAX4C,GAAqBA,UAAU,CAAC3C,QAAX2C,GAAsBE,UAA3CF;QACAA,UAAU,CAACpF,KAAXoF,GAAmBA,UAAU,CAAC7E,QAAX6E,GAAsBjI,IAAI,CAACmF,MAAD,EAASgD,UAAT,CAA7CF;QACAA,UAAU,CAAC7C,MAAX6C,GAAoB9C,MAApB8C;QACAI,MAAM,CAACC,MAAPD,CAAcJ,UAAdI,EAA0B/E,sBAAsB,CAAC2E,UAAU,CAAC7E,QAAZ,EAAsB6E,UAAU,CAACpF,KAAjC,EAAwC,CAAxC,CAAhDwF,CAAAA;OAJF,MAKO;QACLJ,UAAU,CAAC5C,OAAX4C,GAAqBA,UAAU,CAAC3C,QAAX2C,GAAsB9C,MAA3C8C;QACAA,UAAU,CAAC7C,MAAX6C,GAAoB7C,MAApB6C;;MAGF,KAAI,CAACP,WAAL,CAAA,QAAA,CAAA,CAAA,CAAA,EAAsB,KAAI,CAACa,gBAA3B,EAAA,CAAA,CAAA,EAAgDR,aAAhD,CAAA,EAAA,QAAA,CAAA,CAAA,CAAA,EAAsEE,UAAtE,EAAA,CAAA,CAAA,EAAqFH,cAArF,EAAA,CAAA,CAAA,EAAwGD,OAAxG,CAAA,CAAA;MACA,KAAI,CAACD,kBAAL,CAAwBzI,WAAW,CAACqJ,OAApC,CAAA;KA5BQ,CAAA,CAAA;;iBAgCA,GAAW,UAAC7H,KAAD,EAAyBkH,OAAzB,EAAA;mCAC+B,KAAI,CAACG,mBAAL,CAAyBrH,KAAzB,CAAA;QAA1CwE,MAAAA,GAAAA,sBAAAA,CAAAA,MAAAA;QAAQ2C,cAAAA,GAAAA,sBAAAA,CAAAA,cAAAA;QAAgBC,aAAAA,GAAAA,sBAAAA,CAAAA,aAAAA;UAC1BU,UAAU,GAAG,KAAI,CAACC,aAAL,CAAmBvD,MAAnB,EAA2BxE,KAA3B,CAAnB;MACA,KAAI,CAAC+G,WAAL,CAAA,QAAA,CAAA,CAAA,CAAA,EAAsBK,aAAtB,CAAA,EAAA,QAAA,CAAA;QAAyCxC,KAAK,EAAE;SAAUkD,UAA1D,EAAA,CAAA,CAAA,EAAyEX,cAAzE,EAAA,CAAA,CAAA,EAA4FD,OAA5F,CAAA,CAAA;MACA,KAAI,CAACD,kBAAL,CAAwBzI,WAAW,CAACwJ,QAApC,CAAA;KAJQ,CAAA,CAAA;;cAQA,GAAQ,UAAChI,KAAD,EAAyBkH,OAAzB,EAAA;UACZ,CAAC,KAAI,CAACb,KAAL,CAAWvB,MAAhB,EAAwB;MACxB,KAAI,CAAC8B,qBAAL,EAAA;MACA,KAAI,CAACG,WAAL,CAAiB,KAAI,CAACkB,cAAtB,EAAA,QAAA,CAAA;QAAyCjI,KAAK,EAALA;SAAUgG,eAAnD,EAAA,CAAA,CAAA,EAAuEkB,OAAvE,CAAA,CAAA;MACA,KAAI,CAACD,kBAAL,CAAwBzI,WAAW,CAAC0J,KAApC,CAAA;KAJQ,CAAA,CAAA;;iBAQA,GAAW,UAAClI,KAAD,EAAA;MACnB,KAAI,CAAC+G,WAAL,CAAiB,IAAjB,EAAuB;QAAE9B,QAAQ,EAAE,IAAZ;QAAkBD,MAAM,EAAEvG;OAAjD,CAAA;MACA0J,qBAAqB,CAAC,YAAA;eAAM,KAAI,CAACC,KAAL,CAAWpI,KAAX,CAAN;OAAD,CAArBmI;KAFQ,CAAA,CAAA;;uBAMA,GAAiB,UAACnI,KAAD,EAAA;UACrB,CAAC,KAAI,CAACqE,OAAV,EAAmB;MAEnB,KAAI,CAACqC,YAAL,EAAA;MACA,KAAI,CAACD,UAAL,CAAgB,KAAI,CAAC2B,KAArB,CAAA;UAEI,CAAC,KAAI,CAAC/B,KAAL,CAAWvB,MAAhB,EAAwB,KAAI,CAACuD,OAAL,CAAarI,KAAb,CAAA,CAAxB,KACK,KAAI,CAACsI,QAAL,CAActI,KAAd,CAAA;KAPG,CAAA,CAAA;;;SAlHHqD,QAAL,GAAgBF,UAAU,CAAC+C,UAAD,CAAV/C,CAAuBE,QAAvC;;;;;;aAKO,IAAA,CAAK8C,UAAL,CAAgBC,MAAhB,CAAuB/B,OAAvB,IAAkC,IAAA,CAAK8B,UAAL,CAAgBC,MAAhB,CAAuB,IAAA,CAAKF,UAA5B,CAAzC;;;;;aAIO,IAAA,CAAKC,UAAL,CAAgBE,KAAhB,CAAsB,IAAA,CAAKhD,QAA3B,CAAP;;;;;;ACxDJ;;;;IAG8BkF,qBAAAA,G;;;;;;;SAC5BR,aAAAA,GAAAA,SAAAA,aAAAA,CAAcvD,MAAduD,EAA+B/H,KAA/B+H,EAAAA;;sBAEgD,IAAA,CAAK1B,KAAAA;MAAnC1F,EAAAA,GAAAA,WAAAA,CAAR6D,MAAAA;MAAYE,OAAAA,GAAAA,WAAAA,CAAAA,OAAAA;MAASD,MAAAA,GAAAA,WAAAA,CAAAA,MAAAA;MAAQM,IAAAA,GAAAA,WAAAA,CAAAA,IAAAA,CAAAA,CAAAA;;QAG/BtC,QAAQ,GAAGpD,IAAI,CAACmF,MAAD,EAASE,OAAT,CAArB,CAAA,CAAA;;QAEMxC,KAAK,GAAG7C,IAAI,CAACmF,MAAD,EAAS7D,EAAT,CAAlB;QAEMwB,OAAO,GAAGnC,KAAK,CAACuH,SAANvH,GAAkB+E,IAAlC;gCACsDpC,sBAAsB,CAACF,QAAD,EAAWP,KAAX,EAAkBC,OAAlB,CAAA;MAApEU,QAAAA,GAAAA,qBAAAA,CAAAA,QAAAA;MAAUD,UAAAA,GAAAA,qBAAAA,CAAAA,UAAAA;MAAYE,QAAAA,GAAAA,qBAAAA,CAAAA,QAAAA;MAAUC,SAAAA,GAAAA,qBAAAA,CAAAA,SAAAA;WAEjC;MACL/C,KAAK,EAALA,KADK;MAELwE,MAAM,EAANA,MAFK;MAGL/B,QAAQ,EAARA,QAHK;MAILgC,MAAM,EAAE1F,IAAI,CAAC0F,MAAD,EAASvC,KAAT,CAJP;MAKLA,KAAK,EAALA,KALK;MAMLW,QAAQ,EAARA,QANK;MAOLuC,IAAI,EAAExC,UAPD;MAQLE,QAAQ,EAARA,QARK;MASLC,SAAS,EAATA,SATK;MAUL4B,QAAQ,EAAEhE,EAVL;MAWLoE,IAAI,EAAE/E,KAAK,CAACuH;KAXd;;;EAbwDtB,UAAAA,CAAAA;ACD5D,IAAMuC,kBAAkB,GAAG,GAA3B;IAEqBC,cAAAA,G;;;0BAMPtC,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,MAAN,EAAcuH,UAAd,EAA0BvH,IAA1B,CAAA,IAAA,IAAA;0BANF,GAAmB;MAAEiH,QAAQ,EAAE,IAAZ;MAAkBtE,IAAI,EAAE;KAA3C;wBACA,GAAiB;MAAEsE,QAAQ,EAAE,KAAZ;MAAmBtE,IAAI,EAAE,KAAzB;MAAgCN,OAAO,EAAE,CAAzC;MAA4CD,OAAO,EAAE;KAAtE;sBAEA,GAAe,KAAf;qBAWA,GAAc,UAAChB,KAAD,EAAA;UACR,CAAC,KAAA,CAAKqE,OAAV,EAAmB,OAAA,CAAA;;iCAGCtD,mBAAmB,CAACf,KAAD,CAAA;QAA/BgB,OAAAA,GAAAA,oBAAAA,CAAAA,OAAAA;UACJA,OAAO,GAAG,CAAd,EAAiB;UAETN,aAAAA,GAA6BV,KAAAA,CAA7BU,aAAAA;QAAe6D,SAAAA,GAAcvE,KAAAA,CAAduE,SAAAA;UACnB,KAAA,CAAK4B,UAAL,CAAgBC,MAAhB,CAAuBhC,aAA3B,EAA0C;;QAExC1D,aAAa,IAAKA,aAAqB,CAACgI,iBAAtBhI,CAAwC6D,SAAxC7D,CAAlBA;OAFF,MAGO;cACAkG,qBAAL,EAAA;YACM+B,aAAa,GAAmB,CACpC,CAAC,WAAD,EAAc,KAAA,CAAKC,YAAnB,CADoC,EAEpC,CAAC,WAAD,EAAc,KAAA,CAAKA,YAAnB,CAFoC,EAGpC,CAAC,SAAD,EAAY,KAAA,CAAKC,SAAjB,CAHoC,EAIpC,CAAC,UAAD,EAAa,KAAA,CAAKA,SAAlB,CAJoC,EAKpC,CAAC,aAAD,EAAgB,KAAA,CAAKA,SAArB,CALoC,CAAtC;cAOKlC,kBAAL,CAAwBgC,aAAxB,CAAA;;UAGE,KAAA,CAAKxC,UAAL,CAAgBC,MAAhB,CAAuBlC,SAA3B,EAAsC;YAC9BA,SAAS,GAAG,OAAO,KAAA,CAAKiC,UAAL,CAAgBC,MAAhB,CAAuBlC,SAA9B,KAA4C,QAA5C,GAAuD,KAAA,CAAKiC,UAAL,CAAgBC,MAAhB,CAAuBlC,SAA9E,GAA0FsE,kBAA5G;YACI,OAAOxI,KAAK,CAAC8I,OAAb,KAAyB,UAA7B,EAAyC9I,KAAK,CAAC8I,OAAN9I,EAAAA;cACpC+I,YAAL,GAAoB,IAApB;cACKtC,UAAL,CAAgB,YAAA;iBAAM,KAAA,CAAKuC,SAAL,CAAehJ,KAAf,CAAN;SAAhB,EAA6CkE,SAA7C,CAAA;OAJF,MAKO;cACA8E,SAAL,CAAehJ,KAAf,CAAA;;KA7BJ;mBAiCA,GAAY,UAACA,KAAD,EAAA;UACFU,aAAAA,GAA6BV,KAAAA,CAA7BU,aAAAA;QAAe6D,SAAAA,GAAcvE,KAAAA,CAAduE,SAAAA;YAClB8D,OAAL,CAAarI,KAAb,EAAoB;QAAEU,aAAa,EAAbA,aAAF;QAAiB6D,SAAS,EAATA,SAAjB;QAA4BS,MAAM,EAAE,SAAA,MAAA,GAAA;iBAAM,KAAA,CAAKiE,QAAL,CAAcjJ,KAAd,CAAN;;OAAxD,CAAA;YACK+I,YAAL,GAAoB,KAApB;KAHF;sBAMA,GAAe,UAAC/I,KAAD,EAAA;wBACgB,KAAA,CAAKqG,KAAAA;QAA1BpB,QAAAA,GAAAA,WAAAA,CAAAA,QAAAA;QAAUH,MAAAA,GAAAA,WAAAA,CAAAA,MAAAA;UACdG,QAAJ,EAAc;UAEV,CAACH,MAAL,EAAa;YACP,KAAA,CAAKiE,YAAT,EAAuB;gBAChBrC,YAAL,EAAA;gBACKsC,SAAL,CAAehJ,KAAf,CAAA;;;;kCAKyBe,mBAAmB,CAACf,KAAD,CAAA;QAAxCiB,OAAAA,GAAAA,qBAAAA,CAAAA,OAAAA;QAASD,OAAAA,GAAAA,qBAAAA,CAAAA,OAAAA;UAEbC,OAAO,KAAK,CAAZA,IAAiBD,OAAO,KAAK,CAAjC,EAAoC;cAC7BoH,KAAL,CAAWpI,KAAX,CAAA;;;YAIGsI,QAAL,CAActI,KAAd,EAAqB;QAAEgF,MAAM,EAAE,SAAA,MAAA,GAAA;iBAAM,KAAA,CAAKiE,QAAL,CAAcjJ,KAAd,CAAN;;OAA/B,CAAA;KAnBF;mBAsBA,GAAY,UAACA,KAAD,EAAA;YACL0G,YAAL,EAAA;YACKqC,YAAL,GAAoB,KAApB;UAEI,CAAC,KAAA,CAAK1C,KAAL,CAAWvB,MAAhB,EAAwB;yBAEa,KAAA,CAAKuB,KAAAA;QAAlC3F,aAAAA,GAAAA,YAAAA,CAAAA,aAAAA;QAAe6D,SAAAA,GAAAA,YAAAA,CAAAA,SAAAA;UACnB7D,aAAa,IAAI,KAAA,CAAKyF,UAAL,CAAgBC,MAAhB,CAAuBhC,aAA5C,EAA4D1D,aAAqB,CAACwI,qBAAtBxI,CAA4C6D,SAA5C7D,CAAAA;YACvD0H,KAAL,CAAWpI,KAAX,CAAA;KARF;;;;SAlEAqH,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;gCACmCtG,mBAAmB,CAACf,KAAD,CAAA;MAA5CW,EAAAA,GAAAA,qBAAAA,CAAAA,EAAAA;MAAOyG,aAAAA,GAAAA,6BAAAA,CAAAA,qBAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA;WACR;MAAE5C,MAAM,EAAE7D,EAAV;MAAcyG,aAAa,EAAbA;KAArB;;SA2EF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;QACM,IAAA,CAAKhD,UAAL,CAAgBC,MAAhB,CAAuBhC,aAA3B,EAA0C;aACjC,CAAC,CAAC,eAAD,EAAkB,IAAA,CAAKgF,WAAvB,CAAD,EAAsC,CAAC,eAAD,EAAkB,IAAA,CAAKR,YAAvB,CAAtC,EAA4E,CAAC,CAAC,aAAD,CAAD,EAAkB,IAAA,CAAKC,SAAvB,CAA5E,CAAP;;WAEK,CAAC,CAAC,CAAC,aAAD,EAAgB,cAAhB,CAAD,EAAkC,IAAA,CAAKO,WAAvC,CAAD,CAAP;;;EA3FwCb,qBAAAA,CAAAA;ICHvBc,gBAAAA,G;;;4BAKPlD,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,QAAN,EAAgBuH,UAAhB,EAA4BvH,IAA5B,CAAA,IAAA,IAAA;0BALF,GAAmB;MAAE+G,SAAS,EAAE;KAAhC;wBACA,GAAiB;MAAEA,SAAS,EAAE,KAAb;MAAoB9C,QAAQ,EAAE,CAA9B;MAAiCuC,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ;KAAxD;2BACA,GAAoB,IAApB;;;;SAMAiC,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;8BACmChH,kBAAkB,CAACL,KAAD,CAAA;MAA3CW,EAAAA,GAAAA,mBAAAA,CAAAA,EAAAA;MAAOyG,aAAAA,GAAAA,6BAAAA,CAAAA,mBAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA;WACR;MAAE5C,MAAM,EAAE7D,EAAV;MAAcyG,aAAa,EAAbA;KAArB;;SAGF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;WACS,CAAC,CAAC,UAAD,EAAa,IAAA,CAAKG,cAAlB,CAAD,CAAP;;;EAf0Cf,qBAAAA,CAAAA;ICCzBgB,eAAAA,G;;;2BAKPpD,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,OAAN,EAAeuH,UAAf,EAA2BvH,IAA3B,CAAA,IAAA,IAAA;0BALF,GAAmB;MAAEgH,QAAQ,EAAE;KAA/B;wBACA,GAAiB;MAAEA,QAAQ,EAAE,KAAZ;MAAmB/C,QAAQ,EAAE,CAA7B;MAAgCuC,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ;KAAvD;2BACA,GAAoB,IAApB;iBAcA,GAAU,UAACpF,KAAD,EAAA;UACJA,KAAK,CAACI,OAANJ,IAAiB,KAAA,CAAKmG,UAAL,CAAgBsD,OAAhB,CAAwBC,GAAxB,CAA4B,SAA5B,CAArB,EAA6D;YACxDJ,cAAL,CAAoBtJ,KAApB,CAAA;KAFF;;;;SARAqH,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;QACcmC,MAAAA,GAAW,IAAA,CAAKnD,KAAAA,CAApB1F,EAAAA;6BACyBC,iBAAiB,CAACZ,KAAD,CAAA;MAA1CW,EAAAA,GAAAA,kBAAAA,CAAAA,EAAAA;MAAOyG,aAAAA,GAAAA,6BAAAA,CAAAA,kBAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA;QACT5C,MAAM,GAAGzF,IAAI,CAAC4B,EAAD,EAAK6I,MAAL,CAAnB;WAEO;MAAEhF,MAAM,EAANA,MAAF;MAAU4C,aAAa,EAAbA;KAAjB;;SAQF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;WACS,CAAC,CAAC,SAAD,EAAY,IAAA,CAAKQ,OAAjB,CAAD,CAAP;;;EAvByCpB,qBAAAA,CAAAA;ICDxBqB,cAAAA,G;;;0BAIPzD,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,MAAN,EAAcuH,UAAd,EAA0BvH,IAA1B,CAAA,IAAA,IAAA;0BAJF,GAAmB;MAAEkH,MAAM,EAAE;KAA7B;wBACA,GAAiB;MAAEA,MAAM,EAAE,KAAV;MAAiBjD,QAAQ,EAAE,CAA3B;MAA8BuC,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ;KAArD;;;;SAMAiC,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;+BACmCtG,mBAAmB,CAACf,KAAD,CAAA;MAA5CW,EAAAA,GAAAA,oBAAAA,CAAAA,EAAAA;MAAOyG,aAAAA,GAAAA,6BAAAA,CAAAA,oBAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA;WACR;MAAE5C,MAAM,EAAE7D,EAAV;MAAcyG,aAAa,EAAbA;KAArB;;SAGF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;QACM,IAAA,CAAKhD,UAAL,CAAgBC,MAAhB,CAAuBhC,aAA3B,EAA0C;aACjC,CAAC,CAAC,eAAD,EAAkB,IAAA,CAAKkF,cAAvB,CAAD,CAAP;;WAEK,CAAC,CAAC,aAAD,EAAgB,IAAA,CAAKA,cAArB,CAAD,CAAP;;;EAjBwCf,qBAAAA,CAAAA;ICCvBsB,eAAAA,G;;;2BACP1D,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,OAAN,EAAeuH,UAAf,EAA2BvH,IAA3B,CAAA,IAAA,IAAA;wBAQF,GAAiB,UAACoB,KAAD,EAAA;UACX,CAAC,KAAA,CAAKqE,OAAV,EAAmB;kCACe,KAAA,CAAKgD,mBAAL,CAAyBrH,KAAzB,CAAA;QAA1BwE,MAAAA,GAAAA,qBAAAA,CAAAA,MAAAA;QAAQ4C,aAAAA,GAAAA,qBAAAA,CAAAA,aAAAA;YACXL,WAAL,CAAA,QAAA,CAAA;QAAmBrB,QAAQ,EAAE;SAAS0B,aAAtC,CAAA,EAAuD;QAAE5C,MAAM,EAANA,MAAF;QAAUxE,KAAK,EAALA,KAAV;QAAiBpB,IAAI,EAAE,KAAA,CAAKA;OAAnF,CAAA;YACKqI,kBAAL,CAAwBzI,WAAW,CAACwJ,QAApC,CAAA;KAJF;wBAOA,GAAiB,UAAChI,KAAD,EAAA;UACX,CAAC,KAAA,CAAKqE,OAAV,EAAmB;mCACe,KAAA,CAAKgD,mBAAL,CAAyBrH,KAAzB,CAAA;QAA1BwE,MAAAA,GAAAA,sBAAAA,CAAAA,MAAAA;QAAQ4C,aAAAA,GAAAA,sBAAAA,CAAAA,aAAAA;UACVU,UAAU,GAAG,KAAA,CAAKC,aAAL,CAAmBvD,MAAnB,EAA2BxE,KAA3B,CAAnB;YAEK+G,WAAL,CAAA,QAAA,CAAA;QAAmBrB,QAAQ,EAAE,KAA7B;QAAoCI,MAAM,EAAE;SAAUsB,aAAtD,CAAA,EAAA,QAAA,CAAA,CAAA,CAAA,EAA4EU,UAA5E,EAAA,CAAA,CAAA,EAA2F9B,eAA3F,EAAA;QAA4GnD,QAAQ,EAAE,CAAtH;QAAyHuC,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ;;;;YAI1He,UAAL,CAAgBc,kBAAhB,CAAmC,MAAnC,EAA2CzI,WAAW,CAAC0J,KAAvD,CAAA;YACK/B,UAAL,CAAgBc,kBAAhB,CAAmC,OAAnC,EAA4CzI,WAAW,CAACwJ,QAAxD,CAAA;KAVF;;;;SAZAX,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;+BACmCtG,mBAAmB,CAACf,KAAD,CAAA;MAA5CW,EAAAA,GAAAA,oBAAAA,CAAAA,EAAAA;MAAOyG,aAAAA,GAAAA,6BAAAA,CAAAA,oBAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA;WACR;MAAE5C,MAAM,EAAE7D,EAAV;MAAcyG,aAAa,EAAbA;KAArB;;SAuBF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;QACM,IAAA,CAAKhD,UAAL,CAAgBC,MAAhB,CAAuBhC,aAA3B,EAA0C;aACjC,CAAC,CAAC,gBAAD,EAAmB,IAAA,CAAK0F,cAAxB,CAAD,EAA0C,CAAC,gBAAD,EAAmB,IAAA,CAAKC,cAAxB,CAA1C,CAAP;;WAEK,CAAC,CAAC,cAAD,EAAiB,IAAA,CAAKD,cAAtB,CAAD,EAAwC,CAAC,cAAD,EAAiB,IAAA,CAAKC,cAAtB,CAAxC,CAAP;;;EAlCyCxB,qBAAAA,CAAAA;;ACD7C;;;;IAG8ByB,uBAAAA,G;;;mCAChB9D,UAAZ,EAAoCC,UAApC,EAAmEvH,IAAnE,EAAA;QAAmEA,IAAAA,KAAAA,KAAAA,CAAAA,EAAAA;MAAAA,IAAAA,GAAc,EAAA;;WAC/E,WAAA,CAAA,IAAA,CAAA,IAAA,EAAMsH,UAAN,EAAkBC,UAAlB,EAA8BvH,IAA9B,CAAA,IAAA,IAAA;;;SAGFmJ,aAAAA,GAAAA,SAAAA,aAAAA,CAAAA,IAAAA,EAAyC/H,KAAzC+H,EAAAA;QAAekC,CAAAA,GAAAA,IAAAA,CAAAA,CAAAA,CAAAA;MAAGC,CAAAA,GAAAA,IAAAA,CAAAA,CAAAA,CAAAA;sBACqC,IAAA,CAAK7D,KAAAA;MAA1C1E,EAAAA,GAAAA,WAAAA,CAAR6C,MAAAA;MAAYe,KAAAA,GAAAA,WAAAA,CAAAA,KAAAA;MAAOb,OAAAA,GAAAA,WAAAA,CAAAA,OAAAA;MAASD,MAAAA,GAAAA,WAAAA,CAAAA,MAAAA;MAAQM,IAAAA,GAAAA,WAAAA,CAAAA,IAAAA,CAAAA,CAAAA;;;IAI5CmF,CAAC,GAAGA,CAAC,KAAK,KAAK,CAAXA,GAAeA,CAAfA,GAAmBvI,EAAE,CAAC,CAAD,CAAzBuI;QAEMC,OAAO,GAAGF,CAAC,GAAGtI,EAAE,CAAC,CAAD,CAAtB;QACIyI,OAAO,GAAGF,CAAC,GAAGvI,EAAE,CAAC,CAAD,CAApB;;;;;;;QAOM0I,QAAQ,GAAGzI,IAAI,CAAC0I,GAAL1I,CAASwI,OAATxI,CAAAA,GAAoB,GAApBA,GAA0B2D,KAAK,GAAG3D,IAAI,CAAC2I,IAAL3I,CAAUwI,OAAVxI,CAAlCA,GAAuD2D,KAAxE,CAAA,CAAA;;IAGA6E,OAAO,IAAI,GAAA,IAAOC,QAAQ,GAAG9E,KAAlB,CAAX6E;QACMlI,KAAK,GAAG,CAACiI,OAAD,EAAUC,OAAV,CAAd;QAEMI,UAAU,GAAGP,CAAC,GAAGvF,OAAO,CAAC,CAAD,CAA9B;QACM+F,UAAU,GAAGP,CAAC,GAAG,GAAA,GAAMG,QAAVH,GAAqBxF,OAAO,CAAC,CAAD,CAA/C;QACMjC,QAAQ,GAAY,CAAC+H,UAAD,EAAaC,UAAb,CAA1B;QAEMtI,OAAO,GAAGnC,KAAK,CAACuH,SAANvH,GAAkB+E,IAAlC;QACMO,IAAI,GAAGjD,mBAAmB,CAACH,KAAD,EAAQC,OAAR,CAAhC;QACMY,SAAS,GAAGL,kBAAkB,CAACR,KAAD,CAApC;WACO;MACLlC,KAAK,EAALA,KADK;MAELwE,MAAM,EAAE,CAACyF,CAAD,EAAIC,CAAJ,CAFH;MAGLzH,QAAQ,EAARA,QAHK;MAILP,KAAK,EAALA,KAJK;MAKLuC,MAAM,EAAE1F,IAAI,CAAC0F,MAAD,EAASvC,KAAT,CALP;MAMLoD,IAAI,EAAJA,IANK;MAOLvC,SAAS,EAATA,SAPK;MAQLwC,KAAK,EAAE8E,QARF;MASL1F,QAAQ,EAAEhD,EATL;MAULoD,IAAI,EAAE/E,KAAK,CAACuH;KAVd;;;EAjC0DtB,UAAAA,CAAAA;ICFzCyE,eAAAA,G;;;2BAIPvE,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,OAAN,EAAeuH,UAAf,EAA2BvH,IAA3B,CAAA,IAAA,IAAA;0BAJF,GAAmB;MAAEmH,QAAQ,EAAE;KAA/B;wBACA,GAAiB;MAAEA,QAAQ,EAAE,KAAZ;MAAmBxE,IAAI,EAAE,KAAzB;MAAgCP,OAAO,EAAE;KAA1D;sBAWA,GAAe,UAAChB,KAAD,EAAA;UACT,CAAC,KAAA,CAAKqE,OAAN,IAAiBrE,KAAK,CAACgB,OAANhB,CAAcoB,MAAdpB,KAAyB,CAA9C,EAAiD;YAC5CqI,OAAL,CAAarI,KAAb,EAAoB;QAAEgF,MAAM,EAAE,SAAA,MAAA,GAAA;iBAAM,KAAA,CAAKiE,QAAL,CAAcjJ,KAAd,CAAN;;OAA9B,CAAA;KAFF;uBAKA,GAAgB,UAACA,KAAD,EAAA;wBACqB,KAAA,CAAKqG,KAAAA;QAAhCpB,QAAAA,GAAAA,WAAAA,CAAAA,QAAAA;QAAUH,MAAAA,GAAAA,WAAAA,CAAAA,MAAAA;QAAQC,IAAAA,GAAAA,WAAAA,CAAAA,IAAAA;UACtBE,QAAQ,IAAI,CAACH,MAAbG,IAAuBjF,KAAK,CAACgB,OAANhB,CAAcoB,MAAdpB,KAAyB,CAAhDiF,IAAqDjF,KAAK,CAACuH,SAANvH,KAAoB+E,IAA7E,EAAmF;YAE9EuD,QAAL,CAActI,KAAd,EAAqB;QAAEgF,MAAM,EAAE,SAAA,MAAA,GAAA;iBAAM,KAAA,CAAKiE,QAAL,CAAcjJ,KAAd,CAAN;;OAA/B,CAAA;KAJF;;;;SAVAqH,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;gCAC2C7F,sBAAsB,CAACxB,KAAD,CAAA;MAAvD2B,EAAAA,GAAAA,qBAAAA,CAAAA,EAAAA;MAAIK,MAAAA,GAAAA,qBAAAA,CAAAA,MAAAA;MAAWoF,aAAAA,GAAAA,6BAAAA,CAAAA,qBAAAA,EAAAA,CAAAA,IAAAA,EAAAA,QAAAA,CAAAA,CAAAA;WAChB;MAAE5C,MAAM,EAAE7C,EAAV;MAAcwF,cAAc,EAAE;QAAEnF,MAAM,EAANA;OAAhC;MAA0CoF,aAAa,EAAbA;KAAjD;;SAeF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;WACS,CAAC,CAAC,cAAD,EAAiB,IAAA,CAAKwB,YAAtB,CAAD,EAAsC,CAAC,aAAD,EAAgB,IAAA,CAAKC,aAArB,CAAtC,EAA2E,CAAC,CAAC,YAAD,EAAe,eAAf,CAAD,EAAkC,IAAA,CAAKxC,KAAvC,CAA3E,CAAP;;;EA1ByC4B,uBAAAA,CAAAA;ICAxBa,oBAAAA,G;;;gCAIP1E,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,OAAN,EAAeuH,UAAf,EAA2BvH,IAA3B,CAAA,IAAA,IAAA;0BAJF,GAAmB;MAAEmH,QAAQ,EAAE;KAA/B;wBACA,GAAiB;MAAEA,QAAQ,EAAE;KAA7B;iBAoBA,GAAU,UAAC/F,KAAD,EAAA;UACJ,CAACA,KAAK,CAACI,OAAX,EAAoB;UAEhB,CAAC,KAAA,CAAK+F,UAAL,CAAgBC,MAAhB,CAAuBjC,aAA5B,EAA2CnE,KAAK,CAACgL,cAANhL,EAAAA,CAA3C,KACK,IAAIiL,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,aAA7B,EACHG,OAAO,CAACC,IAARD,CACE,8JADFA,CAAAA;YAIG9B,cAAL,CAAoBtJ,KAApB,CAAA;KATF;;;;SAdAqH,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;6BAIMzG,iBAAiB,CAACZ,KAAD,CAAA;iDAFnBW,EAAAA;MAAOwJ,OAAAA,GAAAA,qBAAAA,CAAAA,CAAAA,CAAAA;MACJ/C,aAAAA,GAAAA,6BAAAA,CAAAA,kBAAAA,EAAAA,CAAAA,IAAAA,CAAAA,CAAAA;yBAID,IAAA,CAAKf,KAAAA,CADP1E,EAAAA;MAAKmJ,MAAAA,GAAAA,cAAAA,CAAAA,CAAAA,CAAAA;MAAQC,MAAAA,GAAAA,cAAAA,CAAAA,CAAAA,CAAAA;QAETd,CAAC,GAAGa,MAAM,GAAGX,OAAnB;QACMD,CAAC,GAAGa,MAAM,KAAK,KAAK,CAAhBA,GAAoBA,MAApBA,GAA6B,CAAvC;QACM/I,MAAM,GAAY,CAAChC,KAAK,CAACqB,OAAP,EAAgBrB,KAAK,CAACsB,OAAtB,CAAxB;WACO;MAAEkD,MAAM,EAAE,CAACyF,CAAD,EAAIC,CAAJ,CAAV;MAA6B/C,cAAc,EAAE;QAAEnF,MAAM,EAANA;OAA/C;MAAyDoF,aAAa,EAAbA;KAAhE;;SAeF+B,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;WACS,CAAC,CAAC,SAAD,EAAY,IAAA,CAAKQ,OAAjB,CAAD,CAAP;;;EAnC8CK,uBAAAA,CAAAA;ACAlD,IAAMsB,YAAY,GAAG,GAArB;IAEqBC,4BAAAA,G;;;wCAKPpF,UAAZ,EAA2CvH,IAA3C,EAAA;;6CACQ,OAAN,EAAeuH,UAAf,EAA2BvH,IAA3B,CAAA,IAAA,IAAA;0BALF,GAAmB;MAAEmH,QAAQ,EAAE,IAAZ;MAAkBxE,IAAI,EAAE,IAAxB;MAA8BP,OAAO,EAAE;KAA1D;wBACA,GAAiB;MAAE+E,QAAQ,EAAE,KAAZ;MAAmBxE,IAAI,EAAE,KAAzB;MAAgCP,OAAO,EAAE;KAA1D;sBAWA,GAAe,UAAChB,KAAD,EAAA;UACT,CAAC,KAAA,CAAKqE,OAAV,EAAmB;MACnBrE,KAAK,CAACgL,cAANhL,EAAAA;UACMgC,MAAM,GAAY,KAAA,CAAKA,MAAL,GAAc,KAAA,CAAKA,MAAnB,GAA4B,CAAChC,KAAK,CAACqB,OAAP,EAAgBrB,KAAK,CAACsB,OAAtB,CAApD;YAEK+G,OAAL,CAAarI,KAAb,EAAoB;QAAEgC,MAAM,EAANA,MAAF;QAAUgD,MAAM,EAAE,SAAA,MAAA,GAAA;iBAAM,KAAA,CAAKiE,QAAL,CAAcjJ,KAAd,CAAN;;OAAtC,CAAA;KALF;uBAQA,GAAgB,UAACA,KAAD,EAAA;wBACe,KAAA,CAAKqG,KAAAA;QAA1BpB,QAAAA,GAAAA,WAAAA,CAAAA,QAAAA;QAAUH,MAAAA,GAAAA,WAAAA,CAAAA,MAAAA;UACdG,QAAQ,IAAI,CAACH,MAAjB,EAAyB;MACzB9E,KAAK,CAACgL,cAANhL,EAAAA;YAEKsI,QAAL,CAActI,KAAd,EAAqB;QAAEgF,MAAM,EAAE,SAAA,MAAA,GAAA;iBAAM,KAAA,CAAKiE,QAAL,CAAcjJ,KAAd,CAAN;;OAA/B,CAAA;KALF;sBAQA,GAAe,UAACA,KAAD,EAAA;YACRoI,KAAL,CAAWpI,KAAX,CAAA;MACAA,KAAK,CAACgL,cAANhL,EAAAA;YACKgC,MAAL,GAAc8B,SAAd;KAHF;yBAMA,GAAkB,UAAC9D,KAAD,EAAA;UACZ,CAAC,KAAA,CAAKqE,OAAN,IAAiBrE,KAAK,CAACgB,OAANhB,CAAcoB,MAAdpB,KAAyB,CAA9C,EAAiD;kCAC9BwB,sBAAsB,CAACxB,KAAD,CAAA;QAAjCgC,MAAAA,GAAAA,qBAAAA,CAAAA,MAAAA;YACHA,MAAL,GAAcA,MAAd;KAHF;;;;SA1BAqF,mBAAAA,GAAAA,SAAAA,mBAAAA,CAAoBrH,KAApBqH,EAAAA;WACS;MAAE7C,MAAM,EAAE,CAACxE,KAAK,CAACwL,KAANxL,GAAcsL,YAAf,EAA6BtL,KAAK,CAACyL,QAAnC;KAAjB;;SA+BFtC,gBAAAA,GAAAA,SAAAA,gBAAAA,GAAAA;WACS,CACL,CAAC,gBAAD,EAAmB,IAAA,CAAKwB,YAAxB,CADK,EAEL,CAAC,iBAAD,EAAoB,IAAA,CAAKC,aAAzB,CAFK,EAGL,CAAC,CAAC,cAAD,EAAiB,eAAjB,CAAD,EAAoC,IAAA,CAAKc,YAAzC,CAHK,EAIL,CAAC,CAAC,cAAD,EAAiB,aAAjB,CAAD,EAAkC,IAAA,CAAKC,eAAvC,CAJK,CAAP;;;EA1CsD3B,uBAAAA,CAAAA;;ACyB1D;;;;;;;IAMqB4B,iBAAAA,GAOnB,SAAA,iBAAA,CAAmB,QAAnB,EAA4D,MAA5D,EAAA;;eAAmB,GAAA,QAAA;aAAyC,GAAA,MAAA;YANrD,GAAqBpG,YAArB,CAAA,CAAA;;eACA,GAA4B,CAAA,CAA5B,CAAA,CAAA;;eAEC,GAAqB,CAAA,CAArB,CAAA,CAAA;;mBACA,GAA+B,EAA/B,CAAA,CAAA;;sBACA,GAAmC,CAAA,CAAnC,CAAA,CAAA;;;;;;;YAWD,GAAQ,YAAA;IACb,KAAI,CAAC0G,WAAL,EAAA;IACAxE,MAAM,CAAClD,MAAPkD,CAAc,KAAI,CAAClB,QAAnBkB,CAAAA,CAA6B7I,OAA7B6I,CAAqChB,YAArCgB,CAAAA;IACAA,MAAM,CAACoE,IAAPpE,CAAY,KAAI,CAACyE,eAAjBzE,CAAAA,CAAkC7I,OAAlC6I,CAA0C,UAAA,QAAQ,EAAA;aAAI,KAAI,CAACd,qBAAL,CAAqCvD,QAArC,CAAJ;KAAlDqE,CAAAA;GAHK;;;;;;kBAUC,GAAc,YAAA;IACpB,KAAI,CAAC0E,QAAL,GAAgB,CAAA,CAAhB;QACQvI,SAAAA,GAAc,KAAI,CAACuC,MAAAA,CAAnBvC,SAAAA;QACJA,SAAJ,EAAe;MACb/D,eAAe,CAAc+D,SAAd,EAAyB,KAAI,CAACwI,YAA9B,EAA4C,KAAI,CAACjG,MAAL,CAAYpG,KAAxD,CAAfF;MACA,KAAI,CAACuM,YAAL,GAAoB,EAApB;;GALI;;;;;;;;kBAeD,GAAc,UAACxF,WAAD,EAAkDC,YAAlD,EAAuFzD,QAAvF,EAAA;;QACbiJ,eAAe,GAAA,QAAA,CAAA,CAAA,CAAA,EAAQ,KAAI,CAACjG,KAAL,CAAWhD,QAAX,CAAR,EAAA,CAAA,CAAA,EAAiCyD,YAAjC,CAArB;QAEI,IAAA,IAAQwF,eAAZ,EAA6BA,eAAe,CAAC3K,EAAhB2K,GAAqBA,eAAe,CAAC9H,MAArC8H,CAA7B,KACK,IAAI,IAAA,IAAQA,eAAZ,EAA6BA,eAAe,CAAC3L,EAAhB2L,GAAqBA,eAAe,CAAC9H,MAArC8H;IAElC,KAAI,CAACjG,KAAL,GAAA,QAAA,CAAA,CAAA,CAAA,EACK,KAAI,CAACA,KADV,GAAA,SAAA,GAAA;MAEEZ,MAAM,EAAA,QAAA,CAAA,CAAA,CAAA,EAAO,KAAI,CAACY,KAAL,CAAWZ,MAAlB,EAAA,CAAA,CAAA,EAA6BoB,WAA7B;iBACLxD,QAHH,CAAA,GAGciJ,eAHd,EAAA,SAAA,EAAA;GANK,CAAA,CAAA;;yBAcA,GAAqB,UAACpG,UAAD,EAAyBc,WAAzB,EAAA;;;gCAGO7D,UAAU,CAAC+C,UAAD,CAAA;MAAnC7C,QAAAA,GAAAA,qBAAAA,CAAAA,QAAAA;MAAUC,UAAAA,GAAAA,qBAAAA,CAAAA,UAAAA;QACZ+C,KAAK,GAAA,QAAA,CAAA,CAAA,CAAA,EAAQ,KAAI,CAACA,KAAL,CAAWZ,MAAnB,EAAA,CAAA,CAAA,EAA8B,KAAI,CAACY,KAAL,CAAWhD,QAAX,CAA9B,CAAX;QACIgD,KAAK,CAACrG,KAAV,EAAiBqG,KAAK,CAACrG,KAANqG,CAAYkG,OAAZlG,GAAsBH,UAAtBG;QAEbW,WAAW,KAAKxI,WAAW,CAACqJ,OAAhC,EAAyC;UACjC2E,YAAY,GAAMlJ,UAAN,GAAA,OAAlB;UACMmJ,QAAO,GAAG,KAAI,CAACV,QAAL,CAAcS,YAAd,CAAhB;MACAC,QAAO,IAAIA,QAAO,CAACpG,KAAD,CAAlBoG;;;;QAKIA,OAAO,GAAG,KAAI,CAACV,QAAL,CAAczI,UAAd,CAAhB;QACImJ,OAAJ,EAAa;UACLC,OAAO,GAAGD,OAAO,CAACpG,KAAD,CAAvB;MACA,KAAI,CAACA,KAAL,CAAWhD,QAAX,CAAA,CAAqB6B,IAArB,GAA4BwH,OAAO,KAAK,KAAK,CAAjBA,GAAqBA,OAArBA,GAA+B,KAAI,CAACrG,KAAL,CAAWhD,QAAX,CAAA,CAAqB6B,IAAhF;;QAGE8B,WAAW,KAAKxI,WAAW,CAAC0J,KAAhC,EAAuC;UAC/ByE,UAAU,GAAMrJ,UAAN,GAAA,KAAhB;UACMmJ,SAAO,GAAG,KAAI,CAACV,QAAL,CAAcY,UAAd,CAAhB;MACAF,SAAO,IAAIA,SAAO,CAACpG,KAAD,CAAlBoG;;GAxBG;;;;;;;yBAiCA,GAAqB,UAACpJ,QAAD,EAAqB5D,SAArB,EAAA;QACtB,CAAC,KAAI,CAAC2G,MAAL,CAAYnC,MAAjB,EAAyB,OAAA,CAAA;;IAEzB,KAAI,CAACkI,eAAL,CAAqB9I,QAArB,CAAA,GAAiC5D,SAAjC;IACAI,YAAY,CAAC,KAAI,CAACuG,MAAL,CAAYnC,MAAb,EAAqBxE,SAArB,EAAgC,KAAI,CAAC2G,MAAL,CAAYpG,KAA5C,CAAZH;GAJK,CAAA,CAAA;;4BAQA,GAAwB,UAACwD,QAAD,EAAA;QACzB,CAAC,KAAI,CAAC+C,MAAL,CAAYnC,MAAjB,EAAyB;QACnBxE,SAAS,GAAG,KAAI,CAAC0M,eAAL,CAAqB9I,QAArB,CAAlB;QACI5D,SAAJ,EAAe;MACbK,eAAe,CAAC,KAAI,CAACsG,MAAL,CAAYnC,MAAb,EAAqBxE,SAArB,EAAgC,KAAI,CAAC2G,MAAL,CAAYpG,KAA5C,CAAfF;aACO,KAAI,CAACqM,eAAL,CAAqB9I,QAArB,CAAP;;GALG;;;;;;oBAaC,GAAgB,UAACuJ,UAAD,EAAA;IACtBA,UAAU,CAACzD,gBAAXyD,EAAAA,CAA8B1N,GAA9B0N,CAAkC,KAAI,CAACC,gBAAvCD,CAAAA;GADM;;;;;;;;uBAUA,GAAmB,UAAA,IAAA,EAAA;QAAEE,UAAAA,GAAAA,IAAAA,CAAAA,CAAAA,CAAAA;MAAYhO,EAAAA,GAAAA,IAAAA,CAAAA,CAAAA,CAAAA;QACjCiO,eAAe,GAAG,CAACzK,KAAK,CAAC0K,OAAN1K,CAAcwK,UAAdxK,CAAD,GAA6B,CAACwK,UAAD,CAA7B,GAA4CA,UAApE;IAEAC,eAAe,CAAClO,OAAhBkO,CAAwB,UAAA,SAAS,EAAA;MAC/B,KAAI,CAACX,QAAL,CAAca,SAAd,CAAA,GAA2B,KAAI,CAACb,QAAL,CAAca,SAAd,CAAA,GAAA,EAAA,CAAA,MAAA,CAAsC,KAAI,CAACb,QAAL,CAAca,SAAd,CAAtC,EAAA,CAAiEnO,EAAjE,CAAA,CAAA,GAAuE,CAACA,EAAD,CAAlG;KADFiO,CAAAA;GAHM;;;;;4BAWA,GAAwB,YAAA;QACtBlJ,SAAAA,GAAc,KAAI,CAACuC,MAAAA,CAAnBvC,SAAAA,CAAAA,CAAAA;;;;IAKR6D,MAAM,CAACwF,OAAPxF,CAAe,KAAI,CAAC0E,QAApB1E,CAAAA,CAA8B7I,OAA9B6I,CAAsC,UAAA,KAAA,EAAA;UAAE1H,KAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA;QAAOrB,GAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA;MAC7C,KAAI,CAAC0N,YAAL,CAAkBc,IAAlB,CAAuB,CAACnN,KAAK,CAACoN,MAANpN,CAAa,CAAbA,CAAAA,CAAgBqN,WAAhBrN,EAAD,EAAgCtB,QAAQ,CAAA,KAARA,CAAAA,KAAAA,CAAAA,EAAmBC,GAAnBD,CAAhC,CAAvB,CAAA;KADFgJ,CAAAA;IAIA7H,YAAY,CAAcgE,SAAd,EAAyB,KAAI,CAACwI,YAA9B,EAA4C,KAAI,CAACjG,MAAL,CAAYpG,KAAxD,CAAZH;GAVM;;;;;;kBAiBA,GAAc,YAAA;QACdyN,MAAM,GAAuB,CAAA,CAAnC;QACMC,aAAa,GAAG,KAAI,CAACnH,MAAL,CAAYpG,KAAZ,CAAkBgE,OAAlB,GAA4B,SAA5B,GAAwC,EAA9D;IAEA0D,MAAM,CAACwF,OAAPxF,CAAe,KAAI,CAAC0E,QAApB1E,CAAAA,CAA8B7I,OAA9B6I,CAAsC,UAAA,KAAA,EAAA;UAAE1H,KAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA;QAAOrB,GAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA;UACvC6O,QAAQ,GAAGlL,KAAK,CAAC0K,OAAN1K,CAAc3D,GAAd2D,CAAAA,GAAqB3D,GAArB2D,GAA2B,CAAC3D,GAAD,CAA5C;UACM8O,GAAG,GAAIzN,KAAK,GAAGuN,aAArB;MACAD,MAAM,CAACG,GAAD,CAANH,GAAc5O,QAAQ,CAAA,KAARA,CAAAA,KAAAA,CAAAA,EAAmB8O,QAAnB9O,CAAd4O;KAHF5F,CAAAA;WAMO4F,MAAP;GAVM;WAaD,GAAO,YAAA;QACJzJ,SAAAA,GAAc,KAAI,CAACuC,MAAAA,CAAnBvC,SAAAA;QAEF6J,eAAe,GAAA,QAAA,CAAA,CAAA,CAAA,EAAQ,KAAI,CAAC3B,QAAb,CAArB,CAAA,CAAA;;IAGA,KAAI,CAACG,WAAL,EAAA;sCANgBtN,IAAAA,GAAAA,IAAAA,KAAAA,CAAAA,IAAAA,CAAAA,EAAAA,IAAAA,GAAAA,CAAAA,EAAAA,IAAAA,GAAAA,IAAAA,EAAAA,IAAAA,EAAAA,EAAAA;MAAAA,IAAAA,CAAAA,IAAAA,CAAAA,GAAAA,SAAAA,CAAAA,IAAAA,CAAAA;;QAQZ,KAAI,CAAC6K,OAAL,CAAaC,GAAb,CAAiB,QAAjB,CAAJ,EAAgC;MAC9B,KAAI,CAACiE,aAAL,CAAmB,IAAIlF,cAAJ,CAAmB,KAAnB,EAAyB7J,IAAzB,CAAnB,CAAA;aACO8O,eAAe,CAACE,MAAvB;aACOF,eAAe,CAACtE,WAAvB;aACOsE,eAAe,CAAC7E,SAAvB;;QAEE,KAAI,CAACY,OAAL,CAAaC,GAAb,CAAiB,UAAjB,CAAJ,EAAkC;MAChC,KAAI,CAACiE,aAAL,CAAmB,IAAItE,gBAAJ,CAAqB,KAArB,EAA2BzK,IAA3B,CAAnB,CAAA;aACO8O,eAAe,CAACG,QAAvB;aACOH,eAAe,CAACI,aAAvB;aACOJ,eAAe,CAACK,WAAvB;;QAEE,KAAI,CAACtE,OAAL,CAAaC,GAAb,CAAiB,SAAjB,CAAJ,EAAiC;MAC/B,KAAI,CAACiE,aAAL,CAAmB,IAAIpE,eAAJ,CAAoB,KAApB,EAA0B3K,IAA1B,CAAnB,CAAA;aACO8O,eAAe,CAAC/D,OAAvB;aACO+D,eAAe,CAACM,YAAvB;aACON,eAAe,CAACO,UAAvB;;QAEE,KAAI,CAACxE,OAAL,CAAaC,GAAb,CAAiB,QAAjB,CAAJ,EAAgC;MAC9B,KAAI,CAACiE,aAAL,CAAmB,IAAI/D,cAAJ,CAAmB,KAAnB,EAAyBhL,IAAzB,CAAnB,CAAA;aACO8O,eAAe,CAACQ,MAAvB;aACOR,eAAe,CAACS,WAAvB;aACOT,eAAe,CAACU,SAAvB;;QAEE,KAAI,CAAC3E,OAAL,CAAaC,GAAb,CAAiB,SAAjB,CAAJ,EAAiC;MAC/B,KAAI,CAACiE,aAAL,CAAmB,IAAI9D,eAAJ,CAAoB,KAApB,EAA0BjL,IAA1B,CAAnB,CAAA;aACO8O,eAAe,CAACW,OAAvB;;QAEE,KAAI,CAAC5E,OAAL,CAAaC,GAAb,CAAiB,SAAjB,CAAJ,EAAiC;;;UAG3B7F,SAAS,IAAIb,qBAAqB,EAAtC,EAA0C;QACxC,KAAI,CAAC2K,aAAL,CAAmB,IAAIpC,4BAAJ,CAAiC,KAAjC,EAAuC3M,IAAvC,CAAnB,CAAA;OADF,MAEO;QACL,KAAI,CAAC+O,aAAL,CAAmB,IAAIjD,eAAJ,CAAoB,KAApB,EAA0B9L,IAA1B,CAAnB,CAAA;QACA,KAAI,CAAC+O,aAAL,CAAmB,IAAI9C,oBAAJ,CAAyB,KAAzB,EAA+BjM,IAA/B,CAAnB,CAAA;;aAEK8O,eAAe,CAACY,OAAvB;aACOZ,eAAe,CAAC/C,YAAvB;aACO+C,eAAe,CAACa,UAAvB;;;IAIF7G,MAAM,CAACwF,OAAPxF,CAAegG,eAAfhG,CAAAA,CAAgCxI,GAAhCwI,CAAoC,UAAA,KAAA,EAAA;UAAE1H,KAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA;QAAOlB,EAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA;;;MAE3C,KAAI,CAAC+N,gBAAL,CAAsB,CAAuB7M,KAAvB,EAAkClB,EAAlC,CAAtB,CAAA;KAFF4I,CAAAA,CAAAA,CAAAA;;QAMI7D,SAAJ,EAAe;MACb,KAAI,CAAC2K,qBAAL,EAAA;aACO,KAAI,CAACC,KAAZ;;;WAIK,KAAI,CAACC,WAAL,EAAP;GA/DK,CAAA,CAAA;;;OAvJAjF,OAAL,GAAe,IAAIoC,GAAJ,CAAQ,MAAM,CAACC,IAAP,CAAY,IAAA,CAAKC,QAAjB,CAAA,CAA2B7M,GAA3B,CAA+B,UAAA,CAAC,EAAA;WAAgB8M,CAAC,CAACC,OAAFD,CAAU,WAAVA,EAAuB,EAAvBA,CAAhB;GAAhC,CAAR,CAAf;;SC1BY2C,UAAAA,CACd5C,QAAAA,EACA3F,MAAAA,EAAAA;;MAGMwI,iBAAiB,GAAGC,KAAK,CAACC,MAAND,EAA1B;MAEI,CAACD,iBAAiB,CAACG,OAAvB,EAAgC;;IAE9BH,iBAAiB,CAACG,OAAlBH,GAA4B,IAAIhD,iBAAJ,CAAsBG,QAAtB,EAAgCiD,gBAAgB,CAAC5I,MAAD,CAAhD,CAA5BwI;;EAGFC,KAAK,CAACI,SAANJ,CAAgB,YAAA;;;IAGdD,iBAAiB,CAACG,OAAlBH,CAA2BxI,MAA3BwI,GAAoCI,gBAAgB,CAAC5I,MAAD,CAApDwI;IACAA,iBAAiB,CAACG,OAAlBH,CAA2B7C,QAA3B6C,GAAsC7C,QAAtC6C;GAJFC,EAKG,CAAC9C,QAAD,EAAW3F,MAAX,CALHyI,CAAAA,CAAAA,CAAAA;;EAQAA,KAAK,CAACI,SAANJ,CAAgB,YAAA;WAAMD,iBAAiB,CAACG,OAAlBH,CAA2BH,KAAjC;GAAhBI,EAAwD,EAAxDA,CAAAA,CAAAA,CAAAA;;;SAIOD,iBAAiB,CAACG,OAAlBH,CAA0BM,IAAjC;;;;AAIF,IAAaC,OAAO,GAAG,SAAVA,OAAU,CAAC1C,OAAD,EAAgCrG,MAAhC,EAAA;SAAkEuI,UAAU,CAAC;IAAEf,MAAM,EAAEnB;GAAX,EAAsBrG,MAAtB,CAA5E;CAAhB;AACP,IAAagJ,OAAO,GAAG,SAAVA,OAAU,CAAC3C,OAAD,EAAgCrG,MAAhC,EAAA;SAAkEuI,UAAU,CAAC;IAAET,MAAM,EAAEzB;GAAX,EAAsBrG,MAAtB,CAA5E;CAAhB;AACP,IAAaiJ,QAAQ,GAAG,SAAXA,QAAW,CAAC5C,OAAD,EAAgCrG,MAAhC,EAAA;SAAkEuI,UAAU,CAAC;IAAEN,OAAO,EAAE5B;GAAZ,EAAuBrG,MAAvB,CAA5E;CAAjB;AACP,IAAakJ,SAAS,GAAG,SAAZA,SAAY,CAAC7C,OAAD,EAAgCrG,MAAhC,EAAA;SAAkEuI,UAAU,CAAC;IAAEd,QAAQ,EAAEpB;GAAb,EAAwBrG,MAAxB,CAA5E;CAAlB;AACP,IAAamJ,QAAQ,GAAG,SAAXA,QAAW,CAAC9C,OAAD,EAAgCrG,MAAhC,EAAA;SAAkEuI,UAAU,CAAC;IAAEhF,OAAO,EAAE8C;GAAZ,EAAuBrG,MAAvB,CAA5E;CAAjB;AACP,IAAaoJ,QAAQ,GAAG,SAAXA,QAAW,CAAC/C,OAAD,EAAkCrG,MAAlC,EAAA;SAAoEuI,UAAU,CAAC;IAAEL,OAAO,EAAE7B;GAAZ,EAAuBrG,MAAvB,CAA9E;CAAjB;AAEP,SAAS4I,gBAAT,CAA0B5I,MAA1B,EAAA;MACQqJ,aAAa,GAAA,QAAA,CAAA,CAAA,CAAA,EAAQ7L,aAAR,EAAA,CAAA,CAAA,EAA0BwC,MAA1B,CAAnB;MACQvC,SAAAA,GAAc4L,aAAAA,CAAd5L,SAAAA;MACF6L,aAAa,GAAG7L,SAAS,IAAI,SAAA,IAAaA,SAA1BA,GAAsCA,SAAS,CAACkL,OAAhDlL,GAA0DA,SAAhF;EACA4L,aAAa,CAAC5L,SAAd4L,GAA0BC,aAA1BD;MAEM1L,OAAO,GAAG0L,aAAa,CAACzP,KAAdyP,CAAoB1L,OAApB0L,KAAgC,KAAK,CAArCA,GAAyCA,aAAa,CAACzP,KAAdyP,CAAoB1L,OAA7D0L,GAAuE,IAAvF,CAAA,CAAA;;;EAKAA,aAAa,CAACtL,aAAdsL,GAA8B,CAACA,aAAa,CAAC5L,SAAf,IAA4BE,OAA1D0L;SAEOA,aAAP","sourcesContent":["import React from 'react'\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\nexport type AtLeastOneOf<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U]\n\nexport type Vector2 = [number, number]\nexport type Fn = (...args: any[]) => any\n\nexport type EventOptions = { capture?: boolean; passive?: boolean }\n\nexport interface GestureConfig {\n  domTarget?: EventTarget | React.RefObject<EventTarget> | null\n  event: EventOptions\n  window?: EventTarget\n  dragDelay: boolean | number\n  passiveEvents: boolean\n  pointerEvents: boolean\n  enabled: boolean\n  drag: boolean\n  pinch: boolean\n  scroll: boolean\n  wheel: boolean\n  hover: boolean\n  move: boolean\n}\n\nexport enum GestureFlag {\n  OnStart = 'start',\n  OnChange = 'change',\n  OnEnd = 'end',\n}\n\nexport type WebKitGestureEvent = React.PointerEvent & { scale: number; rotation: number }\nexport type UseGestureEvent<\n  T extends React.SyntheticEvent = React.MouseEvent | React.TouchEvent | React.WheelEvent | React.PointerEvent | WebKitGestureEvent\n> = T & {\n  gesture?: GestureKey\n}\n\nexport interface ReactEventHandlers {\n  // Mouse Events\n  onMouseDown?: React.MouseEventHandler\n  onMouseDownCapture?: React.MouseEventHandler\n  onMouseEnter?: React.MouseEventHandler\n  onMouseLeave?: React.MouseEventHandler\n  onMouseMove?: React.MouseEventHandler\n  onMouseMoveCapture?: React.MouseEventHandler\n  onMouseOut?: React.MouseEventHandler\n  onMouseOutCapture?: React.MouseEventHandler\n  onMouseOver?: React.MouseEventHandler\n  onMouseOverCapture?: React.MouseEventHandler\n  onMouseUp?: React.MouseEventHandler\n  onMouseUpCapture?: React.MouseEventHandler\n  // Touch Events\n  onTouchCancel?: React.TouchEventHandler\n  onTouchCancelCapture?: React.TouchEventHandler\n  onTouchEnd?: React.TouchEventHandler\n  onTouchEndCapture?: React.TouchEventHandler\n  onTouchMove?: React.TouchEventHandler\n  onTouchMoveCapture?: React.TouchEventHandler\n  onTouchStart?: React.TouchEventHandler\n  onTouchStartCapture?: React.TouchEventHandler\n\n  // Pointer Events\n  onPointerDown?: React.PointerEventHandler\n  onPointerDownCapture?: React.PointerEventHandler\n  onPointerMove?: React.PointerEventHandler\n  onPointerMoveCapture?: React.PointerEventHandler\n  onPointerUp?: React.PointerEventHandler\n  onPointerUpCapture?: React.PointerEventHandler\n  onPointerCancel?: React.PointerEventHandler\n  onPointerCancelCapture?: React.PointerEventHandler\n  onPointerEnter?: React.PointerEventHandler\n  onPointerEnterCapture?: React.PointerEventHandler\n  onPointerLeave?: React.PointerEventHandler\n  onPointerLeaveCapture?: React.PointerEventHandler\n  onPointerOver?: React.PointerEventHandler\n  onPointerOverCapture?: React.PointerEventHandler\n  onPointerOut?: React.PointerEventHandler\n  onPointerOutCapture?: React.PointerEventHandler\n  onGotPointerCapture?: React.PointerEventHandler\n  onGotPointerCaptureCapture?: React.PointerEventHandler\n  onLostPointerCapture?: React.PointerEventHandler\n  onLostPointerCaptureCapture?: React.PointerEventHandler\n\n  // UI Events\n  onScroll?: React.UIEventHandler\n  onScrollCapture?: React.UIEventHandler\n\n  // Wheel Events\n  onWheel?: React.WheelEventHandler\n  onWheelCapture?: React.WheelEventHandler\n\n  // Cheat mode for Gesture Events\n  onGestureStart?: Fn\n  onGestureChange?: Fn\n  onGestureEnd?: Fn\n}\n\nexport type ReactEventHandlerKey = keyof ReactEventHandlers\n\nexport type GestureKey = 'drag' | 'pinch' | 'move' | 'scroll' | 'wheel' | 'hover'\nexport type StateKey = Exclude<GestureKey, 'hover'>\n\nexport interface SharedGestureState {\n  hovering: boolean\n  scrolling: boolean\n  wheeling: boolean\n  dragging: boolean\n  moving: boolean\n  pinching: boolean\n  touches: number\n  down: boolean\n  buttons: number\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\nexport interface CommonGestureState {\n  event?: UseGestureEvent\n  currentTarget?: EventTarget | null\n  pointerId?: number | null\n  values: Vector2\n  delta: Vector2\n  movement: Vector2\n  offset: Vector2\n  initial: Vector2\n  previous: Vector2\n  direction: Vector2\n  first: boolean\n  last: boolean\n  active: boolean\n  time?: number\n  cancel?(): void\n  canceled: boolean\n  memo?: any\n  args?: any\n}\n\nexport interface Coordinates {\n  xy: Vector2\n  velocity: number\n  vxvy: Vector2\n  distance: number\n}\n\nexport interface DistanceAngle {\n  da: Vector2\n  vdva: Vector2\n  origin?: Vector2\n  turns: number\n}\n\nexport type GestureState<T extends Coordinates | DistanceAngle = Coordinates | DistanceAngle> = T & CommonGestureState\nexport type FullGestureState<T extends Coordinates | DistanceAngle> = SharedGestureState & GestureState<T>\n\nexport type StateObject = { shared: SharedGestureState } & { [K in StateKey]: GestureState<Coordinates | DistanceAngle> }\n\nexport type Handler<T extends Coordinates | DistanceAngle> = (state: FullGestureState<T>) => any | void\nexport type HandlerKey = 'onDrag' | 'onPinch' | 'onMove' | 'onHover' | 'onScroll' | 'onWheel'\n\nexport type GestureHandlers = {\n  onDrag: Handler<Coordinates>\n  onDragStart: Handler<Coordinates>\n  onDragEnd: Handler<Coordinates>\n  onHover: Handler<Coordinates>\n  onMove: Handler<Coordinates>\n  onMoveStart: Handler<Coordinates>\n  onMoveEnd: Handler<Coordinates>\n  onScroll: Handler<Coordinates>\n  onScrollStart: Handler<Coordinates>\n  onScrollEnd: Handler<Coordinates>\n  onWheel: Handler<Coordinates>\n  onWheelStart: Handler<Coordinates>\n  onWheelEnd: Handler<Coordinates>\n  onPinch: Handler<DistanceAngle>\n  onPinchStart: Handler<DistanceAngle>\n  onPinchEnd: Handler<DistanceAngle>\n}\n\n/* Handlers should also accept DomAttributes to prevent overrides */\nexport type GestureHandlersPartial = AtLeastOneOf<GestureHandlers> &\n  Partial<Omit<React.DOMAttributes<Element>, 'onDrag' | 'onScroll' | 'onWheel'>>\n","import React from 'react'\nimport { Fn, Vector2, EventOptions, Coordinates, FullGestureState, DistanceAngle, UseGestureEvent } from './types'\n\n// blank function\nexport const noop = () => {}\n\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\n// vector add\nexport const addV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v + v2[i])\n\n// vector substract\nexport const subV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v - v2[i])\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([type, fn]) => el[action](type, fn, options))\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\ntype ScrollEventData = Pick<FullGestureState<Coordinates>, 'xy'> & ModifierKeys\n\n/**\n * Gets scroll event data\n * @param event\n * @returns scroll event data\n */\nexport function getScrollEventData(event: UseGestureEvent): ScrollEventData {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = <Element & Window>event.currentTarget\n  return { xy: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0], ...getModifierKeys(event) }\n}\n\ntype WheelEventData = Pick<FullGestureState<Coordinates>, 'xy'> & ModifierKeys\n\n/**\n * Gets wheel event data\n * @param event\n * @returns wheel event data\n */\nexport function getWheelEventData(event: UseGestureEvent<React.WheelEvent>): WheelEventData {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { xy: [deltaX, deltaY], ...getModifierKeys(event) }\n}\n\ntype PointerEventData = Pick<FullGestureState<Coordinates>, 'xy' | 'touches' | 'down' | 'buttons'> & ModifierKeys\n/**\n * Gets pointer event data\n * @param event\n * @returns pointer event data\n */\nexport function getPointerEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): PointerEventData {\n  const { touches, buttons, changedTouches } = event as any\n  const touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : event\n  const down = (touchEvents && touchEvents.length > 0) || buttons > 0\n  return {\n    xy: [clientX, clientY],\n    touches: (touchEvents && touchEvents.length) || 0,\n    down,\n    buttons,\n    ...getModifierKeys(event),\n  }\n}\n\ntype TwoTouchesEventData = Pick<FullGestureState<DistanceAngle>, 'da' | 'touches' | 'down' | 'origin'> & ModifierKeys\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent): TwoTouchesEventData {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const da: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { da, origin, touches: 2, down: touches.length > 0, ...getModifierKeys(event) }\n}\n\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return delta_t ? <T>delta.map(v => v / delta_t) : <T>Array(delta.length).fill(0)\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return <T>delta.map(v => v / len!)\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function gestureEventSupported(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n","import { noop } from './utils'\nimport { GestureConfig, HandlerKey, CommonGestureState, Coordinates, DistanceAngle, StateObject, StateKey, GestureKey } from './types'\n\ntype MappedKeys = { [K in GestureKey]: { stateKey: StateKey; handlerKey: HandlerKey } }\n\n/**\n * Some gestures might use the state key from another gesture (i.e. hover)\n * so mappedKeys is a commodity object to get the state key and handler key\n * for every gesture\n */\nexport const mappedKeys: MappedKeys = {\n  drag: { stateKey: 'drag', handlerKey: 'onDrag' },\n  pinch: { stateKey: 'pinch', handlerKey: 'onPinch' },\n  move: { stateKey: 'move', handlerKey: 'onMove' },\n  scroll: { stateKey: 'scroll', handlerKey: 'onScroll' },\n  wheel: { stateKey: 'wheel', handlerKey: 'onWheel' },\n  hover: { stateKey: 'move', handlerKey: 'onHover' },\n}\n\n// default config (will extend user config)\nexport const defaultConfig: GestureConfig = {\n  domTarget: undefined,\n  event: { passive: true, capture: false },\n  window: typeof window !== 'undefined' ? window : undefined,\n  dragDelay: false,\n  passiveEvents: true,\n  pointerEvents: false,\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true,\n}\n\n// common initial state for all gestures\nexport const initialCommon: CommonGestureState = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  delta: [0, 0],\n  movement: [0, 0],\n  offset: [0, 0],\n  direction: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined,\n}\n\n// initial state for coordinates-based gestures\nconst initialCoordinates: Coordinates = { xy: [0, 0], vxvy: [0, 0], velocity: 0, distance: 0 } // xy coordinates\n\n// initial state for distance and angle-based gestures (pinch)\nconst initialDistanceAngle: DistanceAngle = { da: [0, 0], vdva: [0, 0], origin: undefined, turns: 0 } // distance and angle\n\n// initial state object (used by the gesture controller)\nexport const initialState: StateObject = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n  },\n  move: { ...initialCommon, ...initialCoordinates },\n  drag: { ...initialCommon, ...initialCoordinates },\n  scroll: { ...initialCommon, ...initialCoordinates },\n  wheel: { ...initialCommon, ...initialCoordinates },\n  pinch: { ...initialCommon, ...initialDistanceAngle },\n}\n\n// generic end state for all gestures\nexport const genericEndState: Partial<CommonGestureState> = { first: false, last: true, active: false }\n","import { mappedKeys, genericEndState, initialState } from '../defaults'\nimport GestureController from '../controllers/GestureController'\nimport {\n  Coordinates,\n  DistanceAngle,\n  StateKey,\n  GestureState,\n  GestureKey,\n  SharedGestureState,\n  Fn,\n  ReactEventHandlerKey,\n  GestureFlag,\n  UseGestureEvent,\n  Vector2,\n} from '../types'\nimport { noop, subV, calculateAllKinematics } from '../utils'\n\ntype PayloadFromEvent = {\n  values: Vector2\n  gesturePayload?: Partial<GestureState>\n  sharedPayload?: Partial<SharedGestureState>\n}\n\n/**\n * Recognizer abstract class\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<GestureType extends Coordinates | DistanceAngle = Coordinates | DistanceAngle> {\n  protected stateKey: StateKey\n  protected sharedStartState?: Partial<SharedGestureState>\n  protected sharedEndState?: Partial<SharedGestureState>\n\n  /**\n   * Continuous gestures are scroll or wheel, where the next gesture continues the previous one.\n   * In other words, these gestures also start with a delta.\n   */\n  protected continuousGesture = false\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param gestureKey drag, move, hover, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly gestureKey: GestureKey,\n    protected readonly controller: GestureController,\n    protected readonly args: any[] = []\n  ) {\n    // mapping this.stateKey to the state key the gesture handles\n    // (ie hover actually deals with the move gesture state)\n    this.stateKey = mappedKeys[gestureKey].stateKey\n  }\n\n  // is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.controller.config[this.gestureKey]\n  }\n  // get the controller state for a given gesture\n  protected get state() {\n    return this.controller.state[this.stateKey] as GestureState<GestureType>\n  }\n\n  // convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  protected abstract getPayloadFromEvent(event: UseGestureEvent): PayloadFromEvent\n\n  /**\n   * Utility function to get kinematics of the gesture\n   * @values values we want to calculate the kinematics from\n   * @event\n   * @returns set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: [number, number | undefined], event: UseGestureEvent): Partial<GestureState<GestureType>>\n\n  // should return the bindings for a given gesture\n  public abstract getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][]\n\n  /**\n   * convenience method to update the controller state for a given gesture\n   * @param sharedState shared partial state object\n   * @param gestureState partial state object for the gesture handled by the recognizer\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\n   */\n  protected updateState = (sharedState: Partial<SharedGestureState> | null, gestureState: Partial<GestureState<GestureType>>): void => {\n    this.controller.updateState(sharedState, gestureState, this.stateKey)\n  }\n\n  protected fireGestureHandler = (gestureFlag: GestureFlag): void => {\n    this.controller.fireGestureHandler(this.gestureKey, gestureFlag)\n  }\n\n  // generic onStart function\n  protected onStart = (event: UseGestureEvent, payload?: Partial<GestureState<GestureType>>): void => {\n    const { values, gesturePayload, sharedPayload } = this.getPayloadFromEvent(event)\n\n    // TODO probably needs some rework, initialState and resetState should be different\n\n    const startState: GestureState<GestureType> = {\n      ...(initialState[this.stateKey] as GestureState<GestureType>),\n      values,\n      event,\n      first: true,\n      active: true,\n      time: event.timeStamp,\n      args: this.args,\n    }\n\n    const { values: prevValues, offset } = this.state\n\n    if (this.continuousGesture) {\n      startState.initial = startState.previous = prevValues\n      startState.delta = startState.movement = subV(values, prevValues)\n      startState.offset = values\n      Object.assign(startState, calculateAllKinematics(startState.movement, startState.delta, 0))\n    } else {\n      startState.initial = startState.previous = values\n      startState.offset = offset\n    }\n\n    this.updateState({ ...this.sharedStartState, ...sharedPayload }, { ...startState, ...gesturePayload, ...payload })\n    this.fireGestureHandler(GestureFlag.OnStart)\n  }\n\n  // generic onChange function\n  protected onChange = (event: UseGestureEvent, payload?: Partial<GestureState<GestureType>>): void => {\n    const { values, gesturePayload, sharedPayload } = this.getPayloadFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n    this.updateState({ ...sharedPayload }, { first: false, ...kinematics, ...gesturePayload, ...payload })\n    this.fireGestureHandler(GestureFlag.OnChange)\n  }\n\n  // generic onEnd function\n  protected onEnd = (event: UseGestureEvent, payload?: Partial<GestureState<GestureType>>): void => {\n    if (!this.state.active) return\n    this.removeWindowListeners()\n    this.updateState(this.sharedEndState!, { event, ...genericEndState, ...payload } as Partial<GestureState<GestureType>>)\n    this.fireGestureHandler(GestureFlag.OnEnd)\n  }\n\n  // generic cancel function\n  protected onCancel = (event: UseGestureEvent): void => {\n    this.updateState(null, { canceled: true, cancel: noop } as Partial<GestureState<GestureType>>)\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  // generic gesture handler for timeout-based gestures\n  protected timeoutHandler = (event: UseGestureEvent) => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    if (!this.state.active) this.onStart(event)\n    else this.onChange(event)\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, subV, calculateAllKinematics } from '../utils'\nimport { Coordinates, GestureState, Vector2, UseGestureEvent } from '../types'\n\n/**\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer extends Recognizer<Coordinates> {\n  getKinematics(values: Vector2, event: UseGestureEvent): Partial<GestureState<Coordinates>> {\n    // we get the gesture specific state\n    const { values: xy, initial, offset, time } = this.state\n\n    // offset is the difference between the current and initial value vectors\n    const movement = subV(values, initial)\n    // delta is the difference between the current and previous value vectors\n    const delta = subV(values, xy)\n\n    const delta_t = event.timeStamp - time!\n    const { velocity, velocities, distance, direction } = calculateAllKinematics(movement, delta, delta_t)\n\n    return {\n      event,\n      values,\n      movement,\n      offset: addV(offset, delta),\n      delta,\n      velocity,\n      vxvy: velocities,\n      distance,\n      direction,\n      previous: xy,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\n\nexport default class DragRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { dragging: true, down: true }\n  sharedEndState = { dragging: false, down: false, buttons: 0, touches: 0 }\n\n  delayedEvent = false\n\n  constructor(controller: GestureController, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getPointerEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.enabled) return\n\n    // making sure we're not dragging the element when more than one finger press the screen\n    const { touches } = getPointerEventData(event)\n    if (touches > 1) return\n\n    const { currentTarget, pointerId } = event as PointerEvent\n    if (this.controller.config.pointerEvents) {\n      // if pointers events\n      currentTarget && (currentTarget as any).setPointerCapture(pointerId)\n    } else {\n      this.removeWindowListeners()\n      const dragListeners: [string, Fn][] = [\n        ['mousemove', this.onDragChange],\n        ['touchmove', this.onDragChange],\n        ['mouseup', this.onDragEnd],\n        ['touchend', this.onDragEnd],\n        ['touchcancel', this.onDragEnd],\n      ]\n      this.addWindowListeners(dragListeners)\n    }\n\n    if (this.controller.config.dragDelay) {\n      const dragDelay = typeof this.controller.config.dragDelay === 'number' ? this.controller.config.dragDelay : DEFAULT_DRAG_DELAY\n      if (typeof event.persist === 'function') event.persist()\n      this.delayedEvent = true\n      this.setTimeout(() => this.startDrag(event), dragDelay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag = (event: UseGestureEvent): void => {\n    const { currentTarget, pointerId } = event as PointerEvent\n    this.onStart(event, { currentTarget, pointerId, cancel: () => this.onCancel(event) })\n    this.delayedEvent = false\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled, active } = this.state\n    if (canceled) return\n\n    if (!active) {\n      if (this.delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const { buttons, touches } = getPointerEventData(event)\n\n    if (buttons === 0 && touches === 0) {\n      this.onEnd(event)\n      return\n    }\n\n    this.onChange(event, { cancel: () => this.onCancel(event) })\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.clearTimeout()\n    this.delayedEvent = false\n\n    if (!this.state.active) return\n\n    const { currentTarget, pointerId } = this.state\n    if (currentTarget && this.controller.config.pointerEvents) (currentTarget as any).releasePointerCapture(pointerId)\n    this.onEnd(event)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerDown', this.onDragStart], ['onPointerMove', this.onDragChange], [['onPointerUp'], this.onDragEnd]]\n    }\n    return [[['onMouseDown', 'onTouchStart'], this.onDragStart]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getScrollEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { scrolling: true }\n  sharedEndState = { scrolling: false, velocity: 0, vxvy: [0, 0] }\n  continuousGesture = true\n\n  constructor(controller: GestureController, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getScrollEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onScroll', this.timeoutHandler]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { addV, getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { wheeling: true }\n  sharedEndState = { wheeling: false, velocity: 0, vxvy: [0, 0] }\n  continuousGesture = true\n\n  constructor(controller: GestureController, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<WheelEvent>) {\n    const { xy: prevXY } = this.state\n    const { xy, ...sharedPayload } = getWheelEventData(event)\n    const values = addV(xy, prevXY)\n\n    return { values, sharedPayload }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (event.ctrlKey && this.controller.actions.has('onPinch')) return\n    this.timeoutHandler(event)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onWheel]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { moving: true }\n  sharedEndState = { moving: false, velocity: 0, vxvy: [0, 0] }\n\n  constructor(controller: GestureController, args: any[]) {\n    super('move', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getPointerEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerMove', this.timeoutHandler]]\n    }\n    return [['onMouseMove', this.timeoutHandler]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { GestureFlag, UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class HoverRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('hover', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getPointerEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    if (!this.enabled) return\n    const { values, sharedPayload } = this.getPayloadFromEvent(event)\n    this.updateState({ hovering: true, ...sharedPayload }, { values, event, args: this.args })\n    this.fireGestureHandler(GestureFlag.OnChange)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    if (!this.enabled) return\n    const { values, sharedPayload } = this.getPayloadFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateState({ hovering: false, moving: false, ...sharedPayload }, { ...kinematics, ...genericEndState, velocity: 0, vxvy: [0, 0] })\n\n    // when the mouse leaves the element, we also fire the move handler\n    // without waiting for move to end with debounce\n    this.controller.fireGestureHandler('move', GestureFlag.OnEnd)\n    this.controller.fireGestureHandler('hover', GestureFlag.OnChange)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerEnter', this.onPointerEnter], ['onPointerLeave', this.onPointerLeave]]\n    }\n    return [['onMouseEnter', this.onPointerEnter], ['onMouseLeave', this.onPointerLeave]]\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, calculateVelocities, calculateDirection } from '../utils'\nimport { DistanceAngle, GestureState, Vector2, UseGestureEvent, GestureKey } from '../types'\nimport GestureController from '../controllers/GestureController'\n\n/**\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer extends Recognizer<DistanceAngle> {\n  constructor(gestureKey: GestureKey, controller: GestureController, args: any[] = []) {\n    super(gestureKey, controller, args)\n  }\n\n  getKinematics([d, a]: [number, number?], event: UseGestureEvent): Partial<GestureState<DistanceAngle>> {\n    const { values: da, turns, initial, offset, time } = this.state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    const delta_d = d - da[0]\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n    delta_a -= 360 * (newTurns - turns)\n    const delta = [delta_d, delta_a] as Vector2\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    const movement: Vector2 = [movement_d, movement_a]\n\n    const delta_t = event.timeStamp - time!\n    const vdva = calculateVelocities(delta, delta_t)\n    const direction = calculateDirection(delta)\n    return {\n      event,\n      values: [d, a],\n      movement,\n      delta,\n      offset: addV(offset, delta),\n      vdva,\n      direction,\n      turns: newTurns,\n      previous: da,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer {\n  sharedStartState = { pinching: true }\n  sharedEndState = { pinching: false, down: false, touches: 0 }\n\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<TouchEvent>) {\n    const { da, origin, ...sharedPayload } = getTwoTouchesEventData(event)\n    return { values: da, gesturePayload: { origin }, sharedPayload }\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2) return\n    this.onStart(event, { cancel: () => this.onCancel(event) })\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, active, time } = this.state\n    if (canceled || !active || event.touches.length !== 2 || event.timeStamp === time) return\n\n    this.onChange(event, { cancel: () => this.onCancel(event) })\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onTouchStart', this.onPinchStart], ['onTouchMove', this.onPinchChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn, Vector2 } from '../types'\n\nexport default class PinchWheelRecognizer extends DistanceAngleRecognizer {\n  sharedStartState = { pinching: true }\n  sharedEndState = { pinching: false }\n\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<WheelEvent>) {\n    const {\n      xy: [, delta_d],\n      ...sharedPayload\n    } = getWheelEventData(event)\n    const {\n      da: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n    const origin: Vector2 = [event.clientX, event.clientY]\n    return { values: [d, a] as Vector2, gesturePayload: { origin }, sharedPayload }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!event.ctrlKey) return\n\n    if (!this.controller.config.passiveEvents) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development')\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n\n    this.timeoutHandler(event)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onWheel]]\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, WebKitGestureEvent, Fn, Vector2 } from '../types'\n\nconst SCALE_FACTOR = 260\n\nexport default class PinchWebKitGestureRecognizer extends DistanceAngleRecognizer {\n  sharedStartState = { pinching: true, down: true, touches: 2 }\n  sharedEndState = { pinching: false, down: false, touches: 0 }\n  private origin?: Vector2\n\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<WebKitGestureEvent>) {\n    return { values: [event.scale * SCALE_FACTOR, event.rotation] as Vector2 }\n  }\n\n  onPinchStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n    const origin: Vector2 = this.origin ? this.origin : [event.clientX, event.clientY]\n\n    this.onStart(event, { origin, cancel: () => this.onCancel(event) })\n  }\n\n  onPinchChange = (event: WebKitGestureEvent): void => {\n    const { canceled, active } = this.state\n    if (canceled || !active) return\n    event.preventDefault()\n\n    this.onChange(event, { cancel: () => this.onCancel(event) })\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.onEnd(event)\n    event.preventDefault()\n    this.origin = undefined\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.origin = origin\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [\n      ['onGestureStart', this.onPinchStart],\n      ['onGestureChange', this.onPinchChange],\n      [['onGestureEnd', 'onTouchCancel'], this.onGestureEnd],\n      [['onTouchStart', 'onTouchMove'], this.updateTouchData],\n    ]\n  }\n}\n","import {\n  StateKey,\n  StateObject,\n  GestureState,\n  SharedGestureState,\n  GestureKey,\n  Fn,\n  ReactEventHandlerKey,\n  GestureFlag,\n  ReactEventHandlers,\n  GestureConfig,\n  GestureHandlers,\n  HandlerKey,\n  GestureHandlersPartial,\n} from '../types'\n\nimport { initialState, mappedKeys } from '../defaults'\nimport { addListeners, removeListeners, gestureEventSupported, chainFns } from '../utils'\n\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport HoverRecognizer from '../recognizers/HoverRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport PinchWheelRecognizer from '../recognizers/PinchWheelRecognizer'\nimport PinchWebKitGestureRecognizer from '../recognizers/PinchWebKitGestureRecognizer'\nimport Recognizer from 'recognizers/Recognizer'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] | Fn }>\n\n/**\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\n * and keep track of the state for all gestures\n *\n * @template BinderType the type the bind function should return\n */\nexport default class GestureController {\n  public state: StateObject = initialState // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  public actions: Set<HandlerKey>\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  constructor(public handlers: GestureHandlersPartial, public config: GestureConfig) {\n    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n    // actions will include 'onDrag' and 'onMove'\n    this.actions = new Set(Object.keys(this.handlers).map(k => <HandlerKey>k.replace(/End|Start/, '')))\n  }\n\n  /**\n   * Function run on component unmount\n   * Cleans timeouts and removes dom listeners set by the bind function\n   */\n  public clean = (): void => {\n    this.cleanOnBind()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(<StateKey>stateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render)\n   * Reset the binding object and remove dom listeners attached to config.domTarget\n   */\n  private cleanOnBind = (): void => {\n    this.bindings = {}\n    const { domTarget } = this.config\n    if (domTarget) {\n      removeListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Commodity function to let gesture recognizer update global state\n   * @param sharedState shared partial state object\n   * @param gestureState partial gesture specific state object\n   * @param stateKey the state key ('drag', 'move'...)\n   */\n  public updateState = (sharedState: Partial<SharedGestureState> | null, gestureState: Partial<GestureState>, stateKey: StateKey): void => {\n    const newGestureState = { ...this.state[stateKey], ...gestureState }\n\n    if ('da' in newGestureState) newGestureState.da = newGestureState.values\n    else if ('xy' in newGestureState) newGestureState.xy = newGestureState.values\n\n    this.state = {\n      ...this.state,\n      shared: { ...this.state.shared, ...sharedState },\n      [stateKey]: newGestureState,\n    }\n  }\n\n  // fire the gesture handler defined by the user\n  public fireGestureHandler = (gestureKey: GestureKey, gestureFlag: GestureFlag): void => {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    const { stateKey, handlerKey } = mappedKeys[gestureKey]\n    const state = { ...this.state.shared, ...this.state[stateKey] }\n    if (state.event) state.event.gesture = gestureKey\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      const handlerStart = `${handlerKey}Start` as keyof GestureHandlers\n      const handler = this.handlers[handlerStart] as any\n      handler && handler(state)\n    }\n\n    // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n    const handler = this.handlers[handlerKey] as any\n    if (handler) {\n      const newMemo = handler(state)\n      this.state[stateKey].memo = newMemo !== void 0 ? newMemo : this.state[stateKey].memo\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      const handlerEnd = `${handlerKey}End` as keyof GestureHandlers\n      const handler = this.handlers[handlerEnd] as any\n      handler && handler(state)\n    }\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window\n   * @param stateKey\n   * @param listeners\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.event)\n  }\n\n  // commodity function to let recognizers simply remove listeners from config.window\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.event)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * Adds a recognizer to this.bindings\n   * @param recognizer\n   */\n  private addRecognizer = (recognizer: Recognizer): void => {\n    recognizer.getEventBindings().map(this.addEventBindings)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  private addEventBindings = ([eventNames, fn]: [ReactEventHandlerKey | ReactEventHandlerKey[], Fn]): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n\n    eventNamesArray.forEach(eventName => {\n      this.bindings[eventName] = this.bindings[eventName] ? [...(<Fn[]>this.bindings[eventName]), fn] : [fn]\n    })\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  private addDomTargetListeners = (): void => {\n    const { domTarget } = this.config\n\n    // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(<Fn[]>fns))])\n    })\n\n    addListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with\n   */\n  private getBindings = (): ReactEventHandlers => {\n    const output: ReactEventHandlers = {}\n    const captureString = this.config.event.capture ? 'Capture' : ''\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      output[key] = chainFns(...(<Fn[]>fnsArray))\n    })\n\n    return output\n  }\n\n  public bind = (...args: any[]): Fn | ReactEventHandlers => {\n    const { domTarget } = this.config\n\n    const genuineHandlers = { ...this.handlers }\n\n    // cleaning before adding\n    this.cleanOnBind()\n\n    if (this.actions.has('onDrag')) {\n      this.addRecognizer(new DragRecognizer(this, args))\n      delete genuineHandlers.onDrag\n      delete genuineHandlers.onDragStart\n      delete genuineHandlers.onDragEnd\n    }\n    if (this.actions.has('onScroll')) {\n      this.addRecognizer(new ScrollRecognizer(this, args))\n      delete genuineHandlers.onScroll\n      delete genuineHandlers.onScrollStart\n      delete genuineHandlers.onScrollEnd\n    }\n    if (this.actions.has('onWheel')) {\n      this.addRecognizer(new WheelRecognizer(this, args))\n      delete genuineHandlers.onWheel\n      delete genuineHandlers.onWheelStart\n      delete genuineHandlers.onWheelEnd\n    }\n    if (this.actions.has('onMove')) {\n      this.addRecognizer(new MoveRecognizer(this, args))\n      delete genuineHandlers.onMove\n      delete genuineHandlers.onMoveStart\n      delete genuineHandlers.onMoveEnd\n    }\n    if (this.actions.has('onHover')) {\n      this.addRecognizer(new HoverRecognizer(this, args))\n      delete genuineHandlers.onHover\n    }\n    if (this.actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && gestureEventSupported()) {\n        this.addRecognizer(new PinchWebKitGestureRecognizer(this, args))\n      } else {\n        this.addRecognizer(new PinchRecognizer(this, args))\n        this.addRecognizer(new PinchWheelRecognizer(this, args))\n      }\n      delete genuineHandlers.onPinch\n      delete genuineHandlers.onPinchStart\n      delete genuineHandlers.onPinchEnd\n    }\n\n    // we also add event bindings for genuine handlers\n    Object.entries(genuineHandlers).map(([event, fn]) => {\n      // we're cheating when it comes to event type :(\n      this.addEventBindings([<ReactEventHandlerKey>event, <Fn>fn])\n    })\n\n    // if config.domTarget is set we add event listeners to it and return the clean function\n    if (domTarget) {\n      this.addDomTargetListeners()\n      return this.clean\n    }\n\n    // if not, we return an object that contains gesture handlers mapped to react handler event keys\n    return this.getBindings()\n  }\n}\n","import React from 'react'\nimport GestureController from './controllers/GestureController'\nimport { Handler, GestureHandlersPartial, GestureConfig, Coordinates, Fn, ReactEventHandlers, DistanceAngle, Omit } from './types'\nimport { defaultConfig } from './defaults'\n\n/** API\n * const bind = useDrag(() => { ... })\n * const bind = usePinch(() => { ... })\n * const bind = useMove(() => { ... })\n * const bind = useScroll(() => { ... })\n * const bind = useWheel(() => { ... })\n *\n * Handlers object:\n * const bind = useGesture({ onDrag: () => { ... }, onMove: () => { ... } })\n *\n * DomTarget:\n * const bind = useGesture({ onScroll: () => { ... } }, { domTarget: window })\n * React.useEffect(bind, [bind])\n */\n\ntype PartialGestureConfig = Partial<Omit<GestureConfig, 'passiveEvents'>>\ntype GetBinderTypeFromDomTarget<T extends PartialGestureConfig> = T['domTarget'] extends object ? Fn : ReactEventHandlers\n\nexport function useGesture<Config extends PartialGestureConfig>(\n  handlers: GestureHandlersPartial,\n  config?: Config\n): (...args: any[]) => GetBinderTypeFromDomTarget<Config> {\n  // the gesture controller will keep track of all gesture states\n  const gestureController = React.useRef<GestureController>()\n\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(handlers, getDerivedConfig(config))\n  }\n\n  React.useEffect(() => {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current!.config = getDerivedConfig(config)\n    gestureController.current!.handlers = handlers\n  }, [handlers, config])\n\n  // when the user component unmounts, we run our gesture controller clean function\n  React.useEffect(() => gestureController.current!.clean, [])\n\n  // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n  return gestureController.current.bind as (...args: any[]) => GetBinderTypeFromDomTarget<Config>\n}\n\n/* SHORTHAND HANDLERS */\nexport const useDrag = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onDrag: handler }, config)\nexport const useMove = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onMove: handler }, config)\nexport const useHover = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onHover: handler }, config)\nexport const useScroll = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onScroll: handler }, config)\nexport const useWheel = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onWheel: handler }, config)\nexport const usePinch = (handler: Handler<DistanceAngle>, config?: PartialGestureConfig) => useGesture({ onPinch: handler }, config)\n\nfunction getDerivedConfig(config?: Partial<GestureConfig>): GestureConfig {\n  const derivedConfig = { ...defaultConfig, ...config }\n  const { domTarget } = derivedConfig\n  const realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  derivedConfig.domTarget = realDomTarget\n\n  const passive = derivedConfig.event.passive !== void 0 ? derivedConfig.event.passive : true\n\n  // TODO make test to check if passive is correctly passed to config\n\n  // if there isn't a domtarget or if event.passive is true, then passiveEvents is true\n  derivedConfig.passiveEvents = !derivedConfig.domTarget || passive\n\n  return derivedConfig\n}\n"]},"metadata":{},"sourceType":"module"}