{"ast":null,"code":"import React, { useMemo, useEffect, useRef, useState } from 'react';\nimport { useSelector, useDispatch, batch } from 'react-redux';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { createSlice } from '@reduxjs/toolkit';\nvar DEFAULT_BLOCKS_PER_FETCH = 1;\nvar DEFAULT_CALL_GAS_REQUIRED = 1000000;\nvar DEFAULT_CHUNK_GAS_REQUIRED = 200000;\nvar CHUNK_GAS_LIMIT = 100000000;\nvar CONSERVATIVE_BLOCK_GAS_LIMIT = 10000000; // conservative, hard-coded estimate of the current block gas limit\n// Consts for hooks\n\nvar INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\nvar NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\nvar INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nvar LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction toCallKey(call) {\n  var key = call.address + \"-\" + call.callData;\n  if (call.gasRequired) {\n    if (!Number.isSafeInteger(call.gasRequired)) {\n      throw new Error(\"Invalid number: \" + call.gasRequired);\n    }\n    key += \"-\" + call.gasRequired;\n  }\n  return key;\n}\nfunction parseCallKey(callKey) {\n  var pcs = callKey.split('-');\n  if (![2, 3].includes(pcs.length)) {\n    throw new Error(\"Invalid call key: \" + callKey);\n  }\n  return _extends({\n    address: pcs[0],\n    callData: pcs[1]\n  }, pcs[2] ? {\n    gasRequired: Number.parseInt(pcs[2])\n  } : {});\n}\nfunction callsToCallKeys(calls) {\n  var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n  return (_calls$filter$map$sor = calls == null ? void 0 : (_calls$filter = calls.filter(function (c) {\n    return Boolean(c);\n  })) == null ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) == null ? void 0 : _calls$filter$map.sort()) != null ? _calls$filter$map$sor : [];\n}\nfunction callKeysToCalls(callKeys) {\n  if (!(callKeys != null && callKeys.length)) return null;\n  return callKeys.map(function (key) {\n    return parseCallKey(key);\n  });\n}\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  var valid = callResult.valid,\n    data = callResult.data,\n    blockNumber = callResult.blockNumber;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  var success = data && data.length > 2;\n  var syncing = (blockNumber != null ? blockNumber : 0) < latestBlockNumber;\n  var result = undefined;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing: syncing,\n        result: result\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing: syncing,\n    result: result,\n    error: !success\n  };\n}\nfunction isMethodArg(x) {\n  return BigNumber.isBigNumber(x) || ['string', 'number'].indexOf(typeof x) !== -1;\n}\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(function (xi) {\n    return isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg);\n  });\n}\nfunction useCallsDataSubscription(context, chainId, calls, listenerOptions) {\n  var reducerPath = context.reducerPath,\n    actions = context.actions;\n  var callResults = useSelector(function (state) {\n    return state[reducerPath].callResults;\n  });\n  var defaultListenerOptions = useSelector(function (state) {\n    return state[reducerPath].listenerOptions;\n  });\n  var dispatch = useDispatch();\n  var serializedCallKeys = useMemo(function () {\n    return JSON.stringify(callsToCallKeys(calls));\n  }, [calls]); // update listeners when there is an actual change that persists for at least 100ms\n\n  useEffect(function () {\n    var _chainId, _ref, _listenerOptions$bloc;\n    var callKeys = JSON.parse(serializedCallKeys);\n    var calls = callKeysToCalls(callKeys);\n    if (!chainId || !calls) return;\n    var blocksPerFetchFromState = (_chainId = (defaultListenerOptions != null ? defaultListenerOptions : {})[chainId]) == null ? void 0 : _chainId.blocksPerFetch;\n    var blocksPerFetchForChain = (_ref = (_listenerOptions$bloc = listenerOptions == null ? void 0 : listenerOptions.blocksPerFetch) != null ? _listenerOptions$bloc : blocksPerFetchFromState) != null ? _ref : DEFAULT_BLOCKS_PER_FETCH;\n    dispatch(actions.addMulticallListeners({\n      chainId: chainId,\n      calls: calls,\n      options: {\n        blocksPerFetch: blocksPerFetchForChain\n      }\n    }));\n    return function () {\n      dispatch(actions.removeMulticallListeners({\n        chainId: chainId,\n        calls: calls,\n        options: {\n          blocksPerFetch: blocksPerFetchForChain\n        }\n      }));\n    };\n  }, [actions, chainId, dispatch, listenerOptions, serializedCallKeys, defaultListenerOptions]); // Ensure that call results arrays remain referentially equivalent when unchanged to prevent\n  // spurious re-renders, which would otherwise occur because mapping always creates a new object.\n\n  var stableResults = useRef([]);\n  return useMemo(function () {\n    // Construct results using a for-loop to handle sparse arrays.\n    // Array.prototype.map would skip empty entries.\n    var results = [];\n    for (var i = 0; i < calls.length; ++i) {\n      var _callResults$chainId;\n      var call = calls[i];\n      if (!chainId || !call) {\n        results.push(INVALID_RESULT);\n        continue;\n      }\n      var result = (_callResults$chainId = callResults[chainId]) == null ? void 0 : _callResults$chainId[toCallKey(call)];\n      var data = result != null && result.data && result.data !== '0x' ? result.data : undefined;\n      results.push({\n        valid: true,\n        data: data,\n        blockNumber: result == null ? void 0 : result.blockNumber\n      });\n    }\n    if (!areCallResultsEqual(results, stableResults.current)) {\n      stableResults.current = results;\n    }\n    return stableResults.current;\n  }, [callResults, calls, chainId]);\n}\nfunction areCallResultsEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every(function (_, i) {\n    return a[i].valid === b[i].valid && a[i].data === b[i].data && a[i].blockNumber === b[i].blockNumber;\n  });\n} // Similar to useCallsDataSubscription above but for subscribing to\n// calls to multiple chains at once\n\nfunction useMultichainCallsDataSubscription(context, chainToCalls, listenerOptions) {\n  var reducerPath = context.reducerPath,\n    actions = context.actions;\n  var callResults = useSelector(function (state) {\n    return state[reducerPath].callResults;\n  });\n  var defaultListenerOptions = useSelector(function (state) {\n    return state[reducerPath].listenerOptions;\n  });\n  var dispatch = useDispatch();\n  var serializedCallKeys = useMemo(function () {\n    var sortedChainIds = getChainIds(chainToCalls).sort();\n    var chainCallKeysTuple = sortedChainIds.map(function (chainId) {\n      var calls = chainToCalls[chainId];\n      var callKeys = callsToCallKeys(calls); // Note, using a tuple to ensure consistent order when serialized\n\n      return [chainId, callKeys];\n    });\n    return JSON.stringify(chainCallKeysTuple);\n  }, [chainToCalls]);\n  useEffect(function () {\n    var chainCallKeysTuples = JSON.parse(serializedCallKeys);\n    if (!(chainCallKeysTuples != null && chainCallKeysTuples.length)) return;\n    batch(function () {\n      for (var _iterator = _createForOfIteratorHelperLoose(chainCallKeysTuples), _step; !(_step = _iterator()).done;) {\n        var _chainId2, _ref2, _listenerOptions$bloc2;\n        var _step$value = _step.value,\n          chainId = _step$value[0],\n          callKeys = _step$value[1];\n        var calls = callKeysToCalls(callKeys);\n        if (!(calls != null && calls.length)) continue;\n        var blocksPerFetchFromState = (_chainId2 = (defaultListenerOptions != null ? defaultListenerOptions : {})[chainId]) == null ? void 0 : _chainId2.blocksPerFetch;\n        var blocksPerFetchForChain = (_ref2 = (_listenerOptions$bloc2 = listenerOptions == null ? void 0 : listenerOptions.blocksPerFetch) != null ? _listenerOptions$bloc2 : blocksPerFetchFromState) != null ? _ref2 : DEFAULT_BLOCKS_PER_FETCH;\n        dispatch(actions.addMulticallListeners({\n          chainId: chainId,\n          calls: calls,\n          options: {\n            blocksPerFetch: blocksPerFetchForChain\n          }\n        }));\n      }\n    });\n    return function () {\n      batch(function () {\n        for (var _iterator2 = _createForOfIteratorHelperLoose(chainCallKeysTuples), _step2; !(_step2 = _iterator2()).done;) {\n          var _chainId3, _ref3, _listenerOptions$bloc3;\n          var _step2$value = _step2.value,\n            chainId = _step2$value[0],\n            callKeys = _step2$value[1];\n          var calls = callKeysToCalls(callKeys);\n          if (!(calls != null && calls.length)) continue;\n          var blocksPerFetchFromState = (_chainId3 = (defaultListenerOptions != null ? defaultListenerOptions : {})[chainId]) == null ? void 0 : _chainId3.blocksPerFetch;\n          var blocksPerFetchForChain = (_ref3 = (_listenerOptions$bloc3 = listenerOptions == null ? void 0 : listenerOptions.blocksPerFetch) != null ? _listenerOptions$bloc3 : blocksPerFetchFromState) != null ? _ref3 : DEFAULT_BLOCKS_PER_FETCH;\n          dispatch(actions.removeMulticallListeners({\n            chainId: chainId,\n            calls: calls,\n            options: {\n              blocksPerFetch: blocksPerFetchForChain\n            }\n          }));\n        }\n      });\n    };\n  }, [actions, dispatch, listenerOptions, serializedCallKeys, defaultListenerOptions]);\n  return useMemo(function () {\n    return getChainIds(chainToCalls).reduce(function (result, chainId) {\n      var calls = chainToCalls[chainId];\n      result[chainId] = calls.map(function (call) {\n        var _callResults$chainId2;\n        if (!chainId || !call) return INVALID_RESULT;\n        var result = (_callResults$chainId2 = callResults[chainId]) == null ? void 0 : _callResults$chainId2[toCallKey(call)];\n        var data = result != null && result.data && result.data !== '0x' ? result.data : undefined;\n        return {\n          valid: true,\n          data: data,\n          blockNumber: result == null ? void 0 : result.blockNumber\n        };\n      });\n      return result;\n    }, {});\n  }, [callResults, chainToCalls]);\n} // formats many calls to a single function on a single contract, with the function name and inputs specified\n\nfunction useSingleContractMultipleData(context, chainId, latestBlockNumber, contract, methodName, callInputs, options) {\n  var _ref4 = options != null ? options : {},\n    gasRequired = _ref4.gasRequired; // Create ethers function fragment\n\n  var fragment = useMemo(function () {\n    var _contract$interface;\n    return contract == null ? void 0 : (_contract$interface = contract[\"interface\"]) == null ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]); // Get encoded call data. Note can't use useCallData below b.c. this is  for a list of CallInputs\n\n  var callDatas = useMemo(function () {\n    if (!contract || !fragment) return [];\n    return callInputs.map(function (callInput) {\n      return isValidMethodArgs(callInput) ? contract[\"interface\"].encodeFunctionData(fragment, callInput) : undefined;\n    });\n  }, [callInputs, contract, fragment]); // Create call objects\n\n  var calls = useMemo(function () {\n    if (!contract) return [];\n    return callDatas.map(function (callData) {\n      if (!callData) return undefined;\n      return {\n        address: contract.address,\n        callData: callData,\n        gasRequired: gasRequired\n      };\n    });\n  }, [contract, callDatas, gasRequired]); // Subscribe to call data\n\n  var results = useCallsDataSubscription(context, chainId, calls, options);\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contract == null ? void 0 : contract[\"interface\"], fragment, latestBlockNumber);\n    });\n  }, [results, contract, fragment, latestBlockNumber]);\n}\nfunction useMultipleContractSingleData(context, chainId, latestBlockNumber, addresses, contractInterface, methodName, callInputs, options) {\n  var _ref5 = options != null ? options : {},\n    gasRequired = _ref5.gasRequired;\n  var _useCallData = useCallData(methodName, contractInterface, callInputs),\n    fragment = _useCallData.fragment,\n    callData = _useCallData.callData; // Create call objects\n\n  var calls = useMemo(function () {\n    if (!callData) return [];\n    return addresses.map(function (address) {\n      if (!address) return undefined;\n      return {\n        address: address,\n        callData: callData,\n        gasRequired: gasRequired\n      };\n    });\n  }, [addresses, callData, gasRequired]); // Subscribe to call data\n\n  var results = useCallsDataSubscription(context, chainId, calls, options);\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contractInterface, fragment, latestBlockNumber);\n    });\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\nfunction useSingleCallResult(context, chainId, latestBlockNumber, contract, methodName, inputs, options) {\n  var _useSingleContractMul;\n  var callInputs = useMemo(function () {\n    return [inputs];\n  }, [inputs]);\n  return (_useSingleContractMul = useSingleContractMultipleData(context, chainId, latestBlockNumber, contract, methodName, callInputs, options)[0]) != null ? _useSingleContractMul : INVALID_CALL_STATE;\n} // formats many calls to any number of functions on a single contract, with only the calldata specified\n\nfunction useSingleContractWithCallData(context, chainId, latestBlockNumber, contract, callDatas, options) {\n  var _ref6 = options != null ? options : {},\n    gasRequired = _ref6.gasRequired; // Create call objects\n\n  var calls = useMemo(function () {\n    if (!contract) return [];\n    return callDatas.map(function (callData) {\n      return {\n        address: contract.address,\n        callData: callData,\n        gasRequired: gasRequired\n      };\n    });\n  }, [contract, callDatas, gasRequired]); // Subscribe to call data\n\n  var results = useCallsDataSubscription(context, chainId, calls, options);\n  return useMemo(function () {\n    return results.map(function (result, i) {\n      var _contract$interface2;\n      return toCallState(result, contract == null ? void 0 : contract[\"interface\"], contract == null ? void 0 : (_contract$interface2 = contract[\"interface\"]) == null ? void 0 : _contract$interface2.getFunction(callDatas[i].substring(0, 10)), latestBlockNumber);\n    });\n  }, [results, contract, callDatas, latestBlockNumber]);\n} // Similar to useMultipleContractSingleData but instead of multiple contracts on one chain,\n// this is for querying compatible contracts on multiple chains\n\nfunction useMultiChainMultiContractSingleData(context, chainToBlockNumber, chainToAddresses, contractInterface, methodName, callInputs, options) {\n  var _ref7 = options != null ? options : {},\n    gasRequired = _ref7.gasRequired;\n  var _useCallData2 = useCallData(methodName, contractInterface, callInputs),\n    fragment = _useCallData2.fragment,\n    callData = _useCallData2.callData; // Create call objects\n\n  var chainToCalls = useMemo(function () {\n    if (!callData || !chainToAddresses) return {};\n    return getChainIds(chainToAddresses).reduce(function (result, chainId) {\n      var addresses = chainToAddresses[chainId];\n      var calls = addresses.map(function (address) {\n        if (!address) return undefined;\n        return {\n          address: address,\n          callData: callData,\n          gasRequired: gasRequired\n        };\n      });\n      result[chainId] = calls;\n      return result;\n    }, {});\n  }, [chainToAddresses, callData, gasRequired]); // Subscribe to call data\n\n  var chainIdToResults = useMultichainCallsDataSubscription(context, chainToCalls, options);\n  return useMemo(function () {\n    return getChainIds(chainIdToResults).reduce(function (combinedResults, chainId) {\n      var latestBlockNumber = chainToBlockNumber == null ? void 0 : chainToBlockNumber[chainId];\n      var results = chainIdToResults[chainId];\n      combinedResults[chainId] = results.map(function (result) {\n        return toCallState(result, contractInterface, fragment, latestBlockNumber);\n      });\n      return combinedResults;\n    }, {});\n  }, [fragment, contractInterface, chainIdToResults, chainToBlockNumber]);\n} // Similar to useSingleCallResult but instead of one contract on one chain,\n// this is for querying a contract on multiple chains\n\nfunction useMultiChainSingleContractSingleData(context, chainToBlockNumber, chainToAddress, contractInterface, methodName, callInputs, options) {\n  // This hook uses the more flexible useMultiChainMultiContractSingleData internally,\n  // but transforms the inputs and outputs for convenience\n  var chainIdToAddresses = useMemo(function () {\n    return getChainIds(chainToAddress).reduce(function (result, chainId) {\n      result[chainId] = [chainToAddress[chainId]];\n      return result;\n    }, {});\n  }, [chainToAddress]);\n  var multiContractResults = useMultiChainMultiContractSingleData(context, chainToBlockNumber, chainIdToAddresses, contractInterface, methodName, callInputs, options);\n  return useMemo(function () {\n    return getChainIds(chainToAddress).reduce(function (result, chainId) {\n      var _multiContractResults, _multiContractResults2;\n      result[chainId] = (_multiContractResults = (_multiContractResults2 = multiContractResults[chainId]) == null ? void 0 : _multiContractResults2[0]) != null ? _multiContractResults : INVALID_CALL_STATE;\n      return result;\n    }, {});\n  }, [chainToAddress, multiContractResults]);\n}\nfunction useCallData(methodName, contractInterface, callInputs) {\n  // Create ethers function fragment\n  var fragment = useMemo(function () {\n    return contractInterface == null ? void 0 : contractInterface.getFunction(methodName);\n  }, [contractInterface, methodName]); // Get encoded call data\n\n  var callData = useMemo(function () {\n    return fragment && isValidMethodArgs(callInputs) ? contractInterface == null ? void 0 : contractInterface.encodeFunctionData(fragment, callInputs) : undefined;\n  }, [callInputs, contractInterface, fragment]);\n  return {\n    fragment: fragment,\n    callData: callData\n  };\n}\nfunction getChainIds(chainIdMap) {\n  return Object.keys(chainIdMap).map(function (c) {\n    return parseInt(c, 10);\n  });\n}\nvar initialState = {\n  callResults: {}\n};\nfunction createMulticallSlice(reducerPath) {\n  return createSlice({\n    name: reducerPath,\n    initialState: initialState,\n    reducers: {\n      addMulticallListeners: function addMulticallListeners(state, action) {\n        var _listeners$chainId;\n        var _action$payload = action.payload,\n          calls = _action$payload.calls,\n          chainId = _action$payload.chainId,\n          blocksPerFetch = _action$payload.options.blocksPerFetch;\n        var listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n        listeners[chainId] = (_listeners$chainId = listeners[chainId]) != null ? _listeners$chainId : {};\n        calls.forEach(function (call) {\n          var _listeners$chainId$ca, _listeners$chainId$ca2;\n          var callKey = toCallKey(call);\n          listeners[chainId][callKey] = (_listeners$chainId$ca = listeners[chainId][callKey]) != null ? _listeners$chainId$ca : {};\n          listeners[chainId][callKey][blocksPerFetch] = ((_listeners$chainId$ca2 = listeners[chainId][callKey][blocksPerFetch]) != null ? _listeners$chainId$ca2 : 0) + 1;\n        });\n      },\n      removeMulticallListeners: function removeMulticallListeners(state, action) {\n        var _action$payload2 = action.payload,\n          calls = _action$payload2.calls,\n          chainId = _action$payload2.chainId,\n          blocksPerFetch = _action$payload2.options.blocksPerFetch;\n        var listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n        if (!listeners[chainId]) return;\n        calls.forEach(function (call) {\n          var callKey = toCallKey(call);\n          if (!listeners[chainId][callKey]) return;\n          if (!listeners[chainId][callKey][blocksPerFetch]) return;\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n            delete listeners[chainId][callKey][blocksPerFetch];\n          } else {\n            listeners[chainId][callKey][blocksPerFetch]--;\n          }\n        });\n      },\n      fetchingMulticallResults: function fetchingMulticallResults(state, action) {\n        var _state$callResults$ch;\n        var _action$payload3 = action.payload,\n          chainId = _action$payload3.chainId,\n          fetchingBlockNumber = _action$payload3.fetchingBlockNumber,\n          calls = _action$payload3.calls;\n        state.callResults[chainId] = (_state$callResults$ch = state.callResults[chainId]) != null ? _state$callResults$ch : {};\n        calls.forEach(function (call) {\n          var callKey = toCallKey(call);\n          var current = state.callResults[chainId][callKey];\n          if (!current) {\n            state.callResults[chainId][callKey] = {\n              fetchingBlockNumber: fetchingBlockNumber\n            };\n          } else {\n            var _current$fetchingBloc;\n            if (((_current$fetchingBloc = current.fetchingBlockNumber) != null ? _current$fetchingBloc : 0) >= fetchingBlockNumber) return;\n            state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;\n          }\n        });\n      },\n      errorFetchingMulticallResults: function errorFetchingMulticallResults(state, action) {\n        var _state$callResults$ch2;\n        var _action$payload4 = action.payload,\n          chainId = _action$payload4.chainId,\n          fetchingBlockNumber = _action$payload4.fetchingBlockNumber,\n          calls = _action$payload4.calls;\n        state.callResults[chainId] = (_state$callResults$ch2 = state.callResults[chainId]) != null ? _state$callResults$ch2 : {};\n        calls.forEach(function (call) {\n          var callKey = toCallKey(call);\n          var current = state.callResults[chainId][callKey];\n          if (!current || typeof current.fetchingBlockNumber !== 'number') return; // only should be dispatched if we are already fetching\n\n          if (current.fetchingBlockNumber <= fetchingBlockNumber) {\n            delete current.fetchingBlockNumber;\n            current.data = null;\n            current.blockNumber = fetchingBlockNumber;\n          }\n        });\n      },\n      updateMulticallResults: function updateMulticallResults(state, action) {\n        var _state$callResults$ch3;\n        var _action$payload5 = action.payload,\n          chainId = _action$payload5.chainId,\n          results = _action$payload5.results,\n          blockNumber = _action$payload5.blockNumber;\n        state.callResults[chainId] = (_state$callResults$ch3 = state.callResults[chainId]) != null ? _state$callResults$ch3 : {};\n        Object.keys(results).forEach(function (callKey) {\n          var _current$blockNumber;\n          var current = state.callResults[chainId][callKey];\n          if (((_current$blockNumber = current == null ? void 0 : current.blockNumber) != null ? _current$blockNumber : 0) > blockNumber) return;\n          if ((current == null ? void 0 : current.data) === results[callKey] && (current == null ? void 0 : current.blockNumber) === blockNumber) return;\n          state.callResults[chainId][callKey] = {\n            data: results[callKey],\n            blockNumber: blockNumber\n          };\n        });\n      },\n      updateListenerOptions: function updateListenerOptions(state, action) {\n        var _state$listenerOption;\n        var _action$payload6 = action.payload,\n          chainId = _action$payload6.chainId,\n          listenerOptions = _action$payload6.listenerOptions;\n        state.listenerOptions = (_state$listenerOption = state.listenerOptions) != null ? _state$listenerOption : {};\n        state.listenerOptions[chainId] = listenerOptions;\n      }\n    }\n  });\n}\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function define(obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []);\n\n      // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n    exports.wrap = wrap;\n\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function () {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction ||\n      // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    };\n\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n      var previousPromise;\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,\n        // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n\n      // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n      this._invoke = enqueue;\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          }\n\n          // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n          return doneResult();\n        }\n        context.method = method;\n        context.arg = arg;\n        while (true) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted;\n            // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    }\n\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n        return ContinueSentinel;\n      }\n      var record = tryCatch(method, delegate.iterator, context.arg);\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      var info = record.arg;\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value;\n\n        // Resume execution at the desired location (see delegateYield).\n        context.next = delegate.nextLoc;\n\n        // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      }\n\n      // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    define(Gp, iteratorSymbol, function () {\n      return this;\n    });\n    define(Gp, \"toString\", function () {\n      return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n      this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n    exports.keys = function (object) {\n      var keys = [];\n      for (var key in object) {\n        keys.push(key);\n      }\n      keys.reverse();\n\n      // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        }\n\n        // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n        next.done = true;\n        return next;\n      };\n    };\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n            next = function next() {\n              while (++i < iterable.length) {\n                if (hasOwn.call(iterable, i)) {\n                  next.value = iterable[i];\n                  next.done = false;\n                  return next;\n                }\n              }\n              next.value = undefined$1;\n              next.done = true;\n              return next;\n            };\n          return next.next = next;\n        }\n      }\n\n      // Return an iterator with no values.\n      return {\n        next: doneResult\n      };\n    }\n    exports.values = values;\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n    Context.prototype = {\n      constructor: Context,\n      reset: function reset(skipTempReset) {\n        this.prev = 0;\n        this.next = 0;\n        // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function stop() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n        return this.rval;\n      },\n      dispatchException: function dispatchException(exception) {\n        if (this.done) {\n          throw exception;\n        }\n        var context = this;\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n          return !!caught;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function abrupt(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n        return this.complete(record);\n      },\n      complete: function complete(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n        return ContinueSentinel;\n      },\n      finish: function finish(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function _catch(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n            return thrown;\n          }\n        }\n\n        // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n        return ContinueSentinel;\n      }\n    };\n\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n  }(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n    }\n  }\n});\n\n/**\r\n * Tries to pack a list of items into as few bins as possible using the first-fit bin packing algorithm\r\n * @param calls the calls to chunk\r\n * @param chunkGasLimit the gas limit of any one chunk of calls, i.e. bin capacity\r\n * @param defaultGasRequired the default amount of gas an individual call should cost if not specified\r\n */\n\nfunction chunkCalls(calls, chunkGasLimit, defaultGasRequired) {\n  if (defaultGasRequired === void 0) {\n    defaultGasRequired = DEFAULT_CHUNK_GAS_REQUIRED;\n  }\n  return calls // first sort by gas required\n  .sort(function (c1, c2) {\n    var _c2$gasRequired, _c1$gasRequired;\n    return ((_c2$gasRequired = c2.gasRequired) != null ? _c2$gasRequired : defaultGasRequired) - ((_c1$gasRequired = c1.gasRequired) != null ? _c1$gasRequired : defaultGasRequired);\n  }) // then bin the calls according to the first fit algorithm\n  .reduce(function (bins, call) {\n    var _call$gasRequired;\n    var gas = (_call$gasRequired = call.gasRequired) != null ? _call$gasRequired : defaultGasRequired;\n    for (var _iterator = _createForOfIteratorHelperLoose(bins), _step; !(_step = _iterator()).done;) {\n      var bin = _step.value;\n      if (bin.cumulativeGasLimit + gas <= chunkGasLimit) {\n        bin.calls.push(call);\n        bin.cumulativeGasLimit += gas;\n        return bins;\n      }\n    } // didn't find a bin for the call, make a new bin\n\n    bins.push({\n      calls: [call],\n      cumulativeGasLimit: gas\n    });\n    return bins;\n  }, []) // pull out just the calls from each bin\n  .map(function (b) {\n    return b.calls;\n  });\n}\n\n// TODO de-duplicate this file with web interface\n// https://github.com/Uniswap/interface/blob/main/src/utils/retry.ts\nfunction wait(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nfunction waitRandom(min, max) {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)));\n}\n/**\r\n * This error is thrown if the function is cancelled before completing\r\n */\n\nvar CancelledError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(CancelledError, _Error);\n  function CancelledError() {\n    var _this;\n    _this = _Error.call(this, 'Cancelled') || this;\n    _this.isCancelledError = true;\n    return _this;\n  }\n  return CancelledError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Throw this error if the function should retry\r\n */\n\nvar RetryableError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(RetryableError, _Error2);\n  function RetryableError() {\n    var _this2;\n    _this2 = _Error2.apply(this, arguments) || this;\n    _this2.isRetryableError = true;\n    return _this2;\n  }\n  return RetryableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\r\n * @param fn function to retry\r\n * @param n how many times to retry\r\n * @param minWait min wait between retries in ms\r\n * @param maxWait max wait between retries in ms\r\n */\n\nfunction retry(fn, _ref) {\n  var n = _ref.n,\n    minWait = _ref.minWait,\n    maxWait = _ref.maxWait;\n  var completed = false;\n  var rejectCancelled;\n  var promise = new Promise( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(resolve, reject) {\n      var result;\n      return runtime_1.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              rejectCancelled = reject;\n            case 1:\n              result = void 0;\n              _context.prev = 3;\n              _context.next = 6;\n              return fn();\n            case 6:\n              result = _context.sent;\n              if (!completed) {\n                resolve(result);\n                completed = true;\n              }\n              return _context.abrupt(\"break\", 24);\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](3);\n              if (!completed) {\n                _context.next = 15;\n                break;\n              }\n              return _context.abrupt(\"break\", 24);\n            case 15:\n              if (!(n <= 0 || !_context.t0.isRetryableError)) {\n                _context.next = 19;\n                break;\n              }\n              reject(_context.t0);\n              completed = true;\n              return _context.abrupt(\"break\", 24);\n            case 19:\n              n--;\n            case 20:\n              _context.next = 22;\n              return waitRandom(minWait, maxWait);\n            case 22:\n              _context.next = 1;\n              break;\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[3, 11]]);\n    }));\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n  return {\n    promise: promise,\n    cancel: function cancel() {\n      if (completed) return;\n      completed = true;\n      rejectCancelled(new CancelledError());\n    }\n  };\n}\n\n// TODO de-duplicate this file with web interface\n\nfunction useDebounce(value, delay) {\n  var _useState = useState(value),\n    debouncedValue = _useState[0],\n    setDebouncedValue = _useState[1];\n  useEffect(function () {\n    // Update debounced value after delay\n    var handler = setTimeout(function () {\n      setDebouncedValue(value);\n    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n\n    return function () {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\nvar FETCH_RETRY_CONFIG = {\n  n: Infinity,\n  minWait: 1000,\n  maxWait: 2500\n};\n/**\r\n * Fetches a chunk of calls, enforcing a minimum block number constraint\r\n * @param multicall multicall contract to fetch against\r\n * @param chunk chunk of calls to make\r\n * @param blockNumber block number passed as the block tag in the eth_call\r\n */\n\nfunction fetchChunk(_x, _x2, _x3, _x4) {\n  return _fetchChunk.apply(this, arguments);\n}\n/**\r\n * From the current all listeners state, return each call key mapped to the\r\n * minimum number of blocks per fetch. This is how often each key must be fetched.\r\n * @param allListeners the all listeners state\r\n * @param chainId the current chain id\r\n */\n\nfunction _fetchChunk() {\n  _fetchChunk = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(multicall, chunk, blockNumber, isDebug) {\n    var _yield$multicall$call, returnData, _error$message, _error$message2, error, half, _yield$Promise$all, c0, c1;\n    return runtime_1.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.debug('Fetching chunk', chunk, blockNumber);\n            _context.prev = 1;\n            _context.next = 4;\n            return multicall.callStatic.multicall(chunk.map(function (obj) {\n              var _obj$gasRequired;\n              return {\n                target: obj.address,\n                callData: obj.callData,\n                gasLimit: (_obj$gasRequired = obj.gasRequired) != null ? _obj$gasRequired : DEFAULT_CALL_GAS_REQUIRED\n              };\n            }),\n            // we aren't passing through the block gas limit we used to create the chunk, because it causes a problem with the integ tests\n            {\n              blockTag: blockNumber\n            });\n          case 4:\n            _yield$multicall$call = _context.sent;\n            returnData = _yield$multicall$call.returnData;\n            if (isDebug) {\n              returnData.forEach(function (_ref, i) {\n                var _chunk$i$gasRequired;\n                var gasUsed = _ref.gasUsed,\n                  returnData = _ref.returnData,\n                  success = _ref.success;\n                if (!success && returnData.length === 2 && gasUsed.gte(Math.floor(((_chunk$i$gasRequired = chunk[i].gasRequired) != null ? _chunk$i$gasRequired : DEFAULT_CALL_GAS_REQUIRED) * 0.95))) {\n                  var _chunk$i$gasRequired2;\n                  console.warn(\"A call failed due to requiring \" + gasUsed.toString() + \" vs. allowed \" + ((_chunk$i$gasRequired2 = chunk[i].gasRequired) != null ? _chunk$i$gasRequired2 : DEFAULT_CALL_GAS_REQUIRED), chunk[i]);\n                }\n              });\n            }\n            return _context.abrupt(\"return\", returnData);\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](1);\n            error = _context.t0;\n            if (!(error.code === -32000 || ((_error$message = error.message) == null ? void 0 : _error$message.indexOf('header not found')) !== -1)) {\n              _context.next = 17;\n              break;\n            }\n            throw new RetryableError(\"header not found for block number \" + blockNumber);\n          case 17:\n            if (!(error.code === -32603 || ((_error$message2 = error.message) == null ? void 0 : _error$message2.indexOf('execution ran out of gas')) !== -1)) {\n              _context.next = 27;\n              break;\n            }\n            if (!(chunk.length > 1)) {\n              _context.next = 27;\n              break;\n            }\n            if (process.env.NODE_ENV === 'development') {\n              console.debug('Splitting a chunk in 2', chunk);\n            }\n            half = Math.floor(chunk.length / 2);\n            _context.next = 23;\n            return Promise.all([fetchChunk(multicall, chunk.slice(0, half), blockNumber), fetchChunk(multicall, chunk.slice(half, chunk.length), blockNumber)]);\n          case 23:\n            _yield$Promise$all = _context.sent;\n            c0 = _yield$Promise$all[0];\n            c1 = _yield$Promise$all[1];\n            return _context.abrupt(\"return\", c0.concat(c1));\n          case 27:\n            console.error('Failed to fetch chunk', error);\n            throw error;\n          case 29:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 10]]);\n  }));\n  return _fetchChunk.apply(this, arguments);\n}\nfunction activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  var listeners = allListeners[chainId];\n  if (!listeners) return {};\n  return Object.keys(listeners).reduce(function (memo, callKey) {\n    var keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(function (key) {\n      var blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce(function (previousMin, current) {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n/**\r\n * Return the keys that need to be refetched\r\n * @param callResults current call result state\r\n * @param listeningKeys each call key mapped to how old the data can be in blocks\r\n * @param chainId the current chain id\r\n * @param latestBlockNumber the latest block number\r\n */\n\nfunction outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  var results = callResults[chainId]; // no results at all, load everything\n\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(function (callKey) {\n    var blocksPerFetch = listeningKeys[callKey];\n    var data = callResults[chainId][callKey]; // no data, must fetch\n\n    if (!data) return true;\n    var minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1); // already fetching it for a recent enough block, don't refetch it\n\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false; // if data is older than minDataBlockNumber, fetch it\n\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\nfunction onFetchChunkSuccess(context, chunk, result) {\n  var actions = context.actions,\n    dispatch = context.dispatch,\n    chainId = context.chainId,\n    latestBlockNumber = context.latestBlockNumber,\n    isDebug = context.isDebug; // split the returned slice into errors and results\n\n  var _chunk$reduce = chunk.reduce(function (memo, call, i) {\n      if (result[i].success) {\n        var _result$i$returnData;\n        memo.results[toCallKey(call)] = (_result$i$returnData = result[i].returnData) != null ? _result$i$returnData : null;\n      } else {\n        memo.erroredCalls.push(call);\n      }\n      return memo;\n    }, {\n      erroredCalls: [],\n      results: {}\n    }),\n    erroredCalls = _chunk$reduce.erroredCalls,\n    results = _chunk$reduce.results; // dispatch any new results\n\n  if (Object.keys(results).length > 0) dispatch(actions.updateMulticallResults({\n    chainId: chainId,\n    results: results,\n    blockNumber: latestBlockNumber\n  })); // dispatch any errored calls\n\n  if (erroredCalls.length > 0) {\n    if (isDebug) {\n      result.forEach(function (returnData, ix) {\n        if (!returnData.success) {\n          console.debug('Call failed', chunk[ix], returnData);\n        }\n      });\n    } else {\n      console.debug('Calls errored in fetch', erroredCalls);\n    }\n    dispatch(actions.errorFetchingMulticallResults({\n      calls: erroredCalls,\n      chainId: chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n  }\n}\nfunction onFetchChunkFailure(context, chunk, error) {\n  var actions = context.actions,\n    dispatch = context.dispatch,\n    chainId = context.chainId,\n    latestBlockNumber = context.latestBlockNumber;\n  if (error.isCancelledError) {\n    console.debug('Cancelled fetch for blockNumber', latestBlockNumber, chunk, chainId);\n    return;\n  }\n  console.error('Failed to fetch multicall chunk', chunk, chainId, error);\n  dispatch(actions.errorFetchingMulticallResults({\n    calls: chunk,\n    chainId: chainId,\n    fetchingBlockNumber: latestBlockNumber\n  }));\n}\nfunction Updater(props) {\n  var context = props.context,\n    chainId = props.chainId,\n    latestBlockNumber = props.latestBlockNumber,\n    contract = props.contract,\n    isDebug = props.isDebug,\n    listenerOptions = props.listenerOptions;\n  var actions = context.actions,\n    reducerPath = context.reducerPath;\n  var dispatch = useDispatch(); // set user configured listenerOptions in state for given chain ID.\n\n  useEffect(function () {\n    if (chainId && listenerOptions) {\n      dispatch(actions.updateListenerOptions({\n        chainId: chainId,\n        listenerOptions: listenerOptions\n      }));\n    }\n  }, [chainId, listenerOptions, actions, dispatch]);\n  var state = useSelector(function (state) {\n    return state[reducerPath];\n  }); // wait for listeners to settle before triggering updates\n\n  var debouncedListeners = useDebounce(state.callListeners, 100);\n  var cancellations = useRef();\n  var listeningKeys = useMemo(function () {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n  var serializedOutdatedCallKeys = useMemo(function () {\n    var outdatedCallKeys = outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);\n    return JSON.stringify(outdatedCallKeys.sort());\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n  useEffect(function () {\n    if (!latestBlockNumber || !chainId || !contract) return;\n    var outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    var calls = outdatedCallKeys.map(function (key) {\n      return parseCallKey(key);\n    });\n    var chunkedCalls = chunkCalls(calls, CHUNK_GAS_LIMIT);\n    if (cancellations.current && cancellations.current.blockNumber !== latestBlockNumber) {\n      cancellations.current.cancellations.forEach(function (c) {\n        return c();\n      });\n    }\n    dispatch(actions.fetchingMulticallResults({\n      calls: calls,\n      chainId: chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    var fetchChunkContext = {\n      actions: actions,\n      dispatch: dispatch,\n      chainId: chainId,\n      latestBlockNumber: latestBlockNumber,\n      isDebug: isDebug\n    }; // Execute fetches and gather cancellation callbacks\n\n    var newCancellations = chunkedCalls.map(function (chunk) {\n      var _retry = retry(function () {\n          return fetchChunk(contract, chunk, latestBlockNumber, isDebug);\n        }, FETCH_RETRY_CONFIG),\n        cancel = _retry.cancel,\n        promise = _retry.promise;\n      promise.then(function (result) {\n        return onFetchChunkSuccess(fetchChunkContext, chunk, result);\n      })[\"catch\"](function (error) {\n        return onFetchChunkFailure(fetchChunkContext, chunk, error);\n      });\n      return cancel;\n    });\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: newCancellations\n    };\n  }, [actions, chainId, contract, dispatch, serializedOutdatedCallKeys, latestBlockNumber, isDebug]);\n  return null;\n}\nfunction createUpdater(context) {\n  var UpdaterContextBound = function UpdaterContextBound(props) {\n    return React.createElement(Updater, Object.assign({\n      context: context\n    }, props));\n  };\n  return UpdaterContextBound;\n}\nfunction createMulticall(options) {\n  var _options$reducerPath;\n  var reducerPath = (_options$reducerPath = options == null ? void 0 : options.reducerPath) != null ? _options$reducerPath : 'multicall';\n  var slice = createMulticallSlice(reducerPath);\n  var actions = slice.actions,\n    reducer = slice.reducer;\n  var context = {\n    reducerPath: reducerPath,\n    actions: actions\n  };\n  var useMultipleContractSingleData$1 = function useMultipleContractSingleData$1() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return useMultipleContractSingleData.apply(void 0, [context].concat(args));\n  };\n  var useSingleContractMultipleData$1 = function useSingleContractMultipleData$1() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return useSingleContractMultipleData.apply(void 0, [context].concat(args));\n  };\n  var useSingleContractWithCallData$1 = function useSingleContractWithCallData$1() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return useSingleContractWithCallData.apply(void 0, [context].concat(args));\n  };\n  var useSingleCallResult$1 = function useSingleCallResult$1() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return useSingleCallResult.apply(void 0, [context].concat(args));\n  };\n  var useMultiChainMultiContractSingleData$1 = function useMultiChainMultiContractSingleData$1() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    return useMultiChainMultiContractSingleData.apply(void 0, [context].concat(args));\n  };\n  var useMultiChainSingleContractSingleData$1 = function useMultiChainSingleContractSingleData$1() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return useMultiChainSingleContractSingleData.apply(void 0, [context].concat(args));\n  };\n  var hooks = {\n    useMultipleContractSingleData: useMultipleContractSingleData$1,\n    useSingleContractMultipleData: useSingleContractMultipleData$1,\n    useSingleContractWithCallData: useSingleContractWithCallData$1,\n    useSingleCallResult: useSingleCallResult$1,\n    useMultiChainMultiContractSingleData: useMultiChainMultiContractSingleData$1,\n    useMultiChainSingleContractSingleData: useMultiChainSingleContractSingleData$1\n  };\n  var Updater = createUpdater(context);\n  return {\n    reducerPath: reducerPath,\n    reducer: reducer,\n    actions: actions,\n    hooks: hooks,\n    Updater: Updater\n  };\n}\nexport { CHUNK_GAS_LIMIT, CONSERVATIVE_BLOCK_GAS_LIMIT, DEFAULT_BLOCKS_PER_FETCH, DEFAULT_CALL_GAS_REQUIRED, DEFAULT_CHUNK_GAS_REQUIRED, INVALID_CALL_STATE, INVALID_RESULT, LOADING_CALL_STATE, NEVER_RELOAD, createMulticall };","map":{"version":3,"sources":["../src/constants.ts","../src/utils/callKeys.ts","../src/utils/callState.ts","../src/validation.ts","../src/hooks.ts","../src/slice.ts","../node_modules/regenerator-runtime/runtime.js","../src/utils/chunkCalls.ts","../src/utils/retry.ts","../src/utils/useDebounce.ts","../src/updater.tsx","../src/create.ts"],"names":["DEFAULT_BLOCKS_PER_FETCH","DEFAULT_CALL_GAS_REQUIRED","DEFAULT_CHUNK_GAS_REQUIRED","CHUNK_GAS_LIMIT","CONSERVATIVE_BLOCK_GAS_LIMIT","INVALID_RESULT","valid","blockNumber","undefined","data","NEVER_RELOAD","blocksPerFetch","Infinity","INVALID_CALL_STATE","result","loading","syncing","error","LOADING_CALL_STATE","toCallKey","call","key","address","callData","gasRequired","Number","isSafeInteger","Error","parseCallKey","callKey","pcs","split","includes","length","parseInt","callsToCallKeys","calls","filter","c","Boolean","map","sort","callKeysToCalls","callKeys","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","isMethodArg","x","BigNumber","isBigNumber","indexOf","isValidMethodArgs","Array","isArray","every","xi","useCallsDataSubscription","context","chainId","listenerOptions","reducerPath","actions","callResults","useSelector","state","defaultListenerOptions","dispatch","useDispatch","serializedCallKeys","useMemo","JSON","stringify","useEffect","parse","blocksPerFetchFromState","blocksPerFetchForChain","addMulticallListeners","options","removeMulticallListeners","stableResults","useRef","results","i","push","areCallResultsEqual","current","a","b","_","useMultichainCallsDataSubscription","chainToCalls","sortedChainIds","getChainIds","chainCallKeysTuple","chainCallKeysTuples","batch","reduce","useSingleContractMultipleData","contract","methodName","callInputs","getFunction","callDatas","callInput","encodeFunctionData","useMultipleContractSingleData","addresses","useCallData","useSingleCallResult","inputs","useSingleContractWithCallData","substring","useMultiChainMultiContractSingleData","chainToBlockNumber","chainToAddresses","chainIdToResults","combinedResults","useMultiChainSingleContractSingleData","chainToAddress","chainIdToAddresses","multiContractResults","chainIdMap","keys","initialState","createMulticallSlice","createSlice","name","reducers","action","payload","listeners","callListeners","forEach","fetchingMulticallResults","fetchingBlockNumber","errorFetchingMulticallResults","updateMulticallResults","Object","updateListenerOptions","chunkCalls","chunkGasLimit","defaultGasRequired","c1","c2","bins","gas","bin","cumulativeGasLimit","wait","ms","Promise","resolve","setTimeout","waitRandom","min","max","Math","round","random","CancelledError","RetryableError","retry","fn","n","minWait","maxWait","completed","rejectCancelled","promise","reject","isRetryableError","cancel","useDebounce","value","delay","debouncedValue","setDebouncedValue","useState","handler","clearTimeout","FETCH_RETRY_CONFIG","fetchChunk","multicall","chunk","isDebug","returnData","callStatic","obj","target","gasLimit","blockTag","gasUsed","gte","floor","warn","toString","code","message","process","env","NODE_ENV","half","c0","all","slice","concat","activeListeningKeys","allListeners","memo","keyListeners","previousMin","outdatedListeningKeys","listeningKeys","minDataBlockNumber","onFetchChunkSuccess","erroredCalls","ix","onFetchChunkFailure","isCancelledError","Updater","props","debouncedListeners","cancellations","serializedOutdatedCallKeys","outdatedCallKeys","chunkedCalls","fetchChunkContext","newCancellations","then","createUpdater","UpdaterContextBound","React","createMulticall","reducer","args","_useMultipleContractSingleData","_useSingleContractMultipleData","_useSingleContractWithCallData","_useSingleCallResult","_useMultiChainMultiContractSingleData","_useMultiChainSingleContractSingleData","hooks"],"mappings":"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","sourcesContent":["import type { CallResult, CallState, ListenerOptions } from './types'\n\nexport const DEFAULT_BLOCKS_PER_FETCH = 1\nexport const DEFAULT_CALL_GAS_REQUIRED = 1_000_000\nexport const DEFAULT_CHUNK_GAS_REQUIRED = 200_000\nexport const CHUNK_GAS_LIMIT = 100_000_000\nexport const CONSERVATIVE_BLOCK_GAS_LIMIT = 10_000_000 // conservative, hard-coded estimate of the current block gas limit\n\n// Consts for hooks\nexport const INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n}\n\nexport const INVALID_CALL_STATE: CallState = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false,\n}\nexport const LOADING_CALL_STATE: CallState = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false,\n}\n","import { Call } from '../types'\n\nexport function toCallKey(call: Call): string {\n  let key = `${call.address}-${call.callData}`\n  if (call.gasRequired) {\n    if (!Number.isSafeInteger(call.gasRequired)) {\n      throw new Error(`Invalid number: ${call.gasRequired}`)\n    }\n    key += `-${call.gasRequired}`\n  }\n  return key\n}\n\nexport function parseCallKey(callKey: string): Call {\n  const pcs = callKey.split('-')\n  if (![2, 3].includes(pcs.length)) {\n    throw new Error(`Invalid call key: ${callKey}`)\n  }\n  return {\n    address: pcs[0],\n    callData: pcs[1],\n    ...(pcs[2] ? { gasRequired: Number.parseInt(pcs[2]) } : {}),\n  }\n}\n\nexport function callsToCallKeys(calls?: Array<Call | undefined>) {\n  return (\n    calls\n      ?.filter((c): c is Call => Boolean(c))\n      ?.map(toCallKey)\n      ?.sort() ?? []\n  )\n}\n\nexport function callKeysToCalls(callKeys: string[]) {\n  if (!callKeys?.length) return null\n  return callKeys.map((key) => parseCallKey(key))\n}\n","import type { FunctionFragment, Interface } from '@ethersproject/abi'\nimport { INVALID_CALL_STATE, LOADING_CALL_STATE } from '../constants'\nimport type { CallResult, CallState, CallStateResult } from '../types'\n\nexport function toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: CallStateResult | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result,\n    error: !success,\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\n\nexport type MethodArg = string | number | BigNumber\nexport type MethodArgs = Array<MethodArg | MethodArg[]>\n\nexport function isMethodArg(x: unknown): x is MethodArg {\n  return BigNumber.isBigNumber(x) || ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nexport function isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { Interface } from '@ethersproject/abi'\nimport { useEffect, useMemo, useRef } from 'react'\nimport { batch, useDispatch, useSelector } from 'react-redux'\nimport { INVALID_CALL_STATE, INVALID_RESULT, DEFAULT_BLOCKS_PER_FETCH } from './constants'\nimport type { MulticallContext } from './context'\nimport type { Call, CallResult, CallState, ListenerOptions, ListenerOptionsWithGas, WithMulticallState } from './types'\nimport { callKeysToCalls, callsToCallKeys, toCallKey } from './utils/callKeys'\nimport { toCallState } from './utils/callState'\nimport { isValidMethodArgs, MethodArg } from './validation'\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\n// the lowest level call for subscribing to contract data\nexport function useCallsDataSubscription(\n  context: MulticallContext,\n  chainId: number | undefined,\n  calls: Array<Call | undefined>,\n  listenerOptions?: ListenerOptions\n): CallResult[] {\n  const { reducerPath, actions } = context\n  const callResults = useSelector((state: WithMulticallState) => state[reducerPath].callResults)\n  const defaultListenerOptions = useSelector((state: WithMulticallState) => state[reducerPath].listenerOptions)\n  const dispatch = useDispatch()\n  const serializedCallKeys: string = useMemo(() => JSON.stringify(callsToCallKeys(calls)), [calls])\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    const calls = callKeysToCalls(callKeys)\n    if (!chainId || !calls) return\n    const blocksPerFetchFromState = (defaultListenerOptions ?? {})[chainId]?.blocksPerFetch\n    const blocksPerFetchForChain =\n      listenerOptions?.blocksPerFetch ?? blocksPerFetchFromState ?? DEFAULT_BLOCKS_PER_FETCH\n\n    dispatch(\n      actions.addMulticallListeners({\n        chainId,\n        calls,\n        options: { blocksPerFetch: blocksPerFetchForChain },\n      })\n    )\n\n    return () => {\n      dispatch(\n        actions.removeMulticallListeners({\n          chainId,\n          calls,\n          options: { blocksPerFetch: blocksPerFetchForChain },\n        })\n      )\n    }\n  }, [actions, chainId, dispatch, listenerOptions, serializedCallKeys, defaultListenerOptions])\n\n  // Ensure that call results arrays remain referentially equivalent when unchanged to prevent\n  // spurious re-renders, which would otherwise occur because mapping always creates a new object.\n  const stableResults = useRef<CallResult[]>([])\n  return useMemo(() => {\n    // Construct results using a for-loop to handle sparse arrays.\n    // Array.prototype.map would skip empty entries.\n    let results: CallResult[] = []\n    for (let i = 0; i < calls.length; ++i) {\n      const call = calls[i]\n      if (!chainId || !call) {\n        results.push(INVALID_RESULT)\n        continue\n      }\n      const result = callResults[chainId]?.[toCallKey(call)]\n      const data = result?.data && result.data !== '0x' ? result.data : undefined\n      results.push({ valid: true, data, blockNumber: result?.blockNumber })\n    }\n\n    if (!areCallResultsEqual(results, stableResults.current)) {\n      stableResults.current = results\n    }\n    return stableResults.current\n  }, [callResults, calls, chainId])\n}\n\nfunction areCallResultsEqual(a: CallResult[], b: CallResult[]) {\n  if (a.length !== b.length) return false\n  return a.every(\n    (_, i) => a[i].valid === b[i].valid && a[i].data === b[i].data && a[i].blockNumber === b[i].blockNumber\n  )\n}\n\n// Similar to useCallsDataSubscription above but for subscribing to\n// calls to multiple chains at once\nfunction useMultichainCallsDataSubscription(\n  context: MulticallContext,\n  chainToCalls: Record<number, Array<Call | undefined>>,\n  listenerOptions?: ListenerOptions\n): Record<number, CallResult[]> {\n  const { reducerPath, actions } = context\n  const callResults = useSelector((state: WithMulticallState) => state[reducerPath].callResults)\n  const defaultListenerOptions = useSelector((state: WithMulticallState) => state[reducerPath].listenerOptions)\n  const dispatch = useDispatch()\n\n  const serializedCallKeys: string = useMemo(() => {\n    const sortedChainIds = getChainIds(chainToCalls).sort()\n    const chainCallKeysTuple = sortedChainIds.map((chainId) => {\n      const calls = chainToCalls[chainId]\n      const callKeys = callsToCallKeys(calls)\n      // Note, using a tuple to ensure consistent order when serialized\n      return [chainId, callKeys]\n    })\n    return JSON.stringify(chainCallKeysTuple)\n  }, [chainToCalls])\n\n  useEffect(() => {\n    const chainCallKeysTuples: Array<[number, string[]]> = JSON.parse(serializedCallKeys)\n    if (!chainCallKeysTuples?.length) return\n\n    batch(() => {\n      for (const [chainId, callKeys] of chainCallKeysTuples) {\n        const calls = callKeysToCalls(callKeys)\n        if (!calls?.length) continue\n        const blocksPerFetchFromState = (defaultListenerOptions ?? {})[chainId]?.blocksPerFetch\n        const blocksPerFetchForChain =\n          listenerOptions?.blocksPerFetch ?? blocksPerFetchFromState ?? DEFAULT_BLOCKS_PER_FETCH\n\n        dispatch(\n          actions.addMulticallListeners({\n            chainId,\n            calls,\n            options: { blocksPerFetch: blocksPerFetchForChain },\n          })\n        )\n      }\n    })\n\n    return () => {\n      batch(() => {\n        for (const [chainId, callKeys] of chainCallKeysTuples) {\n          const calls = callKeysToCalls(callKeys)\n          if (!calls?.length) continue\n          const blocksPerFetchFromState = (defaultListenerOptions ?? {})[chainId]?.blocksPerFetch\n          const blocksPerFetchForChain =\n            listenerOptions?.blocksPerFetch ?? blocksPerFetchFromState ?? DEFAULT_BLOCKS_PER_FETCH\n          dispatch(\n            actions.removeMulticallListeners({\n              chainId,\n              calls,\n              options: { blocksPerFetch: blocksPerFetchForChain },\n            })\n          )\n        }\n      })\n    }\n  }, [actions, dispatch, listenerOptions, serializedCallKeys, defaultListenerOptions])\n\n  return useMemo(\n    () =>\n      getChainIds(chainToCalls).reduce((result, chainId) => {\n        const calls = chainToCalls[chainId]\n        result[chainId] = calls.map<CallResult>((call) => {\n          if (!chainId || !call) return INVALID_RESULT\n          const result = callResults[chainId]?.[toCallKey(call)]\n          const data = result?.data && result.data !== '0x' ? result.data : undefined\n          return { valid: true, data, blockNumber: result?.blockNumber }\n        })\n        return result\n      }, {} as Record<number, CallResult[]>),\n    [callResults, chainToCalls]\n  )\n}\n\n// formats many calls to a single function on a single contract, with the function name and inputs specified\nexport function useSingleContractMultipleData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: Partial<ListenerOptionsWithGas>\n): CallState[] {\n  const { gasRequired } = options ?? {}\n\n  // Create ethers function fragment\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  // Get encoded call data. Note can't use useCallData below b.c. this is  for a list of CallInputs\n  const callDatas = useMemo(() => {\n    if (!contract || !fragment) return []\n    return callInputs.map<string | undefined>((callInput) =>\n      isValidMethodArgs(callInput) ? contract.interface.encodeFunctionData(fragment, callInput) : undefined\n    )\n  }, [callInputs, contract, fragment])\n\n  // Create call objects\n  const calls = useMemo(() => {\n    if (!contract) return []\n    return callDatas.map<Call | undefined>((callData) => {\n      if (!callData) return undefined\n      return {\n        address: contract.address,\n        callData,\n        gasRequired,\n      }\n    })\n  }, [contract, callDatas, gasRequired])\n\n  // Subscribe to call data\n  const results = useCallsDataSubscription(context, chainId, calls, options as ListenerOptions)\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [results, contract, fragment, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: Partial<ListenerOptionsWithGas>\n): CallState[] {\n  const { gasRequired } = options ?? {}\n\n  const { fragment, callData } = useCallData(methodName, contractInterface, callInputs)\n\n  // Create call objects\n  const calls = useMemo(() => {\n    if (!callData) return []\n    return addresses.map<Call | undefined>((address) => {\n      if (!address) return undefined\n      return { address, callData, gasRequired }\n    })\n  }, [addresses, callData, gasRequired])\n\n  // Subscribe to call data\n  const results = useCallsDataSubscription(context, chainId, calls, options as ListenerOptions)\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: Partial<ListenerOptionsWithGas>\n): CallState {\n  const callInputs = useMemo(() => [inputs], [inputs])\n  return (\n    useSingleContractMultipleData(context, chainId, latestBlockNumber, contract, methodName, callInputs, options)[0] ??\n    INVALID_CALL_STATE\n  )\n}\n\n// formats many calls to any number of functions on a single contract, with only the calldata specified\nexport function useSingleContractWithCallData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  contract: Contract | null | undefined,\n  callDatas: string[],\n  options?: Partial<ListenerOptionsWithGas>\n): CallState[] {\n  const { gasRequired } = options ?? {}\n\n  // Create call objects\n  const calls = useMemo(() => {\n    if (!contract) return []\n    return callDatas.map<Call>((callData) => ({\n      address: contract.address,\n      callData,\n      gasRequired,\n    }))\n  }, [contract, callDatas, gasRequired])\n\n  // Subscribe to call data\n  const results = useCallsDataSubscription(context, chainId, calls, options as ListenerOptions)\n\n  return useMemo(() => {\n    return results.map((result, i) =>\n      toCallState(\n        result,\n        contract?.interface,\n        contract?.interface?.getFunction(callDatas[i].substring(0, 10)),\n        latestBlockNumber\n      )\n    )\n  }, [results, contract, callDatas, latestBlockNumber])\n}\n\n// Similar to useMultipleContractSingleData but instead of multiple contracts on one chain,\n// this is for querying compatible contracts on multiple chains\nexport function useMultiChainMultiContractSingleData(\n  context: MulticallContext,\n  chainToBlockNumber: Record<number, number | undefined>,\n  chainToAddresses: Record<number, Array<string | undefined>>,\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: Partial<ListenerOptionsWithGas>\n): Record<number, CallState[]> {\n  const { gasRequired } = options ?? {}\n\n  const { fragment, callData } = useCallData(methodName, contractInterface, callInputs)\n\n  // Create call objects\n  const chainToCalls = useMemo(() => {\n    if (!callData || !chainToAddresses) return {}\n    return getChainIds(chainToAddresses).reduce((result, chainId) => {\n      const addresses = chainToAddresses[chainId]\n      const calls = addresses.map<Call | undefined>((address) => {\n        if (!address) return undefined\n        return { address, callData, gasRequired }\n      })\n      result[chainId] = calls\n      return result\n    }, {} as Record<number, Array<Call | undefined>>)\n  }, [chainToAddresses, callData, gasRequired])\n\n  // Subscribe to call data\n  const chainIdToResults = useMultichainCallsDataSubscription(context, chainToCalls, options as ListenerOptions)\n\n  return useMemo(() => {\n    return getChainIds(chainIdToResults).reduce((combinedResults, chainId) => {\n      const latestBlockNumber = chainToBlockNumber?.[chainId]\n      const results = chainIdToResults[chainId]\n      combinedResults[chainId] = results.map((result) =>\n        toCallState(result, contractInterface, fragment, latestBlockNumber)\n      )\n      return combinedResults\n    }, {} as Record<number, CallState[]>)\n  }, [fragment, contractInterface, chainIdToResults, chainToBlockNumber])\n}\n\n// Similar to useSingleCallResult but instead of one contract on one chain,\n// this is for querying a contract on multiple chains\nexport function useMultiChainSingleContractSingleData(\n  context: MulticallContext,\n  chainToBlockNumber: Record<number, number | undefined>,\n  chainToAddress: Record<number, string | undefined>,\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: Partial<ListenerOptionsWithGas>\n): Record<number, CallState> {\n  // This hook uses the more flexible useMultiChainMultiContractSingleData internally,\n  // but transforms the inputs and outputs for convenience\n  const chainIdToAddresses = useMemo(() => {\n    return getChainIds(chainToAddress).reduce((result, chainId) => {\n      result[chainId] = [chainToAddress[chainId]]\n      return result\n    }, {} as Record<number, Array<string | undefined>>)\n  }, [chainToAddress])\n\n  const multiContractResults = useMultiChainMultiContractSingleData(\n    context,\n    chainToBlockNumber,\n    chainIdToAddresses,\n    contractInterface,\n    methodName,\n    callInputs,\n    options\n  )\n\n  return useMemo(() => {\n    return getChainIds(chainToAddress).reduce((result, chainId) => {\n      result[chainId] = multiContractResults[chainId]?.[0] ?? INVALID_CALL_STATE\n      return result\n    }, {} as Record<number, CallState>)\n  }, [chainToAddress, multiContractResults])\n}\n\nfunction useCallData(\n  methodName: string,\n  contractInterface: Interface | null | undefined,\n  callInputs: OptionalMethodInputs | undefined\n) {\n  // Create ethers function fragment\n  const fragment = useMemo(() => contractInterface?.getFunction(methodName), [contractInterface, methodName])\n  // Get encoded call data\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface?.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  )\n  return { fragment, callData }\n}\n\nfunction getChainIds(chainIdMap: Record<number, any>) {\n  return Object.keys(chainIdMap).map((c) => parseInt(c, 10))\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport {\n  MulticallFetchingPayload,\n  MulticallListenerPayload,\n  MulticallResultsPayload,\n  MulticallState,\n  MulticallListenerOptionsPayload,\n} from './types'\nimport { toCallKey } from './utils/callKeys'\n\nconst initialState: MulticallState = {\n  callResults: {},\n}\n\nexport function createMulticallSlice(reducerPath: string) {\n  return createSlice({\n    name: reducerPath,\n    initialState,\n    reducers: {\n      addMulticallListeners: (state, action: PayloadAction<MulticallListenerPayload>) => {\n        const {\n          calls,\n          chainId,\n          options: { blocksPerFetch },\n        } = action.payload\n        const listeners: MulticallState['callListeners'] = state.callListeners\n          ? state.callListeners\n          : (state.callListeners = {})\n        listeners[chainId] = listeners[chainId] ?? {}\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          listeners[chainId][callKey] = listeners[chainId][callKey] ?? {}\n          listeners[chainId][callKey][blocksPerFetch] = (listeners[chainId][callKey][blocksPerFetch] ?? 0) + 1\n        })\n      },\n\n      removeMulticallListeners: (state, action: PayloadAction<MulticallListenerPayload>) => {\n        const {\n          calls,\n          chainId,\n          options: { blocksPerFetch },\n        } = action.payload\n        const listeners: MulticallState['callListeners'] = state.callListeners\n          ? state.callListeners\n          : (state.callListeners = {})\n\n        if (!listeners[chainId]) return\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          if (!listeners[chainId][callKey]) return\n          if (!listeners[chainId][callKey][blocksPerFetch]) return\n\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n            delete listeners[chainId][callKey][blocksPerFetch]\n          } else {\n            listeners[chainId][callKey][blocksPerFetch]--\n          }\n        })\n      },\n\n      fetchingMulticallResults: (state, action: PayloadAction<MulticallFetchingPayload>) => {\n        const { chainId, fetchingBlockNumber, calls } = action.payload\n        state.callResults[chainId] = state.callResults[chainId] ?? {}\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          const current = state.callResults[chainId][callKey]\n          if (!current) {\n            state.callResults[chainId][callKey] = {\n              fetchingBlockNumber,\n            }\n          } else {\n            if ((current.fetchingBlockNumber ?? 0) >= fetchingBlockNumber) return\n            state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber\n          }\n        })\n      },\n\n      errorFetchingMulticallResults: (state, action: PayloadAction<MulticallFetchingPayload>) => {\n        const { chainId, fetchingBlockNumber, calls } = action.payload\n        state.callResults[chainId] = state.callResults[chainId] ?? {}\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          const current = state.callResults[chainId][callKey]\n          if (!current || typeof current.fetchingBlockNumber !== 'number') return // only should be dispatched if we are already fetching\n          if (current.fetchingBlockNumber <= fetchingBlockNumber) {\n            delete current.fetchingBlockNumber\n            current.data = null\n            current.blockNumber = fetchingBlockNumber\n          }\n        })\n      },\n\n      updateMulticallResults: (state, action: PayloadAction<MulticallResultsPayload>) => {\n        const { chainId, results, blockNumber } = action.payload\n        state.callResults[chainId] = state.callResults[chainId] ?? {}\n        Object.keys(results).forEach((callKey) => {\n          const current = state.callResults[chainId][callKey]\n          if ((current?.blockNumber ?? 0) > blockNumber) return\n          if (current?.data === results[callKey] && current?.blockNumber === blockNumber) return\n          state.callResults[chainId][callKey] = {\n            data: results[callKey],\n            blockNumber,\n          }\n        })\n      },\n\n      updateListenerOptions: (state, action: PayloadAction<MulticallListenerOptionsPayload>) => {\n        const { chainId, listenerOptions } = action.payload\n        state.listenerOptions = state.listenerOptions ?? {}\n        state.listenerOptions[chainId] = listenerOptions\n      },\n    },\n  })\n}\n\nexport type MulticallActions = ReturnType<typeof createMulticallSlice>['actions']\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { DEFAULT_CHUNK_GAS_REQUIRED } from '../constants'\n\ninterface Bin<T> {\n  calls: T[]\n  cumulativeGasLimit: number\n}\n\n/**\n * Tries to pack a list of items into as few bins as possible using the first-fit bin packing algorithm\n * @param calls the calls to chunk\n * @param chunkGasLimit the gas limit of any one chunk of calls, i.e. bin capacity\n * @param defaultGasRequired the default amount of gas an individual call should cost if not specified\n */\nexport default function chunkCalls<T extends { gasRequired?: number }>(\n  calls: T[],\n  chunkGasLimit: number,\n  defaultGasRequired: number = DEFAULT_CHUNK_GAS_REQUIRED\n): T[][] {\n  return (\n    calls\n      // first sort by gas required\n      .sort((c1, c2) => (c2.gasRequired ?? defaultGasRequired) - (c1.gasRequired ?? defaultGasRequired))\n      // then bin the calls according to the first fit algorithm\n      .reduce<Bin<T>[]>((bins, call) => {\n        const gas = call.gasRequired ?? defaultGasRequired\n        for (const bin of bins) {\n          if (bin.cumulativeGasLimit + gas <= chunkGasLimit) {\n            bin.calls.push(call)\n            bin.cumulativeGasLimit += gas\n            return bins\n          }\n        }\n        // didn't find a bin for the call, make a new bin\n        bins.push({\n          calls: [call],\n          cumulativeGasLimit: gas,\n        })\n        return bins\n      }, [])\n      // pull out just the calls from each bin\n      .map((b) => b.calls)\n  )\n}\n","// TODO de-duplicate this file with web interface\n// https://github.com/Uniswap/interface/blob/main/src/utils/retry.ts\n\nfunction wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction waitRandom(min: number, max: number): Promise<void> {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)))\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nclass CancelledError extends Error {\n  public isCancelledError: true = true\n  constructor() {\n    super('Cancelled')\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {\n  public isRetryableError: true = true\n}\n\nexport interface RetryOptions {\n  n: number\n  minWait: number\n  maxWait: number\n}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry<T>(\n  fn: () => Promise<T>,\n  { n, minWait, maxWait }: RetryOptions\n): { promise: Promise<T>; cancel: () => void } {\n  let completed = false\n  let rejectCancelled: (error: Error) => void\n  const promise = new Promise<T>(async (resolve, reject) => {\n    rejectCancelled = reject\n    while (true) {\n      let result: T\n      try {\n        result = await fn()\n        if (!completed) {\n          resolve(result)\n          completed = true\n        }\n        break\n      } catch (error) {\n        if (completed) {\n          break\n        }\n        if (n <= 0 || !(error as any).isRetryableError) {\n          reject(error)\n          completed = true\n          break\n        }\n        n--\n      }\n      await waitRandom(minWait, maxWait)\n    }\n  })\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return\n      completed = true\n      rejectCancelled(new CancelledError())\n    },\n  }\n}\n","// TODO de-duplicate this file with web interface\n// https://github.com/Uniswap/interface/blob/main/src/hooks/useDebounce.ts\n\nimport { useEffect, useState } from 'react'\n\n// modified from https://usehooks.com/useDebounce/\nexport default function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n    return () => {\n      clearTimeout(handler)\n    }\n  }, [value, delay])\n\n  return debouncedValue\n}\n","import React, { Dispatch, useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport type { UniswapInterfaceMulticall } from './abi/types'\nimport { CHUNK_GAS_LIMIT, DEFAULT_CALL_GAS_REQUIRED } from './constants'\nimport type { MulticallContext } from './context'\nimport type { MulticallActions } from './slice'\nimport type { Call, MulticallState, WithMulticallState, ListenerOptions } from './types'\nimport { parseCallKey, toCallKey } from './utils/callKeys'\nimport chunkCalls from './utils/chunkCalls'\nimport { retry, RetryableError } from './utils/retry'\nimport useDebounce from './utils/useDebounce'\n\nconst FETCH_RETRY_CONFIG = {\n  n: Infinity,\n  minWait: 1000,\n  maxWait: 2500,\n}\n\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicall multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param blockNumber block number passed as the block tag in the eth_call\n */\nasync function fetchChunk(\n  multicall: UniswapInterfaceMulticall,\n  chunk: Call[],\n  blockNumber: number,\n  isDebug?: boolean\n): Promise<{ success: boolean; returnData: string }[]> {\n  console.debug('Fetching chunk', chunk, blockNumber)\n  try {\n    const { returnData } = await multicall.callStatic.multicall(\n      chunk.map((obj) => ({\n        target: obj.address,\n        callData: obj.callData,\n        gasLimit: obj.gasRequired ?? DEFAULT_CALL_GAS_REQUIRED,\n      })),\n      // we aren't passing through the block gas limit we used to create the chunk, because it causes a problem with the integ tests\n      { blockTag: blockNumber }\n    )\n\n    if (isDebug) {\n      returnData.forEach(({ gasUsed, returnData, success }, i) => {\n        if (\n          !success &&\n          returnData.length === 2 &&\n          gasUsed.gte(Math.floor((chunk[i].gasRequired ?? DEFAULT_CALL_GAS_REQUIRED) * 0.95))\n        ) {\n          console.warn(\n            `A call failed due to requiring ${gasUsed.toString()} vs. allowed ${\n              chunk[i].gasRequired ?? DEFAULT_CALL_GAS_REQUIRED\n            }`,\n            chunk[i]\n          )\n        }\n      })\n    }\n\n    return returnData\n  } catch (e) {\n    const error = e as any\n    if (error.code === -32000 || error.message?.indexOf('header not found') !== -1) {\n      throw new RetryableError(`header not found for block number ${blockNumber}`)\n    } else if (error.code === -32603 || error.message?.indexOf('execution ran out of gas') !== -1) {\n      if (chunk.length > 1) {\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Splitting a chunk in 2', chunk)\n        }\n        const half = Math.floor(chunk.length / 2)\n        const [c0, c1] = await Promise.all([\n          fetchChunk(multicall, chunk.slice(0, half), blockNumber),\n          fetchChunk(multicall, chunk.slice(half, chunk.length), blockNumber),\n        ])\n        return c0.concat(c1)\n      }\n    }\n    console.error('Failed to fetch chunk', error)\n    throw error\n  }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: MulticallState['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter((key) => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: MulticallState['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter((callKey) => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\ninterface FetchChunkContext {\n  actions: MulticallActions\n  dispatch: Dispatch<any>\n  chainId: number\n  latestBlockNumber: number\n  isDebug?: boolean\n}\n\nfunction onFetchChunkSuccess(\n  context: FetchChunkContext,\n  chunk: Call[],\n  result: Array<{ success: boolean; returnData: string }>\n) {\n  const { actions, dispatch, chainId, latestBlockNumber, isDebug } = context\n\n  // split the returned slice into errors and results\n  const { erroredCalls, results } = chunk.reduce<{\n    erroredCalls: Call[]\n    results: { [callKey: string]: string | null }\n  }>(\n    (memo, call, i) => {\n      if (result[i].success) {\n        memo.results[toCallKey(call)] = result[i].returnData ?? null\n      } else {\n        memo.erroredCalls.push(call)\n      }\n      return memo\n    },\n    { erroredCalls: [], results: {} }\n  )\n\n  // dispatch any new results\n  if (Object.keys(results).length > 0)\n    dispatch(\n      actions.updateMulticallResults({\n        chainId,\n        results,\n        blockNumber: latestBlockNumber,\n      })\n    )\n\n  // dispatch any errored calls\n  if (erroredCalls.length > 0) {\n    if (isDebug) {\n      result.forEach((returnData, ix) => {\n        if (!returnData.success) {\n          console.debug('Call failed', chunk[ix], returnData)\n        }\n      })\n    } else {\n      console.debug('Calls errored in fetch', erroredCalls)\n    }\n    dispatch(\n      actions.errorFetchingMulticallResults({\n        calls: erroredCalls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      })\n    )\n  }\n}\n\nfunction onFetchChunkFailure(context: FetchChunkContext, chunk: Call[], error: any) {\n  const { actions, dispatch, chainId, latestBlockNumber } = context\n\n  if (error.isCancelledError) {\n    console.debug('Cancelled fetch for blockNumber', latestBlockNumber, chunk, chainId)\n    return\n  }\n  console.error('Failed to fetch multicall chunk', chunk, chainId, error)\n  dispatch(\n    actions.errorFetchingMulticallResults({\n      calls: chunk,\n      chainId,\n      fetchingBlockNumber: latestBlockNumber,\n    })\n  )\n}\n\nexport interface UpdaterProps {\n  context: MulticallContext\n  chainId: number | undefined // For now, one updater is required for each chainId to be watched\n  latestBlockNumber: number | undefined\n  contract: UniswapInterfaceMulticall\n  isDebug?: boolean\n  listenerOptions?: ListenerOptions\n}\n\nfunction Updater(props: UpdaterProps): null {\n  const { context, chainId, latestBlockNumber, contract, isDebug, listenerOptions } = props\n  const { actions, reducerPath } = context\n  const dispatch = useDispatch()\n\n  // set user configured listenerOptions in state for given chain ID.\n  useEffect(() => {\n    if (chainId && listenerOptions) {\n      dispatch(actions.updateListenerOptions({ chainId, listenerOptions }))\n    }\n  }, [chainId, listenerOptions, actions, dispatch])\n\n  const state = useSelector((state: WithMulticallState) => state[reducerPath])\n\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId)\n  }, [debouncedListeners, chainId])\n\n  const serializedOutdatedCallKeys = useMemo(() => {\n    const outdatedCallKeys = outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\n    return JSON.stringify(outdatedCallKeys.sort())\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !contract) return\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\n\n    const chunkedCalls = chunkCalls(calls, CHUNK_GAS_LIMIT)\n\n    if (cancellations.current && cancellations.current.blockNumber !== latestBlockNumber) {\n      cancellations.current.cancellations.forEach((c) => c())\n    }\n\n    dispatch(\n      actions.fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      })\n    )\n\n    const fetchChunkContext = {\n      actions,\n      dispatch,\n      chainId,\n      latestBlockNumber,\n      isDebug,\n    }\n    // Execute fetches and gather cancellation callbacks\n    const newCancellations = chunkedCalls.map((chunk) => {\n      const { cancel, promise } = retry(\n        () => fetchChunk(contract, chunk, latestBlockNumber, isDebug),\n        FETCH_RETRY_CONFIG\n      )\n      promise\n        .then((result) => onFetchChunkSuccess(fetchChunkContext, chunk, result))\n        .catch((error) => onFetchChunkFailure(fetchChunkContext, chunk, error))\n      return cancel\n    })\n\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: newCancellations,\n    }\n  }, [actions, chainId, contract, dispatch, serializedOutdatedCallKeys, latestBlockNumber, isDebug])\n\n  return null\n}\n\nexport function createUpdater(context: MulticallContext) {\n  const UpdaterContextBound = (props: Omit<UpdaterProps, 'context'>) => {\n    return <Updater context={context} {...props} />\n  }\n  return UpdaterContextBound\n}\n","import type { MulticallContext } from './context'\nimport {\n  useMultiChainMultiContractSingleData as _useMultiChainMultiContractSingleData,\n  useMultiChainSingleContractSingleData as _useMultiChainSingleContractSingleData,\n  useMultipleContractSingleData as _useMultipleContractSingleData,\n  useSingleCallResult as _useSingleCallResult,\n  useSingleContractMultipleData as _useSingleContractMultipleData,\n  useSingleContractWithCallData as _useSingleContractWithCallData,\n} from './hooks'\nimport { createMulticallSlice } from './slice'\nimport { createUpdater } from './updater'\n\ntype RemoveFirstFromTuple<T extends any[]> = T['length'] extends 0\n  ? undefined\n  : ((...b: T) => void) extends (a: any, ...b: infer I) => void\n  ? I\n  : []\ntype ParamsWithoutContext<T extends (...args: any) => any> = RemoveFirstFromTuple<Parameters<T>>\n\nexport interface MulticallOptions {\n  reducerPath?: string\n  // More options can be added here as multicall's capabilities are extended\n}\n\n// Inspired by RTK Query's createApi\nexport function createMulticall(options?: MulticallOptions) {\n  const reducerPath = options?.reducerPath ?? 'multicall'\n  const slice = createMulticallSlice(reducerPath)\n  const { actions, reducer } = slice\n  const context: MulticallContext = { reducerPath, actions }\n\n  const useMultipleContractSingleData = (...args: ParamsWithoutContext<typeof _useMultipleContractSingleData>) =>\n    _useMultipleContractSingleData(context, ...args)\n  const useSingleContractMultipleData = (...args: ParamsWithoutContext<typeof _useSingleContractMultipleData>) =>\n    _useSingleContractMultipleData(context, ...args)\n  const useSingleContractWithCallData = (...args: ParamsWithoutContext<typeof _useSingleContractWithCallData>) =>\n    _useSingleContractWithCallData(context, ...args)\n  const useSingleCallResult = (...args: ParamsWithoutContext<typeof _useSingleCallResult>) =>\n    _useSingleCallResult(context, ...args)\n  const useMultiChainMultiContractSingleData = (\n    ...args: ParamsWithoutContext<typeof _useMultiChainMultiContractSingleData>\n  ) => _useMultiChainMultiContractSingleData(context, ...args)\n  const useMultiChainSingleContractSingleData = (\n    ...args: ParamsWithoutContext<typeof _useMultiChainSingleContractSingleData>\n  ) => _useMultiChainSingleContractSingleData(context, ...args)\n  const hooks = {\n    useMultipleContractSingleData,\n    useSingleContractMultipleData,\n    useSingleContractWithCallData,\n    useSingleCallResult,\n    useMultiChainMultiContractSingleData,\n    useMultiChainSingleContractSingleData,\n  }\n\n  const Updater = createUpdater(context)\n\n  return {\n    reducerPath,\n    reducer,\n    actions,\n    hooks,\n    Updater,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}