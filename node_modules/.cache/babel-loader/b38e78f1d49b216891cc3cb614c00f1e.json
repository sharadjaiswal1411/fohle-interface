{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo } from 'react';\nimport { ADDITIONAL_BASES, BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants/routing';\nexport function useAllCurrencyCombinations(currencyA, currencyB) {\n  _s();\n  const chainId = currencyA === null || currencyA === void 0 ? void 0 : currencyA.chainId;\n  const [tokenA, tokenB] = chainId ? [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped] : [undefined, undefined];\n  const bases = useMemo(() => {\n    var _BASES_TO_CHECK_TRADE, _ADDITIONAL_BASES$cha, _ADDITIONAL_BASES$cha2, _ADDITIONAL_BASES$cha3, _ADDITIONAL_BASES$cha4;\n    if (!chainId || chainId !== (tokenB === null || tokenB === void 0 ? void 0 : tokenB.chainId)) return [];\n    const common = (_BASES_TO_CHECK_TRADE = BASES_TO_CHECK_TRADES_AGAINST[chainId]) !== null && _BASES_TO_CHECK_TRADE !== void 0 ? _BASES_TO_CHECK_TRADE : [];\n    const additionalA = tokenA ? (_ADDITIONAL_BASES$cha = (_ADDITIONAL_BASES$cha2 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha2 === void 0 ? void 0 : _ADDITIONAL_BASES$cha2[tokenA.address]) !== null && _ADDITIONAL_BASES$cha !== void 0 ? _ADDITIONAL_BASES$cha : [] : [];\n    const additionalB = tokenB ? (_ADDITIONAL_BASES$cha3 = (_ADDITIONAL_BASES$cha4 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha4 === void 0 ? void 0 : _ADDITIONAL_BASES$cha4[tokenB.address]) !== null && _ADDITIONAL_BASES$cha3 !== void 0 ? _ADDITIONAL_BASES$cha3 : [] : [];\n    return [...common, ...additionalA, ...additionalB];\n  }, [chainId, tokenA, tokenB]);\n  const basePairs = useMemo(() => bases.flatMap(base => bases.map(otherBase => [base, otherBase]))\n  // though redundant with the first filter below, that expression runs more often, so this is probably worthwhile\n  .filter(_ref => {\n    let [t0, t1] = _ref;\n    return !t0.equals(t1);\n  }), [bases]);\n  return useMemo(() => tokenA && tokenB ? [\n  // the direct pair\n  [tokenA, tokenB],\n  // token A against all bases\n  ...bases.map(base => [tokenA, base]),\n  // token B against all bases\n  ...bases.map(base => [tokenB, base]),\n  // each base against all bases\n  ...basePairs]\n  // filter out invalid pairs comprised of the same asset (e.g. WETH<>WETH)\n  .filter(_ref2 => {\n    let [t0, t1] = _ref2;\n    return !t0.equals(t1);\n  })\n  // filter out duplicate pairs\n  .filter((_ref3, i, otherPairs) => {\n    let [t0, t1] = _ref3;\n    // find the first index in the array at which there are the same 2 tokens as the current\n    const firstIndexInOtherPairs = otherPairs.findIndex(_ref4 => {\n      let [t0Other, t1Other] = _ref4;\n      return t0.equals(t0Other) && t1.equals(t1Other) || t0.equals(t1Other) && t1.equals(t0Other);\n    });\n    // only accept the first occurrence of the same 2 tokens\n    return firstIndexInOtherPairs === i;\n  })\n  // optionally filter out some pairs for tokens with custom bases defined\n  .filter(_ref5 => {\n    let [tokenA, tokenB] = _ref5;\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    const customBasesA = customBases === null || customBases === void 0 ? void 0 : customBases[tokenA.address];\n    const customBasesB = customBases === null || customBases === void 0 ? void 0 : customBases[tokenB.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n}\n_s(useAllCurrencyCombinations, \"9+cy0ZEVvyGXWfwuHjYoZs4R9uY=\");","map":{"version":3,"names":["useMemo","ADDITIONAL_BASES","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","useAllCurrencyCombinations","currencyA","currencyB","chainId","tokenA","tokenB","wrapped","undefined","bases","common","additionalA","address","additionalB","basePairs","flatMap","base","map","otherBase","filter","t0","t1","equals","i","otherPairs","firstIndexInOtherPairs","findIndex","t0Other","t1Other","customBases","customBasesA","customBasesB","find"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useAllCurrencyCombinations.ts"],"sourcesContent":["import { Currency, Token } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\n\nimport { ADDITIONAL_BASES, BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants/routing'\n\nexport function useAllCurrencyCombinations(currencyA?: Currency, currencyB?: Currency): [Token, Token][] {\n  const chainId = currencyA?.chainId\n\n  const [tokenA, tokenB] = chainId ? [currencyA?.wrapped, currencyB?.wrapped] : [undefined, undefined]\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId || chainId !== tokenB?.chainId) return []\n\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\n\n    return [...common, ...additionalA, ...additionalB]\n  }, [chainId, tokenA, tokenB])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () =>\n      bases\n        .flatMap((base): [Token, Token][] => bases.map((otherBase) => [base, otherBase]))\n        // though redundant with the first filter below, that expression runs more often, so this is probably worthwhile\n        .filter(([t0, t1]) => !t0.equals(t1)),\n    [bases]\n  )\n\n  return useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB] as [Token, Token],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            // filter out invalid pairs comprised of the same asset (e.g. WETH<>WETH)\n            .filter(([t0, t1]) => !t0.equals(t1))\n            // filter out duplicate pairs\n            .filter(([t0, t1], i, otherPairs) => {\n              // find the first index in the array at which there are the same 2 tokens as the current\n              const firstIndexInOtherPairs = otherPairs.findIndex(([t0Other, t1Other]) => {\n                return (t0.equals(t0Other) && t1.equals(t1Other)) || (t0.equals(t1Other) && t1.equals(t0Other))\n              })\n              // only accept the first occurrence of the same 2 tokens\n              return firstIndexInOtherPairs === i\n            })\n            // optionally filter out some pairs for tokens with custom bases defined\n            .filter(([tokenA, tokenB]) => {\n              if (!chainId) return true\n              const customBases = CUSTOM_BASES[chainId]\n\n              const customBasesA: Token[] | undefined = customBases?.[tokenA.address]\n              const customBasesB: Token[] | undefined = customBases?.[tokenB.address]\n\n              if (!customBasesA && !customBasesB) return true\n\n              if (customBasesA && !customBasesA.find((base) => tokenB.equals(base))) return false\n              if (customBasesB && !customBasesB.find((base) => tokenA.equals(base))) return false\n\n              return true\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId]\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}