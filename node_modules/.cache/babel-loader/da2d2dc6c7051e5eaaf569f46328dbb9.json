{"ast":null,"code":"import { _optionalChain } from './buildPolyfills';\nimport { isString, isPlainObject } from './is.js';\nimport { normalize } from './normalize.js';\nimport { stripUrlQueryAndFragment } from './url.js';\nconst DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true\n};\nconst DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nconst DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nfunction addRequestDataToTransaction(transaction, req, deps) {\n  if (!transaction) return;\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    transaction.setName(...extractPathForTransaction(req, {\n      path: true,\n      method: true\n    }));\n  }\n  transaction.setData('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setData('baseUrl', req.baseUrl);\n  }\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nfunction extractPathForTransaction(req) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const method = req.method && req.method.toUpperCase();\n  let path = '';\n  let source = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n  return [name, source];\n}\n\n/** JSDoc */\nfunction extractTransaction(req, type) {\n  switch (type) {\n    case 'path':\n      {\n        return extractPathForTransaction(req, {\n          path: true\n        })[0];\n      }\n    case 'handler':\n      {\n        return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || '<anonymous>';\n      }\n    case 'methodPath':\n    default:\n      {\n        return extractPathForTransaction(req, {\n          path: true,\n          method: true\n        })[0];\n      }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(user, keys) {\n  const extractedUser = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nfunction extractRequestData(req, options) {\n  const {\n    include = DEFAULT_REQUEST_INCLUDES,\n    deps\n  } = options || {};\n  const requestData = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  const headers = req.headers || {};\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  const host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol = req.protocol === 'https' || req.socket && req.socket.encrypted ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  const absoluteUrl = `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers':\n        {\n          requestData.headers = headers;\n          break;\n        }\n      case 'method':\n        {\n          requestData.method = method;\n          break;\n        }\n      case 'url':\n        {\n          requestData.url = absoluteUrl;\n          break;\n        }\n      case 'cookies':\n        {\n          // cookies:\n          //   node, express, koa: req.headers.cookie\n          //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie) || {};\n          break;\n        }\n      case 'query_string':\n        {\n          // query string:\n          //   node: req.url (raw)\n          //   express, koa, nextjs: req.query\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          requestData.query_string = extractQueryParams(req, deps);\n          break;\n        }\n      case 'data':\n        {\n          if (method === 'GET' || method === 'HEAD') {\n            break;\n          }\n          // body data:\n          //   express, koa, nextjs: req.body\n          //\n          //   when using node by itself, you have to read the incoming stream(see\n          //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n          //   where they're going to store the final result, so they'll have to capture this data themselves\n          if (req.body !== undefined) {\n            requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n          }\n          break;\n        }\n      default:\n        {\n          if ({}.hasOwnProperty.call(req, key)) {\n            requestData[key] = req[key];\n          }\n        }\n    }\n  });\n  return requestData;\n}\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @hidden\n */\nfunction addRequestDataToEvent(event, req, options) {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ..._optionalChain([options, 'optionalAccess', _ => _.include])\n  };\n  if (include.request) {\n    const extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, {\n      include: include.request,\n      deps: _optionalChain([options, 'optionalAccess', _2 => _2.deps])\n    }) : extractRequestData(req, {\n      deps: _optionalChain([options, 'optionalAccess', _3 => _3.deps])\n    });\n    event.request = {\n      ...event.request,\n      ...extractedRequestData\n    };\n  }\n  if (include.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    const ip = req.ip || req.socket && req.socket.remoteAddress;\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip\n      };\n    }\n  }\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n  return event;\n}\nfunction extractQueryParams(req, deps) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n  return req.query || typeof URL !== undefined && new URL(originalUrl).search.replace('?', '') ||\n  // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n  deps && deps.url && deps.url.parse(originalUrl).query || undefined;\n}\nexport { addRequestDataToEvent, addRequestDataToTransaction, extractPathForTransaction, extractRequestData };","map":{"version":3,"sources":["../../src/requestdata.ts"],"names":[],"mappings":"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","sourcesContent":["// TODO: Remove this file once equivalent integration is used everywhere\n\n/* eslint-disable complexity */\n/**\n * The functions here, which enrich an event with request data, are mostly for use in Node, but are safe for use in a\n * browser context. They live here in `@sentry/utils` rather than in `@sentry/node` so that they can be used in\n * frameworks (like nextjs), which, because of SSR, run the same code in both Node and browser contexts.\n *\n * TODO (v8 / #5257): Remove the note below\n * Note that for now, the tests for this code have to live in `@sentry/node`, since they test both these functions and\n * the backwards-compatibility-preserving wrappers which still live in `handlers.ts` there.\n */\n\n/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { Event, ExtractedNodeRequestData, PolymorphicRequest, Transaction, TransactionSource } from '@sentry/types';\n\nimport { isPlainObject, isString } from './is';\nimport { normalize } from './normalize';\nimport { stripUrlQueryAndFragment } from './url';\n\nconst DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true,\n};\nconst DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nconst DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n\ntype InjectedNodeDeps = {\n  cookie: {\n    parse: (cookieStr: string) => Record<string, string>;\n  };\n  url: {\n    parse: (urlStr: string) => {\n      query: string | null;\n    };\n  };\n};\n\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nexport function addRequestDataToTransaction(\n  transaction: Transaction | undefined,\n  req: PolymorphicRequest,\n  deps?: InjectedNodeDeps,\n): void {\n  if (!transaction) return;\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    transaction.setName(...extractPathForTransaction(req, { path: true, method: true }));\n  }\n  transaction.setData('url', req.originalUrl || req.url);\n  if (req.baseUrl) {\n    transaction.setData('baseUrl', req.baseUrl);\n  }\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\nexport function extractPathForTransaction(\n  req: PolymorphicRequest,\n  options: { path?: boolean; method?: boolean; customRoute?: string } = {},\n): [string, TransactionSource] {\n  const method = req.method && req.method.toUpperCase();\n\n  let path = '';\n  let source: TransactionSource = 'url';\n\n  // Check to see if there's a parameterized route we can use (as there is in Express)\n  if (options.customRoute || req.route) {\n    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;\n    source = 'route';\n  }\n\n  // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let name = '';\n  if (options.method && method) {\n    name += method;\n  }\n  if (options.method && options.path) {\n    name += ' ';\n  }\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n\ntype TransactionNamingScheme = 'path' | 'methodPath' | 'handler';\n\n/** JSDoc */\nfunction extractTransaction(req: PolymorphicRequest, type: boolean | TransactionNamingScheme): string {\n  switch (type) {\n    case 'path': {\n      return extractPathForTransaction(req, { path: true })[0];\n    }\n    case 'handler': {\n      return (req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name) || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      return extractPathForTransaction(req, { path: true, method: true })[0];\n    }\n  }\n}\n\n/** JSDoc */\nfunction extractUserData(\n  user: {\n    [key: string]: any;\n  },\n  keys: boolean | string[],\n): { [key: string]: any } {\n  const extractedUser: { [key: string]: any } = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\nexport function extractRequestData(\n  req: PolymorphicRequest,\n  options?: {\n    include?: string[];\n    deps?: InjectedNodeDeps;\n  },\n): ExtractedNodeRequestData {\n  const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};\n  const requestData: { [key: string]: any } = {};\n\n  // headers:\n  //   node, express, koa, nextjs: req.headers\n  const headers = (req.headers || {}) as {\n    host?: string;\n    cookie?: string;\n  };\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  const host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = req.originalUrl || req.url || '';\n  // absolute url\n  const absoluteUrl = `${protocol}://${host}${originalUrl}`;\n  include.forEach(key => {\n    switch (key) {\n      case 'headers': {\n        requestData.headers = headers;\n        break;\n      }\n      case 'method': {\n        requestData.method = method;\n        break;\n      }\n      case 'url': {\n        requestData.url = absoluteUrl;\n        break;\n      }\n      case 'cookies': {\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.cookies =\n          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || (headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie)) || {};\n        break;\n      }\n      case 'query_string': {\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.query_string = extractQueryParams(req, deps);\n        break;\n      }\n      case 'data': {\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      }\n      default: {\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req as { [key: string]: any })[key];\n        }\n      }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\nexport interface AddRequestDataToEventOptions {\n  /** Flags controlling whether each type of data should be added to the event */\n  include?: {\n    ip?: boolean;\n    request?: boolean | string[];\n    transaction?: boolean | TransactionNamingScheme;\n    user?: boolean | string[];\n  };\n\n  /** Injected platform-specific dependencies */\n  deps?: {\n    cookie: {\n      parse: (cookieStr: string) => Record<string, string>;\n    };\n    url: {\n      parse: (urlStr: string) => {\n        query: string | null;\n      };\n    };\n  };\n}\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @hidden\n */\nexport function addRequestDataToEvent(\n  event: Event,\n  req: PolymorphicRequest,\n  options?: AddRequestDataToEventOptions,\n): Event {\n  const include = {\n    ...DEFAULT_INCLUDES,\n    ...options?.include,\n  };\n\n  if (include.request) {\n    const extractedRequestData = Array.isArray(include.request)\n      ? extractRequestData(req, { include: include.request, deps: options?.deps })\n      : extractRequestData(req, { deps: options?.deps });\n\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (include.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n  if (include.ip) {\n    const ip = req.ip || (req.socket && req.socket.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(\n  req: PolymorphicRequest,\n  deps?: InjectedNodeDeps,\n): string | Record<string, unknown> | undefined {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  let originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  }\n\n  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n  if (originalUrl.startsWith('/')) {\n    originalUrl = `http://dogs.are.great${originalUrl}`;\n  }\n\n  return (\n    req.query ||\n    (typeof URL !== undefined && new URL(originalUrl).search.replace('?', '')) ||\n    // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n    (deps && deps.url && deps.url.parse(originalUrl).query) ||\n    undefined\n  );\n}\n"]},"metadata":{},"sourceType":"module"}