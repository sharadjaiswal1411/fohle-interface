{"ast":null,"code":"import { createStackParser } from '@sentry/utils';\n\n// global reference to slice\nconst UNKNOWN_FUNCTION = '?';\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\nfunction createFrame(filename, func, lineno, colno) {\n  const frame = {\n    filename,\n    function: func,\n    // All browser frames are considered in_app\n    in_app: true\n  };\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nconst chromeRegex = /^\\s*at (?:(.*\\).*?|.*?) ?\\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nconst chrome = line => {\n  const parts = chromeRegex.exec(line);\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]);\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n  return;\n};\nconst chromeStackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nconst gecko = line => {\n  const parts = geckoREgex.exec(line);\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]);\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n  return;\n};\nconst geckoStackLineParser = [GECKO_PRIORITY, gecko];\nconst winjsRegex = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nconst winjs = line => {\n  const parts = winjsRegex.exec(line);\n  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined) : undefined;\n};\nconst winjsStackLineParser = [WINJS_PRIORITY, winjs];\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\nconst opera10 = line => {\n  const parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\nconst opera10StackLineParser = [OPERA10_PRIORITY, opera10];\nconst opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\nconst opera11 = line => {\n  const parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\nconst opera11StackLineParser = [OPERA11_PRIORITY, opera11];\nconst defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\nconst defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func, filename) => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n  return isSafariExtension || isSafariWebExtension ? [func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION, isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`] : [func, filename];\n};\nexport { chromeStackLineParser, defaultStackLineParsers, defaultStackParser, geckoStackLineParser, opera10StackLineParser, opera11StackLineParser, winjsStackLineParser };","map":{"version":3,"sources":["../../../src/stack-parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { StackFrame, StackLineParser, StackLineParserFn } from '@sentry/types';\nimport { createStackParser } from '@sentry/utils';\n\n// global reference to slice\nconst UNKNOWN_FUNCTION = '?';\n\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\n\nfunction createFrame(filename: string, func: string, lineno?: number, colno?: number): StackFrame {\n  const frame: StackFrame = {\n    filename,\n    function: func,\n    // All browser frames are considered in_app\n    in_app: true,\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nconst chromeRegex =\n  /^\\s*at (?:(.*\\).*?|.*?) ?\\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nconst chrome: StackLineParserFn = line => {\n  const parts = chromeRegex.exec(line);\n\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nexport const chromeStackLineParser: StackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nconst gecko: StackLineParserFn = line => {\n  const parts = geckoREgex.exec(line);\n\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nexport const geckoStackLineParser: StackLineParser = [GECKO_PRIORITY, gecko];\n\nconst winjsRegex =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nconst winjs: StackLineParserFn = line => {\n  const parts = winjsRegex.exec(line);\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nexport const winjsStackLineParser: StackLineParser = [WINJS_PRIORITY, winjs];\n\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nconst opera10: StackLineParserFn = line => {\n  const parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nexport const opera10StackLineParser: StackLineParser = [OPERA10_PRIORITY, opera10];\n\nconst opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nconst opera11: StackLineParserFn = line => {\n  const parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nexport const opera11StackLineParser: StackLineParser = [OPERA11_PRIORITY, opera11];\n\nexport const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\n\nexport const defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func: string, filename: string): [string, string] => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n"]},"metadata":{},"sourceType":"module"}