{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { tokensToChainTokenMap } from 'lib/hooks/useTokenList/utils';\nimport { useMemo } from 'react';\nimport { useAppSelector } from 'state/hooks';\nimport sortByListPriority from 'utils/listSort';\nimport BROKEN_LIST from '../../constants/tokenLists/broken.tokenlist.json';\nimport { DEFAULT_ACTIVE_LIST_URLS, UNSUPPORTED_LIST_URLS } from './../../constants/lists';\nexport function useAllLists() {\n  _s();\n  return useAppSelector(state => state.lists.byUrl);\n}\n\n/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */\n_s(useAllLists, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\nfunction combineMaps(map1, map2) {\n  const chainIds = Object.keys(Object.keys(map1).concat(Object.keys(map2)).reduce((memo, value) => {\n    memo[value] = true;\n    return memo;\n  }, {})).map(id => parseInt(id));\n  return chainIds.reduce((memo, chainId) => {\n    memo[chainId] = {\n      ...map2[chainId],\n      // map1 takes precedence\n      ...map1[chainId]\n    };\n    return memo;\n  }, {});\n}\n\n// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls) {\n  _s2();\n  const lists = useAllLists();\n  return useMemo(() => {\n    if (!urls) return {};\n    return urls.slice()\n    // sort by priority so top priority goes last\n    .sort(sortByListPriority).reduce((allTokens, currentUrl) => {\n      var _lists$currentUrl;\n      const current = (_lists$currentUrl = lists[currentUrl]) === null || _lists$currentUrl === void 0 ? void 0 : _lists$currentUrl.current;\n      if (!current) return allTokens;\n      try {\n        return combineMaps(allTokens, tokensToChainTokenMap(current));\n      } catch (error) {\n        console.error('Could not show token list due to error', error);\n        return allTokens;\n      }\n    }, {});\n  }, [lists, urls]);\n}\n\n// get all the tokens from active lists, combine with local default tokens\n_s2(useCombinedTokenMapFromUrls, \"dehXRrnFU9pff84Mq4UWf/sQUEg=\", false, function () {\n  return [useAllLists];\n});\nexport function useCombinedActiveList() {\n  _s3();\n  const activeTokens = useCombinedTokenMapFromUrls(DEFAULT_ACTIVE_LIST_URLS);\n  return activeTokens;\n}\n\n// list of tokens not supported on interface for various reasons, used to show warnings and prevent swaps and adds\n_s3(useCombinedActiveList, \"MZe3W7kUCFiWVcqsG0pd3jOIAgg=\", false, function () {\n  return [useCombinedTokenMapFromUrls];\n});\nexport function useUnsupportedTokenList() {\n  _s4();\n  // get hard-coded broken tokens\n  const brokenListMap = useMemo(() => tokensToChainTokenMap(BROKEN_LIST), []);\n\n  // get dynamic list of unsupported tokens\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS);\n\n  // format into one token address map\n  return useMemo(() => combineMaps(brokenListMap, loadedUnsupportedListMap), [brokenListMap, loadedUnsupportedListMap]);\n}\n_s4(useUnsupportedTokenList, \"cI/yMyIaehKPeeJhN/sqJcZuXUI=\", false, function () {\n  return [useCombinedTokenMapFromUrls];\n});","map":{"version":3,"names":["tokensToChainTokenMap","useMemo","useAppSelector","sortByListPriority","BROKEN_LIST","DEFAULT_ACTIVE_LIST_URLS","UNSUPPORTED_LIST_URLS","useAllLists","state","lists","byUrl","combineMaps","map1","map2","chainIds","Object","keys","concat","reduce","memo","value","map","id","parseInt","chainId","useCombinedTokenMapFromUrls","urls","slice","sort","allTokens","currentUrl","current","error","console","useCombinedActiveList","activeTokens","useUnsupportedTokenList","brokenListMap","loadedUnsupportedListMap"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/lists/hooks.ts"],"sourcesContent":["import { ChainTokenMap, tokensToChainTokenMap } from 'lib/hooks/useTokenList/utils'\nimport { useMemo } from 'react'\nimport { useAppSelector } from 'state/hooks'\nimport sortByListPriority from 'utils/listSort'\n\nimport BROKEN_LIST from '../../constants/tokenLists/broken.tokenlist.json'\nimport { AppState } from '../index'\nimport { DEFAULT_ACTIVE_LIST_URLS, UNSUPPORTED_LIST_URLS } from './../../constants/lists'\n\nexport type TokenAddressMap = ChainTokenMap\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: Mutable<T[P]>\n}\n\nexport function useAllLists(): AppState['lists']['byUrl'] {\n  return useAppSelector((state) => state.lists.byUrl)\n}\n\n/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */\nfunction combineMaps(map1: TokenAddressMap, map2: TokenAddressMap): TokenAddressMap {\n  const chainIds = Object.keys(\n    Object.keys(map1)\n      .concat(Object.keys(map2))\n      .reduce<{ [chainId: string]: true }>((memo, value) => {\n        memo[value] = true\n        return memo\n      }, {})\n  ).map((id) => parseInt(id))\n\n  return chainIds.reduce<Mutable<TokenAddressMap>>((memo, chainId) => {\n    memo[chainId] = {\n      ...map2[chainId],\n      // map1 takes precedence\n      ...map1[chainId],\n    }\n    return memo\n  }, {}) as TokenAddressMap\n}\n\n// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls: string[] | undefined): TokenAddressMap {\n  const lists = useAllLists()\n  return useMemo(() => {\n    if (!urls) return {}\n    return (\n      urls\n        .slice()\n        // sort by priority so top priority goes last\n        .sort(sortByListPriority)\n        .reduce((allTokens, currentUrl) => {\n          const current = lists[currentUrl]?.current\n          if (!current) return allTokens\n          try {\n            return combineMaps(allTokens, tokensToChainTokenMap(current))\n          } catch (error) {\n            console.error('Could not show token list due to error', error)\n            return allTokens\n          }\n        }, {})\n    )\n  }, [lists, urls])\n}\n\n// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(): TokenAddressMap {\n  const activeTokens = useCombinedTokenMapFromUrls(DEFAULT_ACTIVE_LIST_URLS)\n  return activeTokens\n}\n\n// list of tokens not supported on interface for various reasons, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(): TokenAddressMap {\n  // get hard-coded broken tokens\n  const brokenListMap = useMemo(() => tokensToChainTokenMap(BROKEN_LIST), [])\n\n  // get dynamic list of unsupported tokens\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS)\n\n  // format into one token address map\n  return useMemo(() => combineMaps(brokenListMap, loadedUnsupportedListMap), [brokenListMap, loadedUnsupportedListMap])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}