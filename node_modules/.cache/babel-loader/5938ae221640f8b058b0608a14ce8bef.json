{"ast":null,"code":"'use strict';\n\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\nvar _decode = function decode(string, alphabet, bitsPerChar) {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  var codes = {};\n  for (var i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  // Count the padding bytes:\n  var end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  // Allocate the output:\n  var out = new Uint8Array(end * bitsPerChar / 8 | 0);\n\n  // Parse the data:\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  var written = 0; // Next byte to write\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = codes[string[_i]];\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    }\n\n    // Append the bits to the buffer:\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nvar _encode = function encode(data, alphabet, bitsPerChar) {\n  var pad = alphabet[alphabet.length - 1] === '=';\n  var mask = (1 << bitsPerChar) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\n\n/**\n * RFC4648 Factory\n *\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\nvar rfc4648 = function rfc4648(bitsPerChar) {\n  return function (alphabet) {\n    return {\n      /**\n       * @param {Uint8Array} input\n       * @returns {string}\n       */\n      encode: function encode(input) {\n        return _encode(input, alphabet, bitsPerChar);\n      },\n      /**\n       * @param {string} input\n       * @returns {Uint8Array}\n       */\n      decode: function decode(input) {\n        return _decode(input, alphabet, bitsPerChar);\n      }\n    };\n  };\n};\nmodule.exports = {\n  rfc4648: rfc4648\n};","map":{"version":3,"names":["decode","string","alphabet","bitsPerChar","codes","i","length","end","out","Uint8Array","bits","buffer","written","value","undefined","SyntaxError","encode","data","pad","mask","rfc4648","input","module","exports"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/multibase/src/rfc4648.js"],"sourcesContent":["'use strict'\n\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[i])\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\nconst rfc4648 = (bitsPerChar) => (alphabet) => {\n  return {\n    /**\n     * @param {Uint8Array} input\n     * @returns {string}\n     */\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    /**\n     * @param {string} input\n     * @returns {Uint8Array}\n     */\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar)\n    }\n  }\n}\n\nmodule.exports = { rfc4648 }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}