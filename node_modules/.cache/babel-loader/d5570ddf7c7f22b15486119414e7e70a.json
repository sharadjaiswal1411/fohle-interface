{"ast":null,"code":"\"use strict\";\n\nfunction t(t) {\n  return t && \"object\" == typeof t && \"default\" in t ? t.default : t;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar e,\n  n = t(require(\"jsbi\")),\n  r = require(\"@ethersproject/abi\"),\n  o = t(require(\"tiny-invariant\")),\n  u = require(\"@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json\"),\n  i = require(\"@uniswap/v3-sdk\"),\n  a = require(\"@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json\"),\n  c = require(\"@uniswap/sdk-core\"),\n  s = require(\"@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json\"),\n  p = require(\"@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json\"),\n  d = require(\"@uniswap/v2-sdk\"),\n  l = require(\"@ethersproject/solidity\"),\n  m = \"0x0000000000000000000000000000000000000001\",\n  f = \"0x0000000000000000000000000000000000000002\",\n  h = n.BigInt(0),\n  v = n.BigInt(1);\nfunction A(t) {\n  return Object.keys(t).some(function (t) {\n    return \"recipient\" === t;\n  });\n}\n(e = exports.ApprovalTypes || (exports.ApprovalTypes = {}))[e.NOT_REQUIRED = 0] = \"NOT_REQUIRED\", e[e.MAX = 1] = \"MAX\", e[e.MAX_MINUS_ONE = 2] = \"MAX_MINUS_ONE\", e[e.ZERO_THEN_MAX = 3] = \"ZERO_THEN_MAX\", e[e.ZERO_THEN_MAX_MINUS_ONE = 4] = \"ZERO_THEN_MAX_MINUS_ONE\";\nvar y = function () {\n  function t() {}\n  return t.encodeApproveMax = function (e) {\n    return t.INTERFACE.encodeFunctionData(\"approveMax\", [e.address]);\n  }, t.encodeApproveMaxMinusOne = function (e) {\n    return t.INTERFACE.encodeFunctionData(\"approveMaxMinusOne\", [e.address]);\n  }, t.encodeApproveZeroThenMax = function (e) {\n    return t.INTERFACE.encodeFunctionData(\"approveZeroThenMax\", [e.address]);\n  }, t.encodeApproveZeroThenMaxMinusOne = function (e) {\n    return t.INTERFACE.encodeFunctionData(\"approveZeroThenMaxMinusOne\", [e.address]);\n  }, t.encodeCallPositionManager = function (e) {\n    if (e.length > 0 || o(!1), 1 == e.length) return t.INTERFACE.encodeFunctionData(\"callPositionManager\", e);\n    var n = i.NonfungiblePositionManager.INTERFACE.encodeFunctionData(\"multicall\", [e]);\n    return t.INTERFACE.encodeFunctionData(\"callPositionManager\", [n]);\n  }, t.encodeAddLiquidity = function (e, r, o, u) {\n    var a = e.mintAmountsWithSlippage(u),\n      c = a.amount0,\n      s = a.amount1;\n    return n.lessThan(r.amount0.quotient, c) && (c = r.amount0.quotient), n.lessThan(r.amount1.quotient, s) && (s = r.amount1.quotient), A(o) ? t.INTERFACE.encodeFunctionData(\"mint\", [{\n      token0: e.pool.token0.address,\n      token1: e.pool.token1.address,\n      fee: e.pool.fee,\n      tickLower: e.tickLower,\n      tickUpper: e.tickUpper,\n      amount0Min: i.toHex(c),\n      amount1Min: i.toHex(s),\n      recipient: o.recipient\n    }]) : t.INTERFACE.encodeFunctionData(\"increaseLiquidity\", [{\n      token0: e.pool.token0.address,\n      token1: e.pool.token1.address,\n      amount0Min: i.toHex(c),\n      amount1Min: i.toHex(s),\n      tokenId: i.toHex(o.tokenId)\n    }]);\n  }, t.encodeApprove = function (e, n) {\n    switch (n) {\n      case exports.ApprovalTypes.MAX:\n        return t.encodeApproveMax(e.wrapped);\n      case exports.ApprovalTypes.MAX_MINUS_ONE:\n        return t.encodeApproveMaxMinusOne(e.wrapped);\n      case exports.ApprovalTypes.ZERO_THEN_MAX:\n        return t.encodeApproveZeroThenMax(e.wrapped);\n      case exports.ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return t.encodeApproveZeroThenMaxMinusOne(e.wrapped);\n      default:\n        throw \"Error: invalid ApprovalType\";\n    }\n  }, t;\n}();\ny.INTERFACE = new r.Interface(u.abi);\nvar T = function () {\n  function t() {}\n  return t.encodeMulticall = function (e, n) {\n    if (void 0 === n) return i.Multicall.encodeMulticall(e);\n    if (Array.isArray(e) || (e = [e]), \"string\" == typeof n && n.startsWith(\"0x\")) {\n      var r = function (t) {\n        if (!t.match(/^0x[0-9a-fA-F]{64}$/)) throw new Error(t + \" is not valid bytes32.\");\n        return t.toLowerCase();\n      }(n);\n      return t.INTERFACE.encodeFunctionData(\"multicall(bytes32,bytes[])\", [r, e]);\n    }\n    var o = i.toHex(n);\n    return t.INTERFACE.encodeFunctionData(\"multicall(uint256,bytes[])\", [o, e]);\n  }, t;\n}();\nfunction w(t) {\n  return i.toHex(t.multiply(1e4).quotient);\n}\nT.INTERFACE = new r.Interface(a.abi);\nvar x = function () {\n  function t() {}\n  return t.encodeUnwrapWETH9 = function (e, n, r) {\n    if (\"string\" == typeof n) return i.Payments.encodeUnwrapWETH9(e, n, r);\n    if (r) {\n      var o = w(r.fee),\n        u = c.validateAndParseAddress(r.recipient);\n      return t.INTERFACE.encodeFunctionData(\"unwrapWETH9WithFee(uint256,uint256,address)\", [i.toHex(e), o, u]);\n    }\n    return t.INTERFACE.encodeFunctionData(\"unwrapWETH9(uint256)\", [i.toHex(e)]);\n  }, t.encodeSweepToken = function (e, n, r, o) {\n    if (\"string\" == typeof r) return i.Payments.encodeSweepToken(e, n, r, o);\n    if (o) {\n      var u = w(o.fee),\n        a = c.validateAndParseAddress(o.recipient);\n      return t.INTERFACE.encodeFunctionData(\"sweepTokenWithFee(address,uint256,uint256,address)\", [e.address, i.toHex(n), u, a]);\n    }\n    return t.INTERFACE.encodeFunctionData(\"sweepToken(address,uint256)\", [e.address, i.toHex(n)]);\n  }, t.encodePull = function (e, n) {\n    return t.INTERFACE.encodeFunctionData(\"pull\", [e.address, i.toHex(n)]);\n  }, t.encodeWrapETH = function (e) {\n    return t.INTERFACE.encodeFunctionData(\"wrapETH\", [i.toHex(e)]);\n  }, t;\n}();\nfunction E(t, e, n, r, o, u, i) {\n  try {\n    var a = t[u](i),\n      c = a.value;\n  } catch (t) {\n    return void n(t);\n  }\n  a.done ? e(c) : Promise.resolve(c).then(r, o);\n}\nfunction k(t) {\n  return function () {\n    var e = this,\n      n = arguments;\n    return new Promise(function (r, o) {\n      var u = t.apply(e, n);\n      function i(t) {\n        E(u, r, o, i, a, \"next\", t);\n      }\n      function a(t) {\n        E(u, r, o, i, a, \"throw\", t);\n      }\n      i(void 0);\n    });\n  };\n}\nfunction g(t, e) {\n  for (var n = 0; n < e.length; n++) {\n    var r = e[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n  }\n}\nfunction I(t, e, n) {\n  return e && g(t.prototype, e), n && g(t, n), t;\n}\nfunction P() {\n  return (P = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var r in n) {\n        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n      }\n    }\n    return t;\n  }).apply(this, arguments);\n}\nfunction R(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, (Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\nfunction _(t, e) {\n  (null == e || e > t.length) && (e = t.length);\n  for (var n = 0, r = new Array(e); n < e; n++) {\n    r[n] = t[n];\n  }\n  return r;\n}\nfunction b(t, e) {\n  var n = \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n  if (n) return (n = n.call(t)).next.bind(n);\n  if (Array.isArray(t) || (n = function (t, e) {\n    if (t) {\n      if (\"string\" == typeof t) return _(t, void 0);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _(t, void 0) : void 0;\n    }\n  }(t)) || e && t && \"number\" == typeof t.length) {\n    n && (t = n);\n    var r = 0;\n    return function () {\n      return r >= t.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: t[r++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nx.INTERFACE = new r.Interface(s.abi);\nvar O,\n  N = (function (t) {\n    var e = function (t) {\n      var e = Object.prototype,\n        n = e.hasOwnProperty,\n        r = \"function\" == typeof Symbol ? Symbol : {},\n        o = r.iterator || \"@@iterator\",\n        u = r.asyncIterator || \"@@asyncIterator\",\n        i = r.toStringTag || \"@@toStringTag\";\n      function a(t, e, n) {\n        return Object.defineProperty(t, e, {\n          value: n,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }), t[e];\n      }\n      try {\n        a({}, \"\");\n      } catch (t) {\n        a = function a(t, e, n) {\n          return t[e] = n;\n        };\n      }\n      function c(t, e, n, r) {\n        var o = Object.create((e && e.prototype instanceof d ? e : d).prototype),\n          u = new k(r || []);\n        return o._invoke = function (t, e, n) {\n          var r = \"suspendedStart\";\n          return function (o, u) {\n            if (\"executing\" === r) throw new Error(\"Generator is already running\");\n            if (\"completed\" === r) {\n              if (\"throw\" === o) throw u;\n              return {\n                value: void 0,\n                done: !0\n              };\n            }\n            for (n.method = o, n.arg = u;;) {\n              var i = n.delegate;\n              if (i) {\n                var a = w(i, n);\n                if (a) {\n                  if (a === p) continue;\n                  return a;\n                }\n              }\n              if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n                if (\"suspendedStart\" === r) throw r = \"completed\", n.arg;\n                n.dispatchException(n.arg);\n              } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n              r = \"executing\";\n              var c = s(t, e, n);\n              if (\"normal\" === c.type) {\n                if (r = n.done ? \"completed\" : \"suspendedYield\", c.arg === p) continue;\n                return {\n                  value: c.arg,\n                  done: n.done\n                };\n              }\n              \"throw\" === c.type && (r = \"completed\", n.method = \"throw\", n.arg = c.arg);\n            }\n          };\n        }(t, n, u), o;\n      }\n      function s(t, e, n) {\n        try {\n          return {\n            type: \"normal\",\n            arg: t.call(e, n)\n          };\n        } catch (t) {\n          return {\n            type: \"throw\",\n            arg: t\n          };\n        }\n      }\n      t.wrap = c;\n      var p = {};\n      function d() {}\n      function l() {}\n      function m() {}\n      var f = {};\n      a(f, o, function () {\n        return this;\n      });\n      var h = Object.getPrototypeOf,\n        v = h && h(h(g([])));\n      v && v !== e && n.call(v, o) && (f = v);\n      var A = m.prototype = d.prototype = Object.create(f);\n      function y(t) {\n        [\"next\", \"throw\", \"return\"].forEach(function (e) {\n          a(t, e, function (t) {\n            return this._invoke(e, t);\n          });\n        });\n      }\n      function T(t, e) {\n        var r;\n        this._invoke = function (o, u) {\n          function i() {\n            return new e(function (r, i) {\n              !function r(o, u, i, a) {\n                var c = s(t[o], t, u);\n                if (\"throw\" !== c.type) {\n                  var p = c.arg,\n                    d = p.value;\n                  return d && \"object\" == typeof d && n.call(d, \"__await\") ? e.resolve(d.__await).then(function (t) {\n                    r(\"next\", t, i, a);\n                  }, function (t) {\n                    r(\"throw\", t, i, a);\n                  }) : e.resolve(d).then(function (t) {\n                    p.value = t, i(p);\n                  }, function (t) {\n                    return r(\"throw\", t, i, a);\n                  });\n                }\n                a(c.arg);\n              }(o, u, r, i);\n            });\n          }\n          return r = r ? r.then(i, i) : i();\n        };\n      }\n      function w(t, e) {\n        var n = t.iterator[e.method];\n        if (void 0 === n) {\n          if (e.delegate = null, \"throw\" === e.method) {\n            if (t.iterator.return && (e.method = \"return\", e.arg = void 0, w(t, e), \"throw\" === e.method)) return p;\n            e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n          }\n          return p;\n        }\n        var r = s(n, t.iterator, e.arg);\n        if (\"throw\" === r.type) return e.method = \"throw\", e.arg = r.arg, e.delegate = null, p;\n        var o = r.arg;\n        return o ? o.done ? (e[t.resultName] = o.value, e.next = t.nextLoc, \"return\" !== e.method && (e.method = \"next\", e.arg = void 0), e.delegate = null, p) : o : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, p);\n      }\n      function x(t) {\n        var e = {\n          tryLoc: t[0]\n        };\n        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n      }\n      function E(t) {\n        var e = t.completion || {};\n        e.type = \"normal\", delete e.arg, t.completion = e;\n      }\n      function k(t) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], t.forEach(x, this), this.reset(!0);\n      }\n      function g(t) {\n        if (t) {\n          var e = t[o];\n          if (e) return e.call(t);\n          if (\"function\" == typeof t.next) return t;\n          if (!isNaN(t.length)) {\n            var r = -1,\n              u = function e() {\n                for (; ++r < t.length;) {\n                  if (n.call(t, r)) return e.value = t[r], e.done = !1, e;\n                }\n                return e.value = void 0, e.done = !0, e;\n              };\n            return u.next = u;\n          }\n        }\n        return {\n          next: I\n        };\n      }\n      function I() {\n        return {\n          value: void 0,\n          done: !0\n        };\n      }\n      return l.prototype = m, a(A, \"constructor\", m), a(m, \"constructor\", l), l.displayName = a(m, i, \"GeneratorFunction\"), t.isGeneratorFunction = function (t) {\n        var e = \"function\" == typeof t && t.constructor;\n        return !!e && (e === l || \"GeneratorFunction\" === (e.displayName || e.name));\n      }, t.mark = function (t) {\n        return Object.setPrototypeOf ? Object.setPrototypeOf(t, m) : (t.__proto__ = m, a(t, i, \"GeneratorFunction\")), t.prototype = Object.create(A), t;\n      }, t.awrap = function (t) {\n        return {\n          __await: t\n        };\n      }, y(T.prototype), a(T.prototype, u, function () {\n        return this;\n      }), t.AsyncIterator = T, t.async = function (e, n, r, o, u) {\n        void 0 === u && (u = Promise);\n        var i = new T(c(e, n, r, o), u);\n        return t.isGeneratorFunction(n) ? i : i.next().then(function (t) {\n          return t.done ? t.value : i.next();\n        });\n      }, y(A), a(A, i, \"Generator\"), a(A, o, function () {\n        return this;\n      }), a(A, \"toString\", function () {\n        return \"[object Generator]\";\n      }), t.keys = function (t) {\n        var e = [];\n        for (var n in t) {\n          e.push(n);\n        }\n        return e.reverse(), function n() {\n          for (; e.length;) {\n            var r = e.pop();\n            if (r in t) return n.value = r, n.done = !1, n;\n          }\n          return n.done = !0, n;\n        };\n      }, t.values = g, k.prototype = {\n        constructor: k,\n        reset: function reset(t) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = void 0, this.tryEntries.forEach(E), !t) for (var e in this) {\n            \"t\" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0);\n          }\n        },\n        stop: function stop() {\n          this.done = !0;\n          var t = this.tryEntries[0].completion;\n          if (\"throw\" === t.type) throw t.arg;\n          return this.rval;\n        },\n        dispatchException: function dispatchException(t) {\n          if (this.done) throw t;\n          var e = this;\n          function r(n, r) {\n            return i.type = \"throw\", i.arg = t, e.next = n, r && (e.method = \"next\", e.arg = void 0), !!r;\n          }\n          for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n            var u = this.tryEntries[o],\n              i = u.completion;\n            if (\"root\" === u.tryLoc) return r(\"end\");\n            if (u.tryLoc <= this.prev) {\n              var a = n.call(u, \"catchLoc\"),\n                c = n.call(u, \"finallyLoc\");\n              if (a && c) {\n                if (this.prev < u.catchLoc) return r(u.catchLoc, !0);\n                if (this.prev < u.finallyLoc) return r(u.finallyLoc);\n              } else if (a) {\n                if (this.prev < u.catchLoc) return r(u.catchLoc, !0);\n              } else {\n                if (!c) throw new Error(\"try statement without catch or finally\");\n                if (this.prev < u.finallyLoc) return r(u.finallyLoc);\n              }\n            }\n          }\n        },\n        abrupt: function abrupt(t, e) {\n          for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n            var o = this.tryEntries[r];\n            if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n              var u = o;\n              break;\n            }\n          }\n          u && (\"break\" === t || \"continue\" === t) && u.tryLoc <= e && e <= u.finallyLoc && (u = null);\n          var i = u ? u.completion : {};\n          return i.type = t, i.arg = e, u ? (this.method = \"next\", this.next = u.finallyLoc, p) : this.complete(i);\n        },\n        complete: function complete(t, e) {\n          if (\"throw\" === t.type) throw t.arg;\n          return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), p;\n        },\n        finish: function finish(t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var n = this.tryEntries[e];\n            if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), E(n), p;\n          }\n        },\n        catch: function _catch(t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var n = this.tryEntries[e];\n            if (n.tryLoc === t) {\n              var r = n.completion;\n              if (\"throw\" === r.type) {\n                var o = r.arg;\n                E(n);\n              }\n              return o;\n            }\n          }\n          throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function delegateYield(t, e, n) {\n          return this.delegate = {\n            iterator: g(t),\n            resultName: e,\n            nextLoc: n\n          }, \"next\" === this.method && (this.arg = void 0), p;\n        }\n      }, t;\n    }(t.exports);\n    try {\n      regeneratorRuntime = e;\n    } catch (t) {\n      \"object\" == typeof globalThis ? globalThis.regeneratorRuntime = e : Function(\"r\", \"regeneratorRuntime = r\")(e);\n    }\n  }(O = {\n    exports: {}\n  }), O.exports),\n  F = function () {\n    function t(t, e, n) {\n      this._midPrice = null, t.length > 0 || o(!1);\n      var r = t[0].chainId;\n      t.every(function (t) {\n        return t.chainId === r;\n      }) || o(!1);\n      var u = e.wrapped;\n      t[0].involvesToken(u) || o(!1), t[t.length - 1].involvesToken(n.wrapped) || o(!1);\n      for (var i, a = [u], c = b(t.entries()); !(i = c()).done;) {\n        var s = i.value,\n          p = s[1],\n          d = a[s[0]];\n        d.equals(p.token0) || d.equals(p.token1) || o(!1);\n        var l = d.equals(p.token0) ? p.token1 : p.token0;\n        a.push(l);\n      }\n      this.pools = t, this.path = a, this.input = e, this.output = null != n ? n : a[a.length - 1];\n    }\n    return I(t, [{\n      key: \"chainId\",\n      get: function get() {\n        return this.pools[0].chainId;\n      }\n    }, {\n      key: \"midPrice\",\n      get: function get() {\n        if (null !== this._midPrice) return this._midPrice;\n        var t = this.pools.slice(1).reduce(function (t, e) {\n          var n = t.price;\n          return t.nextInput.equals(e.token0) ? {\n            nextInput: e.token1,\n            price: n.multiply(e.token0Price)\n          } : {\n            nextInput: e.token0,\n            price: n.multiply(e.token1Price)\n          };\n        }, this.pools[0].token0.equals(this.input.wrapped) ? {\n          nextInput: this.pools[0].token1,\n          price: this.pools[0].token0Price\n        } : {\n          nextInput: this.pools[0].token0,\n          price: this.pools[0].token1Price\n        }).price;\n        return this._midPrice = new c.Price(this.input, this.output, t.denominator, t.numerator);\n      }\n    }]), t;\n  }();\nfunction q(t, e) {\n  return t.inputAmount.currency.equals(e.inputAmount.currency) || o(!1), t.outputAmount.currency.equals(e.outputAmount.currency) || o(!1), t.outputAmount.equalTo(e.outputAmount) ? t.inputAmount.equalTo(e.inputAmount) ? t.swaps.reduce(function (t, e) {\n    return t + e.route.path.length;\n  }, 0) - e.swaps.reduce(function (t, e) {\n    return t + e.route.path.length;\n  }, 0) : t.inputAmount.lessThan(e.inputAmount) ? -1 : 1 : t.outputAmount.lessThan(e.outputAmount) ? 1 : -1;\n}\nvar C,\n  M = function () {\n    function t(t) {\n      var e = t.routes,\n        n = t.tradeType,\n        r = e[0].inputAmount.currency,\n        u = e[0].outputAmount.currency;\n      e.every(function (t) {\n        return r.wrapped.equals(t.route.input.wrapped);\n      }) || o(!1), e.every(function (t) {\n        return u.wrapped.equals(t.route.output.wrapped);\n      }) || o(!1);\n      for (var a, s = e.map(function (t) {\n          return t.route.pools.length;\n        }).reduce(function (t, e) {\n          return t + e;\n        }, 0), p = new Set(), l = b(e); !(a = l()).done;) {\n        for (var m, f = b(a.value.route.pools); !(m = f()).done;) {\n          var h = m.value;\n          p.add(h instanceof i.Pool ? i.Pool.getAddress(h.token0, h.token1, h.fee) : d.Pair.getAddress(h.token0, h.token1));\n        }\n      }\n      s != p.size && o(!1), n !== c.TradeType.EXACT_INPUT && o(!1), this.swaps = e, this.tradeType = n;\n    }\n    t.fromRoute = function () {\n      var e = k(N.mark(function e(n, r, u) {\n        var i, a, s, p, d;\n        return N.wrap(function (e) {\n          for (;;) {\n            switch (e.prev = e.next) {\n              case 0:\n                i = new Array(n.path.length), u !== c.TradeType.EXACT_INPUT && o(!1), r.currency.equals(n.input) || o(!1), i[0] = r.wrapped, p = 0;\n              case 5:\n                if (!(p < n.path.length - 1)) {\n                  e.next = 15;\n                  break;\n                }\n                return d = n.pools[p], e.next = 9, d.getOutputAmount(i[p]);\n              case 9:\n                i[p + 1] = e.sent[0];\n              case 12:\n                p++, e.next = 5;\n                break;\n              case 15:\n                return a = c.CurrencyAmount.fromFractionalAmount(n.input, r.numerator, r.denominator), s = c.CurrencyAmount.fromFractionalAmount(n.output, i[i.length - 1].numerator, i[i.length - 1].denominator), e.abrupt(\"return\", new t({\n                  routes: [{\n                    inputAmount: a,\n                    outputAmount: s,\n                    route: n\n                  }],\n                  tradeType: u\n                }));\n              case 18:\n              case \"end\":\n                return e.stop();\n            }\n          }\n        }, e);\n      }));\n      return function (t, n, r) {\n        return e.apply(this, arguments);\n      };\n    }(), t.fromRoutes = function () {\n      var e = k(N.mark(function e(n, r) {\n        var u, i, a, s, p, d, l, m, f, h, v;\n        return N.wrap(function (e) {\n          for (;;) {\n            switch (e.prev = e.next) {\n              case 0:\n                u = [], r !== c.TradeType.EXACT_INPUT && o(!1), i = b(n);\n              case 3:\n                if ((a = i()).done) {\n                  e.next = 26;\n                  break;\n                }\n                p = (s = a.value).route, d = s.amount, l = new Array(p.path.length), m = void 0, f = void 0, d.currency.equals(p.input) || o(!1), m = c.CurrencyAmount.fromFractionalAmount(p.input, d.numerator, d.denominator), l[0] = c.CurrencyAmount.fromFractionalAmount(p.input.wrapped, d.numerator, d.denominator), h = 0;\n              case 12:\n                if (!(h < p.path.length - 1)) {\n                  e.next = 22;\n                  break;\n                }\n                return v = p.pools[h], e.next = 16, v.getOutputAmount(l[h]);\n              case 16:\n                l[h + 1] = e.sent[0];\n              case 19:\n                h++, e.next = 12;\n                break;\n              case 22:\n                f = c.CurrencyAmount.fromFractionalAmount(p.output, l[l.length - 1].numerator, l[l.length - 1].denominator), u.push({\n                  route: p,\n                  inputAmount: m,\n                  outputAmount: f\n                });\n              case 24:\n                e.next = 3;\n                break;\n              case 26:\n                return e.abrupt(\"return\", new t({\n                  routes: u,\n                  tradeType: r\n                }));\n              case 27:\n              case \"end\":\n                return e.stop();\n            }\n          }\n        }, e);\n      }));\n      return function (t, n) {\n        return e.apply(this, arguments);\n      };\n    }(), t.createUncheckedTrade = function (e) {\n      return new t(P({}, e, {\n        routes: [{\n          inputAmount: e.inputAmount,\n          outputAmount: e.outputAmount,\n          route: e.route\n        }]\n      }));\n    }, t.createUncheckedTradeWithMultipleRoutes = function (e) {\n      return new t(e);\n    };\n    var e = t.prototype;\n    return e.minimumAmountOut = function (t, e) {\n      void 0 === e && (e = this.outputAmount), t.lessThan(h) && o(!1);\n      var n = new c.Fraction(v).add(t).invert().multiply(e.quotient).quotient;\n      return c.CurrencyAmount.fromRawAmount(e.currency, n);\n    }, e.maximumAmountIn = function (t, e) {\n      return void 0 === e && (e = this.inputAmount), t.lessThan(h) && o(!1), e;\n    }, e.worstExecutionPrice = function (t) {\n      return new c.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(t).quotient, this.minimumAmountOut(t).quotient);\n    }, t.bestTradeExactIn = function () {\n      var e = k(N.mark(function e(n, r, u, i, a, s, p) {\n        var l, m, f, v, A, y, T, w, x, E, k;\n        return N.wrap(function (e) {\n          for (;;) {\n            switch (e.prev = e.next) {\n              case 0:\n                f = void 0 === (m = (l = void 0 === i ? {} : i).maxNumResults) ? 3 : m, A = void 0 === (v = l.maxHops) ? 3 : v, void 0 === a && (a = []), void 0 === s && (s = r), void 0 === p && (p = []), n.length > 0 || o(!1), A > 0 || o(!1), r === s || a.length > 0 || o(!1), y = s.wrapped, T = u.wrapped, w = 0;\n              case 10:\n                if (!(w < n.length)) {\n                  e.next = 49;\n                  break;\n                }\n                if ((x = n[w]).token0.equals(y.currency) || x.token1.equals(y.currency)) {\n                  e.next = 14;\n                  break;\n                }\n                return e.abrupt(\"continue\", 46);\n              case 14:\n                if (!(x instanceof d.Pair)) {\n                  e.next = 17;\n                  break;\n                }\n                if (!x.reserve0.equalTo(h) && !x.reserve1.equalTo(h)) {\n                  e.next = 17;\n                  break;\n                }\n                return e.abrupt(\"continue\", 46);\n              case 17:\n                return E = void 0, e.prev = 18, e.next = 22, x.getOutputAmount(y);\n              case 22:\n                E = e.sent[0], e.next = 31;\n                break;\n              case 26:\n                if (e.prev = 26, e.t0 = e.catch(18), !e.t0.isInsufficientInputAmountError) {\n                  e.next = 30;\n                  break;\n                }\n                return e.abrupt(\"continue\", 46);\n              case 30:\n                throw e.t0;\n              case 31:\n                if (!E.currency.isToken || !E.currency.equals(T)) {\n                  e.next = 42;\n                  break;\n                }\n                return e.t1 = c.sortedInsert, e.t2 = p, e.next = 36, t.fromRoute(new F([].concat(a, [x]), r.currency, u), r, c.TradeType.EXACT_INPUT);\n              case 36:\n                e.t3 = e.sent, e.t4 = f, e.t5 = q, (0, e.t1)(e.t2, e.t3, e.t4, e.t5), e.next = 46;\n                break;\n              case 42:\n                if (!(A > 1 && n.length > 1)) {\n                  e.next = 46;\n                  break;\n                }\n                return k = n.slice(0, w).concat(n.slice(w + 1, n.length)), e.next = 46, t.bestTradeExactIn(k, r, u, {\n                  maxNumResults: f,\n                  maxHops: A - 1\n                }, [].concat(a, [x]), E, p);\n              case 46:\n                w++, e.next = 10;\n                break;\n              case 49:\n                return e.abrupt(\"return\", p);\n              case 50:\n              case \"end\":\n                return e.stop();\n            }\n          }\n        }, e, null, [[18, 26]]);\n      }));\n      return function (t, n, r, o, u, i, a) {\n        return e.apply(this, arguments);\n      };\n    }(), I(t, [{\n      key: \"route\",\n      get: function get() {\n        return 1 != this.swaps.length && o(!1), this.swaps[0].route;\n      }\n    }, {\n      key: \"inputAmount\",\n      get: function get() {\n        if (this._inputAmount) return this._inputAmount;\n        var t = this.swaps[0].inputAmount.currency,\n          e = this.swaps.map(function (t) {\n            return t.inputAmount;\n          }).reduce(function (t, e) {\n            return t.add(e);\n          }, c.CurrencyAmount.fromRawAmount(t, 0));\n        return this._inputAmount = e, this._inputAmount;\n      }\n    }, {\n      key: \"outputAmount\",\n      get: function get() {\n        if (this._outputAmount) return this._outputAmount;\n        var t = this.swaps[0].outputAmount.currency,\n          e = this.swaps.map(function (t) {\n            return t.outputAmount;\n          }).reduce(function (t, e) {\n            return t.add(e);\n          }, c.CurrencyAmount.fromRawAmount(t, 0));\n        return this._outputAmount = e, this._outputAmount;\n      }\n    }, {\n      key: \"executionPrice\",\n      get: function get() {\n        var t;\n        return null != (t = this._executionPrice) ? t : this._executionPrice = new c.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n      }\n    }, {\n      key: \"priceImpact\",\n      get: function get() {\n        if (this._priceImpact) return this._priceImpact;\n        for (var t, e = c.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0), n = b(this.swaps); !(t = n()).done;) {\n          var r = t.value;\n          e = e.add(r.route.midPrice.quote(r.inputAmount));\n        }\n        var o = e.subtract(this.outputAmount).divide(e);\n        return this._priceImpact = new c.Percent(o.numerator, o.denominator), this._priceImpact;\n      }\n    }]), t;\n  }();\n(C = exports.Protocol || (exports.Protocol = {})).V2 = \"V2\", C.V3 = \"V3\", C.MIXED = \"MIXED\";\nvar S = function (t) {\n    function e(e) {\n      var n;\n      return (n = t.call(this, e.pairs, e.input, e.output) || this).protocol = exports.Protocol.V2, n.pools = n.pairs, n;\n    }\n    return R(e, t), e;\n  }(d.Route),\n  H = function (t) {\n    function e(e) {\n      var n;\n      return (n = t.call(this, e.pools, e.input, e.output) || this).protocol = exports.Protocol.V3, n.path = e.tokenPath, n;\n    }\n    return R(e, t), e;\n  }(i.Route),\n  U = function (t) {\n    function e(e) {\n      var n;\n      return (n = t.call(this, e.pools, e.input, e.output) || this).protocol = exports.Protocol.MIXED, n;\n    }\n    return R(e, t), e;\n  }(F),\n  D = function () {\n    function t(t) {\n      var e = t.v2Routes,\n        n = t.v3Routes,\n        r = t.tradeType,\n        u = t.mixedRoutes;\n      this.swaps = [], this.routes = [];\n      for (var a, c = b(e); !(a = c()).done;) {\n        var s = a.value,\n          p = s.inputAmount,\n          l = s.outputAmount,\n          m = new S(s.routev2);\n        this.routes.push(m), this.swaps.push({\n          route: m,\n          inputAmount: p,\n          outputAmount: l\n        });\n      }\n      for (var f, h = b(n); !(f = h()).done;) {\n        var v = f.value,\n          A = v.inputAmount,\n          y = v.outputAmount,\n          T = new H(v.routev3);\n        this.routes.push(T), this.swaps.push({\n          route: T,\n          inputAmount: A,\n          outputAmount: y\n        });\n      }\n      if (u) for (var w, x = b(u); !(w = x()).done;) {\n        var E = w.value,\n          k = E.inputAmount,\n          g = E.outputAmount,\n          I = new U(E.mixedRoute);\n        this.routes.push(I), this.swaps.push({\n          route: I,\n          inputAmount: k,\n          outputAmount: g\n        });\n      }\n      this.tradeType = r;\n      var P = this.swaps[0].inputAmount.currency,\n        R = this.swaps[0].outputAmount.currency;\n      this.swaps.every(function (t) {\n        return P.wrapped.equals(t.route.input.wrapped);\n      }) || o(!1), this.swaps.every(function (t) {\n        return R.wrapped.equals(t.route.output.wrapped);\n      }) || o(!1);\n      for (var _, O = this.swaps.map(function (t) {\n          return t.route.pools.length;\n        }).reduce(function (t, e) {\n          return t + e;\n        }, 0), N = new Set(), F = b(this.swaps); !(_ = F()).done;) {\n        for (var q, C = b(_.value.route.pools); !(q = C()).done;) {\n          var M = q.value;\n          if (M instanceof i.Pool) N.add(i.Pool.getAddress(M.token0, M.token1, M.fee));else {\n            if (!(M instanceof d.Pair)) throw new Error(\"Unexpected pool type in route when constructing trade object\");\n            N.add(d.Pair.getAddress(M.token0, M.token1));\n          }\n        }\n      }\n      O != N.size && o(!1);\n    }\n    var e = t.prototype;\n    return e.minimumAmountOut = function (t, e) {\n      if (void 0 === e && (e = this.outputAmount), t.lessThan(h) && o(!1), this.tradeType === c.TradeType.EXACT_OUTPUT) return e;\n      var n = new c.Fraction(v).add(t).invert().multiply(e.quotient).quotient;\n      return c.CurrencyAmount.fromRawAmount(e.currency, n);\n    }, e.maximumAmountIn = function (t, e) {\n      if (void 0 === e && (e = this.inputAmount), t.lessThan(h) && o(!1), this.tradeType === c.TradeType.EXACT_INPUT) return e;\n      var n = new c.Fraction(v).add(t).multiply(e.quotient).quotient;\n      return c.CurrencyAmount.fromRawAmount(e.currency, n);\n    }, e.worstExecutionPrice = function (t) {\n      return new c.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(t).quotient, this.minimumAmountOut(t).quotient);\n    }, t.fromRoutes = function () {\n      var e = k(N.mark(function e(n, r, o, u) {\n        var a, c, s, p, l, m, f, h, v, A, y, T, w, x, E, k, g, I, P, R;\n        return N.wrap(function (e) {\n          for (;;) {\n            switch (e.prev = e.next) {\n              case 0:\n                for (a = [], c = [], s = [], p = b(n); !(l = p()).done;) {\n                  h = new d.Trade(f = (m = l.value).routev2, m.amount, o), a.push({\n                    routev2: f,\n                    inputAmount: h.inputAmount,\n                    outputAmount: h.outputAmount\n                  });\n                }\n                v = b(r);\n              case 5:\n                if ((A = v()).done) {\n                  e.next = 14;\n                  break;\n                }\n                return T = (y = A.value).routev3, w = y.amount, e.next = 9, i.Trade.fromRoute(T, w, o);\n              case 9:\n                c.push({\n                  routev3: T,\n                  inputAmount: (x = e.sent).inputAmount,\n                  outputAmount: x.outputAmount\n                });\n              case 12:\n                e.next = 5;\n                break;\n              case 14:\n                if (!u) {\n                  e.next = 25;\n                  break;\n                }\n                E = b(u);\n              case 16:\n                if ((k = E()).done) {\n                  e.next = 25;\n                  break;\n                }\n                return I = (g = k.value).mixedRoute, P = g.amount, e.next = 20, M.fromRoute(I, P, o);\n              case 20:\n                s.push({\n                  mixedRoute: I,\n                  inputAmount: (R = e.sent).inputAmount,\n                  outputAmount: R.outputAmount\n                });\n              case 23:\n                e.next = 16;\n                break;\n              case 25:\n                return e.abrupt(\"return\", new t({\n                  v2Routes: a,\n                  v3Routes: c,\n                  mixedRoutes: s,\n                  tradeType: o\n                }));\n              case 26:\n              case \"end\":\n                return e.stop();\n            }\n          }\n        }, e);\n      }));\n      return function (t, n, r, o) {\n        return e.apply(this, arguments);\n      };\n    }(), t.fromRoute = function () {\n      var e = k(N.mark(function e(n, r, o) {\n        var u, a, c, s, p, l;\n        return N.wrap(function (e) {\n          for (;;) {\n            switch (e.prev = e.next) {\n              case 0:\n                if (u = [], a = [], c = [], !(n instanceof d.Route)) {\n                  e.next = 9;\n                  break;\n                }\n                s = new d.Trade(n, r, o), u = [{\n                  routev2: n,\n                  inputAmount: s.inputAmount,\n                  outputAmount: s.outputAmount\n                }], e.next = 26;\n                break;\n              case 9:\n                if (!(n instanceof i.Route)) {\n                  e.next = 17;\n                  break;\n                }\n                return e.next = 12, i.Trade.fromRoute(n, r, o);\n              case 12:\n                a = [{\n                  routev3: n,\n                  inputAmount: (p = e.sent).inputAmount,\n                  outputAmount: p.outputAmount\n                }], e.next = 26;\n                break;\n              case 17:\n                if (!(n instanceof F)) {\n                  e.next = 25;\n                  break;\n                }\n                return e.next = 20, M.fromRoute(n, r, o);\n              case 20:\n                c = [{\n                  mixedRoute: n,\n                  inputAmount: (l = e.sent).inputAmount,\n                  outputAmount: l.outputAmount\n                }], e.next = 26;\n                break;\n              case 25:\n                throw new Error(\"Invalid route type\");\n              case 26:\n                return e.abrupt(\"return\", new t({\n                  v2Routes: u,\n                  v3Routes: a,\n                  mixedRoutes: c,\n                  tradeType: o\n                }));\n              case 27:\n              case \"end\":\n                return e.stop();\n            }\n          }\n        }, e);\n      }));\n      return function (t, n, r) {\n        return e.apply(this, arguments);\n      };\n    }(), I(t, [{\n      key: \"inputAmount\",\n      get: function get() {\n        if (this._inputAmount) return this._inputAmount;\n        var t = this.swaps[0].inputAmount.currency,\n          e = this.swaps.map(function (t) {\n            return t.inputAmount;\n          }).reduce(function (t, e) {\n            return t.add(e);\n          }, c.CurrencyAmount.fromRawAmount(t, 0));\n        return this._inputAmount = e, this._inputAmount;\n      }\n    }, {\n      key: \"outputAmount\",\n      get: function get() {\n        if (this._outputAmount) return this._outputAmount;\n        var t = this.swaps[0].outputAmount.currency,\n          e = this.swaps.map(function (t) {\n            return t.outputAmount;\n          }).reduce(function (t, e) {\n            return t.add(e);\n          }, c.CurrencyAmount.fromRawAmount(t, 0));\n        return this._outputAmount = e, this._outputAmount;\n      }\n    }, {\n      key: \"executionPrice\",\n      get: function get() {\n        var t;\n        return null != (t = this._executionPrice) ? t : this._executionPrice = new c.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n      }\n    }, {\n      key: \"priceImpact\",\n      get: function get() {\n        if (this._priceImpact) return this._priceImpact;\n        for (var t, e = c.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0), n = b(this.swaps); !(t = n()).done;) {\n          var r = t.value;\n          e = e.add(r.route.midPrice.quote(r.inputAmount));\n        }\n        var o = e.subtract(this.outputAmount).divide(e);\n        return this._priceImpact = new c.Percent(o.numerator, o.denominator), this._priceImpact;\n      }\n    }]), t;\n  }();\nfunction L(t) {\n  var e = t.pools.reduce(function (t, e, n) {\n    var r = t.inputToken,\n      o = t.path,\n      u = t.types,\n      a = e.token0.equals(r) ? e.token1 : e.token0;\n    return 0 === n ? {\n      inputToken: a,\n      types: [\"address\", \"uint24\", \"address\"],\n      path: [r.address, e instanceof i.Pool ? e.fee : 8388608, a.address]\n    } : {\n      inputToken: a,\n      types: [].concat(u, [\"uint24\", \"address\"]),\n      path: [].concat(o, [e instanceof i.Pool ? e.fee : 8388608, a.address])\n    };\n  }, {\n    inputToken: t.input.wrapped,\n    path: [],\n    types: []\n  });\n  return l.pack(e.types, e.path);\n}\nvar X = function X(t) {\n    for (var e = [], n = 0, r = 0; r < t.pools.length;) {\n      (t.pools[n] instanceof i.Pool && t.pools[r] instanceof d.Pair || t.pools[n] instanceof d.Pair && t.pools[r] instanceof i.Pool) && (e.push(t.pools.slice(n, r)), n = r), ++r === t.pools.length && e.push(t.pools.slice(n, r));\n    }\n    return e;\n  },\n  j = function j(t, e) {\n    return t.reduce(function (t, e) {\n      var n = t.inputToken;\n      if (!e.involvesToken(n)) throw new Error(\"PATH\");\n      return {\n        inputToken: e.token0.equals(n) ? e.token1 : e.token0\n      };\n    }, {\n      inputToken: e\n    }).inputToken;\n  },\n  W = n.BigInt(0),\n  V = new c.Percent(n.BigInt(50), n.BigInt(100)),\n  Z = function () {\n    function t() {}\n    return t.encodeV2Swap = function (e, n, r, o) {\n      var u = i.toHex(e.maximumAmountIn(n.slippageTolerance).quotient),\n        a = i.toHex(e.minimumAmountOut(n.slippageTolerance).quotient),\n        s = e.route.path.map(function (t) {\n          return t.address;\n        }),\n        p = r ? f : void 0 === n.recipient ? m : c.validateAndParseAddress(n.recipient);\n      return e.tradeType === c.TradeType.EXACT_INPUT ? t.INTERFACE.encodeFunctionData(\"swapExactTokensForTokens\", [u, o ? 0 : a, s, p]) : t.INTERFACE.encodeFunctionData(\"swapTokensForExactTokens\", [a, u, s, p]);\n    }, t.encodeV3Swap = function (e, n, r, o) {\n      for (var u, a = [], s = b(e.swaps); !(u = s()).done;) {\n        var p = u.value,\n          d = p.route,\n          l = p.outputAmount,\n          h = i.toHex(e.maximumAmountIn(n.slippageTolerance, p.inputAmount).quotient),\n          v = i.toHex(e.minimumAmountOut(n.slippageTolerance, l).quotient),\n          A = 1 === d.pools.length,\n          y = r ? f : void 0 === n.recipient ? m : c.validateAndParseAddress(n.recipient);\n        if (A) a.push(e.tradeType === c.TradeType.EXACT_INPUT ? t.INTERFACE.encodeFunctionData(\"exactInputSingle\", [{\n          tokenIn: d.tokenPath[0].address,\n          tokenOut: d.tokenPath[1].address,\n          fee: d.pools[0].fee,\n          recipient: y,\n          amountIn: h,\n          amountOutMinimum: o ? 0 : v,\n          sqrtPriceLimitX96: 0\n        }]) : t.INTERFACE.encodeFunctionData(\"exactOutputSingle\", [{\n          tokenIn: d.tokenPath[0].address,\n          tokenOut: d.tokenPath[1].address,\n          fee: d.pools[0].fee,\n          recipient: y,\n          amountOut: v,\n          amountInMaximum: h,\n          sqrtPriceLimitX96: 0\n        }]));else {\n          var T = i.encodeRouteToPath(d, e.tradeType === c.TradeType.EXACT_OUTPUT);\n          a.push(e.tradeType === c.TradeType.EXACT_INPUT ? t.INTERFACE.encodeFunctionData(\"exactInput\", [{\n            path: T,\n            recipient: y,\n            amountIn: h,\n            amountOutMinimum: o ? 0 : v\n          }]) : t.INTERFACE.encodeFunctionData(\"exactOutput\", [{\n            path: T,\n            recipient: y,\n            amountOut: v,\n            amountInMaximum: h\n          }]));\n        }\n      }\n      return a;\n    }, t.encodeMixedRouteSwap = function (e, n, r, u) {\n      var a = [];\n      e.tradeType !== c.TradeType.EXACT_INPUT && o(!1);\n      for (var s, p = b(e.swaps); !(s = p()).done;) {\n        var d = s.value,\n          l = d.route,\n          h = d.outputAmount,\n          v = i.toHex(e.maximumAmountIn(n.slippageTolerance, d.inputAmount).quotient),\n          A = i.toHex(e.minimumAmountOut(n.slippageTolerance, h).quotient),\n          y = 1 === l.pools.length,\n          T = r ? f : void 0 === n.recipient ? m : c.validateAndParseAddress(n.recipient),\n          w = function w(t) {\n            return t.pools.every(function (t) {\n              return t instanceof i.Pool;\n            });\n          };\n        if (y) {\n          if (w(l)) a.push(t.INTERFACE.encodeFunctionData(\"exactInputSingle\", [{\n            tokenIn: l.path[0].address,\n            tokenOut: l.path[1].address,\n            fee: l.pools[0].fee,\n            recipient: T,\n            amountIn: v,\n            amountOutMinimum: u ? 0 : A,\n            sqrtPriceLimitX96: 0\n          }]));else {\n            var x = l.path.map(function (t) {\n              return t.address;\n            });\n            a.push(t.INTERFACE.encodeFunctionData(\"swapExactTokensForTokens\", [v, u ? 0 : A, x, T]));\n          }\n        } else !function () {\n          for (var e = X(l), n = function n(t) {\n              return t === e.length - 1;\n            }, r = void 0, o = l.input.wrapped, u = 0; u < e.length; u++) {\n            var i = e[u];\n            r = j(i, o);\n            var c = new F([].concat(i), i[0].token0.equals(o) ? i[0].token0 : i[0].token1, r),\n              s = new U(c);\n            if (o = r, w(s)) {\n              var p = {\n                path: L(s),\n                recipient: n(u) ? T : f,\n                amountIn: 0 == u ? v : 0,\n                amountOutMinimum: n(u) ? A : 0\n              };\n              a.push(t.INTERFACE.encodeFunctionData(\"exactInput\", [p]));\n            } else {\n              var d = [0 == u ? v : 0, n(u) ? A : 0, s.path.map(function (t) {\n                return t.address;\n              }), n(u) ? T : f];\n              a.push(t.INTERFACE.encodeFunctionData(\"swapExactTokensForTokens\", d));\n            }\n          }\n        }();\n      }\n      return a;\n    }, t.encodeSwaps = function (e, n, r) {\n      if (e instanceof D) {\n        e.swaps.every(function (t) {\n          return t.route.protocol == exports.Protocol.V3 || t.route.protocol == exports.Protocol.V2 || t.route.protocol == exports.Protocol.MIXED;\n        }) || o(!1);\n        for (var u, a = [], s = b(e.swaps); !(u = s()).done;) {\n          var p = u.value,\n            l = p.route,\n            m = p.inputAmount,\n            f = p.outputAmount;\n          if (l.protocol == exports.Protocol.V2) a.push(new d.Trade(l, e.tradeType == c.TradeType.EXACT_INPUT ? m : f, e.tradeType));else if (l.protocol == exports.Protocol.V3) a.push(i.Trade.createUncheckedTrade({\n            route: l,\n            inputAmount: m,\n            outputAmount: f,\n            tradeType: e.tradeType\n          }));else {\n            if (l.protocol != exports.Protocol.MIXED) throw new Error(\"UNSUPPORTED_TRADE_PROTOCOL\");\n            a.push(M.createUncheckedTrade({\n              route: l,\n              inputAmount: m,\n              outputAmount: f,\n              tradeType: e.tradeType\n            }));\n          }\n        }\n        e = a;\n      }\n      Array.isArray(e) || (e = [e]);\n      var h = e.reduce(function (t, e) {\n          return t + (e instanceof i.Trade || e instanceof M ? e.swaps.length : 1);\n        }, 0),\n        v = e[0];\n      e.every(function (t) {\n        return t.inputAmount.currency.equals(v.inputAmount.currency);\n      }) || o(!1), e.every(function (t) {\n        return t.outputAmount.currency.equals(v.outputAmount.currency);\n      }) || o(!1), e.every(function (t) {\n        return t.tradeType === v.tradeType;\n      }) || o(!1);\n      var A = [],\n        y = v.inputAmount.currency.isNative,\n        T = v.outputAmount.currency.isNative,\n        w = v.tradeType === c.TradeType.EXACT_INPUT && h > 2,\n        x = T || !!n.fee || !!r || w;\n      n.inputTokenPermit && (v.inputAmount.currency.isToken || o(!1), A.push(i.SelfPermit.encodePermit(v.inputAmount.currency, n.inputTokenPermit)));\n      for (var E, k = b(e); !(E = k()).done;) {\n        var g = E.value;\n        if (g instanceof d.Trade) A.push(t.encodeV2Swap(g, n, x, w));else if (g instanceof i.Trade) for (var I, P = b(t.encodeV3Swap(g, n, x, w)); !(I = P()).done;) {\n          A.push(I.value);\n        } else {\n          if (!(g instanceof M)) throw new Error(\"Unsupported trade object\");\n          for (var R, _ = b(t.encodeMixedRouteSwap(g, n, x, w)); !(R = _()).done;) {\n            A.push(R.value);\n          }\n        }\n      }\n      var O = c.CurrencyAmount.fromRawAmount(v.inputAmount.currency, 0),\n        N = c.CurrencyAmount.fromRawAmount(v.outputAmount.currency, 0),\n        F = e.reduce(function (t, e) {\n          return t.add(e.minimumAmountOut(n.slippageTolerance));\n        }, N),\n        q = e.reduce(function (t, e) {\n          return t.add(e.outputAmount);\n        }, N),\n        C = e.reduce(function (t, e) {\n          return t.add(e.maximumAmountIn(n.slippageTolerance));\n        }, O);\n      return {\n        calldatas: A,\n        sampleTrade: v,\n        routerMustCustody: x,\n        inputIsNative: y,\n        outputIsNative: T,\n        totalAmountIn: C,\n        minimumAmountOut: F,\n        quoteAmountOut: q\n      };\n    }, t.swapCallParameters = function (e, n) {\n      var r = t.encodeSwaps(e, n),\n        o = r.calldatas,\n        u = r.sampleTrade,\n        a = r.inputIsNative,\n        s = r.totalAmountIn,\n        p = r.minimumAmountOut;\n      return r.routerMustCustody && o.push(r.outputIsNative ? x.encodeUnwrapWETH9(p.quotient, n.recipient, n.fee) : x.encodeSweepToken(u.outputAmount.currency.wrapped, p.quotient, n.recipient, n.fee)), a && (u.tradeType === c.TradeType.EXACT_OUTPUT || t.riskOfPartialFill(e)) && o.push(i.Payments.encodeRefundETH()), {\n        calldata: T.encodeMulticall(o, n.deadlineOrPreviousBlockhash),\n        value: i.toHex(a ? s.quotient : W)\n      };\n    }, t.swapAndAddCallParameters = function (e, n, r, u, a, s) {\n      var p = t.encodeSwaps(e, n, !0),\n        d = p.calldatas,\n        l = p.inputIsNative,\n        m = p.outputIsNative,\n        f = p.sampleTrade,\n        h = p.totalAmountIn,\n        v = p.quoteAmountOut,\n        A = p.minimumAmountOut;\n      n.outputTokenPermit && (v.currency.isToken || o(!1), d.push(i.SelfPermit.encodePermit(v.currency, n.outputTokenPermit)));\n      var w = f.route.chainId,\n        E = r.pool.token0.wrapped.address === h.currency.wrapped.address,\n        k = t.getPositionAmounts(r, E),\n        g = k.positionAmountIn,\n        I = k.positionAmountOut,\n        P = l ? c.WETH9[w] : g.currency.wrapped,\n        R = m ? c.WETH9[w] : I.currency.wrapped,\n        _ = I.subtract(v.wrapped);\n      _.greaterThan(c.CurrencyAmount.fromRawAmount(I.currency, 0)) && d.push(m ? x.encodeWrapETH(_.quotient) : x.encodePull(R, _.quotient)), d.push(l ? x.encodeWrapETH(g.quotient) : x.encodePull(P, g.quotient)), a !== exports.ApprovalTypes.NOT_REQUIRED && d.push(y.encodeApprove(P, a)), s !== exports.ApprovalTypes.NOT_REQUIRED && d.push(y.encodeApprove(R, s));\n      var b,\n        O = i.Position.fromAmounts({\n          pool: r.pool,\n          tickLower: r.tickLower,\n          tickUpper: r.tickUpper,\n          amount0: E ? r.amount0.quotient.toString() : A.quotient.toString(),\n          amount1: E ? A.quotient.toString() : r.amount1.quotient.toString(),\n          useFullPrecision: !1\n        });\n      return d.push(y.encodeAddLiquidity(r, O, u, n.slippageTolerance)), d.push(l ? x.encodeUnwrapWETH9(W) : x.encodeSweepToken(P, W)), d.push(m ? x.encodeUnwrapWETH9(W) : x.encodeSweepToken(R, W)), b = l ? h.wrapped.add(g.wrapped).quotient : m ? _.quotient : W, {\n        calldata: T.encodeMulticall(d, n.deadlineOrPreviousBlockhash),\n        value: b.toString()\n      };\n    }, t.riskOfPartialFill = function (e) {\n      return Array.isArray(e) ? e.some(function (e) {\n        return t.v3TradeWithHighPriceImpact(e);\n      }) : t.v3TradeWithHighPriceImpact(e);\n    }, t.v3TradeWithHighPriceImpact = function (t) {\n      return !(t instanceof d.Trade) && t.priceImpact.greaterThan(V);\n    }, t.getPositionAmounts = function (t, e) {\n      var n = t.mintAmounts,\n        r = n.amount1,\n        o = c.CurrencyAmount.fromRawAmount(t.pool.token0, n.amount0),\n        u = c.CurrencyAmount.fromRawAmount(t.pool.token1, r),\n        i = e ? [o, u] : [u, o];\n      return {\n        positionAmountIn: i[0],\n        positionAmountOut: i[1]\n      };\n    }, t;\n  }();\nZ.INTERFACE = new r.Interface(p.abi), exports.ADDRESS_THIS = f, exports.ApproveAndCall = y, exports.MSG_SENDER = m, exports.MixedRoute = U, exports.MixedRouteSDK = F, exports.MixedRouteTrade = M, exports.MulticallExtended = T, exports.ONE = v, exports.PaymentsExtended = x, exports.RouteV2 = S, exports.RouteV3 = H, exports.SwapRouter = Z, exports.Trade = D, exports.V2_FEE_PATH_PLACEHOLDER = 8388608, exports.ZERO = h, exports.encodeMixedRouteToPath = L, exports.getOutputOfPools = j, exports.isMint = A, exports.partitionMixedRouteByProtocol = X, exports.tradeComparator = q;","map":{"version":3,"sources":["../src/approveAndCall.ts","../src/constants.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../node_modules/regenerator-runtime/runtime.js","../src/entities/mixedRoute/route.ts","../src/entities/mixedRoute/trade.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/utils/encodeMixedRouteToPath.ts","../src/utils/index.ts","../src/swapRouter.ts"],"names":["ApprovalTypes","isMint","options","Object","keys","some","k","ApproveAndCall","Interface","abi","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","invariant","length","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","amount0","amount0Min","amount1","amount1Min","mintAmountsWithSlippage","JSBI","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","MSG_SENDER","ADDRESS_THIS","ZERO","BigInt","ONE","bytes32","match","Error","toLowerCase","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","validateAndParseBytes32","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","runtime","exports","Op","prototype","hasOwn","hasOwnProperty","undefined","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","Generator","generator","create","context","Context","_invoke","makeInvokeMethod","tryCatch","fn","arg","type","call","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","displayName","defineIteratorMethods","forEach","method","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","__await","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","async","Promise","iter","next","done","state","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","object","reverse","pop","iterable","iteratorMethod","isNaN","i","doneResult","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","MixedRouteSDK","pools","input","output","chainId","every","wrappedInput","involvesToken","tokenPath","entries","currentInputToken","equals","nextToken","path","_midPrice","price","reduce","nextInput","token0Price","token1Price","Price","denominator","numerator","tradeComparator","a","b","inputAmount","currency","outputAmount","equalTo","swaps","total","cur","route","MixedRouteTrade","_inputAmount","inputCurrency","totalInputFromRoutes","map","add","CurrencyAmount","fromRawAmount","_outputAmount","outputCurrency","totalOutputFromRoutes","_executionPrice","_priceImpact","spotOutputAmount","midPrice","quote","priceImpact","subtract","divide","Percent","fromRoute","tradeType","amounts","TradeType","EXACT_INPUT","getOutputAmount","fromFractionalAmount","routes","fromRoutes","populatedRoutes","createUncheckedTrade","constructorArguments","createUncheckedTradeWithMultipleRoutes","numPools","poolAddressSet","Set","Pool","getAddress","Pair","size","minimumAmountOut","amountOut","slippageAdjustedAmountOut","Fraction","invert","maximumAmountIn","amountIn","worstExecutionPrice","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPools","nextAmountIn","bestTrades","tokenOut","reserve0","reserve1","_context3","isInsufficientInputAmountError","isToken","sortedInsert","poolsExcludingThisPool","concat","Protocol","RouteV2","V2RouteSDK","V2","v2Route","pairs","_this","RouteV3","V3RouteSDK","V3","v3Route","MixedRoute","MIXED","mixedRoute","Trade","v2Routes","v3Routes","mixedRoutes","routev2","routev3","EXACT_OUTPUT","slippageAdjustedAmountIn","populatedV2Routes","populatedV3Routes","populatedMixedRoutes","v2Trade","V2TradeSDK","v3Trade","V3TradeSDK","mixedRouteTrade","MixedRouteTradeSDK","encodeMixedRouteToPath","types","inputToken","index","outputToken","pack","partitionMixedRouteByProtocol","acc","left","right","getOutputOfPools","firstInputToken","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","encodeV3Swap","singleHop","tokenIn","amountOutMinimum","sqrtPriceLimitX96","amountInMaximum","encodeRouteToPath","encodeMixedRouteSwap","mixedRouteIsAllV3","sections","isLastSectionInRoute","section","newRouteOriginal","newRoute","exactInputParams","encodeSwaps","trades","isSwapAndAdd","swap","protocol","individualTrades","V2Trade","V3Trade","numberOfTrades","sampleTrade","inputIsNative","isNative","outputIsNative","inputTokenPermit","SelfPermit","encodePermit","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","riskOfPartialFill","encodeRefundETH","calldata","deadlineOrPreviousBlockhash","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","totalAmountSwapped","outputTokenPermit","zeroForOne","positionAmountIn","positionAmountOut","getPositionAmounts","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw 'Error: invalid ApprovalType'\n    }\n  }\n}\n","import JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n\n// = 1 << 23 or 100000000000000000000000\nexport const V2_FEE_PATH_PLACEHOLDER = 8388608\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\n\ntype TPool = Pair | Pool\n\n/**\n * Represents a list of pools or pairs through which a swap can occur\n * @template TInput The input token\n * @template TOutput The output token\n */\nexport class MixedRouteSDK<TInput extends Currency, TOutput extends Currency> {\n  public readonly pools: TPool[]\n  public readonly path: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  /**\n   * Creates an instance of route.\n   * @param pools An array of `TPool` objects (pools or pairs), ordered by the route the swap will take\n   * @param input The input token\n   * @param output The output token\n   */\n  public constructor(pools: TPool[], input: TInput, output: TOutput) {\n    invariant(pools.length > 0, 'POOLS')\n\n    const chainId = pools[0].chainId\n    const allOnSameChain = pools.every((pool) => pool.chainId === chainId)\n    invariant(allOnSameChain, 'CHAIN_IDS')\n\n    const wrappedInput = input.wrapped\n    invariant(pools[0].involvesToken(wrappedInput), 'INPUT')\n\n    invariant(pools[pools.length - 1].involvesToken(output.wrapped), 'OUTPUT')\n\n    /**\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\n     * */\n    const tokenPath: Token[] = [wrappedInput]\n    for (const [i, pool] of pools.entries()) {\n      const currentInputToken = tokenPath[i]\n      invariant(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1), 'PATH')\n      const nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0\n      tokenPath.push(nextToken)\n    }\n\n    this.pools = pools\n    this.path = tokenPath\n    this.input = input\n    this.output = output ?? tokenPath[tokenPath.length - 1]\n  }\n\n  public get chainId(): number {\n    return this.pools[0].chainId\n  }\n\n  /**\n   * Returns the mid price of the route\n   */\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n\n    const price = this.pools.slice(1).reduce(\n      ({ nextInput, price }, pool) => {\n        return nextInput.equals(pool.token0)\n          ? {\n              nextInput: pool.token1,\n              price: price.multiply(pool.token0Price),\n            }\n          : {\n              nextInput: pool.token0,\n              price: price.multiply(pool.token1Price),\n            }\n      },\n      this.pools[0].token0.equals(this.input.wrapped)\n        ? {\n            nextInput: this.pools[0].token1,\n            price: this.pools[0].token0Price,\n          }\n        : {\n            nextInput: this.pools[0].token0,\n            price: this.pools[0].token1Price,\n          }\n    ).price\n\n    return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))\n  }\n}\n","import { Currency, Fraction, Percent, Price, sortedInsert, CurrencyAmount, TradeType, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { BestTradeOptions, Pool } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../../constants'\nimport { MixedRouteSDK } from './route'\n\n/**\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n * @param a The first trade to compare\n * @param b The second trade to compare\n * @returns A sorted ordering for two neighboring elements in a trade array\n */\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: MixedRouteTrade<TInput, TOutput, TTradeType>,\n  b: MixedRouteTrade<TInput, TOutput, TTradeType>\n) {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      // consider the number of hops since each hop costs gas\n      const aHops = a.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      const bHops = b.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      return aHops - bHops\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n/**\n * Represents a trade executed against a set of routes where some percentage of the input is\n * split across each route.\n *\n * Each route has its own set of pools. Pools can not be re-used across routes.\n *\n * Does not account for slippage, i.e., changes in price environment that can occur between\n * the time the trade is submitted and when it is executed.\n * @notice This class is functionally the same as the `Trade` class in the `@uniswap/v3-sdk` package, aside from typing and some input validation.\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n */\nexport class MixedRouteTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\n   * this will return an error.\n   *\n   * When the trade consists of just a single route, this returns the route of the trade,\n   * i.e. which pools the trade goes through.\n   */\n  public get route(): MixedRouteSDK<TInput, TOutput> {\n    invariant(this.swaps.length == 1, 'MULTIPLE_ROUTES')\n    return this.swaps[0].route\n  }\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade.\n   */\n  public readonly swaps: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n\n  /**\n   * The cached result of the input amount computation\n   * @private\n   */\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  /**\n   * The cached result of the output amount computation\n   * @private\n   */\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  /**\n   * The cached result of the computed execution price\n   * @private\n   */\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Constructs a trade by simulating swaps through the given route\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param route route to swap through\n   * @param amount the amount specified, either input or output, depending on tradeType\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The route\n   */\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const amounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n    let inputAmount: CurrencyAmount<TInput>\n    let outputAmount: CurrencyAmount<TOutput>\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    invariant(amount.currency.equals(route.input), 'INPUT')\n    amounts[0] = amount.wrapped\n    for (let i = 0; i < route.path.length - 1; i++) {\n      const pool = route.pools[i]\n      const [outputAmount] = await pool.getOutputAmount(amounts[i])\n      amounts[i + 1] = outputAmount\n    }\n    inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n    outputAmount = CurrencyAmount.fromFractionalAmount(\n      route.output,\n      amounts[amounts.length - 1].numerator,\n      amounts[amounts.length - 1].denominator\n    )\n\n    return new MixedRouteTrade({\n      routes: [{ inputAmount, outputAmount, route }],\n      tradeType,\n    })\n  }\n\n  /**\n   * Constructs a trade from routes by simulating swaps\n   *\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param routes the routes to swap through and how much of the amount should be routed through each\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The trade\n   */\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    routes: {\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n      route: MixedRouteSDK<TInput, TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const populatedRoutes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, amount } of routes) {\n      const amounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n      let inputAmount: CurrencyAmount<TInput>\n      let outputAmount: CurrencyAmount<TOutput>\n\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      amounts[0] = CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator)\n\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pool = route.pools[i]\n        const [outputAmount] = await pool.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n      }\n\n      outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        amounts[amounts.length - 1].numerator,\n        amounts[amounts.length - 1].denominator\n      )\n\n      populatedRoutes.push({ route, inputAmount, outputAmount })\n    }\n\n    return new MixedRouteTrade({\n      routes: populatedRoutes,\n      tradeType,\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTrade<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade({\n      ...constructorArguments,\n      routes: [\n        {\n          inputAmount: constructorArguments.inputAmount,\n          outputAmount: constructorArguments.outputAmount,\n          route: constructorArguments.route,\n        },\n      ],\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTradeWithMultipleRoutes<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade(constructorArguments)\n  }\n\n  /**\n   * Construct a trade by passing in the pre-computed property values\n   * @param routes The routes through which the trade occurs\n   * @param tradeType The type of trade, exact input or exact output\n   */\n  private constructor({\n    routes,\n    tradeType,\n  }: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    const inputCurrency = routes[0].inputAmount.currency\n    const outputCurrency = routes[0].outputAmount.currency\n    invariant(\n      routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    const numPools = routes.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of routes) {\n      for (const pool of route.pools) {\n        pool instanceof Pool\n          ? poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee))\n          : poolAddressSet.add(Pair.getAddress(pool.token0, pool.token1))\n      }\n    }\n\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    this.swaps = routes\n    this.tradeType = tradeType\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    /// does not support exactOutput, as enforced in the constructor\n    const slippageAdjustedAmountOut = new Fraction(ONE)\n      .add(slippageTolerance)\n      .invert()\n      .multiply(amountOut.quotient).quotient\n    return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    return amountIn\n    /// does not support exactOutput\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pools the pools to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\n   * @param currentPools used in recursion; the current list of pools\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   * @returns The exact in trade\n   */\n  public static async bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pools: (Pool | Pair)[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPools: (Pool | Pair)[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Promise<MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[]> {\n    invariant(pools.length > 0, 'POOLS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn.wrapped\n    const tokenOut = currencyOut.wrapped\n    for (let i = 0; i < pools.length; i++) {\n      const pool = pools[i]\n      // pool irrelevant\n      if (!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency)) continue\n      if (pool instanceof Pair) {\n        if ((pool as Pair).reserve0.equalTo(ZERO) || (pool as Pair).reserve1.equalTo(ZERO)) continue\n      }\n\n      let amountOut: CurrencyAmount<Token>\n      try {\n        ;[amountOut] = await pool.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        // @ts-ignore[2571] error is unknown\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          await MixedRouteTrade.fromRoute(\n            new MixedRouteSDK([...currentPools, pool], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pools.length > 1) {\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        await MixedRouteTrade.bestTradeExactIn(\n          poolsExcludingThisPool,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPools, pool],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n  MIXED = 'MIXED',\n}\n","// entities/route.ts\n\nimport { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { MixedRouteSDK } from './mixedRoute/route'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n\n// Mixed route wrapper\nexport class MixedRoute<TInput extends Currency, TOutput extends Currency>\n  extends MixedRouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool | Pair>\n{\n  public readonly protocol: Protocol = Protocol.MIXED\n\n  constructor(mixedRoute: MixedRouteSDK<TInput, TOutput>) {\n    super(mixedRoute.pools, mixedRoute.input, mixedRoute.output)\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../constants'\nimport { MixedRouteSDK } from './mixedRoute/route'\nimport { MixedRouteTrade as MixedRouteTradeSDK } from './mixedRoute/trade'\nimport { IRoute, MixedRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n    mixedRoutes,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap mixedRoutes\n    if (mixedRoutes) {\n      for (const { mixedRoute, inputAmount, outputAmount } of mixedRoutes) {\n        const route = new MixedRoute(mixedRoute)\n        this.routes.push(route)\n        this.swaps.push({\n          route,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (pool instanceof Pool) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[]\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedMixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    if (mixedRoutes) {\n      for (const { mixedRoute, amount } of mixedRoutes) {\n        const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(mixedRoute, amount, tradeType)\n        const { inputAmount, outputAmount } = mixedRouteTrade\n\n        populatedMixedRoutes.push({\n          mixedRoute,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      mixedRoutes: populatedMixedRoutes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput> | MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let mixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n    } else if (route instanceof V3RouteSDK) {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n    } else if (route instanceof MixedRouteSDK) {\n      const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = mixedRouteTrade\n      mixedRoutes = [{ mixedRoute: route, inputAmount, outputAmount }]\n    } else {\n      throw new Error('Invalid route type')\n    }\n\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      mixedRoutes,\n      tradeType,\n    })\n  }\n}\n","import { pack } from '@ethersproject/solidity'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\nimport { V2_FEE_PATH_PLACEHOLDER } from '../constants'\n\n/**\n * Converts a route to a hex encoded path\n * @notice only supports exactIn route encodings\n * @param route the mixed path to convert to an encoded path\n * @returns the exactIn encoded path\n */\nexport function encodeMixedRouteToPath(route: MixedRouteSDK<Currency, Currency>): string {\n  const firstInputToken: Token = route.input.wrapped\n\n  const { path, types } = route.pools.reduce(\n    (\n      { inputToken, path, types }: { inputToken: Token; path: (string | number)[]; types: string[] },\n      pool: Pool | Pair,\n      index\n    ): { inputToken: Token; path: (string | number)[]; types: string[] } => {\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [inputToken.address, pool instanceof Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address],\n        }\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [...types, 'uint24', 'address'],\n          path: [...path, pool instanceof Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address],\n        }\n      }\n    },\n    { inputToken: firstInputToken, path: [], types: [] }\n  )\n\n  return pack(types, path)\n}\n","import { Currency, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\n\n/**\n * Utility function to return each consecutive section of Pools or Pairs in a MixedRoute\n * @param route\n * @returns a nested array of Pools or Pairs in the order of the route\n */\nexport const partitionMixedRouteByProtocol = (route: MixedRouteSDK<Currency, Currency>): (Pool | Pair)[][] => {\n  let acc = []\n\n  let left = 0\n  let right = 0\n  while (right < route.pools.length) {\n    if (\n      (route.pools[left] instanceof Pool && route.pools[right] instanceof Pair) ||\n      (route.pools[left] instanceof Pair && route.pools[right] instanceof Pool)\n    ) {\n      acc.push(route.pools.slice(left, right))\n      left = right\n    }\n    // seek forward with right pointer\n    right++\n    if (right === route.pools.length) {\n      /// we reached the end, take the rest\n      acc.push(route.pools.slice(left, right))\n    }\n  }\n  return acc\n}\n\n/**\n * Simple utility function to get the output of an array of Pools or Pairs\n * @param pools\n * @param firstInputToken\n * @returns the output token of the last pool in the array\n */\nexport const getOutputOfPools = (pools: (Pool | Pair)[], firstInputToken: Token): Token => {\n  const { inputToken: outputToken } = pools.reduce(\n    ({ inputToken }, pool: Pool | Pair): { inputToken: Token } => {\n      if (!pool.involvesToken(inputToken)) throw new Error('PATH')\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      return {\n        inputToken: outputToken,\n      }\n    },\n    { inputToken: firstInputToken }\n  )\n  return outputToken\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Pool,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { MixedRoute, RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\nimport { MixedRouteTrade } from './entities/mixedRoute/trade'\nimport { encodeMixedRouteToPath } from './utils/encodeMixedRouteToPath'\nimport { MixedRouteSDK } from './entities/mixedRoute/route'\nimport { partitionMixedRouteByProtocol, getOutputOfPools } from './utils'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | MixedRouteTrade<Currency, Currency, TradeType>\n  | (\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    )[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * @notice Generates the calldata for a Swap with a V2 Route.\n   * @param trade The V2Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  /**\n   * @notice Generates the calldata for a Swap with a V3 Route.\n   * @param trade The V3Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  /**\n   * @notice Generates the calldata for a MixedRouteSwap. Since single hop routes are not MixedRoutes, we will instead generate\n   *         them via the existing encodeV3Swap and encodeV2Swap methods.\n   * @param trade The MixedRouteTrade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeMixedRouteSwap(\n    trade: MixedRouteTrade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    invariant(trade.tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n        return route.pools.every((pool) => pool instanceof Pool)\n      }\n\n      if (singleHop) {\n        /// For single hop, since it isn't really a mixedRoute, we'll just mimic behavior of V3 or V2\n        /// We don't use encodeV3Swap() or encodeV2Swap() because casting the trade to a V3Trade or V2Trade is overcomplex\n        if (mixedRouteIsAllV3(route)) {\n          const exactInputSingleParams = {\n            tokenIn: route.path[0].address,\n            tokenOut: route.path[1].address,\n            fee: (route.pools as Pool[])[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const path = route.path.map((token) => token.address)\n\n          const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n        }\n      } else {\n        const sections = partitionMixedRouteByProtocol(route)\n\n        const isLastSectionInRoute = (i: number) => {\n          return i === sections.length - 1\n        }\n\n        let outputToken\n        let inputToken = route.input.wrapped\n\n        for (let i = 0; i < sections.length; i++) {\n          const section = sections[i]\n          /// Now, we get output of this section\n          outputToken = getOutputOfPools(section, inputToken)\n\n          const newRouteOriginal = new MixedRouteSDK(\n            [...section],\n            section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n            outputToken\n          )\n          const newRoute = new MixedRoute(newRouteOriginal)\n\n          /// Previous output is now input\n          inputToken = outputToken\n\n          if (mixedRouteIsAllV3(newRoute)) {\n            const path: string = encodeMixedRouteToPath(newRoute)\n            const exactInputParams = {\n              path,\n              // By default router holds funds until the last swap, then it is sent to the recipient\n              // special case exists where we are unwrapping WETH output, in which case `routerMustCustody` is set to true\n              // and router still holds the funds. That logic bundled into how the value of `recipient` is calculated\n              recipient: isLastSectionInRoute(i) ? recipient : ADDRESS_THIS,\n              amountIn: i == 0 ? amountIn : 0,\n              amountOutMinimum: !isLastSectionInRoute(i) ? 0 : amountOut,\n            }\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n          } else {\n            const exactInputParams = [\n              i == 0 ? amountIn : 0, // amountIn\n              !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n              newRoute.path.map((token) => token.address), // path\n              isLastSectionInRoute(i) ? recipient : ADDRESS_THIS, // to\n            ]\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n          }\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade:\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every(\n          (swap) =>\n            swap.route.protocol == Protocol.V3 ||\n            swap.route.protocol == Protocol.V2 ||\n            swap.route.protocol == Protocol.MIXED\n        ),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let individualTrades: (\n        | V2Trade<Currency, Currency, TradeType>\n        | V3Trade<Currency, Currency, TradeType>\n        | MixedRouteTrade<Currency, Currency, TradeType>\n      )[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol == Protocol.V2) {\n          individualTrades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol == Protocol.V3) {\n          individualTrades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else if (route.protocol == Protocol.MIXED) {\n          individualTrades.push(\n            /// we can change the naming of this function on MixedRouteTrade if needed\n            MixedRouteTrade.createUncheckedTrade({\n              route: route as MixedRoute<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else {\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n        }\n      }\n      trades = individualTrades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) =>\n        numberOfTrades + (trade instanceof V3Trade || trade instanceof MixedRouteTrade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else if (trade instanceof V3Trade) {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else if (trade instanceof MixedRouteTrade) {\n        for (const calldata of SwapRouter.encodeMixedRouteSwap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else {\n        throw new Error('Unsupported trade object')\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n      | (\n          | V2Trade<Currency, Currency, TradeType>\n          | V3Trade<Currency, Currency, TradeType>\n          | MixedRouteTrade<Currency, Currency, TradeType>\n        )[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): {\n    positionAmountIn: CurrencyAmount<Currency>\n    positionAmountOut: CurrencyAmount<Currency>\n  } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}