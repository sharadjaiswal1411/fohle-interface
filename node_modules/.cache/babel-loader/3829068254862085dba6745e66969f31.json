{"ast":null,"code":"import _toConsumableArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport FixedReverseHeap from 'mnemonist/fixed-reverse-heap';\nimport Queue from 'mnemonist/queue';\nimport { HAS_L1_FEE } from '../../../util';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport function getBestSwapRoute(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n  return _getBestSwapRoute.apply(this, arguments);\n}\nfunction _getBestSwapRoute() {\n  _getBestSwapRoute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig, gasModel) {\n    var now, forceMixedRoutes, percentToQuotes, _iterator4, _step4, routeWithValidQuote, swapRoute, routeAmounts, totalAmount, missingAmount;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            now = Date.now();\n            forceMixedRoutes = routingConfig.forceMixedRoutes; /// Like with forceCrossProtocol, we apply that logic here when determining the bestSwapRoute\n            if (!forceMixedRoutes) {\n              _context.next = 7;\n              break;\n            }\n            log.info({\n              forceMixedRoutes: forceMixedRoutes\n            }, 'Forcing mixed routes by filtering out other route types');\n            routesWithValidQuotes = _.filter(routesWithValidQuotes, function (quotes) {\n              return quotes.protocol === Protocol.MIXED;\n            });\n            if (routesWithValidQuotes) {\n              _context.next = 7;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 7:\n            // Build a map of percentage of the input to list of valid quotes.\n            // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n            percentToQuotes = {};\n            _iterator4 = _createForOfIteratorHelper(routesWithValidQuotes);\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                routeWithValidQuote = _step4.value;\n                if (!percentToQuotes[routeWithValidQuote.percent]) {\n                  percentToQuotes[routeWithValidQuote.percent] = [];\n                }\n                percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n            metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds);\n            // Given all the valid quotes for each percentage find the optimal route.\n            _context.next = 13;\n            return getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, function (rq) {\n              return rq.quoteAdjustedForGas;\n            }, routingConfig, gasModel);\n          case 13:\n            swapRoute = _context.sent;\n            if (swapRoute) {\n              _context.next = 16;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 16:\n            // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n            // route of our optimal quote may not add up exactly to exactIn or exactOut.\n            //\n            // We check this here, and if there is a mismatch\n            // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n            routeAmounts = swapRoute.routes;\n            totalAmount = _.reduce(routeAmounts, function (total, routeAmount) {\n              return total.add(routeAmount.amount);\n            }, CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n            missingAmount = amount.subtract(totalAmount);\n            if (missingAmount.greaterThan(0)) {\n              log.info({\n                missingAmount: missingAmount.quotient.toString()\n              }, \"Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.\");\n              routeAmounts[routeAmounts.length - 1].amount = routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n            }\n            log.info({\n              routes: routeAmountsToString(routeAmounts),\n              numSplits: routeAmounts.length,\n              amount: amount.toExact(),\n              quote: swapRoute.quote.toExact(),\n              quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(Math.min(swapRoute.quoteGasAdjusted.currency.decimals, 2)),\n              estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(Math.min(swapRoute.estimatedGasUsedUSD.currency.decimals, 2)),\n              estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(Math.min(swapRoute.estimatedGasUsedQuoteToken.currency.decimals, 2))\n            }, \"Found best swap route. \".concat(routeAmounts.length, \" split.\"));\n            return _context.abrupt(\"return\", swapRoute);\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getBestSwapRoute.apply(this, arguments);\n}\nexport function getBestSwapRouteBy(_x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n  return _getBestSwapRouteBy.apply(this, arguments);\n}\n// We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\nfunction _getBestSwapRouteBy() {\n  _getBestSwapRouteBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(routeType, percentToQuotes, percents, chainId, by, routingConfig, gasModel) {\n    var _a, percentToSortedQuotes, quoteCompFn, sumFn, bestQuote, bestSwap, bestSwapsPerSplit, minSplits, maxSplits, forceCrossProtocol, _iterator5, _step5, routeWithQuote, queue, i, percent, splits, startedSplit, layer, _queue$dequeue, remainingPercent, curRoutes, percentIndex, special, _i, percentA, candidateRoutesA, routeWithQuoteA, remainingPercentNew, curRoutesNew, quotesNew, quoteNew, _gasCostL1QuoteToken, onlyV3Routes, gasCostL1, quoteAfterL1Adjust, postSplitNow, quoteGasAdjusted, estimatedGasUsed, usdToken, usdTokenDecimals, gasCostsL1ToL2, _onlyV3Routes, _gasCostsL1ToL, gasCostL1USD, gasCostL1QuoteToken, estimatedGasUsedUSDs, estimatedGasUsedUSD, decimalsDiff, estimatedGasUsedQuoteToken, quote, quoteGasAdjustedForL1, _quoteGasAdjustedForL, routeWithQuotes;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n            percentToSortedQuotes = _.mapValues(percentToQuotes, function (routeQuotes) {\n              return routeQuotes.sort(function (routeQuoteA, routeQuoteB) {\n                if (routeType == TradeType.EXACT_INPUT) {\n                  return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n                } else {\n                  return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n                }\n              });\n            });\n            quoteCompFn = routeType == TradeType.EXACT_INPUT ? function (a, b) {\n              return a.greaterThan(b);\n            } : function (a, b) {\n              return a.lessThan(b);\n            };\n            sumFn = function sumFn(currencyAmounts) {\n              var sum = currencyAmounts[0];\n              for (var i = 1; i < currencyAmounts.length; i++) {\n                sum = sum.add(currencyAmounts[i]);\n              }\n              return sum;\n            };\n            // Min-heap for tracking the 5 best swaps given some number of splits.\n            bestSwapsPerSplit = new FixedReverseHeap(Array, function (a, b) {\n              return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n            }, 3);\n            minSplits = routingConfig.minSplits, maxSplits = routingConfig.maxSplits, forceCrossProtocol = routingConfig.forceCrossProtocol;\n            if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n              log.info({\n                percentToSortedQuotes: _.mapValues(percentToSortedQuotes, function (p) {\n                  return p.length;\n                })\n              }, 'Did not find a valid route without any splits. Continuing search anyway.');\n            } else {\n              bestQuote = by(percentToSortedQuotes[100][0]);\n              bestSwap = [percentToSortedQuotes[100][0]];\n              _iterator5 = _createForOfIteratorHelper(percentToSortedQuotes[100].slice(0, 5));\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  routeWithQuote = _step5.value;\n                  bestSwapsPerSplit.push({\n                    quote: by(routeWithQuote),\n                    routes: [routeWithQuote]\n                  });\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n            // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n            queue = new Queue(); // First we seed BFS queue with the best quotes for each percentage.\n            // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n            // We will explore the various combinations from each node.\n            i = percents.length;\n          case 8:\n            if (!(i >= 0)) {\n              _context2.next = 19;\n              break;\n            }\n            percent = percents[i];\n            if (percentToSortedQuotes[percent]) {\n              _context2.next = 12;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 16);\n          case 12:\n            queue.enqueue({\n              curRoutes: [percentToSortedQuotes[percent][0]],\n              percentIndex: i,\n              remainingPercent: 100 - percent,\n              special: false\n            });\n            if (!(!percentToSortedQuotes[percent] || !percentToSortedQuotes[percent][1])) {\n              _context2.next = 15;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 16);\n          case 15:\n            queue.enqueue({\n              curRoutes: [percentToSortedQuotes[percent][1]],\n              percentIndex: i,\n              remainingPercent: 100 - percent,\n              special: true\n            });\n          case 16:\n            i--;\n            _context2.next = 8;\n            break;\n          case 19:\n            splits = 1;\n            startedSplit = Date.now();\n          case 21:\n            if (!(queue.size > 0)) {\n              _context2.next = 77;\n              break;\n            }\n            metric.putMetric(\"Split\".concat(splits, \"Done\"), Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n            startedSplit = Date.now();\n            log.info({\n              top5: _.map(Array.from(bestSwapsPerSplit.consume()), function (q) {\n                return \"\".concat(q.quote.toExact(), \" (\").concat(_(q.routes).map(function (r) {\n                  return r.toString();\n                }).join(', '), \")\");\n              }),\n              onQueue: queue.size\n            }, \"Top 3 with \".concat(splits, \" splits\"));\n            bestSwapsPerSplit.clear();\n            // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n            layer = queue.size;\n            splits++;\n            // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n            if (!(splits >= 3 && bestSwap && bestSwap.length < splits - 1)) {\n              _context2.next = 30;\n              break;\n            }\n            return _context2.abrupt(\"break\", 77);\n          case 30:\n            if (!(splits > maxSplits)) {\n              _context2.next = 34;\n              break;\n            }\n            log.info('Max splits reached. Stopping search.');\n            metric.putMetric(\"MaxSplitsHitReached\", 1, MetricLoggerUnit.Count);\n            return _context2.abrupt(\"break\", 77);\n          case 34:\n            if (!(layer > 0)) {\n              _context2.next = 75;\n              break;\n            }\n            layer--;\n            _queue$dequeue = queue.dequeue(), remainingPercent = _queue$dequeue.remainingPercent, curRoutes = _queue$dequeue.curRoutes, percentIndex = _queue$dequeue.percentIndex, special = _queue$dequeue.special; // For all other percentages, add a new potential route.\n            // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n            // 50% + new 10% route, 50% + new 20% route, etc.\n            _i = percentIndex;\n          case 38:\n            if (!(_i >= 0)) {\n              _context2.next = 73;\n              break;\n            }\n            percentA = percents[_i];\n            if (!(percentA > remainingPercent)) {\n              _context2.next = 42;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 70);\n          case 42:\n            if (percentToSortedQuotes[percentA]) {\n              _context2.next = 44;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 70);\n          case 44:\n            candidateRoutesA = percentToSortedQuotes[percentA]; // Find the best route in the complimentary percentage that doesn't re-use a pool already\n            // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n            // so it would make the quotes inaccurate.\n            routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n            if (routeWithQuoteA) {\n              _context2.next = 48;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 70);\n          case 48:\n            remainingPercentNew = remainingPercent - percentA;\n            curRoutesNew = [].concat(_toConsumableArray(curRoutes), [routeWithQuoteA]); // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n            if (!(remainingPercentNew == 0 && splits >= minSplits)) {\n              _context2.next = 69;\n              break;\n            }\n            quotesNew = _.map(curRoutesNew, function (r) {\n              return by(r);\n            });\n            quoteNew = sumFn(quotesNew);\n            _gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteNew.currency, 0);\n            if (!HAS_L1_FEE.includes(chainId)) {\n              _context2.next = 64;\n              break;\n            }\n            onlyV3Routes = curRoutesNew.every(function (route) {\n              return route.protocol == Protocol.V3;\n            });\n            if (!(gasModel == undefined || !onlyV3Routes)) {\n              _context2.next = 60;\n              break;\n            }\n            throw new Error(\"Can't compute L1 gas fees.\");\n          case 60:\n            _context2.next = 62;\n            return gasModel.calculateL1GasFees(curRoutesNew);\n          case 62:\n            gasCostL1 = _context2.sent;\n            _gasCostL1QuoteToken = gasCostL1.gasCostL1QuoteToken;\n          case 64:\n            quoteAfterL1Adjust = routeType == TradeType.EXACT_INPUT ? quoteNew.subtract(_gasCostL1QuoteToken) : quoteNew.add(_gasCostL1QuoteToken);\n            bestSwapsPerSplit.push({\n              quote: quoteAfterL1Adjust,\n              routes: curRoutesNew\n            });\n            if (!bestQuote || quoteCompFn(quoteAfterL1Adjust, bestQuote)) {\n              bestQuote = quoteAfterL1Adjust;\n              bestSwap = curRoutesNew;\n              // Temporary experiment.\n              if (special) {\n                metric.putMetric(\"BestSwapNotPickingBestForPercent\", 1, MetricLoggerUnit.Count);\n              }\n            }\n            _context2.next = 70;\n            break;\n          case 69:\n            queue.enqueue({\n              curRoutes: curRoutesNew,\n              remainingPercent: remainingPercentNew,\n              percentIndex: _i,\n              special: special\n            });\n          case 70:\n            _i--;\n            _context2.next = 38;\n            break;\n          case 73:\n            _context2.next = 34;\n            break;\n          case 75:\n            _context2.next = 21;\n            break;\n          case 77:\n            if (bestSwap) {\n              _context2.next = 80;\n              break;\n            }\n            log.info(\"Could not find a valid swap\");\n            return _context2.abrupt(\"return\", undefined);\n          case 80:\n            postSplitNow = Date.now();\n            quoteGasAdjusted = sumFn(_.map(bestSwap, function (routeWithValidQuote) {\n              return routeWithValidQuote.quoteAdjustedForGas;\n            })); // this calculates the base gas used\n            // if on L1, its the estimated gas used based on hops and ticks across all the routes\n            // if on L2, its the gas used on the L2 based on hops and ticks across all the routes\n            estimatedGasUsed = _(bestSwap).map(function (routeWithValidQuote) {\n              return routeWithValidQuote.gasEstimate;\n            }).reduce(function (sum, routeWithValidQuote) {\n              return sum.add(routeWithValidQuote);\n            }, BigNumber.from(0));\n            if (!(!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0])) {\n              _context2.next = 85;\n              break;\n            }\n            throw new Error(\"Could not find a USD token for computing gas costs on \".concat(chainId));\n          case 85:\n            usdToken = usdGasTokensByChain[chainId][0];\n            usdTokenDecimals = usdToken.decimals; // if on L2, calculate the L1 security fee\n            gasCostsL1ToL2 = {\n              gasUsedL1: BigNumber.from(0),\n              gasCostL1USD: CurrencyAmount.fromRawAmount(usdToken, 0),\n              gasCostL1QuoteToken: CurrencyAmount.fromRawAmount(\n              // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n              (_a = bestSwap[0]) === null || _a === void 0 ? void 0 : _a.quoteToken, 0)\n            }; // If swapping on an L2 that includes a L1 security fee, calculate the fee and include it in the gas adjusted quotes\n            if (!HAS_L1_FEE.includes(chainId)) {\n              _context2.next = 97;\n              break;\n            }\n            // ensure the gasModel exists and that the swap route is a v3 only route\n            _onlyV3Routes = bestSwap.every(function (route) {\n              return route.protocol == Protocol.V3;\n            });\n            if (!(gasModel == undefined || !_onlyV3Routes)) {\n              _context2.next = 94;\n              break;\n            }\n            throw new Error(\"Can't compute L1 gas fees.\");\n          case 94:\n            _context2.next = 96;\n            return gasModel.calculateL1GasFees(bestSwap);\n          case 96:\n            gasCostsL1ToL2 = _context2.sent;\n          case 97:\n            _gasCostsL1ToL = gasCostsL1ToL2, gasCostL1USD = _gasCostsL1ToL.gasCostL1USD, gasCostL1QuoteToken = _gasCostsL1ToL.gasCostL1QuoteToken; // For each gas estimate, normalize decimals to that of the chosen usd token.\n            estimatedGasUsedUSDs = _(bestSwap).map(function (routeWithValidQuote) {\n              // TODO: will error if gasToken has decimals greater than usdToken\n              var decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n              if (decimalsDiff == 0) {\n                return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n              }\n              return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n            }).value();\n            estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs); // if they are different usd pools, convert to the usdToken\n            if (estimatedGasUsedUSD.currency != gasCostL1USD.currency) {\n              decimalsDiff = usdTokenDecimals - gasCostL1USD.currency.decimals;\n              estimatedGasUsedUSD = estimatedGasUsedUSD.add(CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(gasCostL1USD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff)))));\n            } else {\n              estimatedGasUsedUSD = estimatedGasUsedUSD.add(gasCostL1USD);\n            }\n            log.info({\n              estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n              normalizedUsdToken: usdToken,\n              routeUSDGasEstimates: _.map(bestSwap, function (b) {\n                return \"\".concat(b.percent, \"% \").concat(routeToString(b.route), \" \").concat(b.gasCostInUSD.toExact());\n              }),\n              flatL1GasCostUSD: gasCostL1USD.toExact()\n            }, 'USD gas estimates of best route');\n            estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, function (routeWithValidQuote) {\n              return routeWithValidQuote.gasCostInToken;\n            })).add(gasCostL1QuoteToken);\n            quote = sumFn(_.map(bestSwap, function (routeWithValidQuote) {\n              return routeWithValidQuote.quote;\n            })); // Adjust the quoteGasAdjusted for the l1 fee\n            if (routeType == TradeType.EXACT_INPUT) {\n              quoteGasAdjustedForL1 = quoteGasAdjusted.subtract(gasCostL1QuoteToken);\n              quoteGasAdjusted = quoteGasAdjustedForL1;\n            } else {\n              _quoteGasAdjustedForL = quoteGasAdjusted.add(gasCostL1QuoteToken);\n              quoteGasAdjusted = _quoteGasAdjustedForL;\n            }\n            routeWithQuotes = bestSwap.sort(function (routeAmountA, routeAmountB) {\n              return routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1;\n            });\n            metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n            return _context2.abrupt(\"return\", {\n              quote: quote,\n              quoteGasAdjusted: quoteGasAdjusted,\n              estimatedGasUsed: estimatedGasUsed,\n              estimatedGasUsedUSD: estimatedGasUsedUSD,\n              estimatedGasUsedQuoteToken: estimatedGasUsedQuoteToken,\n              routes: routeWithQuotes\n            });\n          case 108:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getBestSwapRouteBy.apply(this, arguments);\n}\nvar findFirstRouteNotUsingUsedPools = function findFirstRouteNotUsingUsedPools(usedRoutes, candidateRouteQuotes, forceCrossProtocol) {\n  var poolAddressSet = new Set();\n  var usedPoolAddresses = _(usedRoutes).flatMap(function (r) {\n    return r.poolAddresses;\n  }).value();\n  var _iterator = _createForOfIteratorHelper(usedPoolAddresses),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var poolAddress = _step.value;\n      poolAddressSet.add(poolAddress);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var protocolsSet = new Set();\n  var usedProtocols = _(usedRoutes).flatMap(function (r) {\n    return r.protocol;\n  }).uniq().value();\n  var _iterator2 = _createForOfIteratorHelper(usedProtocols),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var protocol = _step2.value;\n      protocolsSet.add(protocol);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper(candidateRouteQuotes),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var routeQuote = _step3.value;\n      var poolAddresses = routeQuote.poolAddresses,\n        _protocol = routeQuote.protocol;\n      if (poolAddresses.some(function (poolAddress) {\n        return poolAddressSet.has(poolAddress);\n      })) {\n        continue;\n      }\n      // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n      // consideration of routes that come from the same protocol as a used route.\n      var needToForce = forceCrossProtocol && protocolsSet.size == 1;\n      if (needToForce && protocolsSet.has(_protocol)) {\n        continue;\n      }\n      return routeQuote;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return null;\n};","map":{"version":3,"sources":["../../../../../src/routers/alpha-router/functions/best-swap-route.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport FixedReverseHeap from 'mnemonist/fixed-reverse-heap';\nimport Queue from 'mnemonist/queue';\nimport { HAS_L1_FEE } from '../../../util';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport async function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig, gasModel) {\n    const now = Date.now();\n    const { forceMixedRoutes } = routingConfig;\n    /// Like with forceCrossProtocol, we apply that logic here when determining the bestSwapRoute\n    if (forceMixedRoutes) {\n        log.info({\n            forceMixedRoutes: forceMixedRoutes,\n        }, 'Forcing mixed routes by filtering out other route types');\n        routesWithValidQuotes = _.filter(routesWithValidQuotes, (quotes) => {\n            return quotes.protocol === Protocol.MIXED;\n        });\n        if (!routesWithValidQuotes) {\n            return null;\n        }\n    }\n    // Build a map of percentage of the input to list of valid quotes.\n    // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n    const percentToQuotes = {};\n    for (const routeWithValidQuote of routesWithValidQuotes) {\n        if (!percentToQuotes[routeWithValidQuote.percent]) {\n            percentToQuotes[routeWithValidQuote.percent] = [];\n        }\n        percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n    }\n    metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds);\n    // Given all the valid quotes for each percentage find the optimal route.\n    const swapRoute = await getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, (rq) => rq.quoteAdjustedForGas, routingConfig, gasModel);\n    // It is possible we were unable to find any valid route given the quotes.\n    if (!swapRoute) {\n        return null;\n    }\n    // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n    // route of our optimal quote may not add up exactly to exactIn or exactOut.\n    //\n    // We check this here, and if there is a mismatch\n    // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n    const { routes: routeAmounts } = swapRoute;\n    const totalAmount = _.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n    const missingAmount = amount.subtract(totalAmount);\n    if (missingAmount.greaterThan(0)) {\n        log.info({\n            missingAmount: missingAmount.quotient.toString(),\n        }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);\n        routeAmounts[routeAmounts.length - 1].amount =\n            routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n    }\n    log.info({\n        routes: routeAmountsToString(routeAmounts),\n        numSplits: routeAmounts.length,\n        amount: amount.toExact(),\n        quote: swapRoute.quote.toExact(),\n        quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(Math.min(swapRoute.quoteGasAdjusted.currency.decimals, 2)),\n        estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(Math.min(swapRoute.estimatedGasUsedUSD.currency.decimals, 2)),\n        estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(Math.min(swapRoute.estimatedGasUsedQuoteToken.currency.decimals, 2)),\n    }, `Found best swap route. ${routeAmounts.length} split.`);\n    return swapRoute;\n}\nexport async function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig, gasModel) {\n    var _a;\n    // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n    const percentToSortedQuotes = _.mapValues(percentToQuotes, (routeQuotes) => {\n        return routeQuotes.sort((routeQuoteA, routeQuoteB) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n            }\n            else {\n                return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n            }\n        });\n    });\n    const quoteCompFn = routeType == TradeType.EXACT_INPUT\n        ? (a, b) => a.greaterThan(b)\n        : (a, b) => a.lessThan(b);\n    const sumFn = (currencyAmounts) => {\n        let sum = currencyAmounts[0];\n        for (let i = 1; i < currencyAmounts.length; i++) {\n            sum = sum.add(currencyAmounts[i]);\n        }\n        return sum;\n    };\n    let bestQuote;\n    let bestSwap;\n    // Min-heap for tracking the 5 best swaps given some number of splits.\n    const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {\n        return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n    }, 3);\n    const { minSplits, maxSplits, forceCrossProtocol } = routingConfig;\n    if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n        log.info({\n            percentToSortedQuotes: _.mapValues(percentToSortedQuotes, (p) => p.length),\n        }, 'Did not find a valid route without any splits. Continuing search anyway.');\n    }\n    else {\n        bestQuote = by(percentToSortedQuotes[100][0]);\n        bestSwap = [percentToSortedQuotes[100][0]];\n        for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {\n            bestSwapsPerSplit.push({\n                quote: by(routeWithQuote),\n                routes: [routeWithQuote],\n            });\n        }\n    }\n    // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n    const queue = new Queue();\n    // First we seed BFS queue with the best quotes for each percentage.\n    // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n    // We will explore the various combinations from each node.\n    for (let i = percents.length; i >= 0; i--) {\n        const percent = percents[i];\n        if (!percentToSortedQuotes[percent]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][0]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: false,\n        });\n        if (!percentToSortedQuotes[percent] ||\n            !percentToSortedQuotes[percent][1]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][1]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: true,\n        });\n    }\n    let splits = 1;\n    let startedSplit = Date.now();\n    while (queue.size > 0) {\n        metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n        startedSplit = Date.now();\n        log.info({\n            top5: _.map(Array.from(bestSwapsPerSplit.consume()), (q) => `${q.quote.toExact()} (${_(q.routes)\n                .map((r) => r.toString())\n                .join(', ')})`),\n            onQueue: queue.size,\n        }, `Top 3 with ${splits} splits`);\n        bestSwapsPerSplit.clear();\n        // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n        let layer = queue.size;\n        splits++;\n        // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n        if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n            break;\n        }\n        if (splits > maxSplits) {\n            log.info('Max splits reached. Stopping search.');\n            metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);\n            break;\n        }\n        while (layer > 0) {\n            layer--;\n            const { remainingPercent, curRoutes, percentIndex, special } = queue.dequeue();\n            // For all other percentages, add a new potential route.\n            // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n            // 50% + new 10% route, 50% + new 20% route, etc.\n            for (let i = percentIndex; i >= 0; i--) {\n                const percentA = percents[i];\n                if (percentA > remainingPercent) {\n                    continue;\n                }\n                // At some point the amount * percentage is so small that the quoter is unable to get\n                // a quote. In this case there could be no quotes for that percentage.\n                if (!percentToSortedQuotes[percentA]) {\n                    continue;\n                }\n                const candidateRoutesA = percentToSortedQuotes[percentA];\n                // Find the best route in the complimentary percentage that doesn't re-use a pool already\n                // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n                // so it would make the quotes inaccurate.\n                const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n                if (!routeWithQuoteA) {\n                    continue;\n                }\n                const remainingPercentNew = remainingPercent - percentA;\n                const curRoutesNew = [...curRoutes, routeWithQuoteA];\n                // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n                if (remainingPercentNew == 0 && splits >= minSplits) {\n                    const quotesNew = _.map(curRoutesNew, (r) => by(r));\n                    const quoteNew = sumFn(quotesNew);\n                    let gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteNew.currency, 0);\n                    if (HAS_L1_FEE.includes(chainId)) {\n                        const onlyV3Routes = curRoutesNew.every((route) => route.protocol == Protocol.V3);\n                        if (gasModel == undefined || !onlyV3Routes) {\n                            throw new Error(\"Can't compute L1 gas fees.\");\n                        }\n                        else {\n                            const gasCostL1 = await gasModel.calculateL1GasFees(curRoutesNew);\n                            gasCostL1QuoteToken = gasCostL1.gasCostL1QuoteToken;\n                        }\n                    }\n                    const quoteAfterL1Adjust = routeType == TradeType.EXACT_INPUT\n                        ? quoteNew.subtract(gasCostL1QuoteToken)\n                        : quoteNew.add(gasCostL1QuoteToken);\n                    bestSwapsPerSplit.push({\n                        quote: quoteAfterL1Adjust,\n                        routes: curRoutesNew,\n                    });\n                    if (!bestQuote || quoteCompFn(quoteAfterL1Adjust, bestQuote)) {\n                        bestQuote = quoteAfterL1Adjust;\n                        bestSwap = curRoutesNew;\n                        // Temporary experiment.\n                        if (special) {\n                            metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);\n                        }\n                    }\n                }\n                else {\n                    queue.enqueue({\n                        curRoutes: curRoutesNew,\n                        remainingPercent: remainingPercentNew,\n                        percentIndex: i,\n                        special,\n                    });\n                }\n            }\n        }\n    }\n    if (!bestSwap) {\n        log.info(`Could not find a valid swap`);\n        return undefined;\n    }\n    const postSplitNow = Date.now();\n    let quoteGasAdjusted = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quoteAdjustedForGas));\n    // this calculates the base gas used\n    // if on L1, its the estimated gas used based on hops and ticks across all the routes\n    // if on L2, its the gas used on the L2 based on hops and ticks across all the routes\n    const estimatedGasUsed = _(bestSwap)\n        .map((routeWithValidQuote) => routeWithValidQuote.gasEstimate)\n        .reduce((sum, routeWithValidQuote) => sum.add(routeWithValidQuote), BigNumber.from(0));\n    if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n        // Each route can use a different stablecoin to account its gas costs.\n        // They should all be pegged, and this is just an estimate, so we do a merge\n        // to an arbitrary stable.\n        throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n    }\n    const usdToken = usdGasTokensByChain[chainId][0];\n    const usdTokenDecimals = usdToken.decimals;\n    // if on L2, calculate the L1 security fee\n    let gasCostsL1ToL2 = {\n        gasUsedL1: BigNumber.from(0),\n        gasCostL1USD: CurrencyAmount.fromRawAmount(usdToken, 0),\n        gasCostL1QuoteToken: CurrencyAmount.fromRawAmount(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n        (_a = bestSwap[0]) === null || _a === void 0 ? void 0 : _a.quoteToken, 0),\n    };\n    // If swapping on an L2 that includes a L1 security fee, calculate the fee and include it in the gas adjusted quotes\n    if (HAS_L1_FEE.includes(chainId)) {\n        // ensure the gasModel exists and that the swap route is a v3 only route\n        const onlyV3Routes = bestSwap.every((route) => route.protocol == Protocol.V3);\n        if (gasModel == undefined || !onlyV3Routes) {\n            throw new Error(\"Can't compute L1 gas fees.\");\n        }\n        else {\n            gasCostsL1ToL2 = await gasModel.calculateL1GasFees(bestSwap);\n        }\n    }\n    const { gasCostL1USD, gasCostL1QuoteToken } = gasCostsL1ToL2;\n    // For each gas estimate, normalize decimals to that of the chosen usd token.\n    const estimatedGasUsedUSDs = _(bestSwap)\n        .map((routeWithValidQuote) => {\n        // TODO: will error if gasToken has decimals greater than usdToken\n        const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n        if (decimalsDiff == 0) {\n            return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n        }\n        return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n    })\n        .value();\n    let estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n    // if they are different usd pools, convert to the usdToken\n    if (estimatedGasUsedUSD.currency != gasCostL1USD.currency) {\n        const decimalsDiff = usdTokenDecimals - gasCostL1USD.currency.decimals;\n        estimatedGasUsedUSD = estimatedGasUsedUSD.add(CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(gasCostL1USD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff)))));\n    }\n    else {\n        estimatedGasUsedUSD = estimatedGasUsedUSD.add(gasCostL1USD);\n    }\n    log.info({\n        estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n        normalizedUsdToken: usdToken,\n        routeUSDGasEstimates: _.map(bestSwap, (b) => `${b.percent}% ${routeToString(b.route)} ${b.gasCostInUSD.toExact()}`),\n        flatL1GasCostUSD: gasCostL1USD.toExact(),\n    }, 'USD gas estimates of best route');\n    const estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.gasCostInToken)).add(gasCostL1QuoteToken);\n    const quote = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quote));\n    // Adjust the quoteGasAdjusted for the l1 fee\n    if (routeType == TradeType.EXACT_INPUT) {\n        const quoteGasAdjustedForL1 = quoteGasAdjusted.subtract(gasCostL1QuoteToken);\n        quoteGasAdjusted = quoteGasAdjustedForL1;\n    }\n    else {\n        const quoteGasAdjustedForL1 = quoteGasAdjusted.add(gasCostL1QuoteToken);\n        quoteGasAdjusted = quoteGasAdjustedForL1;\n    }\n    const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);\n    metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n    return {\n        quote,\n        quoteGasAdjusted,\n        estimatedGasUsed,\n        estimatedGasUsedUSD,\n        estimatedGasUsedQuoteToken,\n        routes: routeWithQuotes,\n    };\n}\n// We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\nconst findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {\n    const poolAddressSet = new Set();\n    const usedPoolAddresses = _(usedRoutes)\n        .flatMap((r) => r.poolAddresses)\n        .value();\n    for (const poolAddress of usedPoolAddresses) {\n        poolAddressSet.add(poolAddress);\n    }\n    const protocolsSet = new Set();\n    const usedProtocols = _(usedRoutes)\n        .flatMap((r) => r.protocol)\n        .uniq()\n        .value();\n    for (const protocol of usedProtocols) {\n        protocolsSet.add(protocol);\n    }\n    for (const routeQuote of candidateRouteQuotes) {\n        const { poolAddresses, protocol } = routeQuote;\n        if (poolAddresses.some((poolAddress) => poolAddressSet.has(poolAddress))) {\n            continue;\n        }\n        // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n        // consideration of routes that come from the same protocol as a used route.\n        const needToForce = forceCrossProtocol && protocolsSet.size == 1;\n        if (needToForce && protocolsSet.has(protocol)) {\n            continue;\n        }\n        return routeQuote;\n    }\n    return null;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVzdC1zd2FwLXJvdXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3JvdXRlcnMvYWxwaGEtcm91dGVyL2Z1bmN0aW9ucy9iZXN0LXN3YXAtcm91dGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLGdCQUFnQixNQUFNLDhCQUE4QixDQUFDO0FBQzVELE9BQU8sS0FBSyxNQUFNLGlCQUFpQixDQUFDO0FBRXBDLE9BQU8sRUFBVyxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUN4QyxPQUFPLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGFBQWEsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRTNFLE9BQU8sRUFBNkIsbUJBQW1CLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFPL0UsTUFBTSxDQUFDLEtBQUssVUFBVSxnQkFBZ0IsQ0FDcEMsTUFBc0IsRUFDdEIsUUFBa0IsRUFDbEIscUJBQTRDLEVBQzVDLFNBQW9CLEVBQ3BCLE9BQWdCLEVBQ2hCLGFBQWdDLEVBQ2hDLFFBQTJDO0lBUzNDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUV2QixNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxh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"]},"metadata":{},"sourceType":"module"}