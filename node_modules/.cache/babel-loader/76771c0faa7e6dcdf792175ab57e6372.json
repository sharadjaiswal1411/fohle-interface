{"ast":null,"code":"import { arrayify, logger } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\nimport { addGlobalEventProcessor } from './scope.js';\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n  integrations.forEach(currentInstance => {\n    const {\n      name\n    } = currentInstance;\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n  let integrations;\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(integrations) {\n  const integrationIndex = {};\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Integration installed: ${integration.name}`);\n    }\n  });\n  return integrationIndex;\n}\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegrations };","map":{"version":3,"sources":["../../src/integration.ts"],"names":[],"mappings":";;;AAYA,MAAA,qBAAA,GAAA,EAAA;;AAEA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,gBAAA,CAAA,YAAA,EAAA;EACA,MAAA,kBAAA,GAAA,CAAA,CAAA;EAEA,YAAA,CAAA,OAAA,CAAA,eAAA,IAAA;IACA,MAAA;MAAA;IAAA,CAAA,GAAA,eAAA;IAEA,MAAA,gBAAA,GAAA,kBAAA,CAAA,IAAA,CAAA;;IAEA;IACA;IACA,IAAA,gBAAA,IAAA,CAAA,gBAAA,CAAA,iBAAA,IAAA,eAAA,CAAA,iBAAA,EAAA;MACA;IACA;IAEA,kBAAA,CAAA,IAAA,CAAA,GAAA,eAAA;EACA,CAAA,CAAA;EAEA,OAAA,MAAA,CAAA,MAAA,CAAA,kBAAA,CAAA;AACA;;AAEA;AACA,SAAA,sBAAA,CAAA,OAAA,EAAA;EACA,MAAA,mBAAA,GAAA,OAAA,CAAA,mBAAA,IAAA,EAAA;EACA,MAAA,gBAAA,GAAA,OAAA,CAAA,YAAA;;EAEA;EACA,mBAAA,CAAA,OAAA,CAAA,WAAA,IAAA;IACA,WAAA,CAAA,iBAAA,GAAA,IAAA;EACA,CAAA,CAAA;EAEA,IAAA,YAAA;EAEA,IAAA,KAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,EAAA;IACA,YAAA,GAAA,CAAA,GAAA,mBAAA,EAAA,GAAA,gBAAA,CAAA;EACA,CAAA,MAAA,IAAA,OAAA,gBAAA,KAAA,UAAA,EAAA;IACA,YAAA,GAAA,QAAA,CAAA,gBAAA,CAAA,mBAAA,CAAA,CAAA;EACA,CAAA,MAAA;IACA,YAAA,GAAA,mBAAA;EACA;EAEA,MAAA,iBAAA,GAAA,gBAAA,CAAA,YAAA,CAAA;;EAEA;EACA;EACA;EACA;EACA,MAAA,UAAA,GAAA,iBAAA,CAAA,SAAA,CAAA,WAAA,IAAA,WAAA,CAAA,IAAA,KAAA,OAAA,CAAA;EACA,IAAA,UAAA,KAAA,CAAA,CAAA,EAAA;IACA,MAAA,CAAA,aAAA,CAAA,GAAA,iBAAA,CAAA,MAAA,CAAA,UAAA,EAAA,CAAA,CAAA;IACA,iBAAA,CAAA,IAAA,CAAA,aAAA,CAAA;EACA;EAEA,OAAA,iBAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,iBAAA,CAAA,YAAA,EAAA;EACA,MAAA,gBAAA,GAAA,CAAA,CAAA;EAEA,YAAA,CAAA,OAAA,CAAA,WAAA,IAAA;IACA,gBAAA,CAAA,WAAA,CAAA,IAAA,CAAA,GAAA,WAAA;IAEA,IAAA,qBAAA,CAAA,OAAA,CAAA,WAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA,EAAA;MACA,WAAA,CAAA,SAAA,CAAA,uBAAA,EAAA,aAAA,CAAA;MACA,qBAAA,CAAA,IAAA,CAAA,WAAA,CAAA,IAAA,CAAA;MACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,GAAA,CAAA,0BAAA,WAAA,CAAA,IAAA,EAAA,CAAA;IACA;EACA,CAAA,CAAA;EAEA,OAAA,gBAAA;AACA","sourcesContent":["import { Integration, Options } from '@sentry/types';\nimport { arrayify, logger } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\nimport { addGlobalEventProcessor } from './scope';\n\ndeclare module '@sentry/types' {\n  interface Integration {\n    isDefaultInstance?: boolean;\n  }\n}\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      __DEBUG_BUILD__ && logger.log(`Integration installed: ${integration.name}`);\n    }\n  });\n\n  return integrationIndex;\n}\n"]},"metadata":{},"sourceType":"module"}