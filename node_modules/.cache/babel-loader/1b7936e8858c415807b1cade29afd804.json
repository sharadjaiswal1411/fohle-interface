{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { CurrencyAmount, Price, TradeType } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount';\nimport { useMemo, useRef } from 'react';\nimport { RouterPreference } from 'state/routing/slice';\nimport { useRoutingAPITrade } from 'state/routing/useRoutingAPITrade';\nimport { SupportedChainId } from '../constants/chains';\nimport { CUSD_CELO, DAI_OPTIMISM, USDC_ARBITRUM, USDC_MAINNET, USDC_POLYGON } from '../constants/tokens';\n\n// Stablecoin amounts used when calculating spot price for a given currency.\n// The amount is large enough to filter low liquidity pairs.\nconst STABLECOIN_AMOUNT_OUT = {\n  [SupportedChainId.MAINNET]: CurrencyAmount.fromRawAmount(USDC_MAINNET, 100000e6),\n  [SupportedChainId.ARBITRUM_ONE]: CurrencyAmount.fromRawAmount(USDC_ARBITRUM, 10000e6),\n  [SupportedChainId.OPTIMISM]: CurrencyAmount.fromRawAmount(DAI_OPTIMISM, 10000e18),\n  [SupportedChainId.POLYGON]: CurrencyAmount.fromRawAmount(USDC_POLYGON, 10000e6),\n  [SupportedChainId.CELO]: CurrencyAmount.fromRawAmount(CUSD_CELO, 10000e18)\n};\n\n/**\n * Returns the price in USDC of the input currency\n * @param currency currency to compute the USDC price of\n */\nexport default function useStablecoinPrice(currency) {\n  _s();\n  const chainId = currency === null || currency === void 0 ? void 0 : currency.chainId;\n  const amountOut = chainId ? STABLECOIN_AMOUNT_OUT[chainId] : undefined;\n  const stablecoin = amountOut === null || amountOut === void 0 ? void 0 : amountOut.currency;\n  const {\n    trade\n  } = useRoutingAPITrade(TradeType.EXACT_OUTPUT, amountOut, currency, RouterPreference.PRICE);\n  const price = useMemo(() => {\n    if (!currency || !stablecoin) {\n      return undefined;\n    }\n\n    // handle usdc\n    if (currency === null || currency === void 0 ? void 0 : currency.wrapped.equals(stablecoin)) {\n      return new Price(stablecoin, stablecoin, '1', '1');\n    }\n    if (trade) {\n      const {\n        numerator,\n        denominator\n      } = trade.routes[0].midPrice;\n      return new Price(currency, stablecoin, denominator, numerator);\n    }\n    return undefined;\n  }, [currency, stablecoin, trade]);\n  const lastPrice = useRef(price);\n  if (!price || !lastPrice.current || !price.equalTo(lastPrice.current)) {\n    lastPrice.current = price;\n  }\n  return lastPrice.current;\n}\n_s(useStablecoinPrice, \"ORRLUsejA2u/JK9xsVgN9pQFqB0=\", false, function () {\n  return [useRoutingAPITrade];\n});\nexport function useStablecoinValue(currencyAmount) {\n  _s2();\n  const price = useStablecoinPrice(currencyAmount === null || currencyAmount === void 0 ? void 0 : currencyAmount.currency);\n  return useMemo(() => {\n    if (!price || !currencyAmount) return null;\n    try {\n      return price.quote(currencyAmount);\n    } catch (error) {\n      return null;\n    }\n  }, [currencyAmount, price]);\n}\n\n/**\n *\n * @param fiatValue string representation of a USD amount\n * @returns CurrencyAmount where currency is stablecoin on active chain\n */\n_s2(useStablecoinValue, \"09g6p15V0c2CVIZx0MryOcP8kRc=\", false, function () {\n  return [useStablecoinPrice];\n});\nexport function useStablecoinAmountFromFiatValue(fiatValue) {\n  _s3();\n  var _STABLECOIN_AMOUNT_OU;\n  const {\n    chainId\n  } = useWeb3React();\n  const stablecoin = chainId ? (_STABLECOIN_AMOUNT_OU = STABLECOIN_AMOUNT_OUT[chainId]) === null || _STABLECOIN_AMOUNT_OU === void 0 ? void 0 : _STABLECOIN_AMOUNT_OU.currency : undefined;\n  return useMemo(() => {\n    if (fiatValue === null || fiatValue === undefined || !chainId || !stablecoin) {\n      return undefined;\n    }\n\n    // trim for decimal precision when parsing\n    const parsedForDecimals = parseFloat(fiatValue).toFixed(stablecoin.decimals).toString();\n    try {\n      // parse USD string into CurrencyAmount based on stablecoin decimals\n      return tryParseCurrencyAmount(parsedForDecimals, stablecoin);\n    } catch (error) {\n      return undefined;\n    }\n  }, [chainId, fiatValue, stablecoin]);\n}\n_s3(useStablecoinAmountFromFiatValue, \"ARXJQdl1Tr2ytTu0YufD558EwWE=\", false, function () {\n  return [useWeb3React];\n});","map":{"version":3,"names":["CurrencyAmount","Price","TradeType","useWeb3React","tryParseCurrencyAmount","useMemo","useRef","RouterPreference","useRoutingAPITrade","SupportedChainId","CUSD_CELO","DAI_OPTIMISM","USDC_ARBITRUM","USDC_MAINNET","USDC_POLYGON","STABLECOIN_AMOUNT_OUT","MAINNET","fromRawAmount","ARBITRUM_ONE","OPTIMISM","POLYGON","CELO","useStablecoinPrice","currency","chainId","amountOut","undefined","stablecoin","trade","EXACT_OUTPUT","PRICE","price","wrapped","equals","numerator","denominator","routes","midPrice","lastPrice","current","equalTo","useStablecoinValue","currencyAmount","quote","error","useStablecoinAmountFromFiatValue","fiatValue","parsedForDecimals","parseFloat","toFixed","decimals","toString"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useStablecoinPrice.ts"],"sourcesContent":["import { Currency, CurrencyAmount, Price, Token, TradeType } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { useMemo, useRef } from 'react'\nimport { RouterPreference } from 'state/routing/slice'\nimport { useRoutingAPITrade } from 'state/routing/useRoutingAPITrade'\n\nimport { SupportedChainId } from '../constants/chains'\nimport { CUSD_CELO, DAI_OPTIMISM, USDC_ARBITRUM, USDC_MAINNET, USDC_POLYGON } from '../constants/tokens'\n\n// Stablecoin amounts used when calculating spot price for a given currency.\n// The amount is large enough to filter low liquidity pairs.\nconst STABLECOIN_AMOUNT_OUT: { [chainId: number]: CurrencyAmount<Token> } = {\n  [SupportedChainId.MAINNET]: CurrencyAmount.fromRawAmount(USDC_MAINNET, 100_000e6),\n  [SupportedChainId.ARBITRUM_ONE]: CurrencyAmount.fromRawAmount(USDC_ARBITRUM, 10_000e6),\n  [SupportedChainId.OPTIMISM]: CurrencyAmount.fromRawAmount(DAI_OPTIMISM, 10_000e18),\n  [SupportedChainId.POLYGON]: CurrencyAmount.fromRawAmount(USDC_POLYGON, 10_000e6),\n  [SupportedChainId.CELO]: CurrencyAmount.fromRawAmount(CUSD_CELO, 10_000e18),\n}\n\n/**\n * Returns the price in USDC of the input currency\n * @param currency currency to compute the USDC price of\n */\nexport default function useStablecoinPrice(currency?: Currency): Price<Currency, Token> | undefined {\n  const chainId = currency?.chainId\n\n  const amountOut = chainId ? STABLECOIN_AMOUNT_OUT[chainId] : undefined\n  const stablecoin = amountOut?.currency\n\n  const { trade } = useRoutingAPITrade(TradeType.EXACT_OUTPUT, amountOut, currency, RouterPreference.PRICE)\n  const price = useMemo(() => {\n    if (!currency || !stablecoin) {\n      return undefined\n    }\n\n    // handle usdc\n    if (currency?.wrapped.equals(stablecoin)) {\n      return new Price(stablecoin, stablecoin, '1', '1')\n    }\n\n    if (trade) {\n      const { numerator, denominator } = trade.routes[0].midPrice\n      return new Price(currency, stablecoin, denominator, numerator)\n    }\n\n    return undefined\n  }, [currency, stablecoin, trade])\n\n  const lastPrice = useRef(price)\n  if (!price || !lastPrice.current || !price.equalTo(lastPrice.current)) {\n    lastPrice.current = price\n  }\n  return lastPrice.current\n}\n\nexport function useStablecoinValue(currencyAmount: CurrencyAmount<Currency> | undefined | null) {\n  const price = useStablecoinPrice(currencyAmount?.currency)\n\n  return useMemo(() => {\n    if (!price || !currencyAmount) return null\n    try {\n      return price.quote(currencyAmount)\n    } catch (error) {\n      return null\n    }\n  }, [currencyAmount, price])\n}\n\n/**\n *\n * @param fiatValue string representation of a USD amount\n * @returns CurrencyAmount where currency is stablecoin on active chain\n */\nexport function useStablecoinAmountFromFiatValue(fiatValue: string | null | undefined) {\n  const { chainId } = useWeb3React()\n  const stablecoin = chainId ? STABLECOIN_AMOUNT_OUT[chainId]?.currency : undefined\n\n  return useMemo(() => {\n    if (fiatValue === null || fiatValue === undefined || !chainId || !stablecoin) {\n      return undefined\n    }\n\n    // trim for decimal precision when parsing\n    const parsedForDecimals = parseFloat(fiatValue).toFixed(stablecoin.decimals).toString()\n    try {\n      // parse USD string into CurrencyAmount based on stablecoin decimals\n      return tryParseCurrencyAmount(parsedForDecimals, stablecoin)\n    } catch (error) {\n      return undefined\n    }\n  }, [chainId, fiatValue, stablecoin])\n}\n"],"mappings":";;;AAAA,SAAmBA,cAAc,EAAEC,KAAK,EAASC,SAAS,QAAQ,mBAAmB;AACrF,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,OAAOC,sBAAsB,MAAM,kCAAkC;AACrE,SAASC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACvC,SAASC,gBAAgB,QAAQ,qBAAqB;AACtD,SAASC,kBAAkB,QAAQ,kCAAkC;AAErE,SAASC,gBAAgB,QAAQ,qBAAqB;AACtD,SAASC,SAAS,EAAEC,YAAY,EAAEC,aAAa,EAAEC,YAAY,EAAEC,YAAY,QAAQ,qBAAqB;;AAExG;AACA;AACA,MAAMC,qBAAmE,GAAG;EAC1E,CAACN,gBAAgB,CAACO,OAAO,GAAGhB,cAAc,CAACiB,aAAa,CAACJ,YAAY,EAAE,QAAS,CAAC;EACjF,CAACJ,gBAAgB,CAACS,YAAY,GAAGlB,cAAc,CAACiB,aAAa,CAACL,aAAa,EAAE,OAAQ,CAAC;EACtF,CAACH,gBAAgB,CAACU,QAAQ,GAAGnB,cAAc,CAACiB,aAAa,CAACN,YAAY,EAAE,QAAS,CAAC;EAClF,CAACF,gBAAgB,CAACW,OAAO,GAAGpB,cAAc,CAACiB,aAAa,CAACH,YAAY,EAAE,OAAQ,CAAC;EAChF,CAACL,gBAAgB,CAACY,IAAI,GAAGrB,cAAc,CAACiB,aAAa,CAACP,SAAS,EAAE,QAAS;AAC5E,CAAC;;AAED;AACA;AACA;AACA;AACA,eAAe,SAASY,kBAAkB,CAACC,QAAmB,EAAsC;EAAA;EAClG,MAAMC,OAAO,GAAGD,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEC,OAAO;EAEjC,MAAMC,SAAS,GAAGD,OAAO,GAAGT,qBAAqB,CAACS,OAAO,CAAC,GAAGE,SAAS;EACtE,MAAMC,UAAU,GAAGF,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEF,QAAQ;EAEtC,MAAM;IAAEK;EAAM,CAAC,GAAGpB,kBAAkB,CAACN,SAAS,CAAC2B,YAAY,EAAEJ,SAAS,EAAEF,QAAQ,EAAEhB,gBAAgB,CAACuB,KAAK,CAAC;EACzG,MAAMC,KAAK,GAAG1B,OAAO,CAAC,MAAM;IAC1B,IAAI,CAACkB,QAAQ,IAAI,CAACI,UAAU,EAAE;MAC5B,OAAOD,SAAS;IAClB;;IAEA;IACA,IAAIH,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAES,OAAO,CAACC,MAAM,CAACN,UAAU,CAAC,EAAE;MACxC,OAAO,IAAI1B,KAAK,CAAC0B,UAAU,EAAEA,UAAU,EAAE,GAAG,EAAE,GAAG,CAAC;IACpD;IAEA,IAAIC,KAAK,EAAE;MACT,MAAM;QAAEM,SAAS;QAAEC;MAAY,CAAC,GAAGP,KAAK,CAACQ,MAAM,CAAC,CAAC,CAAC,CAACC,QAAQ;MAC3D,OAAO,IAAIpC,KAAK,CAACsB,QAAQ,EAAEI,UAAU,EAAEQ,WAAW,EAAED,SAAS,CAAC;IAChE;IAEA,OAAOR,SAAS;EAClB,CAAC,EAAE,CAACH,QAAQ,EAAEI,UAAU,EAAEC,KAAK,CAAC,CAAC;EAEjC,MAAMU,SAAS,GAAGhC,MAAM,CAACyB,KAAK,CAAC;EAC/B,IAAI,CAACA,KAAK,IAAI,CAACO,SAAS,CAACC,OAAO,IAAI,CAACR,KAAK,CAACS,OAAO,CAACF,SAAS,CAACC,OAAO,CAAC,EAAE;IACrED,SAAS,CAACC,OAAO,GAAGR,KAAK;EAC3B;EACA,OAAOO,SAAS,CAACC,OAAO;AAC1B;AAAC,GA9BuBjB,kBAAkB;EAAA,QAMtBd,kBAAkB;AAAA;AA0BtC,OAAO,SAASiC,kBAAkB,CAACC,cAA2D,EAAE;EAAA;EAC9F,MAAMX,KAAK,GAAGT,kBAAkB,CAACoB,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEnB,QAAQ,CAAC;EAE1D,OAAOlB,OAAO,CAAC,MAAM;IACnB,IAAI,CAAC0B,KAAK,IAAI,CAACW,cAAc,EAAE,OAAO,IAAI;IAC1C,IAAI;MACF,OAAOX,KAAK,CAACY,KAAK,CAACD,cAAc,CAAC;IACpC,CAAC,CAAC,OAAOE,KAAK,EAAE;MACd,OAAO,IAAI;IACb;EACF,CAAC,EAAE,CAACF,cAAc,EAAEX,KAAK,CAAC,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AAJA,IAbgBU,kBAAkB;EAAA,QAClBnB,kBAAkB;AAAA;AAiBlC,OAAO,SAASuB,gCAAgC,CAACC,SAAoC,EAAE;EAAA;EAAA;EACrF,MAAM;IAAEtB;EAAQ,CAAC,GAAGrB,YAAY,EAAE;EAClC,MAAMwB,UAAU,GAAGH,OAAO,4BAAGT,qBAAqB,CAACS,OAAO,CAAC,0DAA9B,sBAAgCD,QAAQ,GAAGG,SAAS;EAEjF,OAAOrB,OAAO,CAAC,MAAM;IACnB,IAAIyC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAKpB,SAAS,IAAI,CAACF,OAAO,IAAI,CAACG,UAAU,EAAE;MAC5E,OAAOD,SAAS;IAClB;;IAEA;IACA,MAAMqB,iBAAiB,GAAGC,UAAU,CAACF,SAAS,CAAC,CAACG,OAAO,CAACtB,UAAU,CAACuB,QAAQ,CAAC,CAACC,QAAQ,EAAE;IACvF,IAAI;MACF;MACA,OAAO/C,sBAAsB,CAAC2C,iBAAiB,EAAEpB,UAAU,CAAC;IAC9D,CAAC,CAAC,OAAOiB,KAAK,EAAE;MACd,OAAOlB,SAAS;IAClB;EACF,CAAC,EAAE,CAACF,OAAO,EAAEsB,SAAS,EAAEnB,UAAU,CAAC,CAAC;AACtC;AAAC,IAlBekB,gCAAgC;EAAA,QAC1B1C,YAAY;AAAA"},"metadata":{},"sourceType":"module"}