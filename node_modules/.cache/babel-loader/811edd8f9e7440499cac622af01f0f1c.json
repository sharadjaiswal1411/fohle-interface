{"ast":null,"code":"import _ from 'lodash';\nimport { log } from '../../util/log';\n/**\n * Provider for getting V2 pools, with functionality for caching the results per block.\n *\n * @export\n * @class CachingV2PoolProvider\n */\nexport class CachingV2PoolProvider {\n  /**\n   * Creates an instance of CachingV3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param poolProvider The provider to use to get the pools when not in the cache.\n   * @param cache Cache instance to hold cached pools.\n   */\n  constructor(chainId, poolProvider,\n  // Cache is block aware. For V2 pools we need to use the current blocks reserves values since\n  // we compute quotes off-chain.\n  // If no block is specified in the call to getPools we just return whatever is in the cache.\n  cache) {\n    this.chainId = chainId;\n    this.poolProvider = poolProvider;\n    this.cache = cache;\n    this.POOL_KEY = (chainId, address) => `pool-${chainId}-${address}`;\n  }\n  async getPools(tokenPairs, providerConfig) {\n    const poolAddressSet = new Set();\n    const poolsToGetTokenPairs = [];\n    const poolsToGetAddresses = [];\n    const poolAddressToPool = {};\n    const blockNumber = await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber);\n    for (const [tokenA, tokenB] of tokenPairs) {\n      const {\n        poolAddress,\n        token0,\n        token1\n      } = this.getPoolAddress(tokenA, tokenB);\n      if (poolAddressSet.has(poolAddress)) {\n        continue;\n      }\n      poolAddressSet.add(poolAddress);\n      const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n      if (cachedPool) {\n        // If a block was specified by the caller, ensure that the result in our cache matches the\n        // expected block number. If a block number is not specified, just return whatever is in the\n        // cache.\n        if (!blockNumber || blockNumber && cachedPool.block == blockNumber) {\n          poolAddressToPool[poolAddress] = cachedPool.pair;\n          continue;\n        }\n      }\n      poolsToGetTokenPairs.push([token0, token1]);\n      poolsToGetAddresses.push(poolAddress);\n    }\n    log.info({\n      poolsFound: _.map(Object.values(poolAddressToPool), p => p.token0.symbol + ' ' + p.token1.symbol),\n      poolsToGetTokenPairs: _.map(poolsToGetTokenPairs, t => t[0].symbol + ' ' + t[1].symbol)\n    }, `Found ${Object.keys(poolAddressToPool).length} V2 pools already in local cache for block ${blockNumber}. About to get reserves for ${poolsToGetTokenPairs.length} pools.`);\n    if (poolsToGetAddresses.length > 0) {\n      const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n      for (const address of poolsToGetAddresses) {\n        const pool = poolAccessor.getPoolByAddress(address);\n        if (pool) {\n          poolAddressToPool[address] = pool;\n          await this.cache.set(this.POOL_KEY(this.chainId, address), {\n            pair: pool,\n            block: blockNumber\n          });\n        }\n      }\n    }\n    return {\n      getPool: (tokenA, tokenB) => {\n        const {\n          poolAddress\n        } = this.getPoolAddress(tokenA, tokenB);\n        return poolAddressToPool[poolAddress];\n      },\n      getPoolByAddress: address => poolAddressToPool[address],\n      getAllPools: () => Object.values(poolAddressToPool)\n    };\n  }\n  getPoolAddress(tokenA, tokenB) {\n    return this.poolProvider.getPoolAddress(tokenA, tokenB);\n  }\n}","map":{"version":3,"sources":["../../../../src/providers/v2/caching-pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from 'lodash';\nimport { log } from '../../util/log';\n/**\n * Provider for getting V2 pools, with functionality for caching the results per block.\n *\n * @export\n * @class CachingV2PoolProvider\n */\nexport class CachingV2PoolProvider {\n    /**\n     * Creates an instance of CachingV3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param poolProvider The provider to use to get the pools when not in the cache.\n     * @param cache Cache instance to hold cached pools.\n     */\n    constructor(chainId, poolProvider, \n    // Cache is block aware. For V2 pools we need to use the current blocks reserves values since\n    // we compute quotes off-chain.\n    // If no block is specified in the call to getPools we just return whatever is in the cache.\n    cache) {\n        this.chainId = chainId;\n        this.poolProvider = poolProvider;\n        this.cache = cache;\n        this.POOL_KEY = (chainId, address) => `pool-${chainId}-${address}`;\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const poolsToGetTokenPairs = [];\n        const poolsToGetAddresses = [];\n        const poolAddressToPool = {};\n        const blockNumber = await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber);\n        for (const [tokenA, tokenB] of tokenPairs) {\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n            if (cachedPool) {\n                // If a block was specified by the caller, ensure that the result in our cache matches the\n                // expected block number. If a block number is not specified, just return whatever is in the\n                // cache.\n                if (!blockNumber || (blockNumber && cachedPool.block == blockNumber)) {\n                    poolAddressToPool[poolAddress] = cachedPool.pair;\n                    continue;\n                }\n            }\n            poolsToGetTokenPairs.push([token0, token1]);\n            poolsToGetAddresses.push(poolAddress);\n        }\n        log.info({\n            poolsFound: _.map(Object.values(poolAddressToPool), (p) => p.token0.symbol + ' ' + p.token1.symbol),\n            poolsToGetTokenPairs: _.map(poolsToGetTokenPairs, (t) => t[0].symbol + ' ' + t[1].symbol),\n        }, `Found ${Object.keys(poolAddressToPool).length} V2 pools already in local cache for block ${blockNumber}. About to get reserves for ${poolsToGetTokenPairs.length} pools.`);\n        if (poolsToGetAddresses.length > 0) {\n            const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n            for (const address of poolsToGetAddresses) {\n                const pool = poolAccessor.getPoolByAddress(address);\n                if (pool) {\n                    poolAddressToPool[address] = pool;\n                    await this.cache.set(this.POOL_KEY(this.chainId, address), {\n                        pair: pool,\n                        block: blockNumber,\n                    });\n                }\n            }\n        }\n        return {\n            getPool: (tokenA, tokenB) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB) {\n        return this.poolProvider.getPoolAddress(tokenA, tokenB);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGluZy1wb29sLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy92Mi9jYWNoaW5nLXBvb2wtcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU1yQzs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxxQkFBcUI7SUFJaEM7Ozs7O09BS0c7SUFDSCxZQUNZLE9BQWdCLEVBQ2hCLFlBQTZCO0lBQ3ZDLDZGQUE2RjtJQUM3RiwrQkFBK0I7SUFDL0IsNEZBQTRGO0lBQ3BGLEtBQTZDO1FBTDNDLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsaUJBQVksR0FBWixZQUFZLENBQWlCO1FBSS9CLFVBQUssR0FBTCxLQUFLLENBQXdDO1FBZi9DLGFBQVEsR0FBRyxDQUFDLE9BQWdCLEVBQUUsT0FBZSxFQUFFLEVBQUUsQ0FDdkQsUUFBUSxPQUFPLElBQUksT0FBTyxFQUFFLENBQUM7SUFlNUIsQ0FBQztJQUVHLEtBQUssQ0FBQyxRQUFRLENBQ25CLFVBQTRCLEVBQzVCLGNBQStCO1FBRS9CLE1BQU0sY0FBYyxHQUFnQixJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3RELE1BQU0sb0JBQW9CLEdBQTBCLEVBQUUsQ0FBQztRQUN2RCxNQUFNLG1CQUFtQixHQUFhLEVBQUUsQ0FBQztRQUN6QyxNQUFNLGlCQUFpQixHQUFvQyxFQUFFLENBQUM7UUFFOUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFBLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRSxXQUFXLENBQUEsQ0FBQztRQUV0RCxLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQUksVUFBVSxFQUFFO1lBQ3pDLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxH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"]},"metadata":{},"sourceType":"module"}