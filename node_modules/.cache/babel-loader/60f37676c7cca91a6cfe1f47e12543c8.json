{"ast":null,"code":"import _slicedToArray from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{WrappedTokenInfo}from'state/lists/wrappedTokenInfo';var mapCache=typeof WeakMap!=='undefined'?new WeakMap():null;export function tokensToChainTokenMap(tokens){var cached=mapCache===null||mapCache===void 0?void 0:mapCache.get(tokens);if(cached)return cached;var _ref=Array.isArray(tokens)?[undefined,tokens]:[tokens,tokens.tokens],_ref2=_slicedToArray(_ref,2),list=_ref2[0],infos=_ref2[1];var map=infos.reduce(function(map,info){try{var _map$token$chainId;var token=new WrappedTokenInfo(info,list);if(((_map$token$chainId=map[token.chainId])===null||_map$token$chainId===void 0?void 0:_map$token$chainId[token.address])!==undefined){console.warn(\"Duplicate token skipped: \".concat(token.address));return map;}if(!map[token.chainId]){map[token.chainId]={};}map[token.chainId][token.address]={token:token,list:list};return map;}catch(_unused){return map;}},{});mapCache===null||mapCache===void 0?void 0:mapCache.set(tokens,map);return map;}","map":{"version":3,"names":["WrappedTokenInfo","mapCache","WeakMap","tokensToChainTokenMap","tokens","cached","get","Array","isArray","undefined","list","infos","map","reduce","info","token","chainId","address","console","warn","set"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useTokenList/utils.ts"],"sourcesContent":["import { TokenInfo, TokenList } from '@uniswap/token-lists'\nimport { WrappedTokenInfo } from 'state/lists/wrappedTokenInfo'\n\ntype TokenMap = Readonly<{ [tokenAddress: string]: { token: WrappedTokenInfo; list?: TokenList } }>\nexport type ChainTokenMap = Readonly<{ [chainId: number]: TokenMap }>\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: Mutable<T[P]>\n}\n\nconst mapCache = typeof WeakMap !== 'undefined' ? new WeakMap<TokenList | TokenInfo[], ChainTokenMap>() : null\n\nexport function tokensToChainTokenMap(tokens: TokenList | TokenInfo[]): ChainTokenMap {\n  const cached = mapCache?.get(tokens)\n  if (cached) return cached\n\n  const [list, infos] = Array.isArray(tokens) ? [undefined, tokens] : [tokens, tokens.tokens]\n  const map = infos.reduce<Mutable<ChainTokenMap>>((map, info) => {\n    try {\n      const token = new WrappedTokenInfo(info, list)\n      if (map[token.chainId]?.[token.address] !== undefined) {\n        console.warn(`Duplicate token skipped: ${token.address}`)\n        return map\n      }\n      if (!map[token.chainId]) {\n        map[token.chainId] = {}\n      }\n      map[token.chainId][token.address] = { token, list }\n      return map\n    } catch {\n      return map\n    }\n  }, {}) as ChainTokenMap\n  mapCache?.set(tokens, map)\n  return map\n}\n"],"mappings":"4KACA,OAASA,gBAAgB,KAAQ,8BAA8B,CAS/D,GAAMC,SAAQ,CAAG,MAAOC,QAAO,GAAK,WAAW,CAAG,GAAIA,QAAO,EAA0C,CAAG,IAAI,CAE9G,MAAO,SAASC,sBAAqB,CAACC,MAA+B,CAAiB,CACpF,GAAMC,OAAM,CAAGJ,QAAQ,SAARA,QAAQ,iBAARA,QAAQ,CAAEK,GAAG,CAACF,MAAM,CAAC,CACpC,GAAIC,MAAM,CAAE,MAAOA,OAAM,CAEzB,SAAsBE,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,CAAG,CAACK,SAAS,CAAEL,MAAM,CAAC,CAAG,CAACA,MAAM,CAAEA,MAAM,CAACA,MAAM,CAAC,8BAApFM,IAAI,UAAEC,KAAK,UAClB,GAAMC,IAAG,CAAGD,KAAK,CAACE,MAAM,CAAyB,SAACD,GAAG,CAAEE,IAAI,CAAK,CAC9D,GAAI,wBACF,GAAMC,MAAK,CAAG,GAAIf,iBAAgB,CAACc,IAAI,CAAEJ,IAAI,CAAC,CAC9C,GAAI,qBAAAE,GAAG,CAACG,KAAK,CAACC,OAAO,CAAC,6CAAlB,mBAAqBD,KAAK,CAACE,OAAO,CAAC,IAAKR,SAAS,CAAE,CACrDS,OAAO,CAACC,IAAI,oCAA6BJ,KAAK,CAACE,OAAO,EAAG,CACzD,MAAOL,IAAG,CACZ,CACA,GAAI,CAACA,GAAG,CAACG,KAAK,CAACC,OAAO,CAAC,CAAE,CACvBJ,GAAG,CAACG,KAAK,CAACC,OAAO,CAAC,CAAG,CAAC,CAAC,CACzB,CACAJ,GAAG,CAACG,KAAK,CAACC,OAAO,CAAC,CAACD,KAAK,CAACE,OAAO,CAAC,CAAG,CAAEF,KAAK,CAALA,KAAK,CAAEL,IAAI,CAAJA,IAAK,CAAC,CACnD,MAAOE,IAAG,CACZ,CAAE,cAAM,CACN,MAAOA,IAAG,CACZ,CACF,CAAC,CAAE,CAAC,CAAC,CAAkB,CACvBX,QAAQ,SAARA,QAAQ,iBAARA,QAAQ,CAAEmB,GAAG,CAAChB,MAAM,CAAEQ,GAAG,CAAC,CAC1B,MAAOA,IAAG,CACZ"},"metadata":{},"sourceType":"module"}