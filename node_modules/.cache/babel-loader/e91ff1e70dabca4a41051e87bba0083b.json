{"ast":null,"code":"import { BigNumber } from '@ethersproject/bignumber';\nimport { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport FixedReverseHeap from 'mnemonist/fixed-reverse-heap';\nimport Queue from 'mnemonist/queue';\nimport { HAS_L1_FEE } from '../../../util';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport async function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig, gasModel) {\n  const now = Date.now();\n  const {\n    forceMixedRoutes\n  } = routingConfig;\n  /// Like with forceCrossProtocol, we apply that logic here when determining the bestSwapRoute\n  if (forceMixedRoutes) {\n    log.info({\n      forceMixedRoutes: forceMixedRoutes\n    }, 'Forcing mixed routes by filtering out other route types');\n    routesWithValidQuotes = _.filter(routesWithValidQuotes, quotes => {\n      return quotes.protocol === Protocol.MIXED;\n    });\n    if (!routesWithValidQuotes) {\n      return null;\n    }\n  }\n  // Build a map of percentage of the input to list of valid quotes.\n  // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n  const percentToQuotes = {};\n  for (const routeWithValidQuote of routesWithValidQuotes) {\n    if (!percentToQuotes[routeWithValidQuote.percent]) {\n      percentToQuotes[routeWithValidQuote.percent] = [];\n    }\n    percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n  }\n  metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds);\n  // Given all the valid quotes for each percentage find the optimal route.\n  const swapRoute = await getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, rq => rq.quoteAdjustedForGas, routingConfig, gasModel);\n  // It is possible we were unable to find any valid route given the quotes.\n  if (!swapRoute) {\n    return null;\n  }\n  // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n  // route of our optimal quote may not add up exactly to exactIn or exactOut.\n  //\n  // We check this here, and if there is a mismatch\n  // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n  const {\n    routes: routeAmounts\n  } = swapRoute;\n  const totalAmount = _.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n  const missingAmount = amount.subtract(totalAmount);\n  if (missingAmount.greaterThan(0)) {\n    log.info({\n      missingAmount: missingAmount.quotient.toString()\n    }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);\n    routeAmounts[routeAmounts.length - 1].amount = routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n  }\n  log.info({\n    routes: routeAmountsToString(routeAmounts),\n    numSplits: routeAmounts.length,\n    amount: amount.toExact(),\n    quote: swapRoute.quote.toExact(),\n    quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(Math.min(swapRoute.quoteGasAdjusted.currency.decimals, 2)),\n    estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(Math.min(swapRoute.estimatedGasUsedUSD.currency.decimals, 2)),\n    estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(Math.min(swapRoute.estimatedGasUsedQuoteToken.currency.decimals, 2))\n  }, `Found best swap route. ${routeAmounts.length} split.`);\n  return swapRoute;\n}\nexport async function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig, gasModel) {\n  var _a;\n  // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n  const percentToSortedQuotes = _.mapValues(percentToQuotes, routeQuotes => {\n    return routeQuotes.sort((routeQuoteA, routeQuoteB) => {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n      } else {\n        return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n      }\n    });\n  });\n  const quoteCompFn = routeType == TradeType.EXACT_INPUT ? (a, b) => a.greaterThan(b) : (a, b) => a.lessThan(b);\n  const sumFn = currencyAmounts => {\n    let sum = currencyAmounts[0];\n    for (let i = 1; i < currencyAmounts.length; i++) {\n      sum = sum.add(currencyAmounts[i]);\n    }\n    return sum;\n  };\n  let bestQuote;\n  let bestSwap;\n  // Min-heap for tracking the 5 best swaps given some number of splits.\n  const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {\n    return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n  }, 3);\n  const {\n    minSplits,\n    maxSplits,\n    forceCrossProtocol\n  } = routingConfig;\n  if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n    log.info({\n      percentToSortedQuotes: _.mapValues(percentToSortedQuotes, p => p.length)\n    }, 'Did not find a valid route without any splits. Continuing search anyway.');\n  } else {\n    bestQuote = by(percentToSortedQuotes[100][0]);\n    bestSwap = [percentToSortedQuotes[100][0]];\n    for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {\n      bestSwapsPerSplit.push({\n        quote: by(routeWithQuote),\n        routes: [routeWithQuote]\n      });\n    }\n  }\n  // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n  const queue = new Queue();\n  // First we seed BFS queue with the best quotes for each percentage.\n  // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n  // We will explore the various combinations from each node.\n  for (let i = percents.length; i >= 0; i--) {\n    const percent = percents[i];\n    if (!percentToSortedQuotes[percent]) {\n      continue;\n    }\n    queue.enqueue({\n      curRoutes: [percentToSortedQuotes[percent][0]],\n      percentIndex: i,\n      remainingPercent: 100 - percent,\n      special: false\n    });\n    if (!percentToSortedQuotes[percent] || !percentToSortedQuotes[percent][1]) {\n      continue;\n    }\n    queue.enqueue({\n      curRoutes: [percentToSortedQuotes[percent][1]],\n      percentIndex: i,\n      remainingPercent: 100 - percent,\n      special: true\n    });\n  }\n  let splits = 1;\n  let startedSplit = Date.now();\n  while (queue.size > 0) {\n    metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n    startedSplit = Date.now();\n    log.info({\n      top5: _.map(Array.from(bestSwapsPerSplit.consume()), q => `${q.quote.toExact()} (${_(q.routes).map(r => r.toString()).join(', ')})`),\n      onQueue: queue.size\n    }, `Top 3 with ${splits} splits`);\n    bestSwapsPerSplit.clear();\n    // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n    let layer = queue.size;\n    splits++;\n    // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n    if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n      break;\n    }\n    if (splits > maxSplits) {\n      log.info('Max splits reached. Stopping search.');\n      metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);\n      break;\n    }\n    while (layer > 0) {\n      layer--;\n      const {\n        remainingPercent,\n        curRoutes,\n        percentIndex,\n        special\n      } = queue.dequeue();\n      // For all other percentages, add a new potential route.\n      // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n      // 50% + new 10% route, 50% + new 20% route, etc.\n      for (let i = percentIndex; i >= 0; i--) {\n        const percentA = percents[i];\n        if (percentA > remainingPercent) {\n          continue;\n        }\n        // At some point the amount * percentage is so small that the quoter is unable to get\n        // a quote. In this case there could be no quotes for that percentage.\n        if (!percentToSortedQuotes[percentA]) {\n          continue;\n        }\n        const candidateRoutesA = percentToSortedQuotes[percentA];\n        // Find the best route in the complimentary percentage that doesn't re-use a pool already\n        // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n        // so it would make the quotes inaccurate.\n        const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n        if (!routeWithQuoteA) {\n          continue;\n        }\n        const remainingPercentNew = remainingPercent - percentA;\n        const curRoutesNew = [...curRoutes, routeWithQuoteA];\n        // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n        if (remainingPercentNew == 0 && splits >= minSplits) {\n          const quotesNew = _.map(curRoutesNew, r => by(r));\n          const quoteNew = sumFn(quotesNew);\n          let gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteNew.currency, 0);\n          if (HAS_L1_FEE.includes(chainId)) {\n            const onlyV3Routes = curRoutesNew.every(route => route.protocol == Protocol.V3);\n            if (gasModel == undefined || !onlyV3Routes) {\n              throw new Error(\"Can't compute L1 gas fees.\");\n            } else {\n              const gasCostL1 = await gasModel.calculateL1GasFees(curRoutesNew);\n              gasCostL1QuoteToken = gasCostL1.gasCostL1QuoteToken;\n            }\n          }\n          const quoteAfterL1Adjust = routeType == TradeType.EXACT_INPUT ? quoteNew.subtract(gasCostL1QuoteToken) : quoteNew.add(gasCostL1QuoteToken);\n          bestSwapsPerSplit.push({\n            quote: quoteAfterL1Adjust,\n            routes: curRoutesNew\n          });\n          if (!bestQuote || quoteCompFn(quoteAfterL1Adjust, bestQuote)) {\n            bestQuote = quoteAfterL1Adjust;\n            bestSwap = curRoutesNew;\n            // Temporary experiment.\n            if (special) {\n              metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);\n            }\n          }\n        } else {\n          queue.enqueue({\n            curRoutes: curRoutesNew,\n            remainingPercent: remainingPercentNew,\n            percentIndex: i,\n            special\n          });\n        }\n      }\n    }\n  }\n  if (!bestSwap) {\n    log.info(`Could not find a valid swap`);\n    return undefined;\n  }\n  const postSplitNow = Date.now();\n  let quoteGasAdjusted = sumFn(_.map(bestSwap, routeWithValidQuote => routeWithValidQuote.quoteAdjustedForGas));\n  // this calculates the base gas used\n  // if on L1, its the estimated gas used based on hops and ticks across all the routes\n  // if on L2, its the gas used on the L2 based on hops and ticks across all the routes\n  const estimatedGasUsed = _(bestSwap).map(routeWithValidQuote => routeWithValidQuote.gasEstimate).reduce((sum, routeWithValidQuote) => sum.add(routeWithValidQuote), BigNumber.from(0));\n  if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n    // Each route can use a different stablecoin to account its gas costs.\n    // They should all be pegged, and this is just an estimate, so we do a merge\n    // to an arbitrary stable.\n    throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n  }\n  const usdToken = usdGasTokensByChain[chainId][0];\n  const usdTokenDecimals = usdToken.decimals;\n  // if on L2, calculate the L1 security fee\n  let gasCostsL1ToL2 = {\n    gasUsedL1: BigNumber.from(0),\n    gasCostL1USD: CurrencyAmount.fromRawAmount(usdToken, 0),\n    gasCostL1QuoteToken: CurrencyAmount.fromRawAmount(\n    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n    (_a = bestSwap[0]) === null || _a === void 0 ? void 0 : _a.quoteToken, 0)\n  };\n  // If swapping on an L2 that includes a L1 security fee, calculate the fee and include it in the gas adjusted quotes\n  if (HAS_L1_FEE.includes(chainId)) {\n    // ensure the gasModel exists and that the swap route is a v3 only route\n    const onlyV3Routes = bestSwap.every(route => route.protocol == Protocol.V3);\n    if (gasModel == undefined || !onlyV3Routes) {\n      throw new Error(\"Can't compute L1 gas fees.\");\n    } else {\n      gasCostsL1ToL2 = await gasModel.calculateL1GasFees(bestSwap);\n    }\n  }\n  const {\n    gasCostL1USD,\n    gasCostL1QuoteToken\n  } = gasCostsL1ToL2;\n  // For each gas estimate, normalize decimals to that of the chosen usd token.\n  const estimatedGasUsedUSDs = _(bestSwap).map(routeWithValidQuote => {\n    // TODO: will error if gasToken has decimals greater than usdToken\n    const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n    if (decimalsDiff == 0) {\n      return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n    }\n    return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n  }).value();\n  let estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n  // if they are different usd pools, convert to the usdToken\n  if (estimatedGasUsedUSD.currency != gasCostL1USD.currency) {\n    const decimalsDiff = usdTokenDecimals - gasCostL1USD.currency.decimals;\n    estimatedGasUsedUSD = estimatedGasUsedUSD.add(CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(gasCostL1USD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff)))));\n  } else {\n    estimatedGasUsedUSD = estimatedGasUsedUSD.add(gasCostL1USD);\n  }\n  log.info({\n    estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n    normalizedUsdToken: usdToken,\n    routeUSDGasEstimates: _.map(bestSwap, b => `${b.percent}% ${routeToString(b.route)} ${b.gasCostInUSD.toExact()}`),\n    flatL1GasCostUSD: gasCostL1USD.toExact()\n  }, 'USD gas estimates of best route');\n  const estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, routeWithValidQuote => routeWithValidQuote.gasCostInToken)).add(gasCostL1QuoteToken);\n  const quote = sumFn(_.map(bestSwap, routeWithValidQuote => routeWithValidQuote.quote));\n  // Adjust the quoteGasAdjusted for the l1 fee\n  if (routeType == TradeType.EXACT_INPUT) {\n    const quoteGasAdjustedForL1 = quoteGasAdjusted.subtract(gasCostL1QuoteToken);\n    quoteGasAdjusted = quoteGasAdjustedForL1;\n  } else {\n    const quoteGasAdjustedForL1 = quoteGasAdjusted.add(gasCostL1QuoteToken);\n    quoteGasAdjusted = quoteGasAdjustedForL1;\n  }\n  const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);\n  metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n  return {\n    quote,\n    quoteGasAdjusted,\n    estimatedGasUsed,\n    estimatedGasUsedUSD,\n    estimatedGasUsedQuoteToken,\n    routes: routeWithQuotes\n  };\n}\n// We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\nconst findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {\n  const poolAddressSet = new Set();\n  const usedPoolAddresses = _(usedRoutes).flatMap(r => r.poolAddresses).value();\n  for (const poolAddress of usedPoolAddresses) {\n    poolAddressSet.add(poolAddress);\n  }\n  const protocolsSet = new Set();\n  const usedProtocols = _(usedRoutes).flatMap(r => r.protocol).uniq().value();\n  for (const protocol of usedProtocols) {\n    protocolsSet.add(protocol);\n  }\n  for (const routeQuote of candidateRouteQuotes) {\n    const {\n      poolAddresses,\n      protocol\n    } = routeQuote;\n    if (poolAddresses.some(poolAddress => poolAddressSet.has(poolAddress))) {\n      continue;\n    }\n    // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n    // consideration of routes that come from the same protocol as a used route.\n    const needToForce = forceCrossProtocol && protocolsSet.size == 1;\n    if (needToForce && protocolsSet.has(protocol)) {\n      continue;\n    }\n    return routeQuote;\n  }\n  return null;\n};","map":{"version":3,"sources":["../../../../../src/routers/alpha-router/functions/best-swap-route.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport FixedReverseHeap from 'mnemonist/fixed-reverse-heap';\nimport Queue from 'mnemonist/queue';\nimport { HAS_L1_FEE } from '../../../util';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport async function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig, gasModel) {\n    const now = Date.now();\n    const { forceMixedRoutes } = routingConfig;\n    /// Like with forceCrossProtocol, we apply that logic here when determining the bestSwapRoute\n    if (forceMixedRoutes) {\n        log.info({\n            forceMixedRoutes: forceMixedRoutes,\n        }, 'Forcing mixed routes by filtering out other route types');\n        routesWithValidQuotes = _.filter(routesWithValidQuotes, (quotes) => {\n            return quotes.protocol === Protocol.MIXED;\n        });\n        if (!routesWithValidQuotes) {\n            return null;\n        }\n    }\n    // Build a map of percentage of the input to list of valid quotes.\n    // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n    const percentToQuotes = {};\n    for (const routeWithValidQuote of routesWithValidQuotes) {\n        if (!percentToQuotes[routeWithValidQuote.percent]) {\n            percentToQuotes[routeWithValidQuote.percent] = [];\n        }\n        percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n    }\n    metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds);\n    // Given all the valid quotes for each percentage find the optimal route.\n    const swapRoute = await getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, (rq) => rq.quoteAdjustedForGas, routingConfig, gasModel);\n    // It is possible we were unable to find any valid route given the quotes.\n    if (!swapRoute) {\n        return null;\n    }\n    // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n    // route of our optimal quote may not add up exactly to exactIn or exactOut.\n    //\n    // We check this here, and if there is a mismatch\n    // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n    const { routes: routeAmounts } = swapRoute;\n    const totalAmount = _.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n    const missingAmount = amount.subtract(totalAmount);\n    if (missingAmount.greaterThan(0)) {\n        log.info({\n            missingAmount: missingAmount.quotient.toString(),\n        }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);\n        routeAmounts[routeAmounts.length - 1].amount =\n            routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n    }\n    log.info({\n        routes: routeAmountsToString(routeAmounts),\n        numSplits: routeAmounts.length,\n        amount: amount.toExact(),\n        quote: swapRoute.quote.toExact(),\n        quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(Math.min(swapRoute.quoteGasAdjusted.currency.decimals, 2)),\n        estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(Math.min(swapRoute.estimatedGasUsedUSD.currency.decimals, 2)),\n        estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(Math.min(swapRoute.estimatedGasUsedQuoteToken.currency.decimals, 2)),\n    }, `Found best swap route. ${routeAmounts.length} split.`);\n    return swapRoute;\n}\nexport async function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig, gasModel) {\n    var _a;\n    // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n    const percentToSortedQuotes = _.mapValues(percentToQuotes, (routeQuotes) => {\n        return routeQuotes.sort((routeQuoteA, routeQuoteB) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n            }\n            else {\n                return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n            }\n        });\n    });\n    const quoteCompFn = routeType == TradeType.EXACT_INPUT\n        ? (a, b) => a.greaterThan(b)\n        : (a, b) => a.lessThan(b);\n    const sumFn = (currencyAmounts) => {\n        let sum = currencyAmounts[0];\n        for (let i = 1; i < currencyAmounts.length; i++) {\n            sum = sum.add(currencyAmounts[i]);\n        }\n        return sum;\n    };\n    let bestQuote;\n    let bestSwap;\n    // Min-heap for tracking the 5 best swaps given some number of splits.\n    const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {\n        return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n    }, 3);\n    const { minSplits, maxSplits, forceCrossProtocol } = routingConfig;\n    if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n        log.info({\n            percentToSortedQuotes: _.mapValues(percentToSortedQuotes, (p) => p.length),\n        }, 'Did not find a valid route without any splits. Continuing search anyway.');\n    }\n    else {\n        bestQuote = by(percentToSortedQuotes[100][0]);\n        bestSwap = [percentToSortedQuotes[100][0]];\n        for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {\n            bestSwapsPerSplit.push({\n                quote: by(routeWithQuote),\n                routes: [routeWithQuote],\n            });\n        }\n    }\n    // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n    const queue = new Queue();\n    // First we seed BFS queue with the best quotes for each percentage.\n    // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n    // We will explore the various combinations from each node.\n    for (let i = percents.length; i >= 0; i--) {\n        const percent = percents[i];\n        if (!percentToSortedQuotes[percent]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][0]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: false,\n        });\n        if (!percentToSortedQuotes[percent] ||\n            !percentToSortedQuotes[percent][1]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][1]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: true,\n        });\n    }\n    let splits = 1;\n    let startedSplit = Date.now();\n    while (queue.size > 0) {\n        metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n        startedSplit = Date.now();\n        log.info({\n            top5: _.map(Array.from(bestSwapsPerSplit.consume()), (q) => `${q.quote.toExact()} (${_(q.routes)\n                .map((r) => r.toString())\n                .join(', ')})`),\n            onQueue: queue.size,\n        }, `Top 3 with ${splits} splits`);\n        bestSwapsPerSplit.clear();\n        // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n        let layer = queue.size;\n        splits++;\n        // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n        if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n            break;\n        }\n        if (splits > maxSplits) {\n            log.info('Max splits reached. Stopping search.');\n            metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);\n            break;\n        }\n        while (layer > 0) {\n            layer--;\n            const { remainingPercent, curRoutes, percentIndex, special } = queue.dequeue();\n            // For all other percentages, add a new potential route.\n            // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n            // 50% + new 10% route, 50% + new 20% route, etc.\n            for (let i = percentIndex; i >= 0; i--) {\n                const percentA = percents[i];\n                if (percentA > remainingPercent) {\n                    continue;\n                }\n                // At some point the amount * percentage is so small that the quoter is unable to get\n                // a quote. In this case there could be no quotes for that percentage.\n                if (!percentToSortedQuotes[percentA]) {\n                    continue;\n                }\n                const candidateRoutesA = percentToSortedQuotes[percentA];\n                // Find the best route in the complimentary percentage that doesn't re-use a pool already\n                // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n                // so it would make the quotes inaccurate.\n                const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n                if (!routeWithQuoteA) {\n                    continue;\n                }\n                const remainingPercentNew = remainingPercent - percentA;\n                const curRoutesNew = [...curRoutes, routeWithQuoteA];\n                // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n                if (remainingPercentNew == 0 && splits >= minSplits) {\n                    const quotesNew = _.map(curRoutesNew, (r) => by(r));\n                    const quoteNew = sumFn(quotesNew);\n                    let gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteNew.currency, 0);\n                    if (HAS_L1_FEE.includes(chainId)) {\n                        const onlyV3Routes = curRoutesNew.every((route) => route.protocol == Protocol.V3);\n                        if (gasModel == undefined || !onlyV3Routes) {\n                            throw new Error(\"Can't compute L1 gas fees.\");\n                        }\n                        else {\n                            const gasCostL1 = await gasModel.calculateL1GasFees(curRoutesNew);\n                            gasCostL1QuoteToken = gasCostL1.gasCostL1QuoteToken;\n                        }\n                    }\n                    const quoteAfterL1Adjust = routeType == TradeType.EXACT_INPUT\n                        ? quoteNew.subtract(gasCostL1QuoteToken)\n                        : quoteNew.add(gasCostL1QuoteToken);\n                    bestSwapsPerSplit.push({\n                        quote: quoteAfterL1Adjust,\n                        routes: curRoutesNew,\n                    });\n                    if (!bestQuote || quoteCompFn(quoteAfterL1Adjust, bestQuote)) {\n                        bestQuote = quoteAfterL1Adjust;\n                        bestSwap = curRoutesNew;\n                        // Temporary experiment.\n                        if (special) {\n                            metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);\n                        }\n                    }\n                }\n                else {\n                    queue.enqueue({\n                        curRoutes: curRoutesNew,\n                        remainingPercent: remainingPercentNew,\n                        percentIndex: i,\n                        special,\n                    });\n                }\n            }\n        }\n    }\n    if (!bestSwap) {\n        log.info(`Could not find a valid swap`);\n        return undefined;\n    }\n    const postSplitNow = Date.now();\n    let quoteGasAdjusted = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quoteAdjustedForGas));\n    // this calculates the base gas used\n    // if on L1, its the estimated gas used based on hops and ticks across all the routes\n    // if on L2, its the gas used on the L2 based on hops and ticks across all the routes\n    const estimatedGasUsed = _(bestSwap)\n        .map((routeWithValidQuote) => routeWithValidQuote.gasEstimate)\n        .reduce((sum, routeWithValidQuote) => sum.add(routeWithValidQuote), BigNumber.from(0));\n    if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n        // Each route can use a different stablecoin to account its gas costs.\n        // They should all be pegged, and this is just an estimate, so we do a merge\n        // to an arbitrary stable.\n        throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n    }\n    const usdToken = usdGasTokensByChain[chainId][0];\n    const usdTokenDecimals = usdToken.decimals;\n    // if on L2, calculate the L1 security fee\n    let gasCostsL1ToL2 = {\n        gasUsedL1: BigNumber.from(0),\n        gasCostL1USD: CurrencyAmount.fromRawAmount(usdToken, 0),\n        gasCostL1QuoteToken: CurrencyAmount.fromRawAmount(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n        (_a = bestSwap[0]) === null || _a === void 0 ? void 0 : _a.quoteToken, 0),\n    };\n    // If swapping on an L2 that includes a L1 security fee, calculate the fee and include it in the gas adjusted quotes\n    if (HAS_L1_FEE.includes(chainId)) {\n        // ensure the gasModel exists and that the swap route is a v3 only route\n        const onlyV3Routes = bestSwap.every((route) => route.protocol == Protocol.V3);\n        if (gasModel == undefined || !onlyV3Routes) {\n            throw new Error(\"Can't compute L1 gas fees.\");\n        }\n        else {\n            gasCostsL1ToL2 = await gasModel.calculateL1GasFees(bestSwap);\n        }\n    }\n    const { gasCostL1USD, gasCostL1QuoteToken } = gasCostsL1ToL2;\n    // For each gas estimate, normalize decimals to that of the chosen usd token.\n    const estimatedGasUsedUSDs = _(bestSwap)\n        .map((routeWithValidQuote) => {\n        // TODO: will error if gasToken has decimals greater than usdToken\n        const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n        if (decimalsDiff == 0) {\n            return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n        }\n        return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n    })\n        .value();\n    let estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n    // if they are different usd pools, convert to the usdToken\n    if (estimatedGasUsedUSD.currency != gasCostL1USD.currency) {\n        const decimalsDiff = usdTokenDecimals - gasCostL1USD.currency.decimals;\n        estimatedGasUsedUSD = estimatedGasUsedUSD.add(CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(gasCostL1USD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff)))));\n    }\n    else {\n        estimatedGasUsedUSD = estimatedGasUsedUSD.add(gasCostL1USD);\n    }\n    log.info({\n        estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n        normalizedUsdToken: usdToken,\n        routeUSDGasEstimates: _.map(bestSwap, (b) => `${b.percent}% ${routeToString(b.route)} ${b.gasCostInUSD.toExact()}`),\n        flatL1GasCostUSD: gasCostL1USD.toExact(),\n    }, 'USD gas estimates of best route');\n    const estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.gasCostInToken)).add(gasCostL1QuoteToken);\n    const quote = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quote));\n    // Adjust the quoteGasAdjusted for the l1 fee\n    if (routeType == TradeType.EXACT_INPUT) {\n        const quoteGasAdjustedForL1 = quoteGasAdjusted.subtract(gasCostL1QuoteToken);\n        quoteGasAdjusted = quoteGasAdjustedForL1;\n    }\n    else {\n        const quoteGasAdjustedForL1 = quoteGasAdjusted.add(gasCostL1QuoteToken);\n        quoteGasAdjusted = quoteGasAdjustedForL1;\n    }\n    const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);\n    metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n    return {\n        quote,\n        quoteGasAdjusted,\n        estimatedGasUsed,\n        estimatedGasUsedUSD,\n        estimatedGasUsedQuoteToken,\n        routes: routeWithQuotes,\n    };\n}\n// We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\nconst findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {\n    const poolAddressSet = new Set();\n    const usedPoolAddresses = _(usedRoutes)\n        .flatMap((r) => r.poolAddresses)\n        .value();\n    for (const poolAddress of usedPoolAddresses) {\n        poolAddressSet.add(poolAddress);\n    }\n    const protocolsSet = new Set();\n    const usedProtocols = _(usedRoutes)\n        .flatMap((r) => r.protocol)\n        .uniq()\n        .value();\n    for (const protocol of usedProtocols) {\n        protocolsSet.add(protocol);\n    }\n    for (const routeQuote of candidateRouteQuotes) {\n        const { poolAddresses, protocol } = routeQuote;\n        if (poolAddresses.some((poolAddress) => poolAddressSet.has(poolAddress))) {\n            continue;\n        }\n        // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n        // consideration of routes that come from the same protocol as a used route.\n        const needToForce = forceCrossProtocol && protocolsSet.size == 1;\n        if (needToForce && protocolsSet.has(protocol)) {\n            continue;\n        }\n        return routeQuote;\n    }\n    return null;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVzdC1zd2FwLXJvdXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3JvdXRlcnMvYWxwaGEtcm91dGVyL2Z1bmN0aW9ucy9iZXN0LXN3YXAtcm91dGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLGdCQUFnQixNQUFNLDhCQUE4QixDQUFDO0FBQzVELE9BQU8sS0FBSyxNQUFNLGlCQUFpQixDQUFDO0FBRXBDLE9BQU8sRUFBVyxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUN4QyxPQUFPLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGFBQWEsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRTNFLE9BQU8sRUFBNkIsbUJBQW1CLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFPL0UsTUFBTSxDQUFDLEtBQUssVUFBVSxnQkFBZ0IsQ0FDcEMsTUFBc0IsRUFDdEIsUUFBa0IsRUFDbEIscUJBQTRDLEVBQzVDLFNBQW9CLEVBQ3BCLE9BQWdCLEVBQ2hCLGFBQWdDLEVBQ2hDLFFBQTJDO0lBUzNDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUV2QixNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxh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"]},"metadata":{},"sourceType":"module"}