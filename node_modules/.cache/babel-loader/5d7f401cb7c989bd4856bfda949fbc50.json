{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBestProvider = void 0;\n/**\n * @param providers - An array of providers to try to connect to.\n * @param timeout - How long to wait before a call is considered failed, in ms.\n */\nfunction getBestProvider(providers) {\n  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(providers.length === 1)) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\", providers[0]);\n          case 2:\n            return _context.abrupt(\"return\", new Promise(function (resolve) {\n              var resolved = false;\n              var successes = {};\n              providers.forEach(function (provider, i) {\n                // create a promise that resolves on a successful call, and rejects on a failed call or after timeout milliseconds\n                var promise = new Promise(function (resolve, reject) {\n                  provider.getNetwork().then(function () {\n                    return resolve();\n                  }).catch(function () {\n                    return reject();\n                  });\n                  // set a timeout to reject\n                  setTimeout(function () {\n                    reject();\n                  }, timeout);\n                });\n                void promise.then(function () {\n                  return true;\n                }).catch(function () {\n                  return false;\n                }).then(function (success) {\n                  // if we already resolved, return\n                  if (resolved) return;\n                  // store the result of the call\n                  successes[i] = success;\n                  // if this is the last call and we haven't resolved yet - do so\n                  if (Object.keys(successes).length === providers.length) {\n                    var index = Object.keys(successes).findIndex(function (j) {\n                      return successes[Number(j)];\n                    });\n                    // no need to set resolved to true, as this is the last promise\n                    return resolve(providers[index === -1 ? 0 : index]);\n                  }\n                  // otherwise, for each prospective index, check if we can resolve\n                  new Array(providers.length).fill(0).forEach(function (_, prospectiveIndex) {\n                    // to resolve, we need to:\n                    // a) have successfully made a call\n                    // b) not be waiting on any other higher-index calls\n                    if (successes[prospectiveIndex] && new Array(prospectiveIndex).fill(0).every(function (_, j) {\n                      return successes[j] === false;\n                    })) {\n                      resolved = true;\n                      resolve(providers[prospectiveIndex]);\n                    }\n                  });\n                });\n              });\n            }));\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexports.getBestProvider = getBestProvider;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","getBestProvider","providers","timeout","length","resolved","successes","forEach","provider","i","promise","getNetwork","catch","setTimeout","success","keys","index","findIndex","j","Number","Array","fill","_","prospectiveIndex","every"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/@web3-react/network/dist/utils.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBestProvider = void 0;\n/**\n * @param providers - An array of providers to try to connect to.\n * @param timeout - How long to wait before a call is considered failed, in ms.\n */\nfunction getBestProvider(providers, timeout = 5000) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // if we only have 1 provider, it's the best!\n        if (providers.length === 1)\n            return providers[0];\n        // the below returns the first provider for which there's been a successful call, prioritized by index\n        return new Promise((resolve) => {\n            let resolved = false;\n            const successes = {};\n            providers.forEach((provider, i) => {\n                // create a promise that resolves on a successful call, and rejects on a failed call or after timeout milliseconds\n                const promise = new Promise((resolve, reject) => {\n                    provider\n                        .getNetwork()\n                        .then(() => resolve())\n                        .catch(() => reject());\n                    // set a timeout to reject\n                    setTimeout(() => {\n                        reject();\n                    }, timeout);\n                });\n                void promise\n                    .then(() => true)\n                    .catch(() => false)\n                    .then((success) => {\n                    // if we already resolved, return\n                    if (resolved)\n                        return;\n                    // store the result of the call\n                    successes[i] = success;\n                    // if this is the last call and we haven't resolved yet - do so\n                    if (Object.keys(successes).length === providers.length) {\n                        const index = Object.keys(successes).findIndex((j) => successes[Number(j)]);\n                        // no need to set resolved to true, as this is the last promise\n                        return resolve(providers[index === -1 ? 0 : index]);\n                    }\n                    // otherwise, for each prospective index, check if we can resolve\n                    new Array(providers.length).fill(0).forEach((_, prospectiveIndex) => {\n                        // to resolve, we need to:\n                        // a) have successfully made a call\n                        // b) not be waiting on any other higher-index calls\n                        if (successes[prospectiveIndex] &&\n                            new Array(prospectiveIndex).fill(0).every((_, j) => successes[j] === false)) {\n                            resolved = true;\n                            resolve(providers[prospectiveIndex]);\n                        }\n                    });\n                });\n            });\n        });\n    });\n}\nexports.getBestProvider = getBestProvider;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}