{"ast":null,"code":"var _s = $RefreshSig$();\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { SupportedChainId } from 'constants/chains';\nimport { useMemo } from 'react';\nimport { useAllCurrencyCombinations } from './useAllCurrencyCombinations';\nimport { PoolState, usePools } from './usePools';\n\n/**\n * Returns all the existing pools that should be considered for swapping between an input currency and an output currency\n * @param currencyIn the input currency\n * @param currencyOut the output currency\n */\nexport function useV3SwapPools(currencyIn, currencyOut) {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  const allCurrencyCombinations = useAllCurrencyCombinations(currencyIn, currencyOut);\n  const allCurrencyCombinationsWithAllFees = useMemo(() => allCurrencyCombinations.reduce((list, _ref) => {\n    let [tokenA, tokenB] = _ref;\n    return chainId === SupportedChainId.MAINNET ? list.concat([[tokenA, tokenB, FeeAmount.LOW], [tokenA, tokenB, FeeAmount.MEDIUM], [tokenA, tokenB, FeeAmount.HIGH]]) : list.concat([[tokenA, tokenB, FeeAmount.LOWEST], [tokenA, tokenB, FeeAmount.LOW], [tokenA, tokenB, FeeAmount.MEDIUM], [tokenA, tokenB, FeeAmount.HIGH]]);\n  }, []), [allCurrencyCombinations, chainId]);\n  const pools = usePools(allCurrencyCombinationsWithAllFees);\n  return useMemo(() => {\n    return {\n      pools: pools.filter(tuple => {\n        return tuple[0] === PoolState.EXISTS && tuple[1] !== null;\n      }).map(_ref2 => {\n        let [, pool] = _ref2;\n        return pool;\n      }),\n      loading: pools.some(_ref3 => {\n        let [state] = _ref3;\n        return state === PoolState.LOADING;\n      })\n    };\n  }, [pools]);\n}\n_s(useV3SwapPools, \"3rDF9LK9woFn2hklwcUzoLfII4A=\", false, function () {\n  return [useWeb3React, useAllCurrencyCombinations, usePools];\n});","map":{"version":3,"names":["FeeAmount","useWeb3React","SupportedChainId","useMemo","useAllCurrencyCombinations","PoolState","usePools","useV3SwapPools","currencyIn","currencyOut","chainId","allCurrencyCombinations","allCurrencyCombinationsWithAllFees","reduce","list","tokenA","tokenB","MAINNET","concat","LOW","MEDIUM","HIGH","LOWEST","pools","filter","tuple","EXISTS","map","pool","loading","some","state","LOADING"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useV3SwapPools.ts"],"sourcesContent":["import { Currency, Token } from '@uniswap/sdk-core'\nimport { FeeAmount, Pool } from '@uniswap/v3-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { SupportedChainId } from 'constants/chains'\nimport { useMemo } from 'react'\n\nimport { useAllCurrencyCombinations } from './useAllCurrencyCombinations'\nimport { PoolState, usePools } from './usePools'\n\n/**\n * Returns all the existing pools that should be considered for swapping between an input currency and an output currency\n * @param currencyIn the input currency\n * @param currencyOut the output currency\n */\nexport function useV3SwapPools(\n  currencyIn?: Currency,\n  currencyOut?: Currency\n): {\n  pools: Pool[]\n  loading: boolean\n} {\n  const { chainId } = useWeb3React()\n\n  const allCurrencyCombinations = useAllCurrencyCombinations(currencyIn, currencyOut)\n\n  const allCurrencyCombinationsWithAllFees: [Token, Token, FeeAmount][] = useMemo(\n    () =>\n      allCurrencyCombinations.reduce<[Token, Token, FeeAmount][]>((list, [tokenA, tokenB]) => {\n        return chainId === SupportedChainId.MAINNET\n          ? list.concat([\n              [tokenA, tokenB, FeeAmount.LOW],\n              [tokenA, tokenB, FeeAmount.MEDIUM],\n              [tokenA, tokenB, FeeAmount.HIGH],\n            ])\n          : list.concat([\n              [tokenA, tokenB, FeeAmount.LOWEST],\n              [tokenA, tokenB, FeeAmount.LOW],\n              [tokenA, tokenB, FeeAmount.MEDIUM],\n              [tokenA, tokenB, FeeAmount.HIGH],\n            ])\n      }, []),\n    [allCurrencyCombinations, chainId]\n  )\n\n  const pools = usePools(allCurrencyCombinationsWithAllFees)\n\n  return useMemo(() => {\n    return {\n      pools: pools\n        .filter((tuple): tuple is [PoolState.EXISTS, Pool] => {\n          return tuple[0] === PoolState.EXISTS && tuple[1] !== null\n        })\n        .map(([, pool]) => pool),\n      loading: pools.some(([state]) => state === PoolState.LOADING),\n    }\n  }, [pools])\n}\n"],"mappings":";AACA,SAASA,SAAS,QAAc,iBAAiB;AACjD,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,gBAAgB,QAAQ,kBAAkB;AACnD,SAASC,OAAO,QAAQ,OAAO;AAE/B,SAASC,0BAA0B,QAAQ,8BAA8B;AACzE,SAASC,SAAS,EAAEC,QAAQ,QAAQ,YAAY;;AAEhD;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAc,CAC5BC,UAAqB,EACrBC,WAAsB,EAItB;EAAA;EACA,MAAM;IAAEC;EAAQ,CAAC,GAAGT,YAAY,EAAE;EAElC,MAAMU,uBAAuB,GAAGP,0BAA0B,CAACI,UAAU,EAAEC,WAAW,CAAC;EAEnF,MAAMG,kCAA+D,GAAGT,OAAO,CAC7E,MACEQ,uBAAuB,CAACE,MAAM,CAA8B,CAACC,IAAI,WAAuB;IAAA,IAArB,CAACC,MAAM,EAAEC,MAAM,CAAC;IACjF,OAAON,OAAO,KAAKR,gBAAgB,CAACe,OAAO,GACvCH,IAAI,CAACI,MAAM,CAAC,CACV,CAACH,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACmB,GAAG,CAAC,EAC/B,CAACJ,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACoB,MAAM,CAAC,EAClC,CAACL,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACqB,IAAI,CAAC,CACjC,CAAC,GACFP,IAAI,CAACI,MAAM,CAAC,CACV,CAACH,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACsB,MAAM,CAAC,EAClC,CAACP,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACmB,GAAG,CAAC,EAC/B,CAACJ,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACoB,MAAM,CAAC,EAClC,CAACL,MAAM,EAAEC,MAAM,EAAEhB,SAAS,CAACqB,IAAI,CAAC,CACjC,CAAC;EACR,CAAC,EAAE,EAAE,CAAC,EACR,CAACV,uBAAuB,EAAED,OAAO,CAAC,CACnC;EAED,MAAMa,KAAK,GAAGjB,QAAQ,CAACM,kCAAkC,CAAC;EAE1D,OAAOT,OAAO,CAAC,MAAM;IACnB,OAAO;MACLoB,KAAK,EAAEA,KAAK,CACTC,MAAM,CAAEC,KAAK,IAAwC;QACpD,OAAOA,KAAK,CAAC,CAAC,CAAC,KAAKpB,SAAS,CAACqB,MAAM,IAAID,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI;MAC3D,CAAC,CAAC,CACDE,GAAG,CAAC;QAAA,IAAC,GAAGC,IAAI,CAAC;QAAA,OAAKA,IAAI;MAAA,EAAC;MAC1BC,OAAO,EAAEN,KAAK,CAACO,IAAI,CAAC;QAAA,IAAC,CAACC,KAAK,CAAC;QAAA,OAAKA,KAAK,KAAK1B,SAAS,CAAC2B,OAAO;MAAA;IAC9D,CAAC;EACH,CAAC,EAAE,CAACT,KAAK,CAAC,CAAC;AACb;AAAC,GA1CehB,cAAc;EAAA,QAORN,YAAY,EAEAG,0BAA0B,EAqB5CE,QAAQ;AAAA"},"metadata":{},"sourceType":"module"}