{"ast":null,"code":"import _regeneratorRuntime from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _wrapNativeSuper from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";import _createClass from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _classCallCheck from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _inherits from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import _asyncToGenerator from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getCacheKeyForURL,matchPrecache}from'workbox-precaching';import{Route}from'workbox-routing';import{isDevelopment}from'./utils';var fileExtensionRegexp=new RegExp('/[^/?]+\\\\.[^/]+$');var DOCUMENT=process.env.PUBLIC_URL+'/index.html';/**\n * Matches with App Shell-style routing, so that navigation requests are fulfilled with an index.html shell.\n * See https://developers.google.com/web/fundamentals/architecture/app-shell\n */export function matchDocument(_ref){var request=_ref.request,url=_ref.url;// If this isn't a navigation, skip.\nif(request.mode!=='navigate'){return false;}// If this looks like a resource (ie has a file extension), skip.\nif(url.pathname.match(fileExtensionRegexp)){return false;}// If this isn't app.uniswap.org (or a local build), skip.\n// IPFS gateways may not have domain separation, so they cannot use document caching.\nif(url.hostname!=='app.uniswap.org'&&!isDevelopment()){return false;}return true;}/**\n * The returned document should always be fresh, so this handler uses a custom strategy:\n *\n * - Always fetches the document.\n * - When available, compares the etag headers of the fetched and cached documents:\n *   - If matching (fresh) or missing (offline), returns the cached document.\n *   - If not matching (stale), returns the fetched document.\n *\n * This ensures that the user will always see the latest document. It requires a network fetch to check the cached\n * document's freshness, but does not require a full fetch in most cases, so it still saves time. This is identical to\n * the browser's builtin etag strategy, reimplemented in the ServiceWorker.\n *\n * In addition, this handler may serve an offline document if there is no internet connection.\n */export function handleDocument(_x){return _handleDocument.apply(this,arguments);}function _handleDocument(){_handleDocument=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2){var _this$offlineDocument,_response;var request,requestUrl,cachedResponse,controller,response,etag,cachedEtag;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:request=_ref2.request;if(!('onLine'in navigator&&!navigator.onLine)){_context2.next=3;break;}return _context2.abrupt(\"return\",(this===null||this===void 0?void 0:(_this$offlineDocument=this.offlineDocument)===null||_this$offlineDocument===void 0?void 0:_this$offlineDocument.clone())||fetch(request));case 3:// The exact cache key should be used for requests, as etags will be different for different paths.\n// This also prevents usage of preloadResponse.\nrequestUrl=getCacheKeyForURL(DOCUMENT);_context2.next=6;return matchPrecache(DOCUMENT);case 6:cachedResponse=_context2.sent;// Responses will throw if offline, but if cached the cached response should still be returned.\ncontroller=new AbortController();_context2.prev=8;_context2.next=11;return fetch(requestUrl||DOCUMENT,{cache:'reload',signal:controller.signal});case 11:response=_context2.sent;if(cachedResponse){_context2.next=14;break;}return _context2.abrupt(\"return\",new Response(response.body,response));case 14:_context2.next=21;break;case 16:_context2.prev=16;_context2.t0=_context2[\"catch\"](8);if(cachedResponse){_context2.next=20;break;}throw _context2.t0;case 20:return _context2.abrupt(\"return\",CachedDocument.from(cachedResponse));case 21:// The etag header can be queried before the entire response body has streamed, so it is still a\n// performant cache key.\netag=(_response=response)===null||_response===void 0?void 0:_response.headers.get('etag');cachedEtag=cachedResponse===null||cachedResponse===void 0?void 0:cachedResponse.headers.get('etag');if(!(etag&&etag===cachedEtag)){_context2.next=26;break;}// If the cache is still fresh, cancel the pending response.\ncontroller.abort();return _context2.abrupt(\"return\",CachedDocument.from(cachedResponse));case 26:return _context2.abrupt(\"return\",new Response(response.body,response));case 27:case\"end\":return _context2.stop();}}},_callee2,this,[[8,16]]);}));return _handleDocument.apply(this,arguments);}export var DocumentRoute=/*#__PURE__*/function(_Route){_inherits(DocumentRoute,_Route);var _super=_createSuper(DocumentRoute);function DocumentRoute(offlineDocument){_classCallCheck(this,DocumentRoute);return _super.call(this,matchDocument,handleDocument.bind({offlineDocument:offlineDocument}),'GET');}return _createClass(DocumentRoute);}(Route);/**\n * A cache-specific version of the document.\n * This document sets the local `__isDocumentCached` variable to true.\n */export var CachedDocument=/*#__PURE__*/function(_Response){_inherits(CachedDocument,_Response);var _super2=_createSuper(CachedDocument);function CachedDocument(text,response){_classCallCheck(this,CachedDocument);return _super2.call(this,text,response);}_createClass(CachedDocument,null,[{key:\"from\",value:function(){var _from=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(response){var text,headers,init;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return response.text();case 2:text=_context.sent;// Set the content-type explicitly. Some browsers (Android 12; Chrome 91) use an invalid content-type header.\nheaders=new Headers(response.headers);headers.set('Content-Type','text/html; charset=utf-8');init=_objectSpread(_objectSpread({},response),{},{headers:headers});// Injects a marker into the document so that client code knows it was served from cache.\n// The marker should be injected immediately in the <body> so it is available to client code.\nreturn _context.abrupt(\"return\",new CachedDocument(text.replace('<body>','<body><script>window.__isDocumentCached=true</script>'),init));case 7:case\"end\":return _context.stop();}}},_callee);}));function from(_x2){return _from.apply(this,arguments);}return from;}()}]);return CachedDocument;}(/*#__PURE__*/_wrapNativeSuper(Response));","map":{"version":3,"names":["getCacheKeyForURL","matchPrecache","Route","isDevelopment","fileExtensionRegexp","RegExp","DOCUMENT","process","env","PUBLIC_URL","matchDocument","request","url","mode","pathname","match","hostname","handleDocument","navigator","onLine","offlineDocument","clone","fetch","requestUrl","cachedResponse","controller","AbortController","cache","signal","response","Response","body","CachedDocument","from","etag","headers","get","cachedEtag","abort","DocumentRoute","bind","text","Headers","set","init","replace"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/serviceWorker/document.ts"],"sourcesContent":["import { RouteHandlerCallbackOptions, RouteMatchCallbackOptions } from 'workbox-core'\nimport { getCacheKeyForURL, matchPrecache } from 'workbox-precaching'\nimport { Route } from 'workbox-routing'\n\nimport { isDevelopment } from './utils'\n\nconst fileExtensionRegexp = new RegExp('/[^/?]+\\\\.[^/]+$')\nconst DOCUMENT = process.env.PUBLIC_URL + '/index.html'\n\n/**\n * Matches with App Shell-style routing, so that navigation requests are fulfilled with an index.html shell.\n * See https://developers.google.com/web/fundamentals/architecture/app-shell\n */\nexport function matchDocument({ request, url }: RouteMatchCallbackOptions) {\n  // If this isn't a navigation, skip.\n  if (request.mode !== 'navigate') {\n    return false\n  }\n\n  // If this looks like a resource (ie has a file extension), skip.\n  if (url.pathname.match(fileExtensionRegexp)) {\n    return false\n  }\n\n  // If this isn't app.uniswap.org (or a local build), skip.\n  // IPFS gateways may not have domain separation, so they cannot use document caching.\n  if (url.hostname !== 'app.uniswap.org' && !isDevelopment()) {\n    return false\n  }\n\n  return true\n}\n\ntype HandlerContext = {\n  offlineDocument?: Response\n} | void\n\n/**\n * The returned document should always be fresh, so this handler uses a custom strategy:\n *\n * - Always fetches the document.\n * - When available, compares the etag headers of the fetched and cached documents:\n *   - If matching (fresh) or missing (offline), returns the cached document.\n *   - If not matching (stale), returns the fetched document.\n *\n * This ensures that the user will always see the latest document. It requires a network fetch to check the cached\n * document's freshness, but does not require a full fetch in most cases, so it still saves time. This is identical to\n * the browser's builtin etag strategy, reimplemented in the ServiceWorker.\n *\n * In addition, this handler may serve an offline document if there is no internet connection.\n */\nexport async function handleDocument(this: HandlerContext, { request }: RouteHandlerCallbackOptions) {\n  // If we are offline, serve the offline document.\n  if ('onLine' in navigator && !navigator.onLine) return this?.offlineDocument?.clone() || fetch(request)\n\n  // The exact cache key should be used for requests, as etags will be different for different paths.\n  // This also prevents usage of preloadResponse.\n  const requestUrl = getCacheKeyForURL(DOCUMENT)\n  const cachedResponse = await matchPrecache(DOCUMENT)\n\n  // Responses will throw if offline, but if cached the cached response should still be returned.\n  const controller = new AbortController()\n  let response\n  try {\n    response = await fetch(requestUrl || DOCUMENT, { cache: 'reload', signal: controller.signal })\n    if (!cachedResponse) {\n      return new Response(response.body, response)\n    }\n  } catch (e) {\n    if (!cachedResponse) throw e\n    return CachedDocument.from(cachedResponse)\n  }\n\n  // The etag header can be queried before the entire response body has streamed, so it is still a\n  // performant cache key.\n  const etag = response?.headers.get('etag')\n  const cachedEtag = cachedResponse?.headers.get('etag')\n  if (etag && etag === cachedEtag) {\n    // If the cache is still fresh, cancel the pending response.\n    controller.abort()\n    return CachedDocument.from(cachedResponse)\n  }\n\n  return new Response(response.body, response)\n}\n\nexport class DocumentRoute extends Route {\n  constructor(offlineDocument?: Response) {\n    super(matchDocument, handleDocument.bind({ offlineDocument }), 'GET')\n  }\n}\n\n/**\n * A cache-specific version of the document.\n * This document sets the local `__isDocumentCached` variable to true.\n */\nexport class CachedDocument extends Response {\n  static async from(response: Response) {\n    const text = await response.text()\n\n    // Set the content-type explicitly. Some browsers (Android 12; Chrome 91) use an invalid content-type header.\n    const headers = new Headers(response.headers)\n    headers.set('Content-Type', 'text/html; charset=utf-8')\n    const init = { ...response, headers }\n\n    // Injects a marker into the document so that client code knows it was served from cache.\n    // The marker should be injected immediately in the <body> so it is available to client code.\n    return new CachedDocument(text.replace('<body>', '<body><script>window.__isDocumentCached=true</script>'), init)\n  }\n\n  private constructor(text: string, response: Response) {\n    super(text, response)\n  }\n}\n"],"mappings":"g1CACA,OAASA,iBAAiB,CAAEC,aAAa,KAAQ,oBAAoB,CACrE,OAASC,KAAK,KAAQ,iBAAiB,CAEvC,OAASC,aAAa,KAAQ,SAAS,CAEvC,GAAMC,oBAAmB,CAAG,GAAIC,OAAM,CAAC,kBAAkB,CAAC,CAC1D,GAAMC,SAAQ,CAAGC,OAAO,CAACC,GAAG,CAACC,UAAU,CAAG,aAAa,CAEvD;AACA;AACA;AACA,GACA,MAAO,SAASC,cAAa,MAA8C,IAA3CC,QAAO,MAAPA,OAAO,CAAEC,GAAG,MAAHA,GAAG,CAC1C;AACA,GAAID,OAAO,CAACE,IAAI,GAAK,UAAU,CAAE,CAC/B,MAAO,MAAK,CACd,CAEA;AACA,GAAID,GAAG,CAACE,QAAQ,CAACC,KAAK,CAACX,mBAAmB,CAAC,CAAE,CAC3C,MAAO,MAAK,CACd,CAEA;AACA;AACA,GAAIQ,GAAG,CAACI,QAAQ,GAAK,iBAAiB,EAAI,CAACb,aAAa,EAAE,CAAE,CAC1D,MAAO,MAAK,CACd,CAEA,MAAO,KAAI,CACb,CAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,eAAsBc,eAAc,mDAiCnC,mGAjCM,2PAAsDN,OAAO,OAAPA,OAAO,MAE9D,QAAQ,EAAIO,UAAS,EAAI,CAACA,SAAS,CAACC,MAAM,4DAAS,KAAI,SAAJ,IAAI,wCAAJ,IAAI,CAAEC,eAAe,gDAArB,sBAAuBC,KAAK,EAAE,GAAIC,KAAK,CAACX,OAAO,CAAC,SAEvG;AACA;AACMY,UAAU,CAAGvB,iBAAiB,CAACM,QAAQ,CAAC,wBACjBL,cAAa,CAACK,QAAQ,CAAC,QAA9CkB,cAAc,gBAEpB;AACMC,UAAU,CAAG,GAAIC,gBAAe,EAAE,0CAGrBJ,MAAK,CAACC,UAAU,EAAIjB,QAAQ,CAAE,CAAEqB,KAAK,CAAE,QAAQ,CAAEC,MAAM,CAAEH,UAAU,CAACG,MAAO,CAAC,CAAC,SAA9FC,QAAQ,mBACHL,cAAc,4DACV,GAAIM,SAAQ,CAACD,QAAQ,CAACE,IAAI,CAAEF,QAAQ,CAAC,kGAGzCL,cAAc,uFACZQ,cAAc,CAACC,IAAI,CAACT,cAAc,CAAC,UAG5C;AACA;AACMU,IAAI,YAAGL,QAAQ,oCAAR,UAAUM,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC,CACpCC,UAAU,CAAGb,cAAc,SAAdA,cAAc,iBAAdA,cAAc,CAAEW,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC,MAClDF,IAAI,EAAIA,IAAI,GAAKG,UAAU,4BAC7B;AACAZ,UAAU,CAACa,KAAK,EAAE,kCACXN,cAAc,CAACC,IAAI,CAACT,cAAc,CAAC,2CAGrC,GAAIM,SAAQ,CAACD,QAAQ,CAACE,IAAI,CAAEF,QAAQ,CAAC,yEAC7C,iDAED,UAAaU,cAAa,sGACxB,uBAAYnB,eAA0B,CAAE,6DAChCV,aAAa,CAAEO,cAAc,CAACuB,IAAI,CAAC,CAAEpB,eAAe,CAAfA,eAAgB,CAAC,CAAC,CAAE,KAAK,EACtE,CAAC,qCAHgClB,KAAK,EAMxC;AACA;AACA;AACA,GACA,UAAa8B,eAAc,+GAczB,wBAAoBS,IAAY,CAAEZ,QAAkB,CAAE,+DAC9CY,IAAI,CAAEZ,QAAQ,EACtB,CAAC,iIAfD,iBAAkBA,QAAkB,8JACfA,SAAQ,CAACY,IAAI,EAAE,QAA5BA,IAAI,eAEV;AACMN,OAAO,CAAG,GAAIO,QAAO,CAACb,QAAQ,CAACM,OAAO,CAAC,CAC7CA,OAAO,CAACQ,GAAG,CAAC,cAAc,CAAE,0BAA0B,CAAC,CACjDC,IAAI,gCAAQf,QAAQ,MAAEM,OAAO,CAAPA,OAAO,GAEnC;AACA;AAAA,gCACO,GAAIH,eAAc,CAACS,IAAI,CAACI,OAAO,CAAC,QAAQ,CAAE,uDAAuD,CAAC,CAAED,IAAI,CAAC,wDACjH,mIAZiCd,QAAQ"},"metadata":{},"sourceType":"module"}