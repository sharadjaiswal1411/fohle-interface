{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n  const hash = {};\n  for (const item of arr) hash[item] = true;\n  return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it) {\n  let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : it.schema;\n  const {\n    opts,\n    self\n  } = it;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  const rules = self.RULES.keywords;\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`);\n  }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (rules[key]) return true;\n  return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true;\n  return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal(_ref, schema, keyword, $data) {\n  let {\n    topSchemaRef,\n    schemaPath\n  } = _ref;\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return (0, codegen_1._)`${schema}`;\n  }\n  return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return `${str}`;\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x);\n  } else {\n    f(xs);\n  }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated(_ref2) {\n  let {\n    mergeNames,\n    mergeToName,\n    mergeValues,\n    resultToName\n  } = _ref2;\n  return (gen, from, to, toName) => {\n    const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {\n      gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));\n    }),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {\n      if (from === true) {\n        gen.assign(to, true);\n      } else {\n        gen.assign(to, (0, codegen_1._)`${to} || {}`);\n        setEvaluated(gen, to, from);\n      }\n    }),\n    mergeValues: (from, to) => from === true ? true : {\n      ...from,\n      ...to\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),\n    mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n    resultToName: (gen, items) => gen.var(\"items\", items)\n  })\n};\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  const props = gen.var(\"props\", (0, codegen_1._)`{}`);\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(p => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? (0, codegen_1._)`\"[\" + ${dataProp} + \"]\"` : (0, codegen_1._)`\"['\" + ${dataProp} + \"']\"` : isNumber ? (0, codegen_1._)`\"/\" + ${dataProp}` : (0, codegen_1._)`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n  }\n\n  return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : it.opts.strictSchema;\n  if (!mode) return;\n  msg = `strict mode: ${msg}`;\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;","map":{"version":3,"sources":["../../lib/compile/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}