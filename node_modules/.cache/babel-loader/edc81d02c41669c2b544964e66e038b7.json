{"ast":null,"code":"var _s = $RefreshSig$();\nimport gql from 'graphql-tag';\nimport { useEffect, useMemo, useState } from 'react';\nimport { useActiveNetworkVersion, useClients } from 'state/application/hooks';\nimport { splitQuery } from 'utils/queries';\nconst GET_BLOCKS = timestamps => {\n  let queryString = 'query blocks {';\n  queryString += timestamps.map(timestamp => {\n    return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: desc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${timestamp + 600} }) {\n        number\n      }`;\n  });\n  queryString += '}';\n  return gql(queryString);\n};\n\n/**\n * for a given array of timestamps, returns block entities\n * @param timestamps\n */\n_c = GET_BLOCKS;\nfunction useBlocksFromTimestamps(timestamps, blockClientOverride) {\n  _s();\n  const [activeNetwork] = useActiveNetworkVersion();\n  const [blocks, setBlocks] = useState();\n  const [error, setError] = useState(false);\n  const {\n    blockClient\n  } = useClients();\n  const activeBlockClient = blockClientOverride !== null && blockClientOverride !== void 0 ? blockClientOverride : blockClient;\n\n  // derive blocks based on active network\n  const networkBlocks = blocks === null || blocks === void 0 ? void 0 : blocks[activeNetwork.id];\n  useEffect(() => {\n    async function fetchData() {\n      const results = await splitQuery(GET_BLOCKS, activeBlockClient, [], timestamps);\n      if (results) {\n        setBlocks({\n          ...(blocks !== null && blocks !== void 0 ? blocks : {}),\n          [activeNetwork.id]: results\n        });\n      } else {\n        setError(true);\n      }\n    }\n    if (!networkBlocks && !error) {\n      fetchData();\n    }\n  });\n  const blocksFormatted = useMemo(() => {\n    if (blocks === null || blocks === void 0 ? void 0 : blocks[activeNetwork.id]) {\n      const networkBlocks = blocks === null || blocks === void 0 ? void 0 : blocks[activeNetwork.id];\n      const formatted = [];\n      for (const t in networkBlocks) {\n        if (networkBlocks[t].length > 0) {\n          formatted.push({\n            timestamp: t.split('t')[1],\n            number: networkBlocks[t][0]['number']\n          });\n        }\n      }\n      return formatted;\n    }\n    return undefined;\n  }, [activeNetwork.id, blocks]);\n  return {\n    blocks: blocksFormatted,\n    error\n  };\n}\n\n/**\n * @notice Fetches block objects for an array of timestamps.\n * @dev blocks are returned in chronological order (ASC) regardless of input.\n * @dev blocks are returned at string representations of Int\n * @dev timestamps are returns as they were provided; not the block time.\n * @param {Array} timestamps\n */\n_s(useBlocksFromTimestamps, \"7XPD/MRIv2vachKCsXCpFkQhUmA=\", false, function () {\n  return [useActiveNetworkVersion, useClients];\n});\nexport async function getBlocksFromTimestamps(timestamps, blockClient) {\n  let skipCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n  if ((timestamps === null || timestamps === void 0 ? void 0 : timestamps.length) === 0) {\n    return [];\n  }\n  const fetchedData = await splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount);\n  const blocks = [];\n  if (fetchedData) {\n    for (const t in fetchedData) {\n      if (fetchedData[t].length > 0) {\n        blocks.push({\n          timestamp: t.split('t')[1],\n          number: fetchedData[t][0]['number']\n        });\n      }\n    }\n  }\n  return blocks;\n}\nvar _c;\n$RefreshReg$(_c, \"GET_BLOCKS\");","map":{"version":3,"names":["gql","useEffect","useMemo","useState","useActiveNetworkVersion","useClients","splitQuery","GET_BLOCKS","timestamps","queryString","map","timestamp","useBlocksFromTimestamps","blockClientOverride","activeNetwork","blocks","setBlocks","error","setError","blockClient","activeBlockClient","networkBlocks","id","fetchData","results","blocksFormatted","formatted","t","length","push","split","number","undefined","getBlocksFromTimestamps","skipCount","fetchedData"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useBlocksFromTimestamps.ts"],"sourcesContent":["import { ApolloClient, NormalizedCacheObject } from '@apollo/client'\nimport gql from 'graphql-tag'\nimport { useEffect, useMemo, useState } from 'react'\nimport { useActiveNetworkVersion, useClients } from 'state/application/hooks'\nimport { splitQuery } from 'utils/queries'\n\nconst GET_BLOCKS = (timestamps: string[]) => {\n  let queryString = 'query blocks {'\n  queryString += timestamps.map((timestamp) => {\n    return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: desc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${\n      timestamp + 600\n    } }) {\n        number\n      }`\n  })\n  queryString += '}'\n  return gql(queryString)\n}\n\n/**\n * for a given array of timestamps, returns block entities\n * @param timestamps\n */\nfunction useBlocksFromTimestamps(\n  timestamps: number[],\n  blockClientOverride?: ApolloClient<NormalizedCacheObject>\n): {\n  blocks:\n    | {\n        timestamp: string\n        number: any\n      }[]\n    | undefined\n  error: boolean\n} {\n  const [activeNetwork] = useActiveNetworkVersion()\n  const [blocks, setBlocks] = useState<any>()\n  const [error, setError] = useState(false)\n\n  const { blockClient } = useClients()\n  const activeBlockClient = blockClientOverride ?? blockClient\n\n  // derive blocks based on active network\n  const networkBlocks = blocks?.[activeNetwork.id]\n\n  useEffect(() => {\n    async function fetchData() {\n      const results = await splitQuery(GET_BLOCKS, activeBlockClient, [], timestamps)\n      if (results) {\n        setBlocks({ ...(blocks ?? {}), [activeNetwork.id]: results })\n      } else {\n        setError(true)\n      }\n    }\n    if (!networkBlocks && !error) {\n      fetchData()\n    }\n  })\n\n  const blocksFormatted = useMemo(() => {\n    if (blocks?.[activeNetwork.id]) {\n      const networkBlocks = blocks?.[activeNetwork.id]\n      const formatted = []\n      for (const t in networkBlocks) {\n        if (networkBlocks[t].length > 0) {\n          formatted.push({\n            timestamp: t.split('t')[1],\n            number: networkBlocks[t][0]['number'],\n          })\n        }\n      }\n      return formatted\n    }\n    return undefined\n  }, [activeNetwork.id, blocks])\n\n  return {\n    blocks: blocksFormatted,\n    error,\n  }\n}\n\n/**\n * @notice Fetches block objects for an array of timestamps.\n * @dev blocks are returned in chronological order (ASC) regardless of input.\n * @dev blocks are returned at string representations of Int\n * @dev timestamps are returns as they were provided; not the block time.\n * @param {Array} timestamps\n */\nexport async function getBlocksFromTimestamps(\n  timestamps: number[],\n  blockClient: ApolloClient<NormalizedCacheObject>,\n  skipCount = 500\n) {\n  if (timestamps?.length === 0) {\n    return []\n  }\n  const fetchedData: any = await splitQuery(GET_BLOCKS, blockClient, [], timestamps, skipCount)\n\n  const blocks: any[] = []\n  if (fetchedData) {\n    for (const t in fetchedData) {\n      if (fetchedData[t].length > 0) {\n        blocks.push({\n          timestamp: t.split('t')[1],\n          number: fetchedData[t][0]['number'],\n        })\n      }\n    }\n  }\n  return blocks\n}\n"],"mappings":";AACA,OAAOA,GAAG,MAAM,aAAa;AAC7B,SAASC,SAAS,EAAEC,OAAO,EAAEC,QAAQ,QAAQ,OAAO;AACpD,SAASC,uBAAuB,EAAEC,UAAU,QAAQ,yBAAyB;AAC7E,SAASC,UAAU,QAAQ,eAAe;AAE1C,MAAMC,UAAU,GAAIC,UAAoB,IAAK;EAC3C,IAAIC,WAAW,GAAG,gBAAgB;EAClCA,WAAW,IAAID,UAAU,CAACE,GAAG,CAAEC,SAAS,IAAK;IAC3C,OAAQ,IAAGA,SAAU,sFAAqFA,SAAU,mBAClHA,SAAS,GAAG,GACb;AACL;AACA,QAAQ;EACN,CAAC,CAAC;EACFF,WAAW,IAAI,GAAG;EAClB,OAAOT,GAAG,CAACS,WAAW,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AAHA,KAbMF,UAAU;AAiBhB,SAASK,uBAAuB,CAC9BJ,UAAoB,EACpBK,mBAAyD,EASzD;EAAA;EACA,MAAM,CAACC,aAAa,CAAC,GAAGV,uBAAuB,EAAE;EACjD,MAAM,CAACW,MAAM,EAAEC,SAAS,CAAC,GAAGb,QAAQ,EAAO;EAC3C,MAAM,CAACc,KAAK,EAAEC,QAAQ,CAAC,GAAGf,QAAQ,CAAC,KAAK,CAAC;EAEzC,MAAM;IAAEgB;EAAY,CAAC,GAAGd,UAAU,EAAE;EACpC,MAAMe,iBAAiB,GAAGP,mBAAmB,aAAnBA,mBAAmB,cAAnBA,mBAAmB,GAAIM,WAAW;;EAE5D;EACA,MAAME,aAAa,GAAGN,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAGD,aAAa,CAACQ,EAAE,CAAC;EAEhDrB,SAAS,CAAC,MAAM;IACd,eAAesB,SAAS,GAAG;MACzB,MAAMC,OAAO,GAAG,MAAMlB,UAAU,CAACC,UAAU,EAAEa,iBAAiB,EAAE,EAAE,EAAEZ,UAAU,CAAC;MAC/E,IAAIgB,OAAO,EAAE;QACXR,SAAS,CAAC;UAAE,IAAID,MAAM,aAANA,MAAM,cAANA,MAAM,GAAI,CAAC,CAAC,CAAC;UAAE,CAACD,aAAa,CAACQ,EAAE,GAAGE;QAAQ,CAAC,CAAC;MAC/D,CAAC,MAAM;QACLN,QAAQ,CAAC,IAAI,CAAC;MAChB;IACF;IACA,IAAI,CAACG,aAAa,IAAI,CAACJ,KAAK,EAAE;MAC5BM,SAAS,EAAE;IACb;EACF,CAAC,CAAC;EAEF,MAAME,eAAe,GAAGvB,OAAO,CAAC,MAAM;IACpC,IAAIa,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAGD,aAAa,CAACQ,EAAE,CAAC,EAAE;MAC9B,MAAMD,aAAa,GAAGN,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAGD,aAAa,CAACQ,EAAE,CAAC;MAChD,MAAMI,SAAS,GAAG,EAAE;MACpB,KAAK,MAAMC,CAAC,IAAIN,aAAa,EAAE;QAC7B,IAAIA,aAAa,CAACM,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC,EAAE;UAC/BF,SAAS,CAACG,IAAI,CAAC;YACblB,SAAS,EAAEgB,CAAC,CAACG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC1BC,MAAM,EAAEV,aAAa,CAACM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ;UACtC,CAAC,CAAC;QACJ;MACF;MACA,OAAOD,SAAS;IAClB;IACA,OAAOM,SAAS;EAClB,CAAC,EAAE,CAAClB,aAAa,CAACQ,EAAE,EAAEP,MAAM,CAAC,CAAC;EAE9B,OAAO;IACLA,MAAM,EAAEU,eAAe;IACvBR;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA,GA3DSL,uBAAuB;EAAA,QAYNR,uBAAuB,EAIvBC,UAAU;AAAA;AAkDpC,OAAO,eAAe4B,uBAAuB,CAC3CzB,UAAoB,EACpBW,WAAgD,EAEhD;EAAA,IADAe,SAAS,uEAAG,GAAG;EAEf,IAAI,CAAA1B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEoB,MAAM,MAAK,CAAC,EAAE;IAC5B,OAAO,EAAE;EACX;EACA,MAAMO,WAAgB,GAAG,MAAM7B,UAAU,CAACC,UAAU,EAAEY,WAAW,EAAE,EAAE,EAAEX,UAAU,EAAE0B,SAAS,CAAC;EAE7F,MAAMnB,MAAa,GAAG,EAAE;EACxB,IAAIoB,WAAW,EAAE;IACf,KAAK,MAAMR,CAAC,IAAIQ,WAAW,EAAE;MAC3B,IAAIA,WAAW,CAACR,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC,EAAE;QAC7Bb,MAAM,CAACc,IAAI,CAAC;UACVlB,SAAS,EAAEgB,CAAC,CAACG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UAC1BC,MAAM,EAAEI,WAAW,CAACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ;QACpC,CAAC,CAAC;MACJ;IACF;EACF;EACA,OAAOZ,MAAM;AACf;AAAC;AAAA"},"metadata":{},"sourceType":"module"}