{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$(),\n  _s7 = $RefreshSig$();\nimport { Interface } from '@ethersproject/abi';\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport ERC20ABI from 'abis/erc20.json';\nimport JSBI from 'jsbi';\nimport { useMultipleContractSingleData, useSingleContractMultipleData } from 'lib/hooks/multicall';\nimport { useMemo } from 'react';\nimport { nativeOnChain } from '../../constants/tokens';\nimport { useInterfaceMulticall } from '../../hooks/useContract';\nimport { isAddress } from '../../utils';\n\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useNativeCurrencyBalances(uncheckedAddresses) {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  const multicallContract = useInterfaceMulticall();\n  const validAddressInputs = useMemo(() => uncheckedAddresses ? uncheckedAddresses.map(isAddress).filter(a => a !== false).sort().map(addr => [addr]) : [], [uncheckedAddresses]);\n  const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', validAddressInputs);\n  return useMemo(() => validAddressInputs.reduce((memo, _ref, i) => {\n    var _results$i, _results$i$result;\n    let [address] = _ref;\n    const value = results === null || results === void 0 ? void 0 : (_results$i = results[i]) === null || _results$i === void 0 ? void 0 : (_results$i$result = _results$i.result) === null || _results$i$result === void 0 ? void 0 : _results$i$result[0];\n    if (value && chainId) memo[address] = CurrencyAmount.fromRawAmount(nativeOnChain(chainId), JSBI.BigInt(value.toString()));\n    return memo;\n  }, {}), [validAddressInputs, chainId, results]);\n}\n_s(useNativeCurrencyBalances, \"aLYZORu6bRZbgecI9QTDaE6JJg8=\", false, function () {\n  return [useWeb3React, useInterfaceMulticall, useSingleContractMultipleData];\n});\nconst ERC20Interface = new Interface(ERC20ABI);\nconst tokenBalancesGasRequirement = {\n  gasRequired: 185000\n};\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  _s2();\n  const {\n    chainId\n  } = useWeb3React(); // we cannot fetch balances cross-chain\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false && (t === null || t === void 0 ? void 0 : t.chainId) === chainId)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [chainId, tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20Interface, 'balanceOf', useMemo(() => [address], [address]), tokenBalancesGasRequirement);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return useMemo(() => [address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n    if (amount) {\n      memo[token.address] = CurrencyAmount.fromRawAmount(token, amount);\n    }\n    return memo;\n  }, {}) : {}, anyLoading], [address, validatedTokens, anyLoading, balances]);\n}\n_s2(useTokenBalancesWithLoadingIndicator, \"R4+HLS4y7I3QbDpMEmz5HzJpZpE=\", false, function () {\n  return [useWeb3React, useMultipleContractSingleData];\n});\nexport function useTokenBalances(address, tokens) {\n  _s3();\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n}\n\n// get the balance for a single token/account combo\n_s3(useTokenBalances, \"mWHFhmTyaoodDeiE1Op0b2ODA8c=\", false, function () {\n  return [useTokenBalancesWithLoadingIndicator];\n});\nexport function useTokenBalance(account, token) {\n  _s4();\n  const tokenBalances = useTokenBalances(account, useMemo(() => [token], [token]));\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\n_s4(useTokenBalance, \"bd5z2s6wq4yW1BdLNpBsIpm5uS0=\", false, function () {\n  return [useTokenBalances];\n});\nexport function useCurrencyBalances(account, currencies) {\n  _s5();\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => {\n      var _currency$isToken;\n      return (_currency$isToken = currency === null || currency === void 0 ? void 0 : currency.isToken) !== null && _currency$isToken !== void 0 ? _currency$isToken : false;\n    })) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const {\n    chainId\n  } = useWeb3React();\n  const tokenBalances = useTokenBalances(account, tokens);\n  const containsETH = useMemo(() => {\n    var _currencies$some;\n    return (_currencies$some = currencies === null || currencies === void 0 ? void 0 : currencies.some(currency => currency === null || currency === void 0 ? void 0 : currency.isNative)) !== null && _currencies$some !== void 0 ? _currencies$some : false;\n  }, [currencies]);\n  const ethBalance = useNativeCurrencyBalances(useMemo(() => containsETH ? [account] : [], [containsETH, account]));\n  return useMemo(() => {\n    var _currencies$map;\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency || currency.chainId !== chainId) return undefined;\n      if (currency.isToken) return tokenBalances[currency.address];\n      if (currency.isNative) return ethBalance[account];\n      return undefined;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, chainId, currencies, ethBalance, tokenBalances]);\n}\n_s5(useCurrencyBalances, \"t0kq8Wb/1Yr3BA7LEeEkilqU/Mc=\", false, function () {\n  return [useWeb3React, useTokenBalances, useNativeCurrencyBalances];\n});\nexport default function useCurrencyBalance(account, currency) {\n  _s6();\n  return useCurrencyBalances(account, useMemo(() => [currency], [currency]))[0];\n}\n_s6(useCurrencyBalance, \"0wJSopjcTzaCP/pnaYzHun/ibzg=\", false, function () {\n  return [useCurrencyBalances];\n});\nexport function useCurrencyBalanceString(account) {\n  _s7();\n  var _useNativeCurrencyBal, _useNativeCurrencyBal2, _useNativeCurrencyBal3;\n  return (_useNativeCurrencyBal = (_useNativeCurrencyBal2 = useNativeCurrencyBalances(account ? [account] : [])) === null || _useNativeCurrencyBal2 === void 0 ? void 0 : (_useNativeCurrencyBal3 = _useNativeCurrencyBal2[account !== null && account !== void 0 ? account : '']) === null || _useNativeCurrencyBal3 === void 0 ? void 0 : _useNativeCurrencyBal3.toSignificant(3)) !== null && _useNativeCurrencyBal !== void 0 ? _useNativeCurrencyBal : '';\n}\n_s7(useCurrencyBalanceString, \"h3JHNHsB/LNcMCkhKGMG6yUNJh8=\", false, function () {\n  return [useNativeCurrencyBalances];\n});","map":{"version":3,"names":["Interface","CurrencyAmount","useWeb3React","ERC20ABI","JSBI","useMultipleContractSingleData","useSingleContractMultipleData","useMemo","nativeOnChain","useInterfaceMulticall","isAddress","useNativeCurrencyBalances","uncheckedAddresses","chainId","multicallContract","validAddressInputs","map","filter","a","sort","addr","results","reduce","memo","i","address","value","result","fromRawAmount","BigInt","toString","ERC20Interface","tokenBalancesGasRequirement","gasRequired","useTokenBalancesWithLoadingIndicator","tokens","validatedTokens","t","validatedTokenAddresses","vt","balances","anyLoading","some","callState","loading","length","token","amount","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","currency","isToken","containsETH","isNative","ethBalance","useCurrencyBalance","useCurrencyBalanceString","toSignificant"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useCurrencyBalance.ts"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport ERC20ABI from 'abis/erc20.json'\nimport { Erc20Interface } from 'abis/types/Erc20'\nimport JSBI from 'jsbi'\nimport { useMultipleContractSingleData, useSingleContractMultipleData } from 'lib/hooks/multicall'\nimport { useMemo } from 'react'\n\nimport { nativeOnChain } from '../../constants/tokens'\nimport { useInterfaceMulticall } from '../../hooks/useContract'\nimport { isAddress } from '../../utils'\n\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useNativeCurrencyBalances(uncheckedAddresses?: (string | undefined)[]): {\n  [address: string]: CurrencyAmount<Currency> | undefined\n} {\n  const { chainId } = useWeb3React()\n  const multicallContract = useInterfaceMulticall()\n\n  const validAddressInputs: [string][] = useMemo(\n    () =>\n      uncheckedAddresses\n        ? uncheckedAddresses\n            .map(isAddress)\n            .filter((a): a is string => a !== false)\n            .sort()\n            .map((addr) => [addr])\n        : [],\n    [uncheckedAddresses]\n  )\n\n  const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', validAddressInputs)\n\n  return useMemo(\n    () =>\n      validAddressInputs.reduce<{ [address: string]: CurrencyAmount<Currency> }>((memo, [address], i) => {\n        const value = results?.[i]?.result?.[0]\n        if (value && chainId)\n          memo[address] = CurrencyAmount.fromRawAmount(nativeOnChain(chainId), JSBI.BigInt(value.toString()))\n        return memo\n      }, {}),\n    [validAddressInputs, chainId, results]\n  )\n}\n\nconst ERC20Interface = new Interface(ERC20ABI) as Erc20Interface\nconst tokenBalancesGasRequirement = { gasRequired: 185_000 }\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: CurrencyAmount<Token> | undefined }, boolean] {\n  const { chainId } = useWeb3React() // we cannot fetch balances cross-chain\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false && t?.chainId === chainId) ?? [],\n    [chainId, tokens]\n  )\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map((vt) => vt.address), [validatedTokens])\n\n  const balances = useMultipleContractSingleData(\n    validatedTokenAddresses,\n    ERC20Interface,\n    'balanceOf',\n    useMemo(() => [address], [address]),\n    tokenBalancesGasRequirement\n  )\n\n  const anyLoading: boolean = useMemo(() => balances.some((callState) => callState.loading), [balances])\n\n  return useMemo(\n    () => [\n      address && validatedTokens.length > 0\n        ? validatedTokens.reduce<{ [tokenAddress: string]: CurrencyAmount<Token> | undefined }>((memo, token, i) => {\n            const value = balances?.[i]?.result?.[0]\n            const amount = value ? JSBI.BigInt(value.toString()) : undefined\n            if (amount) {\n              memo[token.address] = CurrencyAmount.fromRawAmount(token, amount)\n            }\n            return memo\n          }, {})\n        : {},\n      anyLoading,\n    ],\n    [address, validatedTokens, anyLoading, balances]\n  )\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: CurrencyAmount<Token> | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): CurrencyAmount<Token> | undefined {\n  const tokenBalances = useTokenBalances(\n    account,\n    useMemo(() => [token], [token])\n  )\n  if (!token) return undefined\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(\n  account?: string,\n  currencies?: (Currency | undefined)[]\n): (CurrencyAmount<Currency> | undefined)[] {\n  const tokens = useMemo(\n    () => currencies?.filter((currency): currency is Token => currency?.isToken ?? false) ?? [],\n    [currencies]\n  )\n\n  const { chainId } = useWeb3React()\n  const tokenBalances = useTokenBalances(account, tokens)\n  const containsETH: boolean = useMemo(() => currencies?.some((currency) => currency?.isNative) ?? false, [currencies])\n  const ethBalance = useNativeCurrencyBalances(useMemo(() => (containsETH ? [account] : []), [containsETH, account]))\n\n  return useMemo(\n    () =>\n      currencies?.map((currency) => {\n        if (!account || !currency || currency.chainId !== chainId) return undefined\n        if (currency.isToken) return tokenBalances[currency.address]\n        if (currency.isNative) return ethBalance[account]\n        return undefined\n      }) ?? [],\n    [account, chainId, currencies, ethBalance, tokenBalances]\n  )\n}\n\nexport default function useCurrencyBalance(\n  account?: string,\n  currency?: Currency\n): CurrencyAmount<Currency> | undefined {\n  return useCurrencyBalances(\n    account,\n    useMemo(() => [currency], [currency])\n  )[0]\n}\n\nexport function useCurrencyBalanceString(account: string): string {\n  return useNativeCurrencyBalances(account ? [account] : [])?.[account ?? '']?.toSignificant(3) ?? ''\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}