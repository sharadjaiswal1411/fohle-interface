{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\nvar normalize = require('../util/normalize');\nmodule.exports = reference;\nreference.locator = locate;\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\nvar C_CARET = '^';\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nfunction reference(eat, value, silent) {\n  var self = this;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = T_LINK;\n  var referenceType = REFERENCE_TYPE_SHORTCUT;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n\n  /* Check whether we’re eating an image. */\n  if (character === '!') {\n    type = T_IMAGE;\n    intro = character;\n    character = value.charAt(++index);\n  }\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n  index++;\n  intro += character;\n  queue = '';\n\n  /* Check whether we’re eating a footnote. */\n  if (self.options.footnotes && value.charAt(index) === C_CARET) {\n    /* Exit if `![^` is found, so the `!` will be seen as text after this,\n     * and we’ll enter this function again when `[^` is found. */\n    if (type === T_IMAGE) {\n      return;\n    }\n    intro += C_CARET;\n    index++;\n    type = T_FOOTNOTE;\n  }\n\n  /* Eat the text. */\n  depth = 0;\n  while (index < length) {\n    character = value.charAt(index);\n    if (character === C_BRACKET_OPEN) {\n      bracketed = true;\n      depth++;\n    } else if (character === C_BRACKET_CLOSE) {\n      if (!depth) {\n        break;\n      }\n      depth--;\n    }\n    if (character === C_BACKSLASH) {\n      queue += C_BACKSLASH;\n      character = value.charAt(++index);\n    }\n    queue += character;\n    index++;\n  }\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n  if (character !== C_BRACKET_CLOSE) {\n    return;\n  }\n  index++;\n  subvalue += character;\n  queue = '';\n  while (index < length) {\n    character = value.charAt(index);\n    if (!whitespace(character)) {\n      break;\n    }\n    queue += character;\n    index++;\n  }\n  character = value.charAt(index);\n\n  /* Inline footnotes cannot have an identifier. */\n  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {\n    identifier = '';\n    queue += character;\n    index++;\n    while (index < length) {\n      character = value.charAt(index);\n      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {\n        break;\n      }\n      if (character === C_BACKSLASH) {\n        identifier += C_BACKSLASH;\n        character = value.charAt(++index);\n      }\n      identifier += character;\n      index++;\n    }\n    character = value.charAt(index);\n    if (character === C_BRACKET_CLOSE) {\n      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n    identifier = content;\n  }\n\n  /* Brackets cannot be inside the identifier. */\n  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n    return;\n  }\n  subvalue = intro + subvalue;\n  if (type === T_LINK && self.inLink) {\n    return null;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {\n    return eat(subvalue)({\n      type: 'footnote',\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier)\n  };\n  if (type === T_LINK || type === T_IMAGE) {\n    node.referenceType = referenceType;\n  }\n  if (type === T_LINK) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === T_IMAGE) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n  return eat(subvalue)(node);\n}","map":{"version":3,"names":["whitespace","require","locate","normalize","module","exports","reference","locator","T_LINK","T_IMAGE","T_FOOTNOTE","REFERENCE_TYPE_SHORTCUT","REFERENCE_TYPE_COLLAPSED","REFERENCE_TYPE_FULL","C_CARET","C_BACKSLASH","C_BRACKET_OPEN","C_BRACKET_CLOSE","eat","value","silent","self","character","charAt","index","length","subvalue","intro","type","referenceType","content","identifier","now","node","exit","queue","bracketed","depth","options","footnotes","inLink","indexOf","children","tokenizeInline","column","offset","enterLink","alt","decode","raw","unescape"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/remark-parse/lib/tokenize/reference.js"],"sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\nvar normalize = require('../util/normalize');\n\nmodule.exports = reference;\nreference.locator = locate;\n\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\nvar C_CARET = '^';\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\n\nfunction reference(eat, value, silent) {\n  var self = this;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = T_LINK;\n  var referenceType = REFERENCE_TYPE_SHORTCUT;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n\n  /* Check whether we’re eating an image. */\n  if (character === '!') {\n    type = T_IMAGE;\n    intro = character;\n    character = value.charAt(++index);\n  }\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  intro += character;\n  queue = '';\n\n  /* Check whether we’re eating a footnote. */\n  if (self.options.footnotes && value.charAt(index) === C_CARET) {\n    /* Exit if `![^` is found, so the `!` will be seen as text after this,\n     * and we’ll enter this function again when `[^` is found. */\n    if (type === T_IMAGE) {\n      return;\n    }\n\n    intro += C_CARET;\n    index++;\n    type = T_FOOTNOTE;\n  }\n\n  /* Eat the text. */\n  depth = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_OPEN) {\n      bracketed = true;\n      depth++;\n    } else if (character === C_BRACKET_CLOSE) {\n      if (!depth) {\n        break;\n      }\n\n      depth--;\n    }\n\n    if (character === C_BACKSLASH) {\n      queue += C_BACKSLASH;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_CLOSE) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  /* Inline footnotes cannot have an identifier. */\n  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {\n    identifier = '';\n    queue += character;\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {\n        break;\n      }\n\n      if (character === C_BACKSLASH) {\n        identifier += C_BACKSLASH;\n        character = value.charAt(++index);\n      }\n\n      identifier += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n\n    identifier = content;\n  }\n\n  /* Brackets cannot be inside the identifier. */\n  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n    return;\n  }\n\n  subvalue = intro + subvalue;\n\n  if (type === T_LINK && self.inLink) {\n    return null;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {\n    return eat(subvalue)({\n      type: 'footnote',\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier)\n  };\n\n  if (type === T_LINK || type === T_IMAGE) {\n    node.referenceType = referenceType;\n  }\n\n  if (type === T_LINK) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === T_IMAGE) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n\n  return eat(subvalue)(node);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}