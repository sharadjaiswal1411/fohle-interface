{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBestProvider = void 0;\n/**\n * @param providers - An array of providers to try to connect to.\n * @param timeout - How long to wait before a call is considered failed, in ms.\n */\nfunction getBestProvider(providers) {\n  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n  return __awaiter(this, void 0, void 0, function* () {\n    // if we only have 1 provider, it's the best!\n    if (providers.length === 1) return providers[0];\n    // the below returns the first provider for which there's been a successful call, prioritized by index\n    return new Promise(resolve => {\n      let resolved = false;\n      const successes = {};\n      providers.forEach((provider, i) => {\n        // create a promise that resolves on a successful call, and rejects on a failed call or after timeout milliseconds\n        const promise = new Promise((resolve, reject) => {\n          provider.getNetwork().then(() => resolve()).catch(() => reject());\n          // set a timeout to reject\n          setTimeout(() => {\n            reject();\n          }, timeout);\n        });\n        void promise.then(() => true).catch(() => false).then(success => {\n          // if we already resolved, return\n          if (resolved) return;\n          // store the result of the call\n          successes[i] = success;\n          // if this is the last call and we haven't resolved yet - do so\n          if (Object.keys(successes).length === providers.length) {\n            const index = Object.keys(successes).findIndex(j => successes[Number(j)]);\n            // no need to set resolved to true, as this is the last promise\n            return resolve(providers[index === -1 ? 0 : index]);\n          }\n          // otherwise, for each prospective index, check if we can resolve\n          new Array(providers.length).fill(0).forEach((_, prospectiveIndex) => {\n            // to resolve, we need to:\n            // a) have successfully made a call\n            // b) not be waiting on any other higher-index calls\n            if (successes[prospectiveIndex] && new Array(prospectiveIndex).fill(0).every((_, j) => successes[j] === false)) {\n              resolved = true;\n              resolve(providers[prospectiveIndex]);\n            }\n          });\n        });\n      });\n    });\n  });\n}\nexports.getBestProvider = getBestProvider;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","getBestProvider","providers","timeout","length","resolved","successes","forEach","provider","i","promise","getNetwork","catch","setTimeout","success","keys","index","findIndex","j","Number","Array","fill","_","prospectiveIndex","every"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/@web3-react/network/dist/utils.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBestProvider = void 0;\n/**\n * @param providers - An array of providers to try to connect to.\n * @param timeout - How long to wait before a call is considered failed, in ms.\n */\nfunction getBestProvider(providers, timeout = 5000) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // if we only have 1 provider, it's the best!\n        if (providers.length === 1)\n            return providers[0];\n        // the below returns the first provider for which there's been a successful call, prioritized by index\n        return new Promise((resolve) => {\n            let resolved = false;\n            const successes = {};\n            providers.forEach((provider, i) => {\n                // create a promise that resolves on a successful call, and rejects on a failed call or after timeout milliseconds\n                const promise = new Promise((resolve, reject) => {\n                    provider\n                        .getNetwork()\n                        .then(() => resolve())\n                        .catch(() => reject());\n                    // set a timeout to reject\n                    setTimeout(() => {\n                        reject();\n                    }, timeout);\n                });\n                void promise\n                    .then(() => true)\n                    .catch(() => false)\n                    .then((success) => {\n                    // if we already resolved, return\n                    if (resolved)\n                        return;\n                    // store the result of the call\n                    successes[i] = success;\n                    // if this is the last call and we haven't resolved yet - do so\n                    if (Object.keys(successes).length === providers.length) {\n                        const index = Object.keys(successes).findIndex((j) => successes[Number(j)]);\n                        // no need to set resolved to true, as this is the last promise\n                        return resolve(providers[index === -1 ? 0 : index]);\n                    }\n                    // otherwise, for each prospective index, check if we can resolve\n                    new Array(providers.length).fill(0).forEach((_, prospectiveIndex) => {\n                        // to resolve, we need to:\n                        // a) have successfully made a call\n                        // b) not be waiting on any other higher-index calls\n                        if (successes[prospectiveIndex] &&\n                            new Array(prospectiveIndex).fill(0).every((_, j) => successes[j] === false)) {\n                            resolved = true;\n                            resolve(providers[prospectiveIndex]);\n                        }\n                    });\n                });\n            });\n        });\n    });\n}\nexports.getBestProvider = getBestProvider;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}