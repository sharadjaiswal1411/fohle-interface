{"ast":null,"code":"import { createTransport } from '@sentry/core';\nimport { rejectedSyncPromise } from '@sentry/utils';\nimport { clearCachedFetchImplementation, getNativeFetchImplementation } from './utils.js';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nfunction makeFetchTransport(options) {\n  let nativeFetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getNativeFetchImplementation();\n  function makeRequest(request) {\n    const requestOptions = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true`\n      //   and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when\n      //   we're below that limit.\n      keepalive: request.body.length <= 65536,\n      ...options.fetchOptions\n    };\n    try {\n      return nativeFetch(options.url, requestOptions).then(response => ({\n        statusCode: response.status,\n        headers: {\n          'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n          'retry-after': response.headers.get('Retry-After')\n        }\n      }));\n    } catch (e) {\n      clearCachedFetchImplementation();\n      return rejectedSyncPromise(e);\n    }\n  }\n  return createTransport(options, makeRequest);\n}\nexport { makeFetchTransport };","map":{"version":3,"sources":["../../../../src/transports/fetch.ts"],"names":[],"mappings":";;;;AAOA;AACA;AACA;AACA,SAAA,kBAAA,CACA,OAAA,EAEA;EAAA,IADA,WAAA,uEAAA,4BAAA,EAAA;EAEA,SAAA,WAAA,CAAA,OAAA,EAAA;IACA,MAAA,cAAA,GAAA;MACA,IAAA,EAAA,OAAA,CAAA,IAAA;MACA,MAAA,EAAA,MAAA;MACA,cAAA,EAAA,QAAA;MACA,OAAA,EAAA,OAAA,CAAA,OAAA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,SAAA,EAAA,OAAA,CAAA,IAAA,CAAA,MAAA,IAAA,KAAA;MACA,GAAA,OAAA,CAAA;IACA,CAAA;IAEA,IAAA;MACA,OAAA,WAAA,CAAA,OAAA,CAAA,GAAA,EAAA,cAAA,CAAA,CAAA,IAAA,CAAA,QAAA,KAAA;QACA,UAAA,EAAA,QAAA,CAAA,MAAA;QACA,OAAA,EAAA;UACA,sBAAA,EAAA,QAAA,CAAA,OAAA,CAAA,GAAA,CAAA,sBAAA,CAAA;UACA,aAAA,EAAA,QAAA,CAAA,OAAA,CAAA,GAAA,CAAA,aAAA;QACA;MACA,CAAA,CAAA,CAAA;IACA,CAAA,CAAA,OAAA,CAAA,EAAA;MACA,8BAAA,EAAA;MACA,OAAA,mBAAA,CAAA,CAAA,CAAA;IACA;EACA;EAEA,OAAA,eAAA,CAAA,OAAA,EAAA,WAAA,CAAA;AACA","sourcesContent":["import { createTransport } from '@sentry/core';\nimport { Transport, TransportMakeRequestResponse, TransportRequest } from '@sentry/types';\nimport { rejectedSyncPromise } from '@sentry/utils';\n\nimport { BrowserTransportOptions } from './types';\nimport { clearCachedFetchImplementation, FetchImpl, getNativeFetchImplementation } from './utils';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nexport function makeFetchTransport(\n  options: BrowserTransportOptions,\n  nativeFetch: FetchImpl = getNativeFetchImplementation(),\n): Transport {\n  function makeRequest(request: TransportRequest): PromiseLike<TransportMakeRequestResponse> {\n    const requestOptions: RequestInit = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true`\n      //   and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when\n      //   we're below that limit.\n      keepalive: request.body.length <= 65536,\n      ...options.fetchOptions,\n    };\n\n    try {\n      return nativeFetch(options.url, requestOptions).then(response => ({\n        statusCode: response.status,\n        headers: {\n          'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n          'retry-after': response.headers.get('Retry-After'),\n        },\n      }));\n    } catch (e) {\n      clearCachedFetchImplementation();\n      return rejectedSyncPromise(e);\n    }\n  }\n\n  return createTransport(options, makeRequest);\n}\n"]},"metadata":{},"sourceType":"module"}