{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar hash = require('@ethersproject/hash');\nvar bignumber = require('@ethersproject/bignumber');\nvar contracts = require('@ethersproject/contracts');\nvar PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';\nvar MaxUint48 = /*#__PURE__*/bignumber.BigNumber.from('0xffffffffffff');\nvar MaxUint160 = /*#__PURE__*/bignumber.BigNumber.from('0xffffffffffffffffffffffffffffffffffffffff');\nvar MaxUint256 = /*#__PURE__*/bignumber.BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n// alias max types for their usages\n// allowance transfer types\nvar MaxAllowanceTransferAmount = MaxUint160;\nvar MaxAllowanceExpiration = MaxUint48;\nvar MaxOrderedNonce = MaxUint48;\n// signature transfer types\nvar MaxSignatureTransferAmount = MaxUint256;\nvar MaxUnorderedNonce = MaxUint256;\nvar MaxSigDeadline = MaxUint256;\nvar InstantExpiration = /*#__PURE__*/bignumber.BigNumber.from(0);\nvar PERMIT2_DOMAIN_NAME = 'Permit2';\nfunction permit2Domain(permit2Address, chainId) {\n  return {\n    name: PERMIT2_DOMAIN_NAME,\n    chainId: chainId,\n    verifyingContract: permit2Address\n  };\n}\nvar PERMIT_DETAILS = [{\n  name: 'token',\n  type: 'address'\n}, {\n  name: 'amount',\n  type: 'uint160'\n}, {\n  name: 'expiration',\n  type: 'uint48'\n}, {\n  name: 'nonce',\n  type: 'uint48'\n}];\nvar PERMIT_TYPES = {\n  PermitSingle: [{\n    name: 'details',\n    type: 'PermitDetails'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'sigDeadline',\n    type: 'uint256'\n  }],\n  PermitDetails: PERMIT_DETAILS\n};\nvar PERMIT_BATCH_TYPES = {\n  PermitBatch: [{\n    name: 'details',\n    type: 'PermitDetails[]'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'sigDeadline',\n    type: 'uint256'\n  }],\n  PermitDetails: PERMIT_DETAILS\n};\nfunction isPermit(permit) {\n  return !Array.isArray(permit.details);\n}\nvar AllowanceTransfer = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function AllowanceTransfer() {}\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  AllowanceTransfer.getPermitData = function getPermitData(permit, permit2Address, chainId) {\n    !MaxSigDeadline.gte(permit.sigDeadline) ? invariant(false, 'SIG_DEADLINE_OUT_OF_RANGE') : void 0;\n    var domain = permit2Domain(permit2Address, chainId);\n    if (isPermit(permit)) {\n      validatePermitDetails(permit.details);\n      return {\n        domain: domain,\n        types: PERMIT_TYPES,\n        values: permit\n      };\n    } else {\n      permit.details.forEach(validatePermitDetails);\n      return {\n        domain: domain,\n        types: PERMIT_BATCH_TYPES,\n        values: permit\n      };\n    }\n  };\n  AllowanceTransfer.hash = function hash$1(permit, permit2Address, chainId) {\n    var _AllowanceTransfer$ge = AllowanceTransfer.getPermitData(permit, permit2Address, chainId),\n      domain = _AllowanceTransfer$ge.domain,\n      types = _AllowanceTransfer$ge.types,\n      values = _AllowanceTransfer$ge.values;\n    return hash._TypedDataEncoder.hash(domain, types, values);\n  };\n  return AllowanceTransfer;\n}();\nfunction validatePermitDetails(details) {\n  !MaxOrderedNonce.gte(details.nonce) ? invariant(false, 'NONCE_OUT_OF_RANGE') : void 0;\n  !MaxAllowanceTransferAmount.gte(details.amount) ? invariant(false, 'AMOUNT_OUT_OF_RANGE') : void 0;\n  !MaxAllowanceExpiration.gte(details.expiration) ? invariant(false, 'EXPIRATION_OUT_OF_RANGE') : void 0;\n}\nfunction _regeneratorRuntime() {\n  _regeneratorRuntime = function () {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function () {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    catch: function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar TOKEN_PERMISSIONS = [{\n  name: 'token',\n  type: 'address'\n}, {\n  name: 'amount',\n  type: 'uint256'\n}];\nvar PERMIT_TRANSFER_FROM_TYPES = {\n  PermitTransferFrom: [{\n    name: 'permitted',\n    type: 'TokenPermissions'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'deadline',\n    type: 'uint256'\n  }],\n  TokenPermissions: TOKEN_PERMISSIONS\n};\nvar PERMIT_BATCH_TRANSFER_FROM_TYPES = {\n  PermitBatchTransferFrom: [{\n    name: 'permitted',\n    type: 'TokenPermissions[]'\n  }, {\n    name: 'spender',\n    type: 'address'\n  }, {\n    name: 'nonce',\n    type: 'uint256'\n  }, {\n    name: 'deadline',\n    type: 'uint256'\n  }],\n  TokenPermissions: TOKEN_PERMISSIONS\n};\nfunction permitTransferFromWithWitnessType(witness) {\n  return _extends({\n    PermitWitnessTransferFrom: [{\n      name: 'permitted',\n      type: 'TokenPermissions'\n    }, {\n      name: 'spender',\n      type: 'address'\n    }, {\n      name: 'nonce',\n      type: 'uint256'\n    }, {\n      name: 'deadline',\n      type: 'uint256'\n    }, {\n      name: 'witness',\n      type: witness.witnessTypeName\n    }],\n    TokenPermissions: TOKEN_PERMISSIONS\n  }, witness.witnessType);\n}\nfunction permitBatchTransferFromWithWitnessType(witness) {\n  return _extends({\n    PermitBatchWitnessTransferFrom: [{\n      name: 'permitted',\n      type: 'TokenPermissions[]'\n    }, {\n      name: 'spender',\n      type: 'address'\n    }, {\n      name: 'nonce',\n      type: 'uint256'\n    }, {\n      name: 'deadline',\n      type: 'uint256'\n    }, {\n      name: 'witness',\n      type: witness.witnessTypeName\n    }],\n    TokenPermissions: TOKEN_PERMISSIONS\n  }, witness.witnessType);\n}\nfunction isPermitTransferFrom(permit) {\n  return !Array.isArray(permit.permitted);\n}\nvar SignatureTransfer = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function SignatureTransfer() {}\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  SignatureTransfer.getPermitData = function getPermitData(permit, permit2Address, chainId, witness) {\n    !MaxSigDeadline.gte(permit.deadline) ? invariant(false, 'SIG_DEADLINE_OUT_OF_RANGE') : void 0;\n    !MaxUnorderedNonce.gte(permit.nonce) ? invariant(false, 'NONCE_OUT_OF_RANGE') : void 0;\n    var domain = permit2Domain(permit2Address, chainId);\n    if (isPermitTransferFrom(permit)) {\n      validateTokenPermissions(permit.permitted);\n      var types = witness ? permitTransferFromWithWitnessType(witness) : PERMIT_TRANSFER_FROM_TYPES;\n      var values = witness ? Object.assign(permit, {\n        witness: witness.witness\n      }) : permit;\n      return {\n        domain: domain,\n        types: types,\n        values: values\n      };\n    } else {\n      permit.permitted.forEach(validateTokenPermissions);\n      var _types = witness ? permitBatchTransferFromWithWitnessType(witness) : PERMIT_BATCH_TRANSFER_FROM_TYPES;\n      var _values = witness ? Object.assign(permit, {\n        witness: witness.witness\n      }) : permit;\n      return {\n        domain: domain,\n        types: _types,\n        values: _values\n      };\n    }\n  };\n  SignatureTransfer.hash = function hash$1(permit, permit2Address, chainId, witness) {\n    var _SignatureTransfer$ge = SignatureTransfer.getPermitData(permit, permit2Address, chainId, witness),\n      domain = _SignatureTransfer$ge.domain,\n      types = _SignatureTransfer$ge.types,\n      values = _SignatureTransfer$ge.values;\n    return hash._TypedDataEncoder.hash(domain, types, values);\n  };\n  return SignatureTransfer;\n}();\nfunction validateTokenPermissions(permissions) {\n  !MaxSignatureTransferAmount.gte(permissions.amount) ? invariant(false, 'AMOUNT_OUT_OF_RANGE') : void 0;\n}\nvar Permit2Abi = [{\n  inputs: [],\n  name: \"AllowanceExpired\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"ExcessiveInvalidation\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InsufficientAllowance\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidContractSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidNonce\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSigner\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"LengthMismatch\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NotSpender\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"SignatureExpired\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }, {\n    indexed: false,\n    internalType: \"uint48\",\n    name: \"expiration\",\n    type: \"uint48\"\n  }],\n  name: \"Approval\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }],\n  name: \"Lockdown\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint48\",\n    name: \"newNonce\",\n    type: \"uint48\"\n  }, {\n    indexed: false,\n    internalType: \"uint48\",\n    name: \"oldNonce\",\n    type: \"uint48\"\n  }],\n  name: \"NonceInvalidation\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"word\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"mask\",\n    type: \"uint256\"\n  }],\n  name: \"UnorderedNonceInvalidation\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }, {\n    internalType: \"uint48\",\n    name: \"expiration\",\n    type: \"uint48\"\n  }, {\n    internalType: \"uint48\",\n    name: \"nonce\",\n    type: \"uint48\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }, {\n    internalType: \"uint48\",\n    name: \"expiration\",\n    type: \"uint48\"\n  }],\n  name: \"approve\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint48\",\n    name: \"newNonce\",\n    type: \"uint48\"\n  }],\n  name: \"invalidateNonces\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"wordPos\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"mask\",\n    type: \"uint256\"\n  }],\n  name: \"invalidateUnorderedNonces\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"spender\",\n      type: \"address\"\n    }],\n    internalType: \"struct IAllowanceTransfer.TokenSpenderPair[]\",\n    name: \"approvals\",\n    type: \"tuple[]\"\n  }],\n  name: \"lockdown\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  name: \"nonceBitmap\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint160\",\n        name: \"amount\",\n        type: \"uint160\"\n      }, {\n        internalType: \"uint48\",\n        name: \"expiration\",\n        type: \"uint48\"\n      }, {\n        internalType: \"uint48\",\n        name: \"nonce\",\n        type: \"uint48\"\n      }],\n      internalType: \"struct IAllowanceTransfer.PermitDetails[]\",\n      name: \"details\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"address\",\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"sigDeadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct IAllowanceTransfer.PermitBatch\",\n    name: \"permitBatch\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permit\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint160\",\n        name: \"amount\",\n        type: \"uint160\"\n      }, {\n        internalType: \"uint48\",\n        name: \"expiration\",\n        type: \"uint48\"\n      }, {\n        internalType: \"uint48\",\n        name: \"nonce\",\n        type: \"uint48\"\n      }],\n      internalType: \"struct IAllowanceTransfer.PermitDetails\",\n      name: \"details\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"sigDeadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct IAllowanceTransfer.PermitSingle\",\n    name: \"permitSingle\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permit\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions[]\",\n      name: \"permitted\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitBatchTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"requestedAmount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.SignatureTransferDetails[]\",\n    name: \"transferDetails\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions\",\n      name: \"permitted\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"requestedAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions\",\n      name: \"permitted\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"requestedAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"witness\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessTypeName\",\n    type: \"string\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessType\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitWitnessTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct ISignatureTransfer.TokenPermissions[]\",\n      name: \"permitted\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.PermitBatchTransferFrom\",\n    name: \"permit\",\n    type: \"tuple\"\n  }, {\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"requestedAmount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct ISignatureTransfer.SignatureTransferDetails[]\",\n    name: \"transferDetails\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"witness\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessTypeName\",\n    type: \"string\"\n  }, {\n    internalType: \"string\",\n    name: \"witnessType\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes\",\n    name: \"signature\",\n    type: \"bytes\"\n  }],\n  name: \"permitWitnessTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint160\",\n    name: \"amount\",\n    type: \"uint160\"\n  }],\n  name: \"transferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint160\",\n      name: \"amount\",\n      type: \"uint160\"\n    }, {\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }],\n    internalType: \"struct IAllowanceTransfer.AllowanceTransferDetails[]\",\n    name: \"transferDetails\",\n    type: \"tuple[]\"\n  }],\n  name: \"transferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar AllowanceProvider = /*#__PURE__*/function () {\n  function AllowanceProvider(provider, permit2Address) {\n    this.provider = provider;\n    this.permit2Address = permit2Address;\n    this.permit2 = new contracts.Contract(this.permit2Address, Permit2Abi, this.provider);\n  }\n  var _proto = AllowanceProvider.prototype;\n  _proto.getAllowanceData = /*#__PURE__*/function () {\n    var _getAllowanceData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.permit2.allowance(owner, token, spender);\n            case 2:\n              return _context.abrupt(\"return\", _context.sent);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n    function getAllowanceData(_x, _x2, _x3) {\n      return _getAllowanceData.apply(this, arguments);\n    }\n    return getAllowanceData;\n  }();\n  _proto.getAllowance = /*#__PURE__*/function () {\n    var _getAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getAllowanceData(token, owner, spender);\n            case 2:\n              return _context2.abrupt(\"return\", _context2.sent.amount);\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n    function getAllowance(_x4, _x5, _x6) {\n      return _getAllowance.apply(this, arguments);\n    }\n    return getAllowance;\n  }();\n  _proto.getNonce = /*#__PURE__*/function () {\n    var _getNonce = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.getAllowanceData(token, owner, spender);\n            case 2:\n              return _context3.abrupt(\"return\", _context3.sent.nonce);\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n    function getNonce(_x7, _x8, _x9) {\n      return _getNonce.apply(this, arguments);\n    }\n    return getNonce;\n  }();\n  _proto.getExpiration = /*#__PURE__*/function () {\n    var _getExpiration = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(token, owner, spender) {\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.getAllowanceData(token, owner, spender);\n            case 2:\n              return _context4.abrupt(\"return\", _context4.sent.expiration);\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n    function getExpiration(_x10, _x11, _x12) {\n      return _getExpiration.apply(this, arguments);\n    }\n    return getExpiration;\n  }();\n  return AllowanceProvider;\n}();\nexports.AllowanceProvider = AllowanceProvider;\nexports.AllowanceTransfer = AllowanceTransfer;\nexports.InstantExpiration = InstantExpiration;\nexports.MaxAllowanceExpiration = MaxAllowanceExpiration;\nexports.MaxAllowanceTransferAmount = MaxAllowanceTransferAmount;\nexports.MaxOrderedNonce = MaxOrderedNonce;\nexports.MaxSigDeadline = MaxSigDeadline;\nexports.MaxSignatureTransferAmount = MaxSignatureTransferAmount;\nexports.MaxUint160 = MaxUint160;\nexports.MaxUint256 = MaxUint256;\nexports.MaxUint48 = MaxUint48;\nexports.MaxUnorderedNonce = MaxUnorderedNonce;\nexports.PERMIT2_ADDRESS = PERMIT2_ADDRESS;\nexports.SignatureTransfer = SignatureTransfer;","map":{"version":3,"sources":["../src/constants.ts","../src/domain.ts","../src/allowanceTransfer.ts","../src/signatureTransfer.ts","../src/providers/AllowanceProvider.ts"],"names":["PERMIT2_ADDRESS","MaxUint48","BigNumber","from","MaxUint160","MaxUint256","MaxAllowanceTransferAmount","MaxAllowanceExpiration","MaxOrderedNonce","MaxSignatureTransferAmount","MaxUnorderedNonce","MaxSigDeadline","InstantExpiration","PERMIT2_DOMAIN_NAME","permit2Domain","permit2Address","chainId","name","verifyingContract","PERMIT_DETAILS","type","PERMIT_TYPES","PermitSingle","PermitDetails","PERMIT_BATCH_TYPES","PermitBatch","isPermit","permit","Array","isArray","details","AllowanceTransfer","getPermitData","gte","sigDeadline","domain","validatePermitDetails","types","values","forEach","hash","_TypedDataEncoder","nonce","amount","expiration","TOKEN_PERMISSIONS","PERMIT_TRANSFER_FROM_TYPES","PermitTransferFrom","TokenPermissions","PERMIT_BATCH_TRANSFER_FROM_TYPES","PermitBatchTransferFrom","permitTransferFromWithWitnessType","witness","PermitWitnessTransferFrom","witnessTypeName","witnessType","permitBatchTransferFromWithWitnessType","PermitBatchWitnessTransferFrom","isPermitTransferFrom","permitted","SignatureTransfer","deadline","validateTokenPermissions","Object","assign","permissions","AllowanceProvider","permit2","Contract","Permit2Abi","provider","getAllowanceData","token","owner","spender","allowance","getAllowance","getNonce","getExpiration"],"mappings":"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","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber'\n\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const MaxUint48 = BigNumber.from('0xffffffffffff')\nexport const MaxUint160 = BigNumber.from('0xffffffffffffffffffffffffffffffffffffffff')\nexport const MaxUint256 = BigNumber.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n\n// alias max types for their usages\n// allowance transfer types\nexport const MaxAllowanceTransferAmount = MaxUint160\nexport const MaxAllowanceExpiration = MaxUint48\nexport const MaxOrderedNonce = MaxUint48\n\n// signature transfer types\nexport const MaxSignatureTransferAmount = MaxUint256\nexport const MaxUnorderedNonce = MaxUint256\nexport const MaxSigDeadline = MaxUint256\n\nexport const InstantExpiration: BigNumber = BigNumber.from(0)\n","import { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer'\n\nconst PERMIT2_DOMAIN_NAME = 'Permit2'\n\nexport function permit2Domain(permit2Address: string, chainId: number): TypedDataDomain {\n  return {\n    name: PERMIT2_DOMAIN_NAME,\n    chainId,\n    verifyingContract: permit2Address,\n  }\n}\n\nexport type PermitData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: any\n}\n","import invariant from 'tiny-invariant'\nimport { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer'\nimport { BigNumberish } from '@ethersproject/bignumber'\nimport { _TypedDataEncoder } from '@ethersproject/hash'\nimport { MaxSigDeadline, MaxOrderedNonce, MaxAllowanceTransferAmount, MaxAllowanceExpiration } from './constants'\nimport { permit2Domain } from './domain'\n\nexport interface PermitDetails {\n  token: string\n  amount: BigNumberish\n  expiration: BigNumberish\n  nonce: BigNumberish\n}\n\nexport interface PermitSingle {\n  details: PermitDetails\n  spender: string\n  sigDeadline: BigNumberish\n}\n\nexport interface PermitBatch {\n  details: PermitDetails[]\n  spender: string\n  sigDeadline: BigNumberish\n}\n\nexport type PermitSingleData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitSingle\n}\n\nexport type PermitBatchData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitBatch\n}\n\nconst PERMIT_DETAILS = [\n  { name: 'token', type: 'address' },\n  { name: 'amount', type: 'uint160' },\n  { name: 'expiration', type: 'uint48' },\n  { name: 'nonce', type: 'uint48' },\n]\n\nconst PERMIT_TYPES = {\n  PermitSingle: [\n    { name: 'details', type: 'PermitDetails' },\n    { name: 'spender', type: 'address' },\n    { name: 'sigDeadline', type: 'uint256' },\n  ],\n  PermitDetails: PERMIT_DETAILS,\n}\n\nconst PERMIT_BATCH_TYPES = {\n  PermitBatch: [\n    { name: 'details', type: 'PermitDetails[]' },\n    { name: 'spender', type: 'address' },\n    { name: 'sigDeadline', type: 'uint256' },\n  ],\n  PermitDetails: PERMIT_DETAILS,\n}\n\nfunction isPermit(permit: PermitSingle | PermitBatch): permit is PermitSingle {\n  return !Array.isArray(permit.details)\n}\n\nexport abstract class AllowanceTransfer {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  public static getPermitData(\n    permit: PermitSingle | PermitBatch,\n    permit2Address: string,\n    chainId: number\n  ): PermitSingleData | PermitBatchData {\n    invariant(MaxSigDeadline.gte(permit.sigDeadline), 'SIG_DEADLINE_OUT_OF_RANGE')\n\n    const domain = permit2Domain(permit2Address, chainId)\n    if (isPermit(permit)) {\n      validatePermitDetails(permit.details)\n      return {\n        domain,\n        types: PERMIT_TYPES,\n        values: permit,\n      }\n    } else {\n      permit.details.forEach(validatePermitDetails)\n      return {\n        domain,\n        types: PERMIT_BATCH_TYPES,\n        values: permit,\n      }\n    }\n  }\n\n  public static hash(permit: PermitSingle | PermitBatch, permit2Address: string, chainId: number): string {\n    const { domain, types, values } = AllowanceTransfer.getPermitData(permit, permit2Address, chainId)\n    return _TypedDataEncoder.hash(domain, types, values)\n  }\n}\n\nfunction validatePermitDetails(details: PermitDetails) {\n  invariant(MaxOrderedNonce.gte(details.nonce), 'NONCE_OUT_OF_RANGE')\n  invariant(MaxAllowanceTransferAmount.gte(details.amount), 'AMOUNT_OUT_OF_RANGE')\n  invariant(MaxAllowanceExpiration.gte(details.expiration), 'EXPIRATION_OUT_OF_RANGE')\n}\n","import invariant from 'tiny-invariant'\nimport { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer'\nimport { BigNumberish } from '@ethersproject/bignumber'\nimport { _TypedDataEncoder } from '@ethersproject/hash'\nimport { permit2Domain } from './domain'\nimport { MaxSigDeadline, MaxUnorderedNonce, MaxSignatureTransferAmount } from './constants'\n\nexport interface Witness {\n  witness: any\n  witnessTypeName: string\n  witnessType: Record<string, TypedDataField[]>\n}\n\nexport interface TokenPermissions {\n  token: string\n  amount: BigNumberish\n}\n\nexport interface PermitTransferFrom {\n  permitted: TokenPermissions\n  spender: string\n  nonce: BigNumberish\n  deadline: BigNumberish\n}\n\nexport interface PermitBatchTransferFrom {\n  permitted: TokenPermissions[]\n  spender: string\n  nonce: BigNumberish\n  deadline: BigNumberish\n}\n\nexport type PermitTransferFromData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitTransferFrom\n}\n\nexport type PermitBatchTransferFromData = {\n  domain: TypedDataDomain\n  types: Record<string, TypedDataField[]>\n  values: PermitBatchTransferFrom\n}\n\nconst TOKEN_PERMISSIONS = [\n  { name: 'token', type: 'address' },\n  { name: 'amount', type: 'uint256' },\n]\n\nconst PERMIT_TRANSFER_FROM_TYPES = {\n  PermitTransferFrom: [\n    { name: 'permitted', type: 'TokenPermissions' },\n    { name: 'spender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n  TokenPermissions: TOKEN_PERMISSIONS,\n}\n\nconst PERMIT_BATCH_TRANSFER_FROM_TYPES = {\n  PermitBatchTransferFrom: [\n    { name: 'permitted', type: 'TokenPermissions[]' },\n    { name: 'spender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n  TokenPermissions: TOKEN_PERMISSIONS,\n}\n\nfunction permitTransferFromWithWitnessType(witness: Witness): Record<string, TypedDataField[]> {\n  return {\n    PermitWitnessTransferFrom: [\n      { name: 'permitted', type: 'TokenPermissions' },\n      { name: 'spender', type: 'address' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint256' },\n      { name: 'witness', type: witness.witnessTypeName },\n    ],\n    TokenPermissions: TOKEN_PERMISSIONS,\n    ...witness.witnessType,\n  }\n}\n\nfunction permitBatchTransferFromWithWitnessType(witness: Witness): Record<string, TypedDataField[]> {\n  return {\n    PermitBatchWitnessTransferFrom: [\n      { name: 'permitted', type: 'TokenPermissions[]' },\n      { name: 'spender', type: 'address' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint256' },\n      { name: 'witness', type: witness.witnessTypeName },\n    ],\n    TokenPermissions: TOKEN_PERMISSIONS,\n    ...witness.witnessType,\n  }\n}\n\nfunction isPermitTransferFrom(permit: PermitTransferFrom | PermitBatchTransferFrom): permit is PermitTransferFrom {\n  return !Array.isArray(permit.permitted)\n}\n\nexport abstract class SignatureTransfer {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  // return the data to be sent in a eth_signTypedData RPC call\n  // for signing the given permit data\n  public static getPermitData(\n    permit: PermitTransferFrom | PermitBatchTransferFrom,\n    permit2Address: string,\n    chainId: number,\n    witness?: Witness\n  ): PermitTransferFromData | PermitBatchTransferFromData {\n    invariant(MaxSigDeadline.gte(permit.deadline), 'SIG_DEADLINE_OUT_OF_RANGE')\n    invariant(MaxUnorderedNonce.gte(permit.nonce), 'NONCE_OUT_OF_RANGE')\n\n    const domain = permit2Domain(permit2Address, chainId)\n    if (isPermitTransferFrom(permit)) {\n      validateTokenPermissions(permit.permitted)\n      const types = witness ? permitTransferFromWithWitnessType(witness) : PERMIT_TRANSFER_FROM_TYPES\n      const values = witness ? Object.assign(permit, { witness: witness.witness }) : permit\n      return {\n        domain,\n        types,\n        values,\n      }\n    } else {\n      permit.permitted.forEach(validateTokenPermissions)\n      const types = witness ? permitBatchTransferFromWithWitnessType(witness) : PERMIT_BATCH_TRANSFER_FROM_TYPES\n      const values = witness ? Object.assign(permit, { witness: witness.witness }) : permit\n      return {\n        domain,\n        types,\n        values,\n      }\n    }\n  }\n\n  public static hash(\n    permit: PermitTransferFrom | PermitBatchTransferFrom,\n    permit2Address: string,\n    chainId: number,\n    witness?: Witness\n  ): string {\n    const { domain, types, values } = SignatureTransfer.getPermitData(permit, permit2Address, chainId, witness)\n    return _TypedDataEncoder.hash(domain, types, values)\n  }\n}\n\nfunction validateTokenPermissions(permissions: TokenPermissions) {\n  invariant(MaxSignatureTransferAmount.gte(permissions.amount), 'AMOUNT_OUT_OF_RANGE')\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Provider } from '@ethersproject/providers'\nimport Permit2Abi from '../../abis/Permit2.json'\nimport { Contract } from '@ethersproject/contracts'\n\nexport interface AllowanceData {\n  amount: BigNumber\n  nonce: number\n  expiration: number\n}\n\nexport class AllowanceProvider {\n  private permit2: Contract\n\n  constructor(private provider: Provider, private permit2Address: string) {\n    this.permit2 = new Contract(this.permit2Address, Permit2Abi, this.provider)\n  }\n\n  async getAllowanceData(token: string, owner: string, spender: string): Promise<AllowanceData> {\n    return await this.permit2.allowance(owner, token, spender)\n  }\n\n  async getAllowance(token: string, owner: string, spender: string): Promise<BigNumber> {\n    return (await this.getAllowanceData(token, owner, spender)).amount\n  }\n\n  async getNonce(token: string, owner: string, spender: string): Promise<number> {\n    return (await this.getAllowanceData(token, owner, spender)).nonce\n  }\n\n  async getExpiration(token: string, owner: string, spender: string): Promise<number> {\n    return (await this.getAllowanceData(token, owner, spender)).expiration\n  }\n}\n"]},"metadata":{},"sourceType":"script"}