{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { nearestUsableTick, Pool, TICK_SPACINGS, tickToPrice } from '@uniswap/v3-sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { SupportedChainId } from 'constants/chains';\nimport { ZERO_ADDRESS } from 'constants/misc';\nimport useAllV3TicksQuery from 'graphql/thegraph/AllV3TicksQuery';\nimport JSBI from 'jsbi';\nimport { useSingleContractMultipleData } from 'lib/hooks/multicall';\nimport { useEffect, useMemo, useState } from 'react';\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses';\nimport { useTickLens } from './useContract';\nimport { PoolState, usePool } from './usePools';\nconst PRICE_FIXED_DIGITS = 8;\nconst CHAIN_IDS_MISSING_SUBGRAPH_DATA = [SupportedChainId.ARBITRUM_ONE, SupportedChainId.ARBITRUM_RINKEBY];\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\n\nconst REFRESH_FREQUENCY = {\n  blocksPerFetch: 2\n};\nconst getActiveTick = (tickCurrent, feeAmount) => tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined;\nconst bitmapIndex = (tick, tickSpacing) => {\n  return Math.floor(tick / tickSpacing / 256);\n};\nfunction useTicksFromTickLens(currencyA, currencyB, feeAmount) {\n  _s();\n  let numSurroundingTicks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 125;\n  const [tickDataLatestSynced, setTickDataLatestSynced] = useState([]);\n  const [poolState, pool] = usePool(currencyA, currencyB, feeAmount);\n  const tickSpacing = feeAmount && TICK_SPACINGS[feeAmount];\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = (pool === null || pool === void 0 ? void 0 : pool.tickCurrent) && tickSpacing ? nearestUsableTick(pool === null || pool === void 0 ? void 0 : pool.tickCurrent, tickSpacing) : undefined;\n  const {\n    chainId\n  } = useWeb3React();\n  const poolAddress = currencyA && currencyB && feeAmount && poolState === PoolState.EXISTS ? Pool.getAddress(currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, feeAmount, undefined, chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined) : undefined;\n\n  // it is also possible to grab all tick data but it is extremely slow\n  // bitmapIndex(nearestUsableTick(TickMath.MIN_TICK, tickSpacing), tickSpacing)\n  const minIndex = useMemo(() => tickSpacing && activeTick ? bitmapIndex(activeTick - numSurroundingTicks * tickSpacing, tickSpacing) : undefined, [tickSpacing, activeTick, numSurroundingTicks]);\n  const maxIndex = useMemo(() => tickSpacing && activeTick ? bitmapIndex(activeTick + numSurroundingTicks * tickSpacing, tickSpacing) : undefined, [tickSpacing, activeTick, numSurroundingTicks]);\n  const tickLensArgs = useMemo(() => maxIndex && minIndex && poolAddress && poolAddress !== ZERO_ADDRESS ? new Array(maxIndex - minIndex + 1).fill(0).map((_, i) => i + minIndex).map(wordIndex => [poolAddress, wordIndex]) : [], [minIndex, maxIndex, poolAddress]);\n  const tickLens = useTickLens();\n  const callStates = useSingleContractMultipleData(tickLensArgs.length > 0 ? tickLens : undefined, 'getPopulatedTicksInWord', tickLensArgs, REFRESH_FREQUENCY);\n  const isError = useMemo(() => callStates.some(_ref => {\n    let {\n      error\n    } = _ref;\n    return error;\n  }), [callStates]);\n  const isLoading = useMemo(() => callStates.some(_ref2 => {\n    let {\n      loading\n    } = _ref2;\n    return loading;\n  }), [callStates]);\n  const IsSyncing = useMemo(() => callStates.some(_ref3 => {\n    let {\n      syncing\n    } = _ref3;\n    return syncing;\n  }), [callStates]);\n  const isValid = useMemo(() => callStates.some(_ref4 => {\n    let {\n      valid\n    } = _ref4;\n    return valid;\n  }), [callStates]);\n  const tickData = useMemo(() => callStates.map(_ref5 => {\n    let {\n      result\n    } = _ref5;\n    return result === null || result === void 0 ? void 0 : result.populatedTicks;\n  }).reduce((accumulator, current) => {\n    var _current$map;\n    return [...accumulator, ...((_current$map = current === null || current === void 0 ? void 0 : current.map(tickData => {\n      return {\n        tick: tickData.tick,\n        liquidityNet: JSBI.BigInt(tickData.liquidityNet)\n      };\n    })) !== null && _current$map !== void 0 ? _current$map : [])];\n  }, []), [callStates]);\n\n  // reset on input change\n  useEffect(() => {\n    setTickDataLatestSynced([]);\n  }, [currencyA, currencyB, feeAmount]);\n\n  // return the latest synced tickData even if we are still loading the newest data\n  useEffect(() => {\n    if (!IsSyncing && !isLoading && !isError && isValid) {\n      setTickDataLatestSynced(tickData.sort((a, b) => a.tick - b.tick));\n    }\n  }, [isError, isLoading, IsSyncing, tickData, isValid]);\n  return useMemo(() => ({\n    isLoading,\n    IsSyncing,\n    isError,\n    isValid,\n    tickData: tickDataLatestSynced\n  }), [isLoading, IsSyncing, isError, isValid, tickDataLatestSynced]);\n}\n_s(useTicksFromTickLens, \"KNoxVHsj5dAUNAeqcEjzxEKDUOg=\", false, function () {\n  return [usePool, useWeb3React, useTickLens, useSingleContractMultipleData];\n});\nfunction useTicksFromSubgraph(currencyA, currencyB, feeAmount) {\n  _s2();\n  const {\n    chainId\n  } = useWeb3React();\n  const poolAddress = currencyA && currencyB && feeAmount ? Pool.getAddress(currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, feeAmount, undefined, chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined) : undefined;\n  return useAllV3TicksQuery(poolAddress, 0, 30000);\n}\n\n// Fetches all ticks for a given pool\n_s2(useTicksFromSubgraph, \"SK46pRsXXxTNUdE3xkwwexqHlQM=\", false, function () {\n  return [useWeb3React, useAllV3TicksQuery];\n});\nfunction useAllV3Ticks(currencyA, currencyB, feeAmount) {\n  _s3();\n  var _subgraphTickData$dat;\n  const useSubgraph = currencyA ? !CHAIN_IDS_MISSING_SUBGRAPH_DATA.includes(currencyA.chainId) : true;\n  const tickLensTickData = useTicksFromTickLens(!useSubgraph ? currencyA : undefined, currencyB, feeAmount);\n  const subgraphTickData = useTicksFromSubgraph(useSubgraph ? currencyA : undefined, currencyB, feeAmount);\n  return {\n    isLoading: useSubgraph ? subgraphTickData.isLoading : tickLensTickData.isLoading,\n    error: useSubgraph ? subgraphTickData.error : tickLensTickData.isError,\n    ticks: useSubgraph ? (_subgraphTickData$dat = subgraphTickData.data) === null || _subgraphTickData$dat === void 0 ? void 0 : _subgraphTickData$dat.ticks : tickLensTickData.tickData\n  };\n}\n_s3(useAllV3Ticks, \"LczQzv2QhOxSBgKSuAq0sg4HFKc=\", false, function () {\n  return [useTicksFromTickLens, useTicksFromSubgraph];\n});\nexport function usePoolActiveLiquidity(currencyA, currencyB, feeAmount) {\n  _s4();\n  const pool = usePool(currencyA, currencyB, feeAmount);\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = useMemo(() => {\n    var _pool$;\n    return getActiveTick((_pool$ = pool[1]) === null || _pool$ === void 0 ? void 0 : _pool$.tickCurrent, feeAmount);\n  }, [pool, feeAmount]);\n  const {\n    isLoading,\n    error,\n    ticks\n  } = useAllV3Ticks(currencyA, currencyB, feeAmount);\n  return useMemo(() => {\n    var _pool$1$liquidity, _pool$2;\n    if (!currencyA || !currencyB || activeTick === undefined || pool[0] !== PoolState.EXISTS || !ticks || ticks.length === 0 || isLoading) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        error,\n        activeTick,\n        data: undefined\n      };\n    }\n    const token0 = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n    const token1 = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n\n    // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n    const pivot = ticks.findIndex(_ref6 => {\n      let {\n        tick\n      } = _ref6;\n      return tick > activeTick;\n    }) - 1;\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found');\n      return {\n        isLoading,\n        error,\n        activeTick,\n        data: undefined\n      };\n    }\n    const activeTickProcessed = {\n      liquidityActive: JSBI.BigInt((_pool$1$liquidity = (_pool$2 = pool[1]) === null || _pool$2 === void 0 ? void 0 : _pool$2.liquidity) !== null && _pool$1$liquidity !== void 0 ? _pool$1$liquidity : 0),\n      tick: activeTick,\n      liquidityNet: Number(ticks[pivot].tick) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS)\n    };\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true);\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false);\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks);\n    return {\n      isLoading,\n      error,\n      activeTick,\n      data: ticksProcessed\n    };\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, error]);\n}\n_s4(usePoolActiveLiquidity, \"zQbOlRypv5eqBNdV22MZ5kTxcbU=\", false, function () {\n  return [usePool, useAllV3Ticks];\n});","map":{"version":3,"names":["nearestUsableTick","Pool","TICK_SPACINGS","tickToPrice","useWeb3React","SupportedChainId","ZERO_ADDRESS","useAllV3TicksQuery","JSBI","useSingleContractMultipleData","useEffect","useMemo","useState","computeSurroundingTicks","V3_CORE_FACTORY_ADDRESSES","useTickLens","PoolState","usePool","PRICE_FIXED_DIGITS","CHAIN_IDS_MISSING_SUBGRAPH_DATA","ARBITRUM_ONE","ARBITRUM_RINKEBY","REFRESH_FREQUENCY","blocksPerFetch","getActiveTick","tickCurrent","feeAmount","Math","floor","undefined","bitmapIndex","tick","tickSpacing","useTicksFromTickLens","currencyA","currencyB","numSurroundingTicks","tickDataLatestSynced","setTickDataLatestSynced","poolState","pool","activeTick","chainId","poolAddress","EXISTS","getAddress","wrapped","minIndex","maxIndex","tickLensArgs","Array","fill","map","_","i","wordIndex","tickLens","callStates","length","isError","some","error","isLoading","loading","IsSyncing","syncing","isValid","valid","tickData","result","populatedTicks","reduce","accumulator","current","liquidityNet","BigInt","sort","a","b","useTicksFromSubgraph","useAllV3Ticks","useSubgraph","includes","tickLensTickData","subgraphTickData","ticks","data","usePoolActiveLiquidity","LOADING","token0","token1","pivot","findIndex","console","activeTickProcessed","liquidityActive","liquidity","Number","price0","toFixed","subsequentTicks","previousTicks","ticksProcessed","concat"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/usePoolTickData.ts"],"sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { FeeAmount, nearestUsableTick, Pool, TICK_SPACINGS, tickToPrice } from '@uniswap/v3-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { SupportedChainId } from 'constants/chains'\nimport { ZERO_ADDRESS } from 'constants/misc'\nimport useAllV3TicksQuery, { TickData } from 'graphql/thegraph/AllV3TicksQuery'\nimport JSBI from 'jsbi'\nimport { useSingleContractMultipleData } from 'lib/hooks/multicall'\nimport ms from 'ms.macro'\nimport { useEffect, useMemo, useState } from 'react'\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks'\n\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses'\nimport { useTickLens } from './useContract'\nimport { PoolState, usePool } from './usePools'\n\nconst PRICE_FIXED_DIGITS = 8\nconst CHAIN_IDS_MISSING_SUBGRAPH_DATA = [SupportedChainId.ARBITRUM_ONE, SupportedChainId.ARBITRUM_RINKEBY]\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\nexport interface TickProcessed {\n  tick: number\n  liquidityActive: JSBI\n  liquidityNet: JSBI\n  price0: string\n}\n\nconst REFRESH_FREQUENCY = { blocksPerFetch: 2 }\n\nconst getActiveTick = (tickCurrent: number | undefined, feeAmount: FeeAmount | undefined) =>\n  tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined\n\nconst bitmapIndex = (tick: number, tickSpacing: number) => {\n  return Math.floor(tick / tickSpacing / 256)\n}\n\nfunction useTicksFromTickLens(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  numSurroundingTicks: number | undefined = 125\n) {\n  const [tickDataLatestSynced, setTickDataLatestSynced] = useState<TickData[]>([])\n\n  const [poolState, pool] = usePool(currencyA, currencyB, feeAmount)\n\n  const tickSpacing = feeAmount && TICK_SPACINGS[feeAmount]\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = pool?.tickCurrent && tickSpacing ? nearestUsableTick(pool?.tickCurrent, tickSpacing) : undefined\n\n  const { chainId } = useWeb3React()\n\n  const poolAddress =\n    currencyA && currencyB && feeAmount && poolState === PoolState.EXISTS\n      ? Pool.getAddress(\n          currencyA?.wrapped,\n          currencyB?.wrapped,\n          feeAmount,\n          undefined,\n          chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined\n        )\n      : undefined\n\n  // it is also possible to grab all tick data but it is extremely slow\n  // bitmapIndex(nearestUsableTick(TickMath.MIN_TICK, tickSpacing), tickSpacing)\n  const minIndex = useMemo(\n    () =>\n      tickSpacing && activeTick ? bitmapIndex(activeTick - numSurroundingTicks * tickSpacing, tickSpacing) : undefined,\n    [tickSpacing, activeTick, numSurroundingTicks]\n  )\n\n  const maxIndex = useMemo(\n    () =>\n      tickSpacing && activeTick ? bitmapIndex(activeTick + numSurroundingTicks * tickSpacing, tickSpacing) : undefined,\n    [tickSpacing, activeTick, numSurroundingTicks]\n  )\n\n  const tickLensArgs: [string, number][] = useMemo(\n    () =>\n      maxIndex && minIndex && poolAddress && poolAddress !== ZERO_ADDRESS\n        ? new Array(maxIndex - minIndex + 1)\n            .fill(0)\n            .map((_, i) => i + minIndex)\n            .map((wordIndex) => [poolAddress, wordIndex])\n        : [],\n    [minIndex, maxIndex, poolAddress]\n  )\n\n  const tickLens = useTickLens()\n  const callStates = useSingleContractMultipleData(\n    tickLensArgs.length > 0 ? tickLens : undefined,\n    'getPopulatedTicksInWord',\n    tickLensArgs,\n    REFRESH_FREQUENCY\n  )\n\n  const isError = useMemo(() => callStates.some(({ error }) => error), [callStates])\n  const isLoading = useMemo(() => callStates.some(({ loading }) => loading), [callStates])\n  const IsSyncing = useMemo(() => callStates.some(({ syncing }) => syncing), [callStates])\n  const isValid = useMemo(() => callStates.some(({ valid }) => valid), [callStates])\n\n  const tickData: TickData[] = useMemo(\n    () =>\n      callStates\n        .map(({ result }) => result?.populatedTicks)\n        .reduce(\n          (accumulator, current) => [\n            ...accumulator,\n            ...(current?.map((tickData: TickData) => {\n              return {\n                tick: tickData.tick,\n                liquidityNet: JSBI.BigInt(tickData.liquidityNet),\n              }\n            }) ?? []),\n          ],\n          []\n        ),\n    [callStates]\n  )\n\n  // reset on input change\n  useEffect(() => {\n    setTickDataLatestSynced([])\n  }, [currencyA, currencyB, feeAmount])\n\n  // return the latest synced tickData even if we are still loading the newest data\n  useEffect(() => {\n    if (!IsSyncing && !isLoading && !isError && isValid) {\n      setTickDataLatestSynced(tickData.sort((a, b) => a.tick - b.tick))\n    }\n  }, [isError, isLoading, IsSyncing, tickData, isValid])\n\n  return useMemo(\n    () => ({ isLoading, IsSyncing, isError, isValid, tickData: tickDataLatestSynced }),\n    [isLoading, IsSyncing, isError, isValid, tickDataLatestSynced]\n  )\n}\n\nfunction useTicksFromSubgraph(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n) {\n  const { chainId } = useWeb3React()\n  const poolAddress =\n    currencyA && currencyB && feeAmount\n      ? Pool.getAddress(\n          currencyA?.wrapped,\n          currencyB?.wrapped,\n          feeAmount,\n          undefined,\n          chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined\n        )\n      : undefined\n\n  return useAllV3TicksQuery(poolAddress, 0, ms`30s`)\n}\n\n// Fetches all ticks for a given pool\nfunction useAllV3Ticks(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): {\n  isLoading: boolean\n  error: unknown\n  ticks: TickData[] | undefined\n} {\n  const useSubgraph = currencyA ? !CHAIN_IDS_MISSING_SUBGRAPH_DATA.includes(currencyA.chainId) : true\n\n  const tickLensTickData = useTicksFromTickLens(!useSubgraph ? currencyA : undefined, currencyB, feeAmount)\n  const subgraphTickData = useTicksFromSubgraph(useSubgraph ? currencyA : undefined, currencyB, feeAmount)\n\n  return {\n    isLoading: useSubgraph ? subgraphTickData.isLoading : tickLensTickData.isLoading,\n    error: useSubgraph ? subgraphTickData.error : tickLensTickData.isError,\n    ticks: useSubgraph ? subgraphTickData.data?.ticks : tickLensTickData.tickData,\n  }\n}\n\nexport function usePoolActiveLiquidity(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): {\n  isLoading: boolean\n  error: any\n  activeTick: number | undefined\n  data: TickProcessed[] | undefined\n} {\n  const pool = usePool(currencyA, currencyB, feeAmount)\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = useMemo(() => getActiveTick(pool[1]?.tickCurrent, feeAmount), [pool, feeAmount])\n\n  const { isLoading, error, ticks } = useAllV3Ticks(currencyA, currencyB, feeAmount)\n\n  return useMemo(() => {\n    if (\n      !currencyA ||\n      !currencyB ||\n      activeTick === undefined ||\n      pool[0] !== PoolState.EXISTS ||\n      !ticks ||\n      ticks.length === 0 ||\n      isLoading\n    ) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const token0 = currencyA?.wrapped\n    const token1 = currencyB?.wrapped\n\n    // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n    const pivot = ticks.findIndex(({ tick }) => tick > activeTick) - 1\n\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found')\n      return {\n        isLoading,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const activeTickProcessed: TickProcessed = {\n      liquidityActive: JSBI.BigInt(pool[1]?.liquidity ?? 0),\n      tick: activeTick,\n      liquidityNet: Number(ticks[pivot].tick) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true)\n\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false)\n\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)\n\n    return {\n      isLoading,\n      error,\n      activeTick,\n      data: ticksProcessed,\n    }\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, error])\n}\n"],"mappings":";;;;AACA,SAAoBA,iBAAiB,EAAEC,IAAI,EAAEC,aAAa,EAAEC,WAAW,QAAQ,iBAAiB;AAChG,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,gBAAgB,QAAQ,kBAAkB;AACnD,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,OAAOC,kBAAkB,MAAoB,kCAAkC;AAC/E,OAAOC,IAAI,MAAM,MAAM;AACvB,SAASC,6BAA6B,QAAQ,qBAAqB;AAEnE,SAASC,SAAS,EAAEC,OAAO,EAAEC,QAAQ,QAAQ,OAAO;AACpD,OAAOC,uBAAuB,MAAM,+BAA+B;AAEnE,SAASC,yBAAyB,QAAQ,wBAAwB;AAClE,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,SAAS,EAAEC,OAAO,QAAQ,YAAY;AAE/C,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,+BAA+B,GAAG,CAACd,gBAAgB,CAACe,YAAY,EAAEf,gBAAgB,CAACgB,gBAAgB,CAAC;;AAE1G;;AAQA,MAAMC,iBAAiB,GAAG;EAAEC,cAAc,EAAE;AAAE,CAAC;AAE/C,MAAMC,aAAa,GAAG,CAACC,WAA+B,EAAEC,SAAgC,KACtFD,WAAW,IAAIC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACH,WAAW,GAAGvB,aAAa,CAACwB,SAAS,CAAC,CAAC,GAAGxB,aAAa,CAACwB,SAAS,CAAC,GAAGG,SAAS;AAEtH,MAAMC,WAAW,GAAG,CAACC,IAAY,EAAEC,WAAmB,KAAK;EACzD,OAAOL,IAAI,CAACC,KAAK,CAACG,IAAI,GAAGC,WAAW,GAAG,GAAG,CAAC;AAC7C,CAAC;AAED,SAASC,oBAAoB,CAC3BC,SAA+B,EAC/BC,SAA+B,EAC/BT,SAAgC,EAEhC;EAAA;EAAA,IADAU,mBAAuC,uEAAG,GAAG;EAE7C,MAAM,CAACC,oBAAoB,EAAEC,uBAAuB,CAAC,GAAG1B,QAAQ,CAAa,EAAE,CAAC;EAEhF,MAAM,CAAC2B,SAAS,EAAEC,IAAI,CAAC,GAAGvB,OAAO,CAACiB,SAAS,EAAEC,SAAS,EAAET,SAAS,CAAC;EAElE,MAAMM,WAAW,GAAGN,SAAS,IAAIxB,aAAa,CAACwB,SAAS,CAAC;;EAEzD;EACA,MAAMe,UAAU,GAAG,CAAAD,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEf,WAAW,KAAIO,WAAW,GAAGhC,iBAAiB,CAACwC,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEf,WAAW,EAAEO,WAAW,CAAC,GAAGH,SAAS;EAEnH,MAAM;IAAEa;EAAQ,CAAC,GAAGtC,YAAY,EAAE;EAElC,MAAMuC,WAAW,GACfT,SAAS,IAAIC,SAAS,IAAIT,SAAS,IAAIa,SAAS,KAAKvB,SAAS,CAAC4B,MAAM,GACjE3C,IAAI,CAAC4C,UAAU,CACbX,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEY,OAAO,EAClBX,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEW,OAAO,EAClBpB,SAAS,EACTG,SAAS,EACTa,OAAO,GAAG5B,yBAAyB,CAAC4B,OAAO,CAAC,GAAGb,SAAS,CACzD,GACDA,SAAS;;EAEf;EACA;EACA,MAAMkB,QAAQ,GAAGpC,OAAO,CACtB,MACEqB,WAAW,IAAIS,UAAU,GAAGX,WAAW,CAACW,UAAU,GAAGL,mBAAmB,GAAGJ,WAAW,EAAEA,WAAW,CAAC,GAAGH,SAAS,EAClH,CAACG,WAAW,EAAES,UAAU,EAAEL,mBAAmB,CAAC,CAC/C;EAED,MAAMY,QAAQ,GAAGrC,OAAO,CACtB,MACEqB,WAAW,IAAIS,UAAU,GAAGX,WAAW,CAACW,UAAU,GAAGL,mBAAmB,GAAGJ,WAAW,EAAEA,WAAW,CAAC,GAAGH,SAAS,EAClH,CAACG,WAAW,EAAES,UAAU,EAAEL,mBAAmB,CAAC,CAC/C;EAED,MAAMa,YAAgC,GAAGtC,OAAO,CAC9C,MACEqC,QAAQ,IAAID,QAAQ,IAAIJ,WAAW,IAAIA,WAAW,KAAKrC,YAAY,GAC/D,IAAI4C,KAAK,CAACF,QAAQ,GAAGD,QAAQ,GAAG,CAAC,CAAC,CAC/BI,IAAI,CAAC,CAAC,CAAC,CACPC,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAGP,QAAQ,CAAC,CAC3BK,GAAG,CAAEG,SAAS,IAAK,CAACZ,WAAW,EAAEY,SAAS,CAAC,CAAC,GAC/C,EAAE,EACR,CAACR,QAAQ,EAAEC,QAAQ,EAAEL,WAAW,CAAC,CAClC;EAED,MAAMa,QAAQ,GAAGzC,WAAW,EAAE;EAC9B,MAAM0C,UAAU,GAAGhD,6BAA6B,CAC9CwC,YAAY,CAACS,MAAM,GAAG,CAAC,GAAGF,QAAQ,GAAG3B,SAAS,EAC9C,yBAAyB,EACzBoB,YAAY,EACZ3B,iBAAiB,CAClB;EAED,MAAMqC,OAAO,GAAGhD,OAAO,CAAC,MAAM8C,UAAU,CAACG,IAAI,CAAC;IAAA,IAAC;MAAEC;IAAM,CAAC;IAAA,OAAKA,KAAK;EAAA,EAAC,EAAE,CAACJ,UAAU,CAAC,CAAC;EAClF,MAAMK,SAAS,GAAGnD,OAAO,CAAC,MAAM8C,UAAU,CAACG,IAAI,CAAC;IAAA,IAAC;MAAEG;IAAQ,CAAC;IAAA,OAAKA,OAAO;EAAA,EAAC,EAAE,CAACN,UAAU,CAAC,CAAC;EACxF,MAAMO,SAAS,GAAGrD,OAAO,CAAC,MAAM8C,UAAU,CAACG,IAAI,CAAC;IAAA,IAAC;MAAEK;IAAQ,CAAC;IAAA,OAAKA,OAAO;EAAA,EAAC,EAAE,CAACR,UAAU,CAAC,CAAC;EACxF,MAAMS,OAAO,GAAGvD,OAAO,CAAC,MAAM8C,UAAU,CAACG,IAAI,CAAC;IAAA,IAAC;MAAEO;IAAM,CAAC;IAAA,OAAKA,KAAK;EAAA,EAAC,EAAE,CAACV,UAAU,CAAC,CAAC;EAElF,MAAMW,QAAoB,GAAGzD,OAAO,CAClC,MACE8C,UAAU,CACPL,GAAG,CAAC;IAAA,IAAC;MAAEiB;IAAO,CAAC;IAAA,OAAKA,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEC,cAAc;EAAA,EAAC,CAC3CC,MAAM,CACL,CAACC,WAAW,EAAEC,OAAO;IAAA;IAAA,OAAK,CACxB,GAAGD,WAAW,EACd,oBAAIC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAErB,GAAG,CAAEgB,QAAkB,IAAK;MACvC,OAAO;QACLrC,IAAI,EAAEqC,QAAQ,CAACrC,IAAI;QACnB2C,YAAY,EAAElE,IAAI,CAACmE,MAAM,CAACP,QAAQ,CAACM,YAAY;MACjD,CAAC;IACH,CAAC,CAAC,uDAAI,EAAE,CAAC,CACV;EAAA,GACD,EAAE,CACH,EACL,CAACjB,UAAU,CAAC,CACb;;EAED;EACA/C,SAAS,CAAC,MAAM;IACd4B,uBAAuB,CAAC,EAAE,CAAC;EAC7B,CAAC,EAAE,CAACJ,SAAS,EAAEC,SAAS,EAAET,SAAS,CAAC,CAAC;;EAErC;EACAhB,SAAS,CAAC,MAAM;IACd,IAAI,CAACsD,SAAS,IAAI,CAACF,SAAS,IAAI,CAACH,OAAO,IAAIO,OAAO,EAAE;MACnD5B,uBAAuB,CAAC8B,QAAQ,CAACQ,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC9C,IAAI,GAAG+C,CAAC,CAAC/C,IAAI,CAAC,CAAC;IACnE;EACF,CAAC,EAAE,CAAC4B,OAAO,EAAEG,SAAS,EAAEE,SAAS,EAAEI,QAAQ,EAAEF,OAAO,CAAC,CAAC;EAEtD,OAAOvD,OAAO,CACZ,OAAO;IAAEmD,SAAS;IAAEE,SAAS;IAAEL,OAAO;IAAEO,OAAO;IAAEE,QAAQ,EAAE/B;EAAqB,CAAC,CAAC,EAClF,CAACyB,SAAS,EAAEE,SAAS,EAAEL,OAAO,EAAEO,OAAO,EAAE7B,oBAAoB,CAAC,CAC/D;AACH;AAAC,GArGQJ,oBAAoB;EAAA,QAQDhB,OAAO,EAObb,YAAY,EAsCfW,WAAW,EACTN,6BAA6B;AAAA;AAiDlD,SAASsE,oBAAoB,CAC3B7C,SAA+B,EAC/BC,SAA+B,EAC/BT,SAAgC,EAChC;EAAA;EACA,MAAM;IAAEgB;EAAQ,CAAC,GAAGtC,YAAY,EAAE;EAClC,MAAMuC,WAAW,GACfT,SAAS,IAAIC,SAAS,IAAIT,SAAS,GAC/BzB,IAAI,CAAC4C,UAAU,CACbX,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEY,OAAO,EAClBX,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEW,OAAO,EAClBpB,SAAS,EACTG,SAAS,EACTa,OAAO,GAAG5B,yBAAyB,CAAC4B,OAAO,CAAC,GAAGb,SAAS,CACzD,GACDA,SAAS;EAEf,OAAOtB,kBAAkB,CAACoC,WAAW,EAAE,CAAC,QAAU;AACpD;;AAEA;AAAA,IApBSoC,oBAAoB;EAAA,QAKP3E,YAAY,EAYzBG,kBAAkB;AAAA;AAI3B,SAASyE,aAAa,CACpB9C,SAA+B,EAC/BC,SAA+B,EAC/BT,SAAgC,EAKhC;EAAA;EAAA;EACA,MAAMuD,WAAW,GAAG/C,SAAS,GAAG,CAACf,+BAA+B,CAAC+D,QAAQ,CAAChD,SAAS,CAACQ,OAAO,CAAC,GAAG,IAAI;EAEnG,MAAMyC,gBAAgB,GAAGlD,oBAAoB,CAAC,CAACgD,WAAW,GAAG/C,SAAS,GAAGL,SAAS,EAAEM,SAAS,EAAET,SAAS,CAAC;EACzG,MAAM0D,gBAAgB,GAAGL,oBAAoB,CAACE,WAAW,GAAG/C,SAAS,GAAGL,SAAS,EAAEM,SAAS,EAAET,SAAS,CAAC;EAExG,OAAO;IACLoC,SAAS,EAAEmB,WAAW,GAAGG,gBAAgB,CAACtB,SAAS,GAAGqB,gBAAgB,CAACrB,SAAS;IAChFD,KAAK,EAAEoB,WAAW,GAAGG,gBAAgB,CAACvB,KAAK,GAAGsB,gBAAgB,CAACxB,OAAO;IACtE0B,KAAK,EAAEJ,WAAW,4BAAGG,gBAAgB,CAACE,IAAI,0DAArB,sBAAuBD,KAAK,GAAGF,gBAAgB,CAACf;EACvE,CAAC;AACH;AAAC,IAnBQY,aAAa;EAAA,QAWK/C,oBAAoB,EACpB8C,oBAAoB;AAAA;AAS/C,OAAO,SAASQ,sBAAsB,CACpCrD,SAA+B,EAC/BC,SAA+B,EAC/BT,SAAgC,EAMhC;EAAA;EACA,MAAMc,IAAI,GAAGvB,OAAO,CAACiB,SAAS,EAAEC,SAAS,EAAET,SAAS,CAAC;;EAErD;EACA,MAAMe,UAAU,GAAG9B,OAAO,CAAC;IAAA;IAAA,OAAMa,aAAa,WAACgB,IAAI,CAAC,CAAC,CAAC,2CAAP,OAASf,WAAW,EAAEC,SAAS,CAAC;EAAA,GAAE,CAACc,IAAI,EAAEd,SAAS,CAAC,CAAC;EAEnG,MAAM;IAAEoC,SAAS;IAAED,KAAK;IAAEwB;EAAM,CAAC,GAAGL,aAAa,CAAC9C,SAAS,EAAEC,SAAS,EAAET,SAAS,CAAC;EAElF,OAAOf,OAAO,CAAC,MAAM;IAAA;IACnB,IACE,CAACuB,SAAS,IACV,CAACC,SAAS,IACVM,UAAU,KAAKZ,SAAS,IACxBW,IAAI,CAAC,CAAC,CAAC,KAAKxB,SAAS,CAAC4B,MAAM,IAC5B,CAACyC,KAAK,IACNA,KAAK,CAAC3B,MAAM,KAAK,CAAC,IAClBI,SAAS,EACT;MACA,OAAO;QACLA,SAAS,EAAEA,SAAS,IAAItB,IAAI,CAAC,CAAC,CAAC,KAAKxB,SAAS,CAACwE,OAAO;QACrD3B,KAAK;QACLpB,UAAU;QACV6C,IAAI,EAAEzD;MACR,CAAC;IACH;IAEA,MAAM4D,MAAM,GAAGvD,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEY,OAAO;IACjC,MAAM4C,MAAM,GAAGvD,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEW,OAAO;;IAEjC;IACA;IACA;IACA,MAAM6C,KAAK,GAAGN,KAAK,CAACO,SAAS,CAAC;MAAA,IAAC;QAAE7D;MAAK,CAAC;MAAA,OAAKA,IAAI,GAAGU,UAAU;IAAA,EAAC,GAAG,CAAC;IAElE,IAAIkD,KAAK,GAAG,CAAC,EAAE;MACb;MACAE,OAAO,CAAChC,KAAK,CAAC,0BAA0B,CAAC;MACzC,OAAO;QACLC,SAAS;QACTD,KAAK;QACLpB,UAAU;QACV6C,IAAI,EAAEzD;MACR,CAAC;IACH;IAEA,MAAMiE,mBAAkC,GAAG;MACzCC,eAAe,EAAEvF,IAAI,CAACmE,MAAM,iCAACnC,IAAI,CAAC,CAAC,CAAC,4CAAP,QAASwD,SAAS,iEAAI,CAAC,CAAC;MACrDjE,IAAI,EAAEU,UAAU;MAChBiC,YAAY,EAAEuB,MAAM,CAACZ,KAAK,CAACM,KAAK,CAAC,CAAC5D,IAAI,CAAC,KAAKU,UAAU,GAAGjC,IAAI,CAACmE,MAAM,CAACU,KAAK,CAACM,KAAK,CAAC,CAACjB,YAAY,CAAC,GAAGlE,IAAI,CAACmE,MAAM,CAAC,CAAC,CAAC;MAChHuB,MAAM,EAAE/F,WAAW,CAACsF,MAAM,EAAEC,MAAM,EAAEjD,UAAU,CAAC,CAAC0D,OAAO,CAACjF,kBAAkB;IAC5E,CAAC;IAED,MAAMkF,eAAe,GAAGvF,uBAAuB,CAAC4E,MAAM,EAAEC,MAAM,EAAEI,mBAAmB,EAAET,KAAK,EAAEM,KAAK,EAAE,IAAI,CAAC;IAExG,MAAMU,aAAa,GAAGxF,uBAAuB,CAAC4E,MAAM,EAAEC,MAAM,EAAEI,mBAAmB,EAAET,KAAK,EAAEM,KAAK,EAAE,KAAK,CAAC;IAEvG,MAAMW,cAAc,GAAGD,aAAa,CAACE,MAAM,CAACT,mBAAmB,CAAC,CAACS,MAAM,CAACH,eAAe,CAAC;IAExF,OAAO;MACLtC,SAAS;MACTD,KAAK;MACLpB,UAAU;MACV6C,IAAI,EAAEgB;IACR,CAAC;EACH,CAAC,EAAE,CAACpE,SAAS,EAAEC,SAAS,EAAEM,UAAU,EAAED,IAAI,EAAE6C,KAAK,EAAEvB,SAAS,EAAED,KAAK,CAAC,CAAC;AACvE;AAAC,IA1Ee0B,sBAAsB;EAAA,QAUvBtE,OAAO,EAKgB+D,aAAa;AAAA"},"metadata":{},"sourceType":"module"}