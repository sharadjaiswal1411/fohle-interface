{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\n// eslint-disable-next-line @sentry-internal/sdk/no-async-await\nfunction _asyncOptionalChain(_x) {\n  return _asyncOptionalChain2.apply(this, arguments);\n} // Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\nfunction _asyncOptionalChain2() {\n  _asyncOptionalChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ops) {\n    var lastAccessLHS, value, i, op, fn;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            lastAccessLHS = undefined;\n            value = ops[0];\n            i = 1;\n          case 3:\n            if (!(i < ops.length)) {\n              _context.next = 23;\n              break;\n            }\n            op = ops[i];\n            fn = ops[i + 1];\n            i += 2;\n            // by checking for loose equality to `null`, we catch both `null` and `undefined`\n            if (!((op === 'optionalAccess' || op === 'optionalCall') && value == null)) {\n              _context.next = 9;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 9:\n            if (!(op === 'access' || op === 'optionalAccess')) {\n              _context.next = 16;\n              break;\n            }\n            lastAccessLHS = value;\n            _context.next = 13;\n            return fn(value);\n          case 13:\n            value = _context.sent;\n            _context.next = 21;\n            break;\n          case 16:\n            if (!(op === 'call' || op === 'optionalCall')) {\n              _context.next = 21;\n              break;\n            }\n            _context.next = 19;\n            return fn(function () {\n              var _value;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_value = value).call.apply(_value, [lastAccessLHS].concat(args));\n            });\n          case 19:\n            value = _context.sent;\n            lastAccessLHS = undefined;\n          case 21:\n            _context.next = 3;\n            break;\n          case 23:\n            return _context.abrupt(\"return\", value);\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _asyncOptionalChain2.apply(this, arguments);\n}\nexport { _asyncOptionalChain };","map":{"version":3,"sources":["../../../src/buildPolyfills/_asyncOptionalChain.ts"],"names":[],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,SACA,mBAAA;EAAA;AAAA,EAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;EAAA,gFA7CA,iBAAA,GAAA;IAAA;IAAA;MAAA;QAAA;UAAA;YACA,aAAA,GAAA,SAAA;YACA,KAAA,GAAA,GAAA,CAAA,CAAA,CAAA;YACA,CAAA,GAAA,CAAA;UAAA;YAAA,MACA,CAAA,GAAA,GAAA,CAAA,MAAA;cAAA;cAAA;YAAA;YACA,EAAA,GAAA,GAAA,CAAA,CAAA,CAAA;YACA,EAAA,GAAA,GAAA,CAAA,CAAA,GAAA,CAAA,CAAA;YACA,CAAA,IAAA,CAAA;YACA;YAAA,MACA,CAAA,EAAA,KAAA,gBAAA,IAAA,EAAA,KAAA,cAAA,KAAA,KAAA,IAAA,IAAA;cAAA;cAAA;YAAA;YAAA;UAAA;YAAA,MAIA,EAAA,KAAA,QAAA,IAAA,EAAA,KAAA,gBAAA;cAAA;cAAA;YAAA;YACA,aAAA,GAAA,KAAA;YAAA;YAAA,OACA,EAAA,CAAA,KAAA,CAAA;UAAA;YAAA,KAAA;YAAA;YAAA;UAAA;YAAA,MACA,EAAA,KAAA,MAAA,IAAA,EAAA,KAAA,cAAA;cAAA;cAAA;YAAA;YAAA;YAAA,OACA,EAAA,CAAA;cAAA;cAAA,kCAAA,IAAA;gBAAA,IAAA;cAAA;cAAA,OAAA,UAAA,KAAA,EAAA,IAAA,gBAAA,aAAA,SAAA,IAAA,EAAA;YAAA,EAAA;UAAA;YAAA,KAAA;YACA,aAAA,GAAA,SAAA;UAAA;YAAA;YAAA;UAAA;YAAA,iCAGA,KAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACA;EAAA;AAAA","sourcesContent":["import { GenericFunction } from './types';\n\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions, for situations in which at least one part of the expression is async.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See\n * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\n// eslint-disable-next-line @sentry-internal/sdk/no-async-await\nexport async function _asyncOptionalChain(ops: unknown[]): Promise<unknown> {\n  let lastAccessLHS: unknown = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i] as string;\n    const fn = ops[i + 1] as (intermediateValue: unknown) => Promise<unknown>;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = await fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = await fn((...args: unknown[]) => (value as GenericFunction).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version:\n// async function _asyncOptionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = await fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = await fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n"]},"metadata":{},"sourceType":"module"}