{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { getVersionUpgrade, VersionUpgrade } from '@uniswap/token-lists';\nimport { DEFAULT_LIST_OF_LISTS } from '../../constants/lists';\nimport { updateVersion } from '../global/actions';\nimport { acceptListUpdate, addList, fetchTokenList, removeList } from './actions';\nconst NEW_LIST_STATE = {\n  error: null,\n  current: null,\n  loadingRequestId: null,\n  pendingUpdate: null\n};\nconst initialState = {\n  lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n  byUrl: {\n    ...DEFAULT_LIST_OF_LISTS.reduce((memo, listUrl) => {\n      memo[listUrl] = NEW_LIST_STATE;\n      return memo;\n    }, {})\n  }\n};\nexport default createReducer(initialState, builder => builder.addCase(fetchTokenList.pending, (state, _ref) => {\n  var _state$byUrl$url$curr, _state$byUrl$url, _state$byUrl$url$pend, _state$byUrl$url2;\n  let {\n    payload: {\n      requestId,\n      url\n    }\n  } = _ref;\n  const current = (_state$byUrl$url$curr = (_state$byUrl$url = state.byUrl[url]) === null || _state$byUrl$url === void 0 ? void 0 : _state$byUrl$url.current) !== null && _state$byUrl$url$curr !== void 0 ? _state$byUrl$url$curr : null;\n  const pendingUpdate = (_state$byUrl$url$pend = (_state$byUrl$url2 = state.byUrl[url]) === null || _state$byUrl$url2 === void 0 ? void 0 : _state$byUrl$url2.pendingUpdate) !== null && _state$byUrl$url$pend !== void 0 ? _state$byUrl$url$pend : null;\n  state.byUrl[url] = {\n    current,\n    pendingUpdate,\n    loadingRequestId: requestId,\n    error: null\n  };\n}).addCase(fetchTokenList.fulfilled, (state, _ref2) => {\n  var _state$byUrl$url3, _state$byUrl$url4;\n  let {\n    payload: {\n      requestId,\n      tokenList,\n      url\n    }\n  } = _ref2;\n  const current = (_state$byUrl$url3 = state.byUrl[url]) === null || _state$byUrl$url3 === void 0 ? void 0 : _state$byUrl$url3.current;\n  const loadingRequestId = (_state$byUrl$url4 = state.byUrl[url]) === null || _state$byUrl$url4 === void 0 ? void 0 : _state$byUrl$url4.loadingRequestId;\n\n  // no-op if update does nothing\n  if (current) {\n    const upgradeType = getVersionUpgrade(current.version, tokenList.version);\n    if (upgradeType === VersionUpgrade.NONE) return;\n    if (loadingRequestId === null || loadingRequestId === requestId) {\n      state.byUrl[url] = {\n        current,\n        pendingUpdate: tokenList,\n        loadingRequestId: null,\n        error: null\n      };\n    }\n  } else {\n    state.byUrl[url] = {\n      current: tokenList,\n      pendingUpdate: null,\n      loadingRequestId: null,\n      error: null\n    };\n  }\n}).addCase(fetchTokenList.rejected, (state, _ref3) => {\n  var _state$byUrl$url5;\n  let {\n    payload: {\n      url,\n      requestId,\n      errorMessage\n    }\n  } = _ref3;\n  if (((_state$byUrl$url5 = state.byUrl[url]) === null || _state$byUrl$url5 === void 0 ? void 0 : _state$byUrl$url5.loadingRequestId) !== requestId) {\n    // no-op since it's not the latest request\n    return;\n  }\n  state.byUrl[url] = {\n    current: state.byUrl[url].current ? state.byUrl[url].current : null,\n    pendingUpdate: null,\n    loadingRequestId: null,\n    error: errorMessage\n  };\n}).addCase(addList, (state, _ref4) => {\n  let {\n    payload: url\n  } = _ref4;\n  if (!state.byUrl[url]) {\n    state.byUrl[url] = NEW_LIST_STATE;\n  }\n}).addCase(removeList, (state, _ref5) => {\n  let {\n    payload: url\n  } = _ref5;\n  if (state.byUrl[url]) {\n    delete state.byUrl[url];\n  }\n}).addCase(acceptListUpdate, (state, _ref6) => {\n  var _state$byUrl$url6;\n  let {\n    payload: url\n  } = _ref6;\n  if (!((_state$byUrl$url6 = state.byUrl[url]) === null || _state$byUrl$url6 === void 0 ? void 0 : _state$byUrl$url6.pendingUpdate)) {\n    throw new Error('accept list update called without pending update');\n  }\n  state.byUrl[url] = {\n    ...state.byUrl[url],\n    current: state.byUrl[url].pendingUpdate,\n    pendingUpdate: null\n  };\n}).addCase(updateVersion, state => {\n  // state loaded from localStorage, but new lists have never been initialized\n  if (!state.lastInitializedDefaultListOfLists) {\n    state.byUrl = initialState.byUrl;\n  } else if (state.lastInitializedDefaultListOfLists) {\n    const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce((s, l) => s.add(l), new Set());\n    const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce((s, l) => s.add(l), new Set());\n    DEFAULT_LIST_OF_LISTS.forEach(listUrl => {\n      if (!lastInitializedSet.has(listUrl)) {\n        state.byUrl[listUrl] = NEW_LIST_STATE;\n      }\n    });\n    state.lastInitializedDefaultListOfLists.forEach(listUrl => {\n      if (!newListOfListsSet.has(listUrl)) {\n        delete state.byUrl[listUrl];\n      }\n    });\n  }\n  state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS;\n}));","map":{"version":3,"names":["createReducer","getVersionUpgrade","VersionUpgrade","DEFAULT_LIST_OF_LISTS","updateVersion","acceptListUpdate","addList","fetchTokenList","removeList","NEW_LIST_STATE","error","current","loadingRequestId","pendingUpdate","initialState","lastInitializedDefaultListOfLists","byUrl","reduce","memo","listUrl","builder","addCase","pending","state","payload","requestId","url","fulfilled","tokenList","upgradeType","version","NONE","rejected","errorMessage","Error","lastInitializedSet","s","l","add","Set","newListOfListsSet","forEach","has"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/lists/reducer.ts"],"sourcesContent":["import { createReducer } from '@reduxjs/toolkit'\nimport { getVersionUpgrade, TokenList, VersionUpgrade } from '@uniswap/token-lists'\n\nimport { DEFAULT_LIST_OF_LISTS } from '../../constants/lists'\nimport { updateVersion } from '../global/actions'\nimport { acceptListUpdate, addList, fetchTokenList, removeList } from './actions'\n\nexport interface ListsState {\n  readonly byUrl: {\n    readonly [url: string]: {\n      readonly current: TokenList | null\n      readonly pendingUpdate: TokenList | null\n      readonly loadingRequestId: string | null\n      readonly error: string | null\n    }\n  }\n  // this contains the default list of lists from the last time the updateVersion was called, i.e. the app was reloaded\n  readonly lastInitializedDefaultListOfLists?: string[]\n}\n\ntype ListState = ListsState['byUrl'][string]\n\nconst NEW_LIST_STATE: ListState = {\n  error: null,\n  current: null,\n  loadingRequestId: null,\n  pendingUpdate: null,\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] extends ReadonlyArray<infer U> ? U[] : T[P] }\n\nconst initialState: ListsState = {\n  lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n  byUrl: {\n    ...DEFAULT_LIST_OF_LISTS.reduce<Mutable<ListsState['byUrl']>>((memo, listUrl) => {\n      memo[listUrl] = NEW_LIST_STATE\n      return memo\n    }, {}),\n  },\n}\n\nexport default createReducer(initialState, (builder) =>\n  builder\n    .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {\n      const current = state.byUrl[url]?.current ?? null\n      const pendingUpdate = state.byUrl[url]?.pendingUpdate ?? null\n\n      state.byUrl[url] = {\n        current,\n        pendingUpdate,\n        loadingRequestId: requestId,\n        error: null,\n      }\n    })\n    .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {\n      const current = state.byUrl[url]?.current\n      const loadingRequestId = state.byUrl[url]?.loadingRequestId\n\n      // no-op if update does nothing\n      if (current) {\n        const upgradeType = getVersionUpgrade(current.version, tokenList.version)\n\n        if (upgradeType === VersionUpgrade.NONE) return\n        if (loadingRequestId === null || loadingRequestId === requestId) {\n          state.byUrl[url] = {\n            current,\n            pendingUpdate: tokenList,\n            loadingRequestId: null,\n            error: null,\n          }\n        }\n      } else {\n        state.byUrl[url] = {\n          current: tokenList,\n          pendingUpdate: null,\n          loadingRequestId: null,\n          error: null,\n        }\n      }\n    })\n    .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {\n      if (state.byUrl[url]?.loadingRequestId !== requestId) {\n        // no-op since it's not the latest request\n        return\n      }\n\n      state.byUrl[url] = {\n        current: state.byUrl[url].current ? state.byUrl[url].current : null,\n        pendingUpdate: null,\n        loadingRequestId: null,\n        error: errorMessage,\n      }\n    })\n    .addCase(addList, (state, { payload: url }) => {\n      if (!state.byUrl[url]) {\n        state.byUrl[url] = NEW_LIST_STATE\n      }\n    })\n    .addCase(removeList, (state, { payload: url }) => {\n      if (state.byUrl[url]) {\n        delete state.byUrl[url]\n      }\n    })\n    .addCase(acceptListUpdate, (state, { payload: url }) => {\n      if (!state.byUrl[url]?.pendingUpdate) {\n        throw new Error('accept list update called without pending update')\n      }\n      state.byUrl[url] = {\n        ...state.byUrl[url],\n        current: state.byUrl[url].pendingUpdate,\n        pendingUpdate: null,\n      }\n    })\n    .addCase(updateVersion, (state) => {\n      // state loaded from localStorage, but new lists have never been initialized\n      if (!state.lastInitializedDefaultListOfLists) {\n        state.byUrl = initialState.byUrl\n      } else if (state.lastInitializedDefaultListOfLists) {\n        const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce<Set<string>>(\n          (s, l) => s.add(l),\n          new Set()\n        )\n        const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce<Set<string>>((s, l) => s.add(l), new Set())\n\n        DEFAULT_LIST_OF_LISTS.forEach((listUrl) => {\n          if (!lastInitializedSet.has(listUrl)) {\n            state.byUrl[listUrl] = NEW_LIST_STATE\n          }\n        })\n\n        state.lastInitializedDefaultListOfLists.forEach((listUrl) => {\n          if (!newListOfListsSet.has(listUrl)) {\n            delete state.byUrl[listUrl]\n          }\n        })\n      }\n\n      state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS\n    })\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}