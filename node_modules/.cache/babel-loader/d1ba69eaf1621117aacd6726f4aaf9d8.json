{"ast":null,"code":"import { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\n\n/**\n * @inheritdoc\n */\nclass SessionFlusher {\n  __init() {\n    this.flushTimeout = 60;\n  }\n  __init2() {\n    this._pendingAggregates = {};\n  }\n  __init3() {\n    this._isEnabled = true;\n  }\n  constructor(client, attrs) {\n    ;\n    SessionFlusher.prototype.__init.call(this);\n    SessionFlusher.prototype.__init2.call(this);\n    SessionFlusher.prototype.__init3.call(this);\n    this._client = client;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n  flush() {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this._client.sendSession(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  getSessionAggregates() {\n    const aggregates = Object.keys(this._pendingAggregates).map(key => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n    const sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  close() {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  incrementSessionStatusCount() {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope && scope.getRequestSession();\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  _incrementSessionStatusCount(status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\nexport { SessionFlusher };","map":{"version":3,"sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"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","sourcesContent":["import { AggregationCounts, Client, RequestSessionStatus, SessionAggregates, SessionFlusherLike } from '@sentry/types';\nimport { dropUndefinedKeys } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _client: Client;\n\n  public constructor(client: Client, attrs: ReleaseHealthAttributes) {\n    this._client = client;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this._client.sendSession(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope && scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}