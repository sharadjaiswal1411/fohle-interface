{"ast":null,"code":"function wait(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction waitRandom(min, max) {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)));\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nclass CancelledError extends Error {\n  constructor() {\n    super('Cancelled');\n    this.isCancelledError = true;\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {\n  constructor() {\n    super(...arguments);\n    this.isRetryableError = true;\n  }\n}\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry(fn, _ref) {\n  let {\n    n,\n    minWait,\n    maxWait\n  } = _ref;\n  let completed = false;\n  let rejectCancelled;\n  // eslint-disable-next-line no-async-promise-executor\n  const promise = new Promise(async (resolve, reject) => {\n    rejectCancelled = reject;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let result;\n      try {\n        result = await fn();\n        if (!completed) {\n          resolve(result);\n          completed = true;\n        }\n        break;\n      } catch (error) {\n        if (completed) {\n          break;\n        }\n        if (n <= 0 || !error.isRetryableError) {\n          reject(error);\n          completed = true;\n          break;\n        }\n        n--;\n      }\n      await waitRandom(minWait, maxWait);\n    }\n  });\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return;\n      completed = true;\n      rejectCancelled(new CancelledError());\n    }\n  };\n}","map":{"version":3,"names":["wait","ms","Promise","resolve","setTimeout","waitRandom","min","max","Math","round","random","CancelledError","Error","constructor","isCancelledError","RetryableError","isRetryableError","retry","fn","n","minWait","maxWait","completed","rejectCancelled","promise","reject","result","error","cancel"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/utils/retry.ts"],"sourcesContent":["function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction waitRandom(min: number, max: number): Promise<void> {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)))\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nclass CancelledError extends Error {\n  public isCancelledError = true as const\n  constructor() {\n    super('Cancelled')\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {\n  public isRetryableError = true as const\n}\n\nexport interface RetryOptions {\n  n: number\n  minWait: number\n  maxWait: number\n}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry<T>(\n  fn: () => Promise<T>,\n  { n, minWait, maxWait }: RetryOptions\n): { promise: Promise<T>; cancel: () => void } {\n  let completed = false\n  let rejectCancelled: (error: Error) => void\n  // eslint-disable-next-line no-async-promise-executor\n  const promise = new Promise<T>(async (resolve, reject) => {\n    rejectCancelled = reject\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let result: T\n      try {\n        result = await fn()\n        if (!completed) {\n          resolve(result)\n          completed = true\n        }\n        break\n      } catch (error) {\n        if (completed) {\n          break\n        }\n        if (n <= 0 || !error.isRetryableError) {\n          reject(error)\n          completed = true\n          break\n        }\n        n--\n      }\n      await waitRandom(minWait, maxWait)\n    }\n  })\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return\n      completed = true\n      rejectCancelled(new CancelledError())\n    },\n  }\n}\n"],"mappings":"AAAA,SAASA,IAAI,CAACC,EAAU,EAAiB;EACvC,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;AAC1D;AAEA,SAASI,UAAU,CAACC,GAAW,EAAEC,GAAW,EAAiB;EAC3D,OAAOP,IAAI,CAACM,GAAG,GAAGE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAGF,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEA,GAAG,GAAGD,GAAG,CAAC,CAAC,CAAC;AACvE;;AAEA;AACA;AACA;AACA,MAAMK,cAAc,SAASC,KAAK,CAAC;EAEjCC,WAAW,GAAG;IACZ,KAAK,CAAC,WAAW,CAAC;IAAA,KAFbC,gBAAgB,GAAG,IAAI;EAG9B;AACF;;AAEA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,SAASH,KAAK,CAAC;EAAA;IAAA;IAAA,KACjCI,gBAAgB,GAAG,IAAI;EAAA;AAChC;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,KAAK,CACnBC,EAAoB,QAEyB;EAAA,IAD7C;IAAEC,CAAC;IAAEC,OAAO;IAAEC;EAAsB,CAAC;EAErC,IAAIC,SAAS,GAAG,KAAK;EACrB,IAAIC,eAAuC;EAC3C;EACA,MAAMC,OAAO,GAAG,IAAItB,OAAO,CAAI,OAAOC,OAAO,EAAEsB,MAAM,KAAK;IACxDF,eAAe,GAAGE,MAAM;IACxB;IACA,OAAO,IAAI,EAAE;MACX,IAAIC,MAAS;MACb,IAAI;QACFA,MAAM,GAAG,MAAMR,EAAE,EAAE;QACnB,IAAI,CAACI,SAAS,EAAE;UACdnB,OAAO,CAACuB,MAAM,CAAC;UACfJ,SAAS,GAAG,IAAI;QAClB;QACA;MACF,CAAC,CAAC,OAAOK,KAAK,EAAE;QACd,IAAIL,SAAS,EAAE;UACb;QACF;QACA,IAAIH,CAAC,IAAI,CAAC,IAAI,CAACQ,KAAK,CAACX,gBAAgB,EAAE;UACrCS,MAAM,CAACE,KAAK,CAAC;UACbL,SAAS,GAAG,IAAI;UAChB;QACF;QACAH,CAAC,EAAE;MACL;MACA,MAAMd,UAAU,CAACe,OAAO,EAAEC,OAAO,CAAC;IACpC;EACF,CAAC,CAAC;EACF,OAAO;IACLG,OAAO;IACPI,MAAM,EAAE,MAAM;MACZ,IAAIN,SAAS,EAAE;MACfA,SAAS,GAAG,IAAI;MAChBC,eAAe,CAAC,IAAIZ,cAAc,EAAE,CAAC;IACvC;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module"}