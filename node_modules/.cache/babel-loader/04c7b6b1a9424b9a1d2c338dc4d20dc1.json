{"ast":null,"code":"import { dsnToString, createEnvelope, dropUndefinedKeys } from '@sentry/utils';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(metadata) {\n  if (!metadata || !metadata.sdk) {\n    return;\n  }\n  const {\n    name,\n    version\n  } = metadata.sdk;\n  return {\n    name,\n    version\n  };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nfunction createSessionEnvelope(session, dsn, metadata, tunnel) {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && {\n      sdk: sdkInfo\n    }),\n    ...(!!tunnel && {\n      dsn: dsnToString(dsn)\n    })\n  };\n  const envelopeItem = 'aggregates' in session ? [{\n    type: 'sessions'\n  }, session] : [{\n    type: 'session'\n  }, session];\n  return createEnvelope(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nfunction createEventEnvelope(event, dsn, metadata, tunnel) {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const eventType = event.type || 'event';\n  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);\n  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n  const eventItem = [{\n    type: eventType\n  }, event];\n  return createEnvelope(envelopeHeaders, [eventItem]);\n}\nfunction createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {\n  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n  return {\n    event_id: event.event_id,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && {\n      sdk: sdkInfo\n    }),\n    ...(!!tunnel && {\n      dsn: dsnToString(dsn)\n    }),\n    ...(event.type === 'transaction' && dynamicSamplingContext && {\n      trace: dropUndefinedKeys({\n        ...dynamicSamplingContext\n      })\n    })\n  };\n}\nexport { createEventEnvelope, createSessionEnvelope };","map":{"version":3,"sources":["../../src/envelope.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DsnComponents,\n  Event,\n  EventEnvelope,\n  EventEnvelopeHeaders,\n  EventItem,\n  SdkInfo,\n  SdkMetadata,\n  Session,\n  SessionAggregates,\n  SessionEnvelope,\n  SessionItem,\n} from '@sentry/types';\nimport { createEnvelope, dropUndefinedKeys, dsnToString } from '@sentry/utils';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(metadata?: SdkMetadata): SdkInfo | undefined {\n  if (!metadata || !metadata.sdk) {\n    return;\n  }\n  const { name, version } = metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event: Event, sdkInfo?: SdkInfo): Event {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nexport function createSessionEnvelope(\n  session: Session | SessionAggregates,\n  dsn: DsnComponents,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n): SessionEnvelope {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n  };\n\n  const envelopeItem: SessionItem =\n    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session];\n\n  return createEnvelope<SessionEnvelope>(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nexport function createEventEnvelope(\n  event: Event,\n  dsn: DsnComponents,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n): EventEnvelope {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const eventType = event.type || 'event';\n\n  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);\n\n  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n\n  const eventItem: EventItem = [{ type: eventType }, event];\n  return createEnvelope<EventEnvelope>(envelopeHeaders, [eventItem]);\n}\n\nfunction createEventEnvelopeHeaders(\n  event: Event,\n  sdkInfo: SdkInfo | undefined,\n  tunnel: string | undefined,\n  dsn: DsnComponents,\n): EventEnvelopeHeaders {\n  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n\n  return {\n    event_id: event.event_id as string,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n    ...(event.type === 'transaction' &&\n      dynamicSamplingContext && {\n        trace: dropUndefinedKeys({ ...dynamicSamplingContext }),\n      }),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}