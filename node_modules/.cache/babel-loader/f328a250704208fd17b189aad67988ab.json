{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  var slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n  var InertRoot = function () {\n    /**\n     * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    function InertRoot(rootElement, inertManager) {\n      _classCallCheck(this, InertRoot);\n\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!HTMLElement} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n    _createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n        if (this._rootElement) {\n          if (this._savedAriaHidden !== null) {\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n        this._managedNodes.forEach(function (inertNode) {\n          this._unmanageNode(inertNode.node);\n        }, this);\n\n        // Note we cast the nulls to the ANY type here because:\n        // 1) We want the class properties to be declared as non-null, or else we\n        //    need even more casts throughout this code. All bets are off if an\n        //    instance has been destroyed and a method is called.\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\n        //    to know which properties we're setting.\n        this._observer = /** @type {?} */null;\n        this._rootElement = /** @type {?} */null;\n        this._managedNodes = /** @type {?} */null;\n        this._inertManager = /** @type {?} */null;\n      }\n\n      /**\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n       */\n    }, {\n      key: '_makeSubtreeUnfocusable',\n      /**\n       * @param {!Node} startNode\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this2 = this;\n        composedTreeWalk(startNode, function (node) {\n          return _this2._visitNode(node);\n        });\n        var activeElement = document.activeElement;\n        if (!document.body.contains(startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          /** @type {!ShadowRoot|undefined} */\n          var root = undefined;\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root = /** @type {!ShadowRoot} */node;\n              break;\n            }\n            node = node.parentNode;\n          }\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n        if (startNode.contains(activeElement)) {\n          activeElement.blur();\n          // In IE11, if an element is already focused, and then set to tabindex=-1\n          // calling blur() will not actually move the focus.\n          // To work around this we call focus() on the body instead.\n          if (activeElement === document.activeElement) {\n            document.body.focus();\n          }\n        }\n      }\n\n      /**\n       * @param {!Node} node\n       */\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */node;\n\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\n          this._adoptInertRoot(element);\n        }\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n          this._manageNode(element);\n        }\n      }\n\n      /**\n       * Register the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n        this._managedNodes.add(inertNode);\n      }\n\n      /**\n       * Unregister the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n        if (inertNode) {\n          this._managedNodes['delete'](inertNode);\n        }\n      }\n\n      /**\n       * Unregister the entire subtree starting at `startNode`.\n       * @param {!Node} startNode\n       */\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this3 = this;\n        composedTreeWalk(startNode, function (node) {\n          return _this3._unmanageNode(node);\n        });\n      }\n\n      /**\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n       * @param {!HTMLElement} node\n       */\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node);\n\n        // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\n          this._manageNode(savedInertNode.node);\n        }, this);\n      }\n\n      /**\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        records.forEach(function (record) {\n          var target = /** @type {!HTMLElement} */record.target;\n          if (record.type === 'childList') {\n            // Manage added nodes\n            slice.call(record.addedNodes).forEach(function (node) {\n              this._makeSubtreeUnfocusable(node);\n            }, this);\n\n            // Un-manage removed nodes\n            slice.call(record.removedNodes).forEach(function (node) {\n              this._unmanageSubtree(node);\n            }, this);\n          } else if (record.type === 'attributes') {\n            if (record.attributeName === 'tabindex') {\n              // Re-initialise inert node if tabindex changes\n              this._manageNode(target);\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n              // already managed nodes from this inert subroot.\n              this._adoptInertRoot(target);\n              var inertSubroot = this._inertManager.getInertRoot(target);\n              this._managedNodes.forEach(function (managedNode) {\n                if (target.contains(managedNode.node)) {\n                  inertSubroot._manageNode(managedNode.node);\n                }\n              });\n            }\n          }\n        }, this);\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get() {\n        return new Set(this._managedNodes);\n      }\n\n      /** @return {boolean} */\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get() {\n        return this._savedAriaHidden !== null;\n      }\n\n      /** @param {?string} ariaHidden */\n    }, {\n      key: 'savedAriaHidden',\n      set: function set(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n\n      /** @return {?string} */,\n\n      get: function get() {\n        return this._savedAriaHidden;\n      }\n    }]);\n    return InertRoot;\n  }();\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n  var InertNode = function () {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    function InertNode(node, inertRoot) {\n      _classCallCheck(this, InertNode);\n\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n    _createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n          var element = /** @type {!HTMLElement} */this._node;\n          if (this._savedTabIndex !== null) {\n            element.setAttribute('tabindex', this._savedTabIndex);\n          } else {\n            element.removeAttribute('tabindex');\n          }\n\n          // Use `delete` to restore native focus method.\n          if (this._overrodeFocusMethod) {\n            delete element.focus;\n          }\n        }\n\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\n        this._node = /** @type {?} */null;\n        this._inertRoots = /** @type {?} */null;\n        this._destroyed = true;\n      }\n\n      /**\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n       * If the object has been destroyed, any attempt to access it will cause an exception.\n       */\n    }, {\n      key: '_throwIfDestroyed',\n      /**\n       * Throw if user tries to access destroyed InertNode.\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n\n      /** @return {boolean} */\n    }, {\n      key: 'ensureUntabbable',\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */this.node;\n        if (matches.call(element, _focusableElementsString)) {\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n          if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          }\n          element.setAttribute('tabindex', '-1');\n          if (element.nodeType === Node.ELEMENT_NODE) {\n            element.focus = function () {};\n            this._overrodeFocusMethod = true;\n          }\n        } else if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          element.removeAttribute('tabindex');\n        }\n      }\n\n      /**\n       * Add another inert root to this inert node's set of managing inert roots.\n       * @param {!InertRoot} inertRoot\n       */\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.add(inertRoot);\n      }\n\n      /**\n       * Remove the given inert root from this inert node's set of managing inert roots.\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\n       * so the object should be destroyed.\n       * @param {!InertRoot} inertRoot\n       */\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots['delete'](inertRoot);\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get() {\n        return (/** @type {!InertNode} */this._destroyed\n        );\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get() {\n        return this._savedTabIndex !== null;\n      }\n\n      /** @return {!Node} */\n    }, {\n      key: 'node',\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._node;\n      }\n\n      /** @param {?number} tabIndex */\n    }, {\n      key: 'savedTabIndex',\n      set: function set(tabIndex) {\n        this._throwIfDestroyed();\n        this._savedTabIndex = tabIndex;\n      }\n\n      /** @return {?number} */,\n\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._savedTabIndex;\n      }\n    }]);\n    return InertNode;\n  }();\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n  var InertManager = function () {\n    /**\n     * @param {!Document} document\n     */\n    function InertManager(document) {\n      _classCallCheck(this, InertManager);\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!HTMLElement} root\n     * @param {boolean} inert\n     */\n\n    _createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n          this._inertRoots.set(root, inertRoot);\n          // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n          if (!this._document.body.contains(root)) {\n            var parent = root.parentNode;\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n          var _inertRoot = this._inertRoots.get(root);\n          _inertRoot.destructor();\n          this._inertRoots['delete'](root);\n          root.removeAttribute('inert');\n        }\n      }\n\n      /**\n       * Get the InertRoot object corresponding to the given inert root element, if any.\n       * @param {!Node} element\n       * @return {!InertRoot|undefined}\n       */\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n\n      /**\n       * Register the given InertRoot as managing the given node.\n       * In the case where the node has a previously existing inert root, this inert root will\n       * be added to its set of inert roots.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {!InertNode} inertNode\n       */\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n        this._managedNodes.set(node, inertNode);\n        return inertNode;\n      }\n\n      /**\n       * De-register the given InertRoot as managing the given inert node.\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n       * node from the InertManager's set of managed nodes if it is destroyed.\n       * If the node is not currently managed, this is essentially a no-op.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n       */\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (!inertNode) {\n          return null;\n        }\n        inertNode.removeInertRoot(inertRoot);\n        if (inertNode.destroyed) {\n          this._managedNodes['delete'](node);\n        }\n        return inertNode;\n      }\n\n      /**\n       * Callback used when document has finished loading.\n       */\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        inertElements.forEach(function (inertElement) {\n          this.setInert(inertElement, true);\n        }, this);\n\n        // Comment this out to use programmatic API only.\n        this._observer.observe(this._document.body || this._document.documentElement, {\n          attributes: true,\n          subtree: true,\n          childList: true\n        });\n      }\n\n      /**\n       * Callback used when mutation observer detects attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _this = this;\n        records.forEach(function (record) {\n          switch (record.type) {\n            case 'childList':\n              slice.call(record.addedNodes).forEach(function (node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) {\n                  return;\n                }\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                if (matches.call(node, '[inert]')) {\n                  inertElements.unshift(node);\n                }\n                inertElements.forEach(function (inertElement) {\n                  this.setInert(inertElement, true);\n                }, _this);\n              }, _this);\n              break;\n            case 'attributes':\n              if (record.attributeName !== 'inert') {\n                return;\n              }\n              var target = /** @type {!HTMLElement} */record.target;\n              var inert = target.hasAttribute('inert');\n              _this.setInert(target, inert);\n              break;\n          }\n        }, this);\n      }\n    }]);\n    return InertManager;\n  }();\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element = /** @type {!HTMLElement} */node;\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        var content = /** @type {!HTMLContentElement} */element;\n        // Verifies if ShadowDom v0 is supported.\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        var slot = /** @type {!HTMLSlotElement} */element;\n        // Verify if ShadowDom v1 is supported.\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({\n          flatten: true\n        }) : [];\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    var child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n  if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n    /** @type {!InertManager} */\n    var inertManager = new InertManager(document);\n    Object.defineProperty(HTMLElement.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!HTMLElement} */\n      get: function get() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!HTMLElement} */\n      set: function set(inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();","map":{"version":3,"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","window","slice","Array","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","value","destructor","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","startNode","_this2","composedTreeWalk","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","_unmanageSubtree","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","attributeName","managedNode","get","set","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","tabIndex","hasSavedTabIndex","addInertRoot","removeInertRoot","size","InertManager","_document","Map","_watchForInert","addInertStyle","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","parent","_inertRoot","inertElements","querySelectorAll","inertElement","_this","unshift","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","slot","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","querySelector","style","createElement","textContent","appendChild","HTMLElement","hasOwnProperty"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/wicg-inert/dist/inert.esm.js"],"sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  var slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n  var InertRoot = function () {\n    /**\n     * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    function InertRoot(rootElement, inertManager) {\n      _classCallCheck(this, InertRoot);\n\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!HTMLElement} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n\n    _createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n\n        if (this._rootElement) {\n          if (this._savedAriaHidden !== null) {\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n\n        this._managedNodes.forEach(function (inertNode) {\n          this._unmanageNode(inertNode.node);\n        }, this);\n\n        // Note we cast the nulls to the ANY type here because:\n        // 1) We want the class properties to be declared as non-null, or else we\n        //    need even more casts throughout this code. All bets are off if an\n        //    instance has been destroyed and a method is called.\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\n        //    to know which properties we're setting.\n        this._observer = /** @type {?} */null;\n        this._rootElement = /** @type {?} */null;\n        this._managedNodes = /** @type {?} */null;\n        this._inertManager = /** @type {?} */null;\n      }\n\n      /**\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n       */\n\n    }, {\n      key: '_makeSubtreeUnfocusable',\n\n\n      /**\n       * @param {!Node} startNode\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this2 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this2._visitNode(node);\n        });\n\n        var activeElement = document.activeElement;\n\n        if (!document.body.contains(startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          /** @type {!ShadowRoot|undefined} */\n          var root = undefined;\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root = /** @type {!ShadowRoot} */node;\n              break;\n            }\n            node = node.parentNode;\n          }\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n        if (startNode.contains(activeElement)) {\n          activeElement.blur();\n          // In IE11, if an element is already focused, and then set to tabindex=-1\n          // calling blur() will not actually move the focus.\n          // To work around this we call focus() on the body instead.\n          if (activeElement === document.activeElement) {\n            document.body.focus();\n          }\n        }\n      }\n\n      /**\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */node;\n\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\n          this._adoptInertRoot(element);\n        }\n\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n          this._manageNode(element);\n        }\n      }\n\n      /**\n       * Register the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n        this._managedNodes.add(inertNode);\n      }\n\n      /**\n       * Unregister the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n        if (inertNode) {\n          this._managedNodes['delete'](inertNode);\n        }\n      }\n\n      /**\n       * Unregister the entire subtree starting at `startNode`.\n       * @param {!Node} startNode\n       */\n\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this3 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this3._unmanageNode(node);\n        });\n      }\n\n      /**\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n       * @param {!HTMLElement} node\n       */\n\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node);\n\n        // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\n          this._manageNode(savedInertNode.node);\n        }, this);\n      }\n\n      /**\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        records.forEach(function (record) {\n          var target = /** @type {!HTMLElement} */record.target;\n          if (record.type === 'childList') {\n            // Manage added nodes\n            slice.call(record.addedNodes).forEach(function (node) {\n              this._makeSubtreeUnfocusable(node);\n            }, this);\n\n            // Un-manage removed nodes\n            slice.call(record.removedNodes).forEach(function (node) {\n              this._unmanageSubtree(node);\n            }, this);\n          } else if (record.type === 'attributes') {\n            if (record.attributeName === 'tabindex') {\n              // Re-initialise inert node if tabindex changes\n              this._manageNode(target);\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n              // already managed nodes from this inert subroot.\n              this._adoptInertRoot(target);\n              var inertSubroot = this._inertManager.getInertRoot(target);\n              this._managedNodes.forEach(function (managedNode) {\n                if (target.contains(managedNode.node)) {\n                  inertSubroot._manageNode(managedNode.node);\n                }\n              });\n            }\n          }\n        }, this);\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get() {\n        return new Set(this._managedNodes);\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get() {\n        return this._savedAriaHidden !== null;\n      }\n\n      /** @param {?string} ariaHidden */\n\n    }, {\n      key: 'savedAriaHidden',\n      set: function set(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n\n      /** @return {?string} */\n      ,\n      get: function get() {\n        return this._savedAriaHidden;\n      }\n    }]);\n\n    return InertRoot;\n  }();\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n\n  var InertNode = function () {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    function InertNode(node, inertRoot) {\n      _classCallCheck(this, InertNode);\n\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n\n    _createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n          var element = /** @type {!HTMLElement} */this._node;\n          if (this._savedTabIndex !== null) {\n            element.setAttribute('tabindex', this._savedTabIndex);\n          } else {\n            element.removeAttribute('tabindex');\n          }\n\n          // Use `delete` to restore native focus method.\n          if (this._overrodeFocusMethod) {\n            delete element.focus;\n          }\n        }\n\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\n        this._node = /** @type {?} */null;\n        this._inertRoots = /** @type {?} */null;\n        this._destroyed = true;\n      }\n\n      /**\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n       * If the object has been destroyed, any attempt to access it will cause an exception.\n       */\n\n    }, {\n      key: '_throwIfDestroyed',\n\n\n      /**\n       * Throw if user tries to access destroyed InertNode.\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'ensureUntabbable',\n\n\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */this.node;\n        if (matches.call(element, _focusableElementsString)) {\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n\n          if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          }\n          element.setAttribute('tabindex', '-1');\n          if (element.nodeType === Node.ELEMENT_NODE) {\n            element.focus = function () {};\n            this._overrodeFocusMethod = true;\n          }\n        } else if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          element.removeAttribute('tabindex');\n        }\n      }\n\n      /**\n       * Add another inert root to this inert node's set of managing inert roots.\n       * @param {!InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.add(inertRoot);\n      }\n\n      /**\n       * Remove the given inert root from this inert node's set of managing inert roots.\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\n       * so the object should be destroyed.\n       * @param {!InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots['delete'](inertRoot);\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get() {\n        return (/** @type {!InertNode} */this._destroyed\n        );\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get() {\n        return this._savedTabIndex !== null;\n      }\n\n      /** @return {!Node} */\n\n    }, {\n      key: 'node',\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._node;\n      }\n\n      /** @param {?number} tabIndex */\n\n    }, {\n      key: 'savedTabIndex',\n      set: function set(tabIndex) {\n        this._throwIfDestroyed();\n        this._savedTabIndex = tabIndex;\n      }\n\n      /** @return {?number} */\n      ,\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._savedTabIndex;\n      }\n    }]);\n\n    return InertNode;\n  }();\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n\n  var InertManager = function () {\n    /**\n     * @param {!Document} document\n     */\n    function InertManager(document) {\n      _classCallCheck(this, InertManager);\n\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!HTMLElement} root\n     * @param {boolean} inert\n     */\n\n\n    _createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n          this._inertRoots.set(root, inertRoot);\n          // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n          if (!this._document.body.contains(root)) {\n            var parent = root.parentNode;\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n\n          var _inertRoot = this._inertRoots.get(root);\n          _inertRoot.destructor();\n          this._inertRoots['delete'](root);\n          root.removeAttribute('inert');\n        }\n      }\n\n      /**\n       * Get the InertRoot object corresponding to the given inert root element, if any.\n       * @param {!Node} element\n       * @return {!InertRoot|undefined}\n       */\n\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n\n      /**\n       * Register the given InertRoot as managing the given node.\n       * In the case where the node has a previously existing inert root, this inert root will\n       * be added to its set of inert roots.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {!InertNode} inertNode\n       */\n\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n\n        this._managedNodes.set(node, inertNode);\n\n        return inertNode;\n      }\n\n      /**\n       * De-register the given InertRoot as managing the given inert node.\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n       * node from the InertManager's set of managed nodes if it is destroyed.\n       * If the node is not currently managed, this is essentially a no-op.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n       */\n\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (!inertNode) {\n          return null;\n        }\n\n        inertNode.removeInertRoot(inertRoot);\n        if (inertNode.destroyed) {\n          this._managedNodes['delete'](node);\n        }\n\n        return inertNode;\n      }\n\n      /**\n       * Callback used when document has finished loading.\n       */\n\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        inertElements.forEach(function (inertElement) {\n          this.setInert(inertElement, true);\n        }, this);\n\n        // Comment this out to use programmatic API only.\n        this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\n      }\n\n      /**\n       * Callback used when mutation observer detects attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _this = this;\n        records.forEach(function (record) {\n          switch (record.type) {\n            case 'childList':\n              slice.call(record.addedNodes).forEach(function (node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) {\n                  return;\n                }\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                if (matches.call(node, '[inert]')) {\n                  inertElements.unshift(node);\n                }\n                inertElements.forEach(function (inertElement) {\n                  this.setInert(inertElement, true);\n                }, _this);\n              }, _this);\n              break;\n            case 'attributes':\n              if (record.attributeName !== 'inert') {\n                return;\n              }\n              var target = /** @type {!HTMLElement} */record.target;\n              var inert = target.hasAttribute('inert');\n              _this.setInert(target, inert);\n              break;\n          }\n        }, this);\n      }\n    }]);\n\n    return InertManager;\n  }();\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element = /** @type {!HTMLElement} */node;\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        var content = /** @type {!HTMLContentElement} */element;\n        // Verifies if ShadowDom v0 is supported.\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        var slot = /** @type {!HTMLSlotElement} */element;\n        // Verify if ShadowDom v1 is supported.\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    var child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n\n  if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n    /** @type {!InertManager} */\n    var inertManager = new InertManager(document);\n\n    Object.defineProperty(HTMLElement.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!HTMLElement} */\n      get: function get() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!HTMLElement} */\n      set: function set(inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}