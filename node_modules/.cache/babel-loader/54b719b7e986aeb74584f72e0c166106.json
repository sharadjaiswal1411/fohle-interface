{"ast":null,"code":"import _ from 'lodash';\nimport stats from 'stats-lite';\nimport { UniswapInterfaceMulticall__factory } from '../types/v3/factories/UniswapInterfaceMulticall__factory';\nimport { UNISWAP_MULTICALL_ADDRESSES } from '../util/addresses';\nimport { log } from '../util/log';\nimport { IMulticallProvider } from './multicall-provider';\n/**\n * The UniswapMulticall contract has added functionality for limiting the amount of gas\n * that each call within the multicall can consume. This is useful for operations where\n * a call could consume such a large amount of gas that it causes the node to error out\n * with an out of gas error.\n *\n * @export\n * @class UniswapMulticallProvider\n */\nexport class UniswapMulticallProvider extends IMulticallProvider {\n  constructor(chainId, provider) {\n    let gasLimitPerCall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000000;\n    super();\n    this.chainId = chainId;\n    this.provider = provider;\n    this.gasLimitPerCall = gasLimitPerCall;\n    const multicallAddress = UNISWAP_MULTICALL_ADDRESSES[this.chainId];\n    if (!multicallAddress) {\n      throw new Error(`No address for Uniswap Multicall Contract on chain id: ${chainId}`);\n    }\n    this.multicallContract = UniswapInterfaceMulticall__factory.connect(multicallAddress, this.provider);\n  }\n  async callSameFunctionOnMultipleContracts(params) {\n    var _a;\n    const {\n      addresses,\n      contractInterface,\n      functionName,\n      functionParams,\n      providerConfig\n    } = params;\n    const blockNumberOverride = (_a = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _a !== void 0 ? _a : undefined;\n    const fragment = contractInterface.getFunction(functionName);\n    const callData = contractInterface.encodeFunctionData(fragment, functionParams);\n    const calls = _.map(addresses, address => {\n      return {\n        target: address,\n        callData,\n        gasLimit: this.gasLimitPerCall\n      };\n    });\n    log.debug({\n      calls\n    }, `About to multicall for ${functionName} across ${addresses.length} addresses`);\n    const {\n      blockNumber,\n      returnData: aggregateResults\n    } = await this.multicallContract.callStatic.multicall(calls, {\n      blockTag: blockNumberOverride\n    });\n    const results = [];\n    for (let i = 0; i < aggregateResults.length; i++) {\n      const {\n        success,\n        returnData\n      } = aggregateResults[i];\n      // Return data \"0x\" is sometimes returned for invalid calls.\n      if (!success || returnData.length <= 2) {\n        log.debug({\n          result: aggregateResults[i]\n        }, `Invalid result calling ${functionName} on address ${addresses[i]}`);\n        results.push({\n          success: false,\n          returnData\n        });\n        continue;\n      }\n      results.push({\n        success: true,\n        result: contractInterface.decodeFunctionResult(fragment, returnData)\n      });\n    }\n    log.debug({\n      results\n    }, `Results for multicall on ${functionName} across ${addresses.length} addresses as of block ${blockNumber}`);\n    return {\n      blockNumber,\n      results\n    };\n  }\n  async callSameFunctionOnContractWithMultipleParams(params) {\n    var _a, _b;\n    const {\n      address,\n      contractInterface,\n      functionName,\n      functionParams,\n      additionalConfig,\n      providerConfig\n    } = params;\n    const fragment = contractInterface.getFunction(functionName);\n    const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;\n    const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : undefined;\n    const calls = _.map(functionParams, functionParam => {\n      const callData = contractInterface.encodeFunctionData(fragment, functionParam);\n      return {\n        target: address,\n        callData,\n        gasLimit: gasLimitPerCall\n      };\n    });\n    log.debug({\n      calls\n    }, `About to multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params`);\n    const {\n      blockNumber,\n      returnData: aggregateResults\n    } = await this.multicallContract.callStatic.multicall(calls, {\n      blockTag: blockNumberOverride\n    });\n    const results = [];\n    const gasUsedForSuccess = [];\n    for (let i = 0; i < aggregateResults.length; i++) {\n      const {\n        success,\n        returnData,\n        gasUsed\n      } = aggregateResults[i];\n      // Return data \"0x\" is sometimes returned for invalid pools.\n      if (!success || returnData.length <= 2) {\n        log.debug({\n          result: aggregateResults[i]\n        }, `Invalid result calling ${functionName} with params ${functionParams[i]}`);\n        results.push({\n          success: false,\n          returnData\n        });\n        continue;\n      }\n      gasUsedForSuccess.push(gasUsed.toNumber());\n      results.push({\n        success: true,\n        result: contractInterface.decodeFunctionResult(fragment, returnData)\n      });\n    }\n    log.debug({\n      results,\n      functionName,\n      address\n    }, `Results for multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params. Results as of block ${blockNumber}`);\n    return {\n      blockNumber,\n      results,\n      approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99)\n    };\n  }\n  async callMultipleFunctionsOnSameContract(params) {\n    var _a, _b;\n    const {\n      address,\n      contractInterface,\n      functionNames,\n      functionParams,\n      additionalConfig,\n      providerConfig\n    } = params;\n    const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;\n    const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : undefined;\n    const calls = _.map(functionNames, (functionName, i) => {\n      const fragment = contractInterface.getFunction(functionName);\n      const param = functionParams ? functionParams[i] : [];\n      const callData = contractInterface.encodeFunctionData(fragment, param);\n      return {\n        target: address,\n        callData,\n        gasLimit: gasLimitPerCall\n      };\n    });\n    log.debug({\n      calls\n    }, `About to multicall for ${functionNames.length} functions at address ${address} with ${functionParams === null || functionParams === void 0 ? void 0 : functionParams.length} different sets of params`);\n    const {\n      blockNumber,\n      returnData: aggregateResults\n    } = await this.multicallContract.callStatic.multicall(calls, {\n      blockTag: blockNumberOverride\n    });\n    const results = [];\n    const gasUsedForSuccess = [];\n    for (let i = 0; i < aggregateResults.length; i++) {\n      const fragment = contractInterface.getFunction(functionNames[i]);\n      const {\n        success,\n        returnData,\n        gasUsed\n      } = aggregateResults[i];\n      // Return data \"0x\" is sometimes returned for invalid pools.\n      if (!success || returnData.length <= 2) {\n        log.debug({\n          result: aggregateResults[i]\n        }, `Invalid result calling ${functionNames[i]} with ${functionParams ? functionParams[i] : '0'} params`);\n        results.push({\n          success: false,\n          returnData\n        });\n        continue;\n      }\n      gasUsedForSuccess.push(gasUsed.toNumber());\n      results.push({\n        success: true,\n        result: contractInterface.decodeFunctionResult(fragment, returnData)\n      });\n    }\n    log.debug({\n      results,\n      functionNames,\n      address\n    }, `Results for multicall for ${functionNames.length} functions at address ${address} with ${functionParams ? functionParams.length : ' 0'} different sets of params. Results as of block ${blockNumber}`);\n    return {\n      blockNumber,\n      results,\n      approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99)\n    };\n  }\n}","map":{"version":3,"sources":["../../../src/providers/multicall-uniswap-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from 'lodash';\nimport stats from 'stats-lite';\nimport { UniswapInterfaceMulticall__factory } from '../types/v3/factories/UniswapInterfaceMulticall__factory';\nimport { UNISWAP_MULTICALL_ADDRESSES } from '../util/addresses';\nimport { log } from '../util/log';\nimport { IMulticallProvider, } from './multicall-provider';\n/**\n * The UniswapMulticall contract has added functionality for limiting the amount of gas\n * that each call within the multicall can consume. This is useful for operations where\n * a call could consume such a large amount of gas that it causes the node to error out\n * with an out of gas error.\n *\n * @export\n * @class UniswapMulticallProvider\n */\nexport class UniswapMulticallProvider extends IMulticallProvider {\n    constructor(chainId, provider, gasLimitPerCall = 1000000) {\n        super();\n        this.chainId = chainId;\n        this.provider = provider;\n        this.gasLimitPerCall = gasLimitPerCall;\n        const multicallAddress = UNISWAP_MULTICALL_ADDRESSES[this.chainId];\n        if (!multicallAddress) {\n            throw new Error(`No address for Uniswap Multicall Contract on chain id: ${chainId}`);\n        }\n        this.multicallContract = UniswapInterfaceMulticall__factory.connect(multicallAddress, this.provider);\n    }\n    async callSameFunctionOnMultipleContracts(params) {\n        var _a;\n        const { addresses, contractInterface, functionName, functionParams, providerConfig, } = params;\n        const blockNumberOverride = (_a = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _a !== void 0 ? _a : undefined;\n        const fragment = contractInterface.getFunction(functionName);\n        const callData = contractInterface.encodeFunctionData(fragment, functionParams);\n        const calls = _.map(addresses, (address) => {\n            return {\n                target: address,\n                callData,\n                gasLimit: this.gasLimitPerCall,\n            };\n        });\n        log.debug({ calls }, `About to multicall for ${functionName} across ${addresses.length} addresses`);\n        const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {\n            blockTag: blockNumberOverride,\n        });\n        const results = [];\n        for (let i = 0; i < aggregateResults.length; i++) {\n            const { success, returnData } = aggregateResults[i];\n            // Return data \"0x\" is sometimes returned for invalid calls.\n            if (!success || returnData.length <= 2) {\n                log.debug({ result: aggregateResults[i] }, `Invalid result calling ${functionName} on address ${addresses[i]}`);\n                results.push({\n                    success: false,\n                    returnData,\n                });\n                continue;\n            }\n            results.push({\n                success: true,\n                result: contractInterface.decodeFunctionResult(fragment, returnData),\n            });\n        }\n        log.debug({ results }, `Results for multicall on ${functionName} across ${addresses.length} addresses as of block ${blockNumber}`);\n        return { blockNumber, results };\n    }\n    async callSameFunctionOnContractWithMultipleParams(params) {\n        var _a, _b;\n        const { address, contractInterface, functionName, functionParams, additionalConfig, providerConfig, } = params;\n        const fragment = contractInterface.getFunction(functionName);\n        const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;\n        const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : undefined;\n        const calls = _.map(functionParams, (functionParam) => {\n            const callData = contractInterface.encodeFunctionData(fragment, functionParam);\n            return {\n                target: address,\n                callData,\n                gasLimit: gasLimitPerCall,\n            };\n        });\n        log.debug({ calls }, `About to multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params`);\n        const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {\n            blockTag: blockNumberOverride,\n        });\n        const results = [];\n        const gasUsedForSuccess = [];\n        for (let i = 0; i < aggregateResults.length; i++) {\n            const { success, returnData, gasUsed } = aggregateResults[i];\n            // Return data \"0x\" is sometimes returned for invalid pools.\n            if (!success || returnData.length <= 2) {\n                log.debug({ result: aggregateResults[i] }, `Invalid result calling ${functionName} with params ${functionParams[i]}`);\n                results.push({\n                    success: false,\n                    returnData,\n                });\n                continue;\n            }\n            gasUsedForSuccess.push(gasUsed.toNumber());\n            results.push({\n                success: true,\n                result: contractInterface.decodeFunctionResult(fragment, returnData),\n            });\n        }\n        log.debug({ results, functionName, address }, `Results for multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params. Results as of block ${blockNumber}`);\n        return {\n            blockNumber,\n            results,\n            approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99),\n        };\n    }\n    async callMultipleFunctionsOnSameContract(params) {\n        var _a, _b;\n        const { address, contractInterface, functionNames, functionParams, additionalConfig, providerConfig, } = params;\n        const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;\n        const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : undefined;\n        const calls = _.map(functionNames, (functionName, i) => {\n            const fragment = contractInterface.getFunction(functionName);\n            const param = functionParams ? functionParams[i] : [];\n            const callData = contractInterface.encodeFunctionData(fragment, param);\n            return {\n                target: address,\n                callData,\n                gasLimit: gasLimitPerCall,\n            };\n        });\n        log.debug({ calls }, `About to multicall for ${functionNames.length} functions at address ${address} with ${functionParams === null || functionParams === void 0 ? void 0 : functionParams.length} different sets of params`);\n        const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {\n            blockTag: blockNumberOverride,\n        });\n        const results = [];\n        const gasUsedForSuccess = [];\n        for (let i = 0; i < aggregateResults.length; i++) {\n            const fragment = contractInterface.getFunction(functionNames[i]);\n            const { success, returnData, gasUsed } = aggregateResults[i];\n            // Return data \"0x\" is sometimes returned for invalid pools.\n            if (!success || returnData.length <= 2) {\n                log.debug({ result: aggregateResults[i] }, `Invalid result calling ${functionNames[i]} with ${functionParams ? functionParams[i] : '0'} params`);\n                results.push({\n                    success: false,\n                    returnData,\n                });\n                continue;\n            }\n            gasUsedForSuccess.push(gasUsed.toNumber());\n            results.push({\n                success: true,\n                result: contractInterface.decodeFunctionResult(fragment, returnData),\n            });\n        }\n        log.debug({ results, functionNames, address }, `Results for multicall for ${functionNames.length} functions at address ${address} with ${functionParams ? functionParams.length : ' 0'} different sets of params. Results as of block ${blockNumber}`);\n        return {\n            blockNumber,\n            results,\n            approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99),\n        };\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGljYWxsLXVuaXN3YXAtcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJvdmlkZXJzL211bHRpY2FsbC11bmlzd2FwLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxZQUFZLENBQUM7QUFFL0IsT0FBTyxFQUFFLGtDQUFrQyxFQUFFLE1BQU0sMERBQTBELENBQUM7QUFHOUcsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDaEUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUVsQyxPQUFPLEVBSUwsa0JBQWtCLEdBRW5CLE1BQU0sc0JBQXNCLENBQUM7QUFNOUI7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLE9BQU8sd0JBQXlCLFNBQVEsa0JBQTBDO0lBR3RGLFlBQ1ksT0FBZ0IsRUFDaEIsUUFBc0IsRUFDdEIsa0JBQWtCLE9BQVM7UUFFckMsS0FBSyxFQUFFLENBQUM7UUFKRSxZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQ2hCLGFBQVEsR0FBUixRQUFRLENBQWM7UUFDdEIsb0JBQWUsR0FBZixlQUFlLENBQVk7UUFHckMsTUFBTSxnQkFBZ0IsR0FBRywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFbkUsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQ2IsMERBQTBELE9BQU8sRUFBRSxDQUNwRSxDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsa0NBQWtDLENBQUMsT0FBTyxDQUNqRSxnQkFBZ0IsRUFDaEIsSUFBSSxDQUFDLFFBQVEsQ0FDZCxDQUFDO0lBQ0osQ0FBQztJQUVNLEtBQUssQ0FBQyxtQ0FBbUMsQ0FJOUMsTUFBa0U7O1FBS2xFLE1BQU0sRUFDSixTQUFTLEVBQ1Qs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"]},"metadata":{},"sourceType":"module"}