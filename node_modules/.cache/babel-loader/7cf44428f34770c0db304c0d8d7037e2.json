{"ast":null,"code":"'use strict';\n\n/* eslint-disable max-params */\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\nmodule.exports = list;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n\n/* Map of characters which can be used to mark\n * list-items. */\nvar LIST_UNORDERED_MARKERS = {};\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_MARKERS = {};\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n  while (index < length) {\n    character = value.charAt(index);\n    if (character === C_TAB) {\n      size += TAB_SIZE - size % TAB_SIZE;\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n    index++;\n  }\n  if (size >= TAB_SIZE) {\n    return;\n  }\n  character = value.charAt(index);\n  markers = commonmark ? LIST_ORDERED_COMMONMARK_MARKERS : LIST_ORDERED_MARKERS;\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n    while (index < length) {\n      character = value.charAt(index);\n      if (!decimal(character)) {\n        break;\n      }\n      queue += character;\n      index++;\n    }\n    character = value.charAt(index);\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n  character = value.charAt(++index);\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n  if (silent) {\n    return true;\n  }\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n    end = index + TAB_SIZE;\n    size = 0;\n    while (index < length) {\n      character = value.charAt(index);\n      if (character === C_TAB) {\n        size += TAB_SIZE - size % TAB_SIZE;\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n      index++;\n    }\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n    character = value.charAt(index);\n    currentMarker = null;\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n        while (index < length) {\n          character = value.charAt(index);\n          if (!decimal(character)) {\n            break;\n          }\n          queue += character;\n          index++;\n        }\n        character = value.charAt(index);\n        index++;\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n      if (currentMarker) {\n        character = value.charAt(index);\n        if (character === C_TAB) {\n          size += TAB_SIZE - size % TAB_SIZE;\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n            index++;\n            size++;\n          }\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n      prefixed = false;\n      index = startIndex;\n    }\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n    if (currentMarker === C_ASTERISK || currentMarker === C_UNDERSCORE || currentMarker === C_DASH) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n    prevEmpty = empty;\n    empty = !trim(content).length;\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n    index = nextIndex + 1;\n  }\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n    item = eat(item)(listItem(self, item, now), node);\n    if (item.loose) {\n      isLoose = true;\n    }\n    item = items[index].trail.join(C_NEWLINE);\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n    eat(item);\n  }\n  enterTop();\n  exitBlockquote();\n  node.loose = isLoose;\n  return node;\n}\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n  value = fn.apply(null, arguments);\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) || value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n\n/* Create a list-item using overly simple mechanics. */\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n  line = position.line;\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n    return '';\n  }\n}\n\n/* Create a list-item using sane mechanics. */\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_BULLET, replacer);\n  lines = value.split(C_NEWLINE);\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n  trimmedLines[0] = rest;\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n  index = 0;\n  length = lines.length;\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n  return trimmedLines.join(C_NEWLINE);\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n    return max + rest;\n  }\n}","map":{"version":3,"names":["trim","require","repeat","decimal","getIndent","removeIndent","interrupt","module","exports","list","C_ASTERISK","C_UNDERSCORE","C_PLUS","C_DASH","C_DOT","C_SPACE","C_NEWLINE","C_TAB","C_PAREN_CLOSE","C_X_LOWER","TAB_SIZE","EXPRESSION_LOOSE_LIST_ITEM","EXPRESSION_TASK_ITEM","EXPRESSION_BULLET","EXPRESSION_PEDANTIC_BULLET","EXPRESSION_INITIAL_INDENT","LIST_UNORDERED_MARKERS","LIST_ORDERED_MARKERS","LIST_ORDERED_COMMONMARK_MARKERS","eat","value","silent","self","commonmark","options","pedantic","tokenizers","blockTokenizers","interuptors","interruptList","markers","index","length","start","size","queue","ordered","character","marker","nextIndex","startIndex","prefixed","currentMarker","content","line","prevEmpty","empty","items","allLines","emptyLines","item","enterTop","exitBlockquote","isLoose","node","now","end","indented","charAt","parseInt","indexOf","indent","slice","thematicBreak","call","concat","push","trail","join","reset","type","loose","children","enterList","enterBlock","listItem","ctx","position","offsets","offset","fn","pedanticListItem","normalListItem","checked","task","apply","arguments","gfm","match","toLowerCase","test","tokenizeBlock","replace","replacer","$0","max","bullet","rest","lines","trimmedLines","split","$1","$2","$3","$4","Number"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/remark-parse/lib/tokenize/list.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable max-params */\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\n\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n\n/* Map of characters which can be used to mark\n * list-items. */\nvar LIST_UNORDERED_MARKERS = {};\n\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_MARKERS = {};\n\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\n\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - (size % TAB_SIZE);\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n\n  markers = commonmark ?\n    LIST_ORDERED_COMMONMARK_MARKERS :\n    LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - (size % TAB_SIZE);\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - (size % TAB_SIZE);\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (\n      currentMarker === C_ASTERISK ||\n      currentMarker === C_UNDERSCORE ||\n      currentMarker === C_DASH\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n\n  node.loose = isLoose;\n\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n      value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n\n/* Create a list-item using overly simple mechanics. */\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n  line = position.line;\n\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n\n    return '';\n  }\n}\n\n/* Create a list-item using sane mechanics. */\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_BULLET, replacer);\n\n  lines = value.split(C_NEWLINE);\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n  trimmedLines[0] = rest;\n\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) +\n      lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n\n    return max + rest;\n  }\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIC,MAAM,GAAGD,OAAO,CAAC,eAAe,CAAC;AACrC,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAY,CAAC;AACnC,IAAIG,SAAS,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAClD,IAAII,YAAY,GAAGJ,OAAO,CAAC,4BAA4B,CAAC;AACxD,IAAIK,SAAS,GAAGL,OAAO,CAAC,mBAAmB,CAAC;AAE5CM,MAAM,CAACC,OAAO,GAAGC,IAAI;AAErB,IAAIC,UAAU,GAAG,GAAG;AACpB,IAAIC,YAAY,GAAG,GAAG;AACtB,IAAIC,MAAM,GAAG,GAAG;AAChB,IAAIC,MAAM,GAAG,GAAG;AAChB,IAAIC,KAAK,GAAG,GAAG;AACf,IAAIC,OAAO,GAAG,GAAG;AACjB,IAAIC,SAAS,GAAG,IAAI;AACpB,IAAIC,KAAK,GAAG,IAAI;AAChB,IAAIC,aAAa,GAAG,GAAG;AACvB,IAAIC,SAAS,GAAG,GAAG;AAEnB,IAAIC,QAAQ,GAAG,CAAC;AAChB,IAAIC,0BAA0B,GAAG,cAAc;AAC/C,IAAIC,oBAAoB,GAAG,sBAAsB;AACjD,IAAIC,iBAAiB,GAAG,6DAA6D;AACrF,IAAIC,0BAA0B,GAAG,kCAAkC;AACnE,IAAIC,yBAAyB,GAAG,iBAAiB;;AAEjD;AACA;AACA,IAAIC,sBAAsB,GAAG,CAAC,CAAC;AAE/BA,sBAAsB,CAAChB,UAAU,CAAC,GAAG,IAAI;AACzCgB,sBAAsB,CAACd,MAAM,CAAC,GAAG,IAAI;AACrCc,sBAAsB,CAACb,MAAM,CAAC,GAAG,IAAI;;AAErC;AACA;AACA,IAAIc,oBAAoB,GAAG,CAAC,CAAC;AAE7BA,oBAAoB,CAACb,KAAK,CAAC,GAAG,IAAI;;AAElC;AACA;AACA,IAAIc,+BAA+B,GAAG,CAAC,CAAC;AAExCA,+BAA+B,CAACd,KAAK,CAAC,GAAG,IAAI;AAC7Cc,+BAA+B,CAACV,aAAa,CAAC,GAAG,IAAI;AAErD,SAAST,IAAI,CAACoB,GAAG,EAAEC,KAAK,EAAEC,MAAM,EAAE;EAChC,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIC,UAAU,GAAGD,IAAI,CAACE,OAAO,CAACD,UAAU;EACxC,IAAIE,QAAQ,GAAGH,IAAI,CAACE,OAAO,CAACC,QAAQ;EACpC,IAAIC,UAAU,GAAGJ,IAAI,CAACK,eAAe;EACrC,IAAIC,WAAW,GAAGN,IAAI,CAACO,aAAa;EACpC,IAAIC,OAAO;EACX,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,MAAM,GAAGZ,KAAK,CAACY,MAAM;EACzB,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,KAAK;EACT,IAAIC,OAAO;EACX,IAAIC,SAAS;EACb,IAAIC,MAAM;EACV,IAAIC,SAAS;EACb,IAAIC,UAAU;EACd,IAAIC,QAAQ;EACZ,IAAIC,aAAa;EACjB,IAAIC,OAAO;EACX,IAAIC,IAAI;EACR,IAAIC,SAAS;EACb,IAAIC,KAAK;EACT,IAAIC,KAAK;EACT,IAAIC,QAAQ;EACZ,IAAIC,UAAU;EACd,IAAIC,IAAI;EACR,IAAIC,QAAQ;EACZ,IAAIC,cAAc;EAClB,IAAIC,OAAO;EACX,IAAIC,IAAI;EACR,IAAIC,GAAG;EACP,IAAIC,GAAG;EACP,IAAIC,QAAQ;EAEZ,OAAO1B,KAAK,GAAGC,MAAM,EAAE;IACrBK,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;IAE/B,IAAIM,SAAS,KAAK9B,KAAK,EAAE;MACvB2B,IAAI,IAAIxB,QAAQ,GAAIwB,IAAI,GAAGxB,QAAS;IACtC,CAAC,MAAM,IAAI2B,SAAS,KAAKhC,OAAO,EAAE;MAChC6B,IAAI,EAAE;IACR,CAAC,MAAM;MACL;IACF;IAEAH,KAAK,EAAE;EACT;EAEA,IAAIG,IAAI,IAAIxB,QAAQ,EAAE;IACpB;EACF;EAEA2B,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;EAE/BD,OAAO,GAAGP,UAAU,GAClBL,+BAA+B,GAC/BD,oBAAoB;EAEtB,IAAID,sBAAsB,CAACqB,SAAS,CAAC,KAAK,IAAI,EAAE;IAC9CC,MAAM,GAAGD,SAAS;IAClBD,OAAO,GAAG,KAAK;EACjB,CAAC,MAAM;IACLA,OAAO,GAAG,IAAI;IACdD,KAAK,GAAG,EAAE;IAEV,OAAOJ,KAAK,GAAGC,MAAM,EAAE;MACrBK,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;MAE/B,IAAI,CAACtC,OAAO,CAAC4C,SAAS,CAAC,EAAE;QACvB;MACF;MAEAF,KAAK,IAAIE,SAAS;MAClBN,KAAK,EAAE;IACT;IAEAM,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;IAE/B,IAAI,CAACI,KAAK,IAAIL,OAAO,CAACO,SAAS,CAAC,KAAK,IAAI,EAAE;MACzC;IACF;IAEAJ,KAAK,GAAG0B,QAAQ,CAACxB,KAAK,EAAE,EAAE,CAAC;IAC3BG,MAAM,GAAGD,SAAS;EACpB;EAEAA,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC,EAAE3B,KAAK,CAAC;EAEjC,IAAIM,SAAS,KAAKhC,OAAO,IAAIgC,SAAS,KAAK9B,KAAK,EAAE;IAChD;EACF;EAEA,IAAIc,MAAM,EAAE;IACV,OAAO,IAAI;EACb;EAEAU,KAAK,GAAG,CAAC;EACTgB,KAAK,GAAG,EAAE;EACVC,QAAQ,GAAG,EAAE;EACbC,UAAU,GAAG,EAAE;EAEf,OAAOlB,KAAK,GAAGC,MAAM,EAAE;IACrBO,SAAS,GAAGnB,KAAK,CAACwC,OAAO,CAACtD,SAAS,EAAEyB,KAAK,CAAC;IAC3CS,UAAU,GAAGT,KAAK;IAClBU,QAAQ,GAAG,KAAK;IAChBgB,QAAQ,GAAG,KAAK;IAEhB,IAAIlB,SAAS,KAAK,CAAC,CAAC,EAAE;MACpBA,SAAS,GAAGP,MAAM;IACpB;IAEAwB,GAAG,GAAGzB,KAAK,GAAGrB,QAAQ;IACtBwB,IAAI,GAAG,CAAC;IAER,OAAOH,KAAK,GAAGC,MAAM,EAAE;MACrBK,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;MAE/B,IAAIM,SAAS,KAAK9B,KAAK,EAAE;QACvB2B,IAAI,IAAIxB,QAAQ,GAAIwB,IAAI,GAAGxB,QAAS;MACtC,CAAC,MAAM,IAAI2B,SAAS,KAAKhC,OAAO,EAAE;QAChC6B,IAAI,EAAE;MACR,CAAC,MAAM;QACL;MACF;MAEAH,KAAK,EAAE;IACT;IAEA,IAAIG,IAAI,IAAIxB,QAAQ,EAAE;MACpB+C,QAAQ,GAAG,IAAI;IACjB;IAEA,IAAIP,IAAI,IAAIhB,IAAI,IAAIgB,IAAI,CAACW,MAAM,EAAE;MAC/BJ,QAAQ,GAAG,IAAI;IACjB;IAEApB,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;IAC/BW,aAAa,GAAG,IAAI;IAEpB,IAAI,CAACe,QAAQ,EAAE;MACb,IAAIzC,sBAAsB,CAACqB,SAAS,CAAC,KAAK,IAAI,EAAE;QAC9CK,aAAa,GAAGL,SAAS;QACzBN,KAAK,EAAE;QACPG,IAAI,EAAE;MACR,CAAC,MAAM;QACLC,KAAK,GAAG,EAAE;QAEV,OAAOJ,KAAK,GAAGC,MAAM,EAAE;UACrBK,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;UAE/B,IAAI,CAACtC,OAAO,CAAC4C,SAAS,CAAC,EAAE;YACvB;UACF;UAEAF,KAAK,IAAIE,SAAS;UAClBN,KAAK,EAAE;QACT;QAEAM,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;QAC/BA,KAAK,EAAE;QAEP,IAAII,KAAK,IAAIL,OAAO,CAACO,SAAS,CAAC,KAAK,IAAI,EAAE;UACxCK,aAAa,GAAGL,SAAS;UACzBH,IAAI,IAAIC,KAAK,CAACH,MAAM,GAAG,CAAC;QAC1B;MACF;MAEA,IAAIU,aAAa,EAAE;QACjBL,SAAS,GAAGjB,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC;QAE/B,IAAIM,SAAS,KAAK9B,KAAK,EAAE;UACvB2B,IAAI,IAAIxB,QAAQ,GAAIwB,IAAI,GAAGxB,QAAS;UACpCqB,KAAK,EAAE;QACT,CAAC,MAAM,IAAIM,SAAS,KAAKhC,OAAO,EAAE;UAChCmD,GAAG,GAAGzB,KAAK,GAAGrB,QAAQ;UAEtB,OAAOqB,KAAK,GAAGyB,GAAG,EAAE;YAClB,IAAIpC,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC,KAAK1B,OAAO,EAAE;cACnC;YACF;YAEA0B,KAAK,EAAE;YACPG,IAAI,EAAE;UACR;UAEA,IAAIH,KAAK,KAAKyB,GAAG,IAAIpC,KAAK,CAACsC,MAAM,CAAC3B,KAAK,CAAC,KAAK1B,OAAO,EAAE;YACpD0B,KAAK,IAAIrB,QAAQ,GAAG,CAAC;YACrBwB,IAAI,IAAIxB,QAAQ,GAAG,CAAC;UACtB;QACF,CAAC,MAAM,IAAI2B,SAAS,KAAK/B,SAAS,IAAI+B,SAAS,KAAK,EAAE,EAAE;UACtDK,aAAa,GAAG,IAAI;QACtB;MACF;IACF;IAEA,IAAIA,aAAa,EAAE;MACjB,IAAI,CAACjB,QAAQ,IAAIa,MAAM,KAAKI,aAAa,EAAE;QACzC;MACF;MAEAD,QAAQ,GAAG,IAAI;IACjB,CAAC,MAAM;MACL,IAAI,CAAClB,UAAU,IAAI,CAACkC,QAAQ,IAAIrC,KAAK,CAACsC,MAAM,CAAClB,UAAU,CAAC,KAAKnC,OAAO,EAAE;QACpEoD,QAAQ,GAAG,IAAI;MACjB,CAAC,MAAM,IAAIlC,UAAU,IAAI2B,IAAI,EAAE;QAC7BO,QAAQ,GAAGvB,IAAI,IAAIgB,IAAI,CAACW,MAAM,IAAI3B,IAAI,GAAGxB,QAAQ;MACnD;MAEA+B,QAAQ,GAAG,KAAK;MAChBV,KAAK,GAAGS,UAAU;IACpB;IAEAI,IAAI,GAAGxB,KAAK,CAAC0C,KAAK,CAACtB,UAAU,EAAED,SAAS,CAAC;IACzCI,OAAO,GAAGH,UAAU,KAAKT,KAAK,GAAGa,IAAI,GAAGxB,KAAK,CAAC0C,KAAK,CAAC/B,KAAK,EAAEQ,SAAS,CAAC;IAErE,IACEG,aAAa,KAAK1C,UAAU,IAC5B0C,aAAa,KAAKzC,YAAY,IAC9ByC,aAAa,KAAKvC,MAAM,EACxB;MACA,IAAIuB,UAAU,CAACqC,aAAa,CAACC,IAAI,CAAC1C,IAAI,EAAEH,GAAG,EAAEyB,IAAI,EAAE,IAAI,CAAC,EAAE;QACxD;MACF;IACF;IAEAC,SAAS,GAAGC,KAAK;IACjBA,KAAK,GAAG,CAACxD,IAAI,CAACqD,OAAO,CAAC,CAACX,MAAM;IAE7B,IAAIyB,QAAQ,IAAIP,IAAI,EAAE;MACpBA,IAAI,CAAC9B,KAAK,GAAG8B,IAAI,CAAC9B,KAAK,CAAC6C,MAAM,CAAChB,UAAU,EAAEL,IAAI,CAAC;MAChDI,QAAQ,GAAGA,QAAQ,CAACiB,MAAM,CAAChB,UAAU,EAAEL,IAAI,CAAC;MAC5CK,UAAU,GAAG,EAAE;IACjB,CAAC,MAAM,IAAIR,QAAQ,EAAE;MACnB,IAAIQ,UAAU,CAACjB,MAAM,KAAK,CAAC,EAAE;QAC3BkB,IAAI,CAAC9B,KAAK,CAAC8C,IAAI,CAAC,EAAE,CAAC;QACnBhB,IAAI,CAACiB,KAAK,GAAGlB,UAAU,CAACgB,MAAM,EAAE;MAClC;MAEAf,IAAI,GAAG;QACL9B,KAAK,EAAE,CAACwB,IAAI,CAAC;QACbiB,MAAM,EAAE3B,IAAI;QACZiC,KAAK,EAAE;MACT,CAAC;MAEDpB,KAAK,CAACmB,IAAI,CAAChB,IAAI,CAAC;MAChBF,QAAQ,GAAGA,QAAQ,CAACiB,MAAM,CAAChB,UAAU,EAAEL,IAAI,CAAC;MAC5CK,UAAU,GAAG,EAAE;IACjB,CAAC,MAAM,IAAIH,KAAK,EAAE;MAChB,IAAID,SAAS,EAAE;QACb;MACF;MAEAI,UAAU,CAACiB,IAAI,CAACtB,IAAI,CAAC;IACvB,CAAC,MAAM;MACL,IAAIC,SAAS,EAAE;QACb;MACF;MAEA,IAAIjD,SAAS,CAACgC,WAAW,EAAEF,UAAU,EAAEJ,IAAI,EAAE,CAACH,GAAG,EAAEyB,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE;QAC/D;MACF;MAEAM,IAAI,CAAC9B,KAAK,GAAG8B,IAAI,CAAC9B,KAAK,CAAC6C,MAAM,CAAChB,UAAU,EAAEL,IAAI,CAAC;MAChDI,QAAQ,GAAGA,QAAQ,CAACiB,MAAM,CAAChB,UAAU,EAAEL,IAAI,CAAC;MAC5CK,UAAU,GAAG,EAAE;IACjB;IAEAlB,KAAK,GAAGQ,SAAS,GAAG,CAAC;EACvB;EAEAe,IAAI,GAAGnC,GAAG,CAAC6B,QAAQ,CAACoB,IAAI,CAAC9D,SAAS,CAAC,CAAC,CAAC+D,KAAK,CAAC;IACzCC,IAAI,EAAE,MAAM;IACZlC,OAAO,EAAEA,OAAO;IAChBH,KAAK,EAAEA,KAAK;IACZsC,KAAK,EAAE,IAAI;IACXC,QAAQ,EAAE;EACZ,CAAC,CAAC;EAEFrB,QAAQ,GAAG7B,IAAI,CAACmD,SAAS,EAAE;EAC3BrB,cAAc,GAAG9B,IAAI,CAACoD,UAAU,EAAE;EAClCrB,OAAO,GAAG,KAAK;EACftB,KAAK,GAAG,CAAC,CAAC;EACVC,MAAM,GAAGe,KAAK,CAACf,MAAM;EAErB,OAAO,EAAED,KAAK,GAAGC,MAAM,EAAE;IACvBkB,IAAI,GAAGH,KAAK,CAAChB,KAAK,CAAC,CAACX,KAAK,CAACgD,IAAI,CAAC9D,SAAS,CAAC;IACzCiD,GAAG,GAAGpC,GAAG,CAACoC,GAAG,EAAE;IAEfL,IAAI,GAAG/B,GAAG,CAAC+B,IAAI,CAAC,CAACyB,QAAQ,CAACrD,IAAI,EAAE4B,IAAI,EAAEK,GAAG,CAAC,EAAED,IAAI,CAAC;IAEjD,IAAIJ,IAAI,CAACqB,KAAK,EAAE;MACdlB,OAAO,GAAG,IAAI;IAChB;IAEAH,IAAI,GAAGH,KAAK,CAAChB,KAAK,CAAC,CAACoC,KAAK,CAACC,IAAI,CAAC9D,SAAS,CAAC;IAEzC,IAAIyB,KAAK,KAAKC,MAAM,GAAG,CAAC,EAAE;MACxBkB,IAAI,IAAI5C,SAAS;IACnB;IAEAa,GAAG,CAAC+B,IAAI,CAAC;EACX;EAEAC,QAAQ,EAAE;EACVC,cAAc,EAAE;EAEhBE,IAAI,CAACiB,KAAK,GAAGlB,OAAO;EAEpB,OAAOC,IAAI;AACb;AAEA,SAASqB,QAAQ,CAACC,GAAG,EAAExD,KAAK,EAAEyD,QAAQ,EAAE;EACtC,IAAIC,OAAO,GAAGF,GAAG,CAACG,MAAM;EACxB,IAAIC,EAAE,GAAGJ,GAAG,CAACpD,OAAO,CAACC,QAAQ,GAAGwD,gBAAgB,GAAGC,cAAc;EACjE,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,IAAI;EACR,IAAIvB,MAAM;EAEVzC,KAAK,GAAG4D,EAAE,CAACK,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAEjC,IAAIV,GAAG,CAACpD,OAAO,CAAC+D,GAAG,EAAE;IACnBH,IAAI,GAAGhE,KAAK,CAACoE,KAAK,CAAC5E,oBAAoB,CAAC;IAExC,IAAIwE,IAAI,EAAE;MACRvB,MAAM,GAAGuB,IAAI,CAAC,CAAC,CAAC,CAACpD,MAAM;MACvBmD,OAAO,GAAGC,IAAI,CAAC,CAAC,CAAC,CAACK,WAAW,EAAE,KAAKhF,SAAS;MAC7CqE,OAAO,CAACD,QAAQ,CAACjC,IAAI,CAAC,IAAIiB,MAAM;MAChCzC,KAAK,GAAGA,KAAK,CAAC0C,KAAK,CAACD,MAAM,CAAC;IAC7B;EACF;EAEA,OAAO;IACLS,IAAI,EAAE,UAAU;IAChBC,KAAK,EAAE5D,0BAA0B,CAAC+E,IAAI,CAACtE,KAAK,CAAC,IAC3CA,KAAK,CAACsC,MAAM,CAACtC,KAAK,CAACY,MAAM,GAAG,CAAC,CAAC,KAAK1B,SAAS;IAC9C6E,OAAO,EAAEA,OAAO;IAChBX,QAAQ,EAAEI,GAAG,CAACe,aAAa,CAACvE,KAAK,EAAEyD,QAAQ;EAC7C,CAAC;AACH;;AAEA;AACA,SAASI,gBAAgB,CAACL,GAAG,EAAExD,KAAK,EAAEyD,QAAQ,EAAE;EAC9C,IAAIC,OAAO,GAAGF,GAAG,CAACG,MAAM;EACxB,IAAInC,IAAI,GAAGiC,QAAQ,CAACjC,IAAI;;EAExB;EACAxB,KAAK,GAAGA,KAAK,CAACwE,OAAO,CAAC9E,0BAA0B,EAAE+E,QAAQ,CAAC;;EAE3D;AACF;EACEjD,IAAI,GAAGiC,QAAQ,CAACjC,IAAI;EAEpB,OAAOxB,KAAK,CAACwE,OAAO,CAAC7E,yBAAyB,EAAE8E,QAAQ,CAAC;;EAEzD;AACF;EACE,SAASA,QAAQ,CAACC,EAAE,EAAE;IACpBhB,OAAO,CAAClC,IAAI,CAAC,GAAG,CAACkC,OAAO,CAAClC,IAAI,CAAC,IAAI,CAAC,IAAIkD,EAAE,CAAC9D,MAAM;IAChDY,IAAI,EAAE;IAEN,OAAO,EAAE;EACX;AACF;;AAEA;AACA,SAASsC,cAAc,CAACN,GAAG,EAAExD,KAAK,EAAEyD,QAAQ,EAAE;EAC5C,IAAIC,OAAO,GAAGF,GAAG,CAACG,MAAM;EACxB,IAAInC,IAAI,GAAGiC,QAAQ,CAACjC,IAAI;EACxB,IAAImD,GAAG;EACP,IAAIC,MAAM;EACV,IAAIC,IAAI;EACR,IAAIC,KAAK;EACT,IAAIC,YAAY;EAChB,IAAIpE,KAAK;EACT,IAAIC,MAAM;;EAEV;EACAZ,KAAK,GAAGA,KAAK,CAACwE,OAAO,CAAC/E,iBAAiB,EAAEgF,QAAQ,CAAC;EAElDK,KAAK,GAAG9E,KAAK,CAACgF,KAAK,CAAC9F,SAAS,CAAC;EAE9B6F,YAAY,GAAGxG,YAAY,CAACyB,KAAK,EAAE1B,SAAS,CAACqG,GAAG,CAAC,CAAClC,MAAM,CAAC,CAACuC,KAAK,CAAC9F,SAAS,CAAC;;EAE1E;AACF;AACA;AACA;AACA;AACA;EACE6F,YAAY,CAAC,CAAC,CAAC,GAAGF,IAAI;EAEtBnB,OAAO,CAAClC,IAAI,CAAC,GAAG,CAACkC,OAAO,CAAClC,IAAI,CAAC,IAAI,CAAC,IAAIoD,MAAM,CAAChE,MAAM;EACpDY,IAAI,EAAE;EAENb,KAAK,GAAG,CAAC;EACTC,MAAM,GAAGkE,KAAK,CAAClE,MAAM;EAErB,OAAO,EAAED,KAAK,GAAGC,MAAM,EAAE;IACvB8C,OAAO,CAAClC,IAAI,CAAC,GAAG,CAACkC,OAAO,CAAClC,IAAI,CAAC,IAAI,CAAC,IACjCsD,KAAK,CAACnE,KAAK,CAAC,CAACC,MAAM,GAAGmE,YAAY,CAACpE,KAAK,CAAC,CAACC,MAAM;IAClDY,IAAI,EAAE;EACR;EAEA,OAAOuD,YAAY,CAAC/B,IAAI,CAAC9D,SAAS,CAAC;EAEnC,SAASuF,QAAQ,CAACC,EAAE,EAAEO,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;IACpCR,MAAM,GAAGK,EAAE,GAAGC,EAAE,GAAGC,EAAE;IACrBN,IAAI,GAAGO,EAAE;;IAET;AACJ;AACA;IACI,IAAIC,MAAM,CAACH,EAAE,CAAC,GAAG,EAAE,IAAIN,MAAM,CAAChE,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MAC9CsE,EAAE,GAAGjG,OAAO,GAAGiG,EAAE;IACnB;IAEAP,GAAG,GAAGM,EAAE,GAAG7G,MAAM,CAACa,OAAO,EAAEiG,EAAE,CAACtE,MAAM,CAAC,GAAGuE,EAAE;IAE1C,OAAOR,GAAG,GAAGE,IAAI;EACnB;AACF"},"metadata":{},"sourceType":"script"}