{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldUseMatchForFulfill = exports.generateRandomSalt = exports.mapOrderAmountsFromUnitsToFill = exports.mapOrderAmountsFromFilledStatus = exports.totalItemsAmount = exports.areAllCurrenciesSame = exports.mapInputItemToOfferItem = exports.deductFees = exports.feeToConsiderationItem = void 0;\nvar ethers_1 = require(\"ethers\");\nvar constants_1 = require(\"../constants\");\nvar item_1 = require(\"./item\");\nvar merkletree_1 = require(\"./merkletree\");\nvar multiplyBasisPoints = function multiplyBasisPoints(amount, basisPoints) {\n  return ethers_1.BigNumber.from(amount).mul(ethers_1.BigNumber.from(basisPoints)).div(constants_1.ONE_HUNDRED_PERCENT_BP);\n};\nvar feeToConsiderationItem = function feeToConsiderationItem(_a) {\n  var fee = _a.fee,\n    token = _a.token,\n    baseAmount = _a.baseAmount,\n    _b = _a.baseEndAmount,\n    baseEndAmount = _b === void 0 ? baseAmount : _b;\n  return {\n    itemType: token === ethers_1.ethers.constants.AddressZero ? constants_1.ItemType.NATIVE : constants_1.ItemType.ERC20,\n    token: token,\n    identifierOrCriteria: \"0\",\n    startAmount: multiplyBasisPoints(baseAmount, fee.basisPoints).toString(),\n    endAmount: multiplyBasisPoints(baseEndAmount, fee.basisPoints).toString(),\n    recipient: fee.recipient\n  };\n};\nexports.feeToConsiderationItem = feeToConsiderationItem;\nvar deductFees = function deductFees(items, fees) {\n  if (!fees) {\n    return items;\n  }\n  var totalBasisPoints = fees.reduce(function (accBasisPoints, fee) {\n    return accBasisPoints + fee.basisPoints;\n  }, 0);\n  return items.map(function (item) {\n    return __assign(__assign({}, item), {\n      startAmount: (0, item_1.isCurrencyItem)(item) ? ethers_1.BigNumber.from(item.startAmount).sub(multiplyBasisPoints(item.startAmount, totalBasisPoints)).toString() : item.startAmount,\n      endAmount: (0, item_1.isCurrencyItem)(item) ? ethers_1.BigNumber.from(item.endAmount).sub(multiplyBasisPoints(item.endAmount, totalBasisPoints)).toString() : item.endAmount\n    });\n  });\n};\nexports.deductFees = deductFees;\nvar mapInputItemToOfferItem = function mapInputItemToOfferItem(item) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  // Item is an NFT\n  if (\"itemType\" in item) {\n    // Convert this to a criteria based item\n    if (\"identifiers\" in item) {\n      var tree = new merkletree_1.MerkleTree(item.identifiers);\n      return {\n        itemType: item.itemType === constants_1.ItemType.ERC721 ? constants_1.ItemType.ERC721_WITH_CRITERIA : constants_1.ItemType.ERC1155_WITH_CRITERIA,\n        token: item.token,\n        identifierOrCriteria: tree.getRoot(),\n        startAmount: (_a = item.amount) !== null && _a !== void 0 ? _a : \"1\",\n        endAmount: (_c = (_b = item.endAmount) !== null && _b !== void 0 ? _b : item.amount) !== null && _c !== void 0 ? _c : \"1\"\n      };\n    }\n    if (\"amount\" in item || \"endAmount\" in item) {\n      return {\n        itemType: item.itemType,\n        token: item.token,\n        identifierOrCriteria: item.identifier,\n        startAmount: item.amount,\n        endAmount: (_e = (_d = item.endAmount) !== null && _d !== void 0 ? _d : item.amount) !== null && _e !== void 0 ? _e : \"1\"\n      };\n    }\n    return {\n      itemType: item.itemType,\n      token: item.token,\n      identifierOrCriteria: item.identifier,\n      startAmount: \"1\",\n      endAmount: \"1\"\n    };\n  }\n  // Item is a currency\n  return {\n    itemType: item.token && item.token !== ethers_1.ethers.constants.AddressZero ? constants_1.ItemType.ERC20 : constants_1.ItemType.NATIVE,\n    token: (_f = item.token) !== null && _f !== void 0 ? _f : ethers_1.ethers.constants.AddressZero,\n    identifierOrCriteria: \"0\",\n    startAmount: item.amount,\n    endAmount: (_g = item.endAmount) !== null && _g !== void 0 ? _g : item.amount\n  };\n};\nexports.mapInputItemToOfferItem = mapInputItemToOfferItem;\nvar areAllCurrenciesSame = function areAllCurrenciesSame(_a) {\n  var offer = _a.offer,\n    consideration = _a.consideration;\n  var allItems = __spreadArray(__spreadArray([], __read(offer), false), __read(consideration), false);\n  var currencies = allItems.filter(item_1.isCurrencyItem);\n  return currencies.every(function (_a) {\n    var itemType = _a.itemType,\n      token = _a.token;\n    return itemType === currencies[0].itemType && token.toLowerCase() === currencies[0].token.toLowerCase();\n  });\n};\nexports.areAllCurrenciesSame = areAllCurrenciesSame;\nvar totalItemsAmount = function totalItemsAmount(items) {\n  var initialValues = {\n    startAmount: ethers_1.BigNumber.from(0),\n    endAmount: ethers_1.BigNumber.from(0)\n  };\n  return items.map(function (_a) {\n    var startAmount = _a.startAmount,\n      endAmount = _a.endAmount;\n    return {\n      startAmount: startAmount,\n      endAmount: endAmount\n    };\n  }).reduce(function (_a, _b) {\n    var totalStartAmount = _a.startAmount,\n      totalEndAmount = _a.endAmount;\n    var startAmount = _b.startAmount,\n      endAmount = _b.endAmount;\n    return {\n      startAmount: totalStartAmount.add(startAmount),\n      endAmount: totalEndAmount.add(endAmount)\n    };\n  }, {\n    startAmount: ethers_1.BigNumber.from(0),\n    endAmount: ethers_1.BigNumber.from(0)\n  });\n};\nexports.totalItemsAmount = totalItemsAmount;\n/**\n * Maps order offer and consideration item amounts based on the order's filled status\n * After applying the fraction, we can view this order as the \"canonical\" order for which we\n * check approvals and balances\n */\nvar mapOrderAmountsFromFilledStatus = function mapOrderAmountsFromFilledStatus(order, _a) {\n  var totalFilled = _a.totalFilled,\n    totalSize = _a.totalSize;\n  if (totalFilled.eq(0) || totalSize.eq(0)) {\n    return order;\n  }\n  // i.e if totalFilled is 3 and totalSize is 4, there are 1 / 4 order amounts left to fill.\n  var basisPoints = totalSize.sub(totalFilled).mul(constants_1.ONE_HUNDRED_PERCENT_BP).div(totalSize);\n  return {\n    parameters: __assign(__assign({}, order.parameters), {\n      offer: order.parameters.offer.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      }),\n      consideration: order.parameters.consideration.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      })\n    }),\n    signature: order.signature\n  };\n};\nexports.mapOrderAmountsFromFilledStatus = mapOrderAmountsFromFilledStatus;\n/**\n * Maps order offer and consideration item amounts based on the units needed to fulfill\n * After applying the fraction, we can view this order as the \"canonical\" order for which we\n * check approvals and balances\n * Returns the numerator and denominator as well, converting this to an AdvancedOrder\n */\nvar mapOrderAmountsFromUnitsToFill = function mapOrderAmountsFromUnitsToFill(order, _a) {\n  var unitsToFill = _a.unitsToFill,\n    totalFilled = _a.totalFilled,\n    totalSize = _a.totalSize;\n  var unitsToFillBn = ethers_1.BigNumber.from(unitsToFill);\n  if (unitsToFillBn.lte(0)) {\n    throw new Error(\"Units to fill must be greater than 1\");\n  }\n  var maxUnits = (0, item_1.getMaximumSizeForOrder)(order);\n  if (totalSize.eq(0)) {\n    totalSize = maxUnits;\n  }\n  // This is the percentage of the order that is left to be fulfilled, and therefore we can't fill more than that.\n  var remainingOrderPercentageToBeFilled = totalSize.sub(totalFilled).mul(constants_1.ONE_HUNDRED_PERCENT_BP).div(totalSize);\n  // i.e if totalSize is 8 and unitsToFill is 3, then we multiply every amount by 3 / 8\n  var unitsToFillBasisPoints = unitsToFillBn.mul(constants_1.ONE_HUNDRED_PERCENT_BP).div(maxUnits);\n  // We basically choose the lesser between the units requested to be filled and the actual remaining order amount left\n  // This is so that if a user tries to fulfill an order that is 1/2 filled, and supplies a fraction such as 3/4, the maximum\n  // amount to fulfill is 1/2 instead of 3/4\n  var basisPoints = remainingOrderPercentageToBeFilled.gt(unitsToFillBasisPoints) ? unitsToFillBasisPoints : remainingOrderPercentageToBeFilled;\n  return {\n    parameters: __assign(__assign({}, order.parameters), {\n      offer: order.parameters.offer.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      }),\n      consideration: order.parameters.consideration.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      })\n    }),\n    signature: order.signature\n  };\n};\nexports.mapOrderAmountsFromUnitsToFill = mapOrderAmountsFromUnitsToFill;\nvar generateRandomSalt = function generateRandomSalt() {\n  return \"0x\".concat(Buffer.from(ethers_1.ethers.utils.randomBytes(16)).toString(\"hex\"));\n};\nexports.generateRandomSalt = generateRandomSalt;\nvar shouldUseMatchForFulfill = function shouldUseMatchForFulfill() {\n  return true;\n};\nexports.shouldUseMatchForFulfill = shouldUseMatchForFulfill;","map":{"version":3,"sources":["../../src/utils/order.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseMatchForFulfill = exports.generateRandomSalt = exports.mapOrderAmountsFromUnitsToFill = exports.mapOrderAmountsFromFilledStatus = exports.totalItemsAmount = exports.areAllCurrenciesSame = exports.mapInputItemToOfferItem = exports.deductFees = exports.feeToConsiderationItem = void 0;\nvar ethers_1 = require(\"ethers\");\nvar constants_1 = require(\"../constants\");\nvar item_1 = require(\"./item\");\nvar merkletree_1 = require(\"./merkletree\");\nvar multiplyBasisPoints = function (amount, basisPoints) {\n    return ethers_1.BigNumber.from(amount)\n        .mul(ethers_1.BigNumber.from(basisPoints))\n        .div(constants_1.ONE_HUNDRED_PERCENT_BP);\n};\nvar feeToConsiderationItem = function (_a) {\n    var fee = _a.fee, token = _a.token, baseAmount = _a.baseAmount, _b = _a.baseEndAmount, baseEndAmount = _b === void 0 ? baseAmount : _b;\n    return {\n        itemType: token === ethers_1.ethers.constants.AddressZero ? constants_1.ItemType.NATIVE : constants_1.ItemType.ERC20,\n        token: token,\n        identifierOrCriteria: \"0\",\n        startAmount: multiplyBasisPoints(baseAmount, fee.basisPoints).toString(),\n        endAmount: multiplyBasisPoints(baseEndAmount, fee.basisPoints).toString(),\n        recipient: fee.recipient,\n    };\n};\nexports.feeToConsiderationItem = feeToConsiderationItem;\nvar deductFees = function (items, fees) {\n    if (!fees) {\n        return items;\n    }\n    var totalBasisPoints = fees.reduce(function (accBasisPoints, fee) { return accBasisPoints + fee.basisPoints; }, 0);\n    return items.map(function (item) { return (__assign(__assign({}, item), { startAmount: (0, item_1.isCurrencyItem)(item)\n            ? ethers_1.BigNumber.from(item.startAmount)\n                .sub(multiplyBasisPoints(item.startAmount, totalBasisPoints))\n                .toString()\n            : item.startAmount, endAmount: (0, item_1.isCurrencyItem)(item)\n            ? ethers_1.BigNumber.from(item.endAmount)\n                .sub(multiplyBasisPoints(item.endAmount, totalBasisPoints))\n                .toString()\n            : item.endAmount })); });\n};\nexports.deductFees = deductFees;\nvar mapInputItemToOfferItem = function (item) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    // Item is an NFT\n    if (\"itemType\" in item) {\n        // Convert this to a criteria based item\n        if (\"identifiers\" in item) {\n            var tree = new merkletree_1.MerkleTree(item.identifiers);\n            return {\n                itemType: item.itemType === constants_1.ItemType.ERC721\n                    ? constants_1.ItemType.ERC721_WITH_CRITERIA\n                    : constants_1.ItemType.ERC1155_WITH_CRITERIA,\n                token: item.token,\n                identifierOrCriteria: tree.getRoot(),\n                startAmount: (_a = item.amount) !== null && _a !== void 0 ? _a : \"1\",\n                endAmount: (_c = (_b = item.endAmount) !== null && _b !== void 0 ? _b : item.amount) !== null && _c !== void 0 ? _c : \"1\",\n            };\n        }\n        if (\"amount\" in item || \"endAmount\" in item) {\n            return {\n                itemType: item.itemType,\n                token: item.token,\n                identifierOrCriteria: item.identifier,\n                startAmount: item.amount,\n                endAmount: (_e = (_d = item.endAmount) !== null && _d !== void 0 ? _d : item.amount) !== null && _e !== void 0 ? _e : \"1\",\n            };\n        }\n        return {\n            itemType: item.itemType,\n            token: item.token,\n            identifierOrCriteria: item.identifier,\n            startAmount: \"1\",\n            endAmount: \"1\",\n        };\n    }\n    // Item is a currency\n    return {\n        itemType: item.token && item.token !== ethers_1.ethers.constants.AddressZero\n            ? constants_1.ItemType.ERC20\n            : constants_1.ItemType.NATIVE,\n        token: (_f = item.token) !== null && _f !== void 0 ? _f : ethers_1.ethers.constants.AddressZero,\n        identifierOrCriteria: \"0\",\n        startAmount: item.amount,\n        endAmount: (_g = item.endAmount) !== null && _g !== void 0 ? _g : item.amount,\n    };\n};\nexports.mapInputItemToOfferItem = mapInputItemToOfferItem;\nvar areAllCurrenciesSame = function (_a) {\n    var offer = _a.offer, consideration = _a.consideration;\n    var allItems = __spreadArray(__spreadArray([], __read(offer), false), __read(consideration), false);\n    var currencies = allItems.filter(item_1.isCurrencyItem);\n    return currencies.every(function (_a) {\n        var itemType = _a.itemType, token = _a.token;\n        return itemType === currencies[0].itemType &&\n            token.toLowerCase() === currencies[0].token.toLowerCase();\n    });\n};\nexports.areAllCurrenciesSame = areAllCurrenciesSame;\nvar totalItemsAmount = function (items) {\n    var initialValues = {\n        startAmount: ethers_1.BigNumber.from(0),\n        endAmount: ethers_1.BigNumber.from(0),\n    };\n    return items\n        .map(function (_a) {\n        var startAmount = _a.startAmount, endAmount = _a.endAmount;\n        return ({\n            startAmount: startAmount,\n            endAmount: endAmount,\n        });\n    })\n        .reduce(function (_a, _b) {\n        var totalStartAmount = _a.startAmount, totalEndAmount = _a.endAmount;\n        var startAmount = _b.startAmount, endAmount = _b.endAmount;\n        return ({\n            startAmount: totalStartAmount.add(startAmount),\n            endAmount: totalEndAmount.add(endAmount),\n        });\n    }, {\n        startAmount: ethers_1.BigNumber.from(0),\n        endAmount: ethers_1.BigNumber.from(0),\n    });\n};\nexports.totalItemsAmount = totalItemsAmount;\n/**\n * Maps order offer and consideration item amounts based on the order's filled status\n * After applying the fraction, we can view this order as the \"canonical\" order for which we\n * check approvals and balances\n */\nvar mapOrderAmountsFromFilledStatus = function (order, _a) {\n    var totalFilled = _a.totalFilled, totalSize = _a.totalSize;\n    if (totalFilled.eq(0) || totalSize.eq(0)) {\n        return order;\n    }\n    // i.e if totalFilled is 3 and totalSize is 4, there are 1 / 4 order amounts left to fill.\n    var basisPoints = totalSize\n        .sub(totalFilled)\n        .mul(constants_1.ONE_HUNDRED_PERCENT_BP)\n        .div(totalSize);\n    return {\n        parameters: __assign(__assign({}, order.parameters), { offer: order.parameters.offer.map(function (item) { return (__assign(__assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() })); }), consideration: order.parameters.consideration.map(function (item) { return (__assign(__assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() })); }) }),\n        signature: order.signature,\n    };\n};\nexports.mapOrderAmountsFromFilledStatus = mapOrderAmountsFromFilledStatus;\n/**\n * Maps order offer and consideration item amounts based on the units needed to fulfill\n * After applying the fraction, we can view this order as the \"canonical\" order for which we\n * check approvals and balances\n * Returns the numerator and denominator as well, converting this to an AdvancedOrder\n */\nvar mapOrderAmountsFromUnitsToFill = function (order, _a) {\n    var unitsToFill = _a.unitsToFill, totalFilled = _a.totalFilled, totalSize = _a.totalSize;\n    var unitsToFillBn = ethers_1.BigNumber.from(unitsToFill);\n    if (unitsToFillBn.lte(0)) {\n        throw new Error(\"Units to fill must be greater than 1\");\n    }\n    var maxUnits = (0, item_1.getMaximumSizeForOrder)(order);\n    if (totalSize.eq(0)) {\n        totalSize = maxUnits;\n    }\n    // This is the percentage of the order that is left to be fulfilled, and therefore we can't fill more than that.\n    var remainingOrderPercentageToBeFilled = totalSize\n        .sub(totalFilled)\n        .mul(constants_1.ONE_HUNDRED_PERCENT_BP)\n        .div(totalSize);\n    // i.e if totalSize is 8 and unitsToFill is 3, then we multiply every amount by 3 / 8\n    var unitsToFillBasisPoints = unitsToFillBn\n        .mul(constants_1.ONE_HUNDRED_PERCENT_BP)\n        .div(maxUnits);\n    // We basically choose the lesser between the units requested to be filled and the actual remaining order amount left\n    // This is so that if a user tries to fulfill an order that is 1/2 filled, and supplies a fraction such as 3/4, the maximum\n    // amount to fulfill is 1/2 instead of 3/4\n    var basisPoints = remainingOrderPercentageToBeFilled.gt(unitsToFillBasisPoints)\n        ? unitsToFillBasisPoints\n        : remainingOrderPercentageToBeFilled;\n    return {\n        parameters: __assign(__assign({}, order.parameters), { offer: order.parameters.offer.map(function (item) { return (__assign(__assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() })); }), consideration: order.parameters.consideration.map(function (item) { return (__assign(__assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() })); }) }),\n        signature: order.signature,\n    };\n};\nexports.mapOrderAmountsFromUnitsToFill = mapOrderAmountsFromUnitsToFill;\nvar generateRandomSalt = function () {\n    return \"0x\".concat(Buffer.from(ethers_1.ethers.utils.randomBytes(16)).toString(\"hex\"));\n};\nexports.generateRandomSalt = generateRandomSalt;\nvar shouldUseMatchForFulfill = function () { return true; };\nexports.shouldUseMatchForFulfill = shouldUseMatchForFulfill;\n//# sourceMappingURL=order.js.map"]},"metadata":{},"sourceType":"script"}