{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _ from 'lodash';\nimport { log } from '../../util/log';\n/**\n * Provider for getting V3 pools, with functionality for caching the results.\n * Does not cache by block because we compute quotes using the on-chain quoter\n * so do not mind if the liquidity values are out of date.\n *\n * @export\n * @class CachingV3PoolProvider\n */\nexport var CachingV3PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of CachingV3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param poolProvider The provider to use to get the pools when not in the cache.\n   * @param cache Cache instance to hold cached pools.\n   */\n  function CachingV3PoolProvider(chainId, poolProvider, cache) {\n    _classCallCheck(this, CachingV3PoolProvider);\n    this.chainId = chainId;\n    this.poolProvider = poolProvider;\n    this.cache = cache;\n    this.POOL_KEY = function (chainId, address) {\n      return \"pool-\".concat(chainId, \"-\").concat(address);\n    };\n  }\n  _createClass(CachingV3PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n        var poolAddressSet, poolsToGetTokenPairs, poolsToGetAddresses, poolAddressToPool, _iterator, _step, _step$value, tokenA, tokenB, feeAmount, _this$getPoolAddress2, poolAddress, token0, token1, cachedPool, poolAccessor, _iterator2, _step2, address, pool;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                poolsToGetTokenPairs = [];\n                poolsToGetAddresses = [];\n                poolAddressToPool = {};\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 5;\n                _iterator.s();\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 23;\n                  break;\n                }\n                _step$value = _slicedToArray(_step.value, 3), tokenA = _step$value[0], tokenB = _step$value[1], feeAmount = _step$value[2];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB, feeAmount), poolAddress = _this$getPoolAddress2.poolAddress, token0 = _this$getPoolAddress2.token0, token1 = _this$getPoolAddress2.token1;\n                if (!poolAddressSet.has(poolAddress)) {\n                  _context.next = 12;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 21);\n              case 12:\n                poolAddressSet.add(poolAddress);\n                _context.next = 15;\n                return this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n              case 15:\n                cachedPool = _context.sent;\n                if (!cachedPool) {\n                  _context.next = 19;\n                  break;\n                }\n                poolAddressToPool[poolAddress] = cachedPool;\n                return _context.abrupt(\"continue\", 21);\n              case 19:\n                poolsToGetTokenPairs.push([token0, token1, feeAmount]);\n                poolsToGetAddresses.push(poolAddress);\n              case 21:\n                _context.next = 7;\n                break;\n              case 23:\n                _context.next = 28;\n                break;\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](5);\n                _iterator.e(_context.t0);\n              case 28:\n                _context.prev = 28;\n                _iterator.f();\n                return _context.finish(28);\n              case 31:\n                log.info({\n                  poolsFound: _.map(Object.values(poolAddressToPool), function (p) {\n                    return \"\".concat(p.token0.symbol, \" \").concat(p.token1.symbol, \" \").concat(p.fee);\n                  }),\n                  poolsToGetTokenPairs: _.map(poolsToGetTokenPairs, function (t) {\n                    return \"\".concat(t[0].symbol, \" \").concat(t[1].symbol, \" \").concat(t[2]);\n                  })\n                }, \"Found \".concat(Object.keys(poolAddressToPool).length, \" V3 pools already in local cache. About to get liquidity and slot0s for \").concat(poolsToGetTokenPairs.length, \" pools.\"));\n                if (!(poolsToGetAddresses.length > 0)) {\n                  _context.next = 56;\n                  break;\n                }\n                _context.next = 35;\n                return this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n              case 35:\n                poolAccessor = _context.sent;\n                _iterator2 = _createForOfIteratorHelper(poolsToGetAddresses);\n                _context.prev = 37;\n                _iterator2.s();\n              case 39:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 48;\n                  break;\n                }\n                address = _step2.value;\n                pool = poolAccessor.getPoolByAddress(address);\n                if (!pool) {\n                  _context.next = 46;\n                  break;\n                }\n                poolAddressToPool[address] = pool;\n                _context.next = 46;\n                return this.cache.set(this.POOL_KEY(this.chainId, address), pool);\n              case 46:\n                _context.next = 39;\n                break;\n              case 48:\n                _context.next = 53;\n                break;\n              case 50:\n                _context.prev = 50;\n                _context.t1 = _context[\"catch\"](37);\n                _iterator2.e(_context.t1);\n              case 53:\n                _context.prev = 53;\n                _iterator2.f();\n                return _context.finish(53);\n              case 56:\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB, feeAmount) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB, feeAmount),\n                      poolAddress = _this$getPoolAddress.poolAddress;\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n              case 57:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 25, 28, 31], [37, 50, 53, 56]]);\n      }));\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB, feeAmount) {\n      return this.poolProvider.getPoolAddress(tokenA, tokenB, feeAmount);\n    }\n  }]);\n  return CachingV3PoolProvider;\n}();","map":{"version":3,"sources":["../../../../src/providers/v3/caching-pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from 'lodash';\nimport { log } from '../../util/log';\n/**\n * Provider for getting V3 pools, with functionality for caching the results.\n * Does not cache by block because we compute quotes using the on-chain quoter\n * so do not mind if the liquidity values are out of date.\n *\n * @export\n * @class CachingV3PoolProvider\n */\nexport class CachingV3PoolProvider {\n    /**\n     * Creates an instance of CachingV3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param poolProvider The provider to use to get the pools when not in the cache.\n     * @param cache Cache instance to hold cached pools.\n     */\n    constructor(chainId, poolProvider, cache) {\n        this.chainId = chainId;\n        this.poolProvider = poolProvider;\n        this.cache = cache;\n        this.POOL_KEY = (chainId, address) => `pool-${chainId}-${address}`;\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const poolsToGetTokenPairs = [];\n        const poolsToGetAddresses = [];\n        const poolAddressToPool = {};\n        for (const [tokenA, tokenB, feeAmount] of tokenPairs) {\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n            if (cachedPool) {\n                poolAddressToPool[poolAddress] = cachedPool;\n                continue;\n            }\n            poolsToGetTokenPairs.push([token0, token1, feeAmount]);\n            poolsToGetAddresses.push(poolAddress);\n        }\n        log.info({\n            poolsFound: _.map(Object.values(poolAddressToPool), (p) => `${p.token0.symbol} ${p.token1.symbol} ${p.fee}`),\n            poolsToGetTokenPairs: _.map(poolsToGetTokenPairs, (t) => `${t[0].symbol} ${t[1].symbol} ${t[2]}`),\n        }, `Found ${Object.keys(poolAddressToPool).length} V3 pools already in local cache. About to get liquidity and slot0s for ${poolsToGetTokenPairs.length} pools.`);\n        if (poolsToGetAddresses.length > 0) {\n            const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n            for (const address of poolsToGetAddresses) {\n                const pool = poolAccessor.getPoolByAddress(address);\n                if (pool) {\n                    poolAddressToPool[address] = pool;\n                    await this.cache.set(this.POOL_KEY(this.chainId, address), pool);\n                }\n            }\n        }\n        return {\n            getPool: (tokenA, tokenB, feeAmount) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB, feeAmount) {\n        return this.poolProvider.getPoolAddress(tokenA, tokenB, feeAmount);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGluZy1wb29sLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy92My9jYWNoaW5nLXBvb2wtcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU1yQzs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxPQUFPLHFCQUFxQjtJQUloQzs7Ozs7T0FLRztJQUNILFlBQ1ksT0FBZ0IsRUFDaEIsWUFBNkIsRUFDL0IsS0FBbUI7UUFGakIsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQUNoQixpQkFBWSxHQUFaLFlBQVksQ0FBaUI7UUFDL0IsVUFBSyxHQUFMLEtBQUssQ0FBYztRQVpyQixhQUFRLEdBQUcsQ0FBQyxPQUFnQixFQUFFLE9BQWUsRUFBRSxFQUFFLENBQ3ZELFFBQVEsT0FBTyxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBWTVCLENBQUM7SUFFRyxLQUFLLENBQUMsUUFBUSxDQUNuQixVQUF1QyxFQUN2QyxjQUErQjtRQUUvQixNQUFNLGNBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUN0RCxNQUFNLG9CQUFvQixHQUFxQyxFQUFFLENBQUM7UUFDbEUsTUFBTSxtQkFBbUIsR0FBYSxFQUFFLENBQUM7UUFDekMsTUFBTSxpQkFBaUIsR0FBb0MsRUFBRSxDQUFDO1FBRTlELEtBQUssTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLElBQUksVUFBVSxFQUFFO1lBQ3BELE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQ3pELE1BQU0sRUFDTixNQUFNLEVBQ04sU0FBUyxDQUNWLENBQUM7WUFFRixJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7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"]},"metadata":{},"sourceType":"module"}