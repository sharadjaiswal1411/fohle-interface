{"ast":null,"code":"/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = require('obliterator/foreach'),\n  comparators = require('./utils/comparators.js'),\n  iterables = require('./utils/iterables.js');\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n  reverseComparator = comparators.reverseComparator;\n\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n    parentIndex,\n    parent;\n  while (i > startIndex) {\n    parentIndex = i - 1 >> 1;\n    parent = heap[parentIndex];\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n    break;\n  }\n  heap[i] = item;\n}\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n    startIndex = i,\n    item = heap[i],\n    childIndex = 2 * i + 1,\n    rightIndex;\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n    if (rightIndex < endIndex && compare(heap[childIndex], heap[rightIndex]) >= 0) {\n      childIndex = rightIndex;\n    }\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n    return item;\n  }\n  return lastItem;\n}\n\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction replace(compare, heap, item) {\n  if (heap.length === 0) throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n  return popped;\n}\n\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction pushpop(compare, heap, item) {\n  var tmp;\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n  return item;\n}\n\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\nfunction heapify(compare, array) {\n  var n = array.length,\n    l = n >> 1,\n    i = l;\n  while (--i >= 0) siftUp(compare, array, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\nfunction consume(compare, heap) {\n  var l = heap.length,\n    i = 0;\n  var array = new Array(l);\n  while (i < l) array[i++] = pop(compare, heap);\n  return array;\n}\n\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n  var reverseCompare = reverseComparator(compare);\n  var i, l, v;\n  var min = Infinity;\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the minimum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n        if (min === Infinity || compare(v, min) < 0) min = v;\n      }\n      result = new iterable.constructor(1);\n      result[0] = min;\n      return result;\n    }\n    forEach(iterable, function (value) {\n      if (min === Infinity || compare(value, min) < 0) min = value;\n    });\n    return [min];\n  }\n  if (iterables.isArrayLike(iterable)) {\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length) return iterable.slice().sort(compare);\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n    for (i = n, l = iterable.length; i < l; i++) if (reverseCompare(iterable[i], result[0]) > 0) replace(reverseCompare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(compare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n  if (size !== null && size < n) n = size;\n  result = new Array(n);\n  i = 0;\n  forEach(iterable, function (value) {\n    if (i < n) {\n      result[i] = value;\n    } else {\n      if (i === n) heapify(reverseCompare, result);\n      if (reverseCompare(value, result[0]) > 0) replace(reverseCompare, result, value);\n    }\n    i++;\n  });\n  if (result.length > i) result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(compare);\n}\n\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n  var reverseCompare = reverseComparator(compare);\n  var i, l, v;\n  var max = -Infinity;\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the maximum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n        if (max === -Infinity || compare(v, max) > 0) max = v;\n      }\n      result = new iterable.constructor(1);\n      result[0] = max;\n      return result;\n    }\n    forEach(iterable, function (value) {\n      if (max === -Infinity || compare(value, max) > 0) max = value;\n    });\n    return [max];\n  }\n  if (iterables.isArrayLike(iterable)) {\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length) return iterable.slice().sort(reverseCompare);\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n    for (i = n, l = iterable.length; i < l; i++) if (compare(iterable[i], result[0]) > 0) replace(compare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(reverseCompare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n  if (size !== null && size < n) n = size;\n  result = new Array(n);\n  i = 0;\n  forEach(iterable, function (value) {\n    if (i < n) {\n      result[i] = value;\n    } else {\n      if (i === n) heapify(compare, result);\n      if (compare(value, result[0]) > 0) replace(compare, result, value);\n    }\n    i++;\n  });\n  if (result.length > i) result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(reverseCompare);\n}\n\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nHeap.prototype.clear = function () {\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nHeap.prototype.push = function (item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.peek = function () {\n  return this.items[0];\n};\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.pop = function () {\n  if (this.size !== 0) this.size--;\n  return pop(this.comparator, this.items);\n};\n\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.replace = function (item) {\n  return replace(this.comparator, this.items, item);\n};\n\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.pushpop = function (item) {\n  return pushpop(this.comparator, this.items, item);\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nHeap.prototype.consume = function () {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nHeap.prototype.toArray = function () {\n  return consume(this.comparator, this.items.slice());\n};\n\n/**\n * Convenience known methods.\n */\nHeap.prototype.inspect = function () {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n  return proxy;\n};\nif (typeof Symbol !== 'undefined') Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n  this.comparator = reverseComparator(this.comparator);\n}\nMaxHeap.prototype = Heap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\nHeap.from = function (iterable, comparator) {\n  var heap = new Heap(comparator);\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable)) items = iterable.slice();else items = iterables.toArray(iterable);\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n  return heap;\n};\nMaxHeap.from = function (iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable)) items = iterable.slice();else items = iterables.toArray(iterable);\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n  return heap;\n};\n\n/**\n * Exporting.\n */\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\nmodule.exports = Heap;","map":{"version":3,"names":["forEach","require","comparators","iterables","DEFAULT_COMPARATOR","reverseComparator","siftDown","compare","heap","startIndex","i","item","parentIndex","parent","siftUp","endIndex","length","childIndex","rightIndex","push","pop","lastItem","replace","Error","popped","pushpop","tmp","heapify","array","n","l","consume","Array","nsmallest","iterable","arguments","reverseCompare","v","min","Infinity","result","isArrayLike","constructor","value","slice","sort","size","guessLength","nlargest","max","Heap","comparator","clear","prototype","items","peek","toArray","inspect","proxy","Object","defineProperty","enumerable","Symbol","for","MaxHeap","from","MinHeap","module","exports"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/mnemonist/heap.js"],"sourcesContent":["/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = require('obliterator/foreach'),\n    comparators = require('./utils/comparators.js'),\n    iterables = require('./utils/iterables.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n      parentIndex,\n      parent;\n\n  while (i > startIndex) {\n    parentIndex = (i - 1) >> 1;\n    parent = heap[parentIndex];\n\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n\n    break;\n  }\n\n  heap[i] = item;\n}\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (\n      rightIndex < endIndex &&\n      compare(heap[childIndex], heap[rightIndex]) >= 0\n    ) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n\n    return item;\n  }\n\n  return lastItem;\n}\n\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction replace(compare, heap, item) {\n  if (heap.length === 0)\n    throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n\n  return popped;\n}\n\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction pushpop(compare, heap, item) {\n  var tmp;\n\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n\n  return item;\n}\n\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\nfunction heapify(compare, array) {\n  var n = array.length,\n      l = n >> 1,\n      i = l;\n\n  while (--i >= 0)\n    siftUp(compare, array, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\nfunction consume(compare, heap) {\n  var l = heap.length,\n      i = 0;\n\n  var array = new Array(l);\n\n  while (i < l)\n    array[i++] = pop(compare, heap);\n\n  return array;\n}\n\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var min = Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the minimum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (min === Infinity || compare(v, min) < 0)\n          min = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = min;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (min === Infinity || compare(value, min) < 0)\n        min = value;\n    });\n\n    return [min];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(compare);\n\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (reverseCompare(iterable[i], result[0]) > 0)\n        replace(reverseCompare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(compare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(reverseCompare, result);\n\n      if (reverseCompare(value, result[0]) > 0)\n        replace(reverseCompare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(compare);\n}\n\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var max = -Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the maximum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (max === -Infinity || compare(v, max) > 0)\n          max = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = max;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (max === -Infinity || compare(value, max) > 0)\n        max = value;\n    });\n\n    return [max];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(reverseCompare);\n\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (compare(iterable[i], result[0]) > 0)\n        replace(compare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(reverseCompare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(compare, result);\n\n      if (compare(value, result[0]) > 0)\n        replace(compare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(reverseCompare);\n}\n\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nHeap.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nHeap.prototype.push = function(item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.peek = function() {\n  return this.items[0];\n};\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.pop = function() {\n  if (this.size !== 0)\n    this.size--;\n\n  return pop(this.comparator, this.items);\n};\n\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.replace = function(item) {\n  return replace(this.comparator, this.items, item);\n};\n\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.pushpop = function(item) {\n  return pushpop(this.comparator, this.items, item);\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nHeap.prototype.consume = function() {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nHeap.prototype.toArray = function() {\n  return consume(this.comparator, this.items.slice());\n};\n\n/**\n * Convenience known methods.\n */\nHeap.prototype.inspect = function() {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxHeap.prototype = Heap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\nHeap.from = function(iterable, comparator) {\n  var heap = new Heap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\nMaxHeap.from = function(iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\n/**\n * Exporting.\n */\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\n\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\n\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\n\nmodule.exports = Heap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}