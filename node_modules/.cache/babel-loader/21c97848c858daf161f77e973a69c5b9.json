{"ast":null,"code":"import { BigNumber } from '@ethersproject/bignumber';\nimport { Contract } from '@ethersproject/contracts';\nimport { parseEther } from '@ethersproject/units';\nimport { addressesByNetwork, signMakerOrder, SupportedChainId } from '@looksrare/sdk';\nimport { Seaport } from '@opensea/seaport-js';\nimport { ItemType } from '@opensea/seaport-js/lib/constants';\nimport { OPENSEA_DEFAULT_CROSS_CHAIN_CONDUIT_KEY, OPENSEA_DEFAULT_ZONE, OPENSEA_KEY_TO_CONDUIT } from 'nft/queries/openSea';\nimport ERC721 from '../../abis/erc721.json';\nimport { createLooksRareOrder, getOrderId, LOOKSRARE_MARKETPLACE_CONTRACT, newX2Y2Order, PostOpenSeaSellOrder } from '../queries';\nimport { INVERSE_BASIS_POINTS, OPENSEA_DEFAULT_FEE, OPENSEA_FEE_ADDRESS } from '../queries/openSea';\nimport { ListingStatus } from '../types';\nimport { createSellOrder, encodeOrder, signOrderData } from './x2y2';\nexport const LOOKS_RARE_CREATOR_BASIS_POINTS = 50;\nexport const ListingMarkets = [{\n  name: 'X2Y2',\n  fee: 0.5,\n  icon: '/nft/svgs/marketplaces/x2y2.svg'\n}, {\n  name: 'LooksRare',\n  fee: 1.5,\n  icon: '/nft/svgs/marketplaces/looksrare.svg'\n}, {\n  name: 'OpenSea',\n  fee: 2.5,\n  icon: '/nft/svgs/marketplaces/opensea.svg'\n}];\nconst createConsiderationItem = (basisPoints, recipient) => {\n  return {\n    amount: basisPoints,\n    recipient\n  };\n};\nconst getConsiderationItems = (asset, price, signerAddress) => {\n  var _asset$basisPoints, _asset$asset_contract, _asset$asset_contract2;\n  const openSeaBasisPoints = OPENSEA_DEFAULT_FEE * INVERSE_BASIS_POINTS;\n  const creatorFeeBasisPoints = (_asset$basisPoints = asset === null || asset === void 0 ? void 0 : asset.basisPoints) !== null && _asset$basisPoints !== void 0 ? _asset$basisPoints : 0;\n  const sellerBasisPoints = INVERSE_BASIS_POINTS - openSeaBasisPoints - creatorFeeBasisPoints;\n  const openseaFee = price.mul(BigNumber.from(openSeaBasisPoints)).div(BigNumber.from(INVERSE_BASIS_POINTS)).toString();\n  const creatorFee = price.mul(BigNumber.from(creatorFeeBasisPoints)).div(BigNumber.from(INVERSE_BASIS_POINTS)).toString();\n  const sellerFee = price.mul(BigNumber.from(sellerBasisPoints)).div(BigNumber.from(INVERSE_BASIS_POINTS)).toString();\n  return {\n    sellerFee: createConsiderationItem(sellerFee, signerAddress),\n    openseaFee: createConsiderationItem(openseaFee, OPENSEA_FEE_ADDRESS),\n    creatorFee: creatorFeeBasisPoints > 0 ? createConsiderationItem(creatorFee, (_asset$asset_contract = asset === null || asset === void 0 ? void 0 : (_asset$asset_contract2 = asset.asset_contract) === null || _asset$asset_contract2 === void 0 ? void 0 : _asset$asset_contract2.payout_address) !== null && _asset$asset_contract !== void 0 ? _asset$asset_contract : '') : undefined\n  };\n};\nexport async function approveCollection(operator, collectionAddress, signer, setStatus) {\n  // This will work for both 721s & 1155s because they both have the\n  // setApprovalForAll() method\n  const ERC721Contract = new Contract(collectionAddress, ERC721, signer);\n  const signerAddress = await signer.getAddress();\n  setStatus(ListingStatus.PENDING);\n  try {\n    const approved = await ERC721Contract.isApprovedForAll(signerAddress, operator);\n    if (approved) {\n      setStatus(ListingStatus.APPROVED);\n      return;\n    }\n    setStatus(ListingStatus.SIGNING);\n    const approvalTransaction = await ERC721Contract.setApprovalForAll(operator, true);\n    setStatus(ListingStatus.PENDING);\n    const tx = await approvalTransaction.wait();\n    tx.status === 1 ? setStatus(ListingStatus.APPROVED) : setStatus(ListingStatus.FAILED);\n  } catch (error) {\n    if (error.code === 4001) setStatus(ListingStatus.REJECTED);else setStatus(ListingStatus.FAILED);\n  }\n}\nexport async function signListing(marketplace, asset, signer, provider) {\n  var _asset$newListings, _asset$newListings$fi;\n  let looksRareNonce = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let setStatus = arguments.length > 5 ? arguments[5] : undefined;\n  const seaport = new Seaport(provider, {\n    conduitKeyToConduit: OPENSEA_KEY_TO_CONDUIT,\n    overrides: {\n      defaultConduitKey: OPENSEA_DEFAULT_CROSS_CHAIN_CONDUIT_KEY\n    }\n  });\n  const signerAddress = await signer.getAddress();\n  const listingPrice = (_asset$newListings = asset.newListings) === null || _asset$newListings === void 0 ? void 0 : (_asset$newListings$fi = _asset$newListings.find(listing => listing.marketplace.name === marketplace.name)) === null || _asset$newListings$fi === void 0 ? void 0 : _asset$newListings$fi.price;\n  if (!listingPrice || !asset.expirationTime || !asset.asset_contract.address || !asset.tokenId) return false;\n  switch (marketplace.name) {\n    case 'OpenSea':\n      try {\n        const listingInWei = parseEther(`${listingPrice}`);\n        const {\n          sellerFee,\n          openseaFee,\n          creatorFee\n        } = getConsiderationItems(asset, listingInWei, signerAddress);\n        const considerationItems = [sellerFee, openseaFee, creatorFee].filter(item => item !== undefined);\n        const {\n          executeAllActions\n        } = await seaport.createOrder({\n          offer: [{\n            itemType: ItemType.ERC721,\n            token: asset.asset_contract.address,\n            identifier: asset.tokenId,\n            amount: '1'\n          }],\n          consideration: considerationItems,\n          endTime: asset.expirationTime.toString(),\n          zone: OPENSEA_DEFAULT_ZONE,\n          restrictedByZone: true,\n          allowPartialFills: true\n        }, signerAddress);\n        const order = await executeAllActions();\n        const res = await PostOpenSeaSellOrder(order);\n        if (res) setStatus(ListingStatus.APPROVED);\n        return res;\n      } catch (error) {\n        if (error.code === 4001) setStatus(ListingStatus.REJECTED);else setStatus(ListingStatus.FAILED);\n        return false;\n      }\n    case 'LooksRare':\n      {\n        const addresses = addressesByNetwork[SupportedChainId.MAINNET];\n        const currentTime = Math.round(Date.now() / 1000);\n        const makerOrder = {\n          // true --> ask / false --> bid\n          isOrderAsk: true,\n          // signer address of the maker order\n          signer: signerAddress,\n          // collection address\n          collection: asset.asset_contract.address,\n          // Price in WEI\n          price: parseEther(listingPrice.toString()),\n          // Token ID\n          tokenId: BigNumber.from(asset.tokenId),\n          // amount of tokens to sell/purchase (must be 1 for ERC721, 1+ for ERC1155)\n          amount: BigNumber.from(1),\n          // strategy for trade execution (e.g., DutchAuction, StandardSaleForFixedPrice), see addresses in the SDK\n          strategy: addresses.STRATEGY_STANDARD_SALE,\n          // currency address\n          currency: addresses.WETH,\n          // order nonce (must be unique unless new maker order is meant to override existing one e.g., lower ask price)\n          nonce: BigNumber.from(looksRareNonce),\n          // startTime timestamp in seconds\n          startTime: BigNumber.from(currentTime),\n          // endTime timestamp in seconds\n          endTime: BigNumber.from(asset.expirationTime),\n          // minimum ratio to be received by the user (per 10000)\n          // As of 11.10.22 LooksRare charges 1.5% + 0.5% if there's creator royalties set https://docs.looksrare.org/blog/looksrare-offers-zero-royalty-trading-shares-protocol-fees-with-creators-instead\n          minPercentageToAsk: BigNumber.from(10000).sub(BigNumber.from(150 + (asset.basisPoints ? 50 : 0))).toNumber(),\n          // params (e.g., price, target account for private sale)\n          params: []\n        };\n        try {\n          const signatureHash = await signMakerOrder(signer, SupportedChainId.MAINNET, makerOrder, LOOKSRARE_MARKETPLACE_CONTRACT);\n          setStatus(ListingStatus.PENDING);\n          const payload = {\n            signature: signatureHash,\n            tokenId: asset.tokenId,\n            collection: asset.asset_contract.address,\n            strategy: addresses.STRATEGY_STANDARD_SALE,\n            currency: addresses.WETH,\n            signer: signerAddress,\n            isOrderAsk: true,\n            nonce: looksRareNonce,\n            amount: 1,\n            price: parseEther(listingPrice.toString()).toString(),\n            startTime: currentTime,\n            endTime: asset.expirationTime,\n            minPercentageToAsk: 10000 - (150 + (asset.basisPoints ? 50 : 0)),\n            params: []\n          };\n          const res = await createLooksRareOrder(payload);\n          if (res) setStatus(ListingStatus.APPROVED);\n          return res;\n        } catch (error) {\n          if (error.code === 4001) setStatus(ListingStatus.REJECTED);else setStatus(ListingStatus.FAILED);\n          return false;\n        }\n      }\n    case 'X2Y2':\n      {\n        const orderItem = {\n          price: parseEther(listingPrice.toString()),\n          tokens: [{\n            token: asset.asset_contract.address,\n            tokenId: BigNumber.from(asset.tokenId)\n          }]\n        };\n        const order = createSellOrder(signerAddress, asset.expirationTime, [orderItem]);\n        try {\n          const prevOrderId = await getOrderId(asset.asset_contract.address, asset.tokenId);\n          await signOrderData(provider, order);\n          const payload = {\n            order: encodeOrder(order),\n            isBundle: false,\n            bundleName: '',\n            bundleDesc: '',\n            orderIds: prevOrderId ? [prevOrderId] : [],\n            changePrice: Boolean(prevOrderId),\n            isCollection: false\n          };\n          setStatus(ListingStatus.PENDING);\n          // call server api\n          const resp = await newX2Y2Order(payload);\n          if (resp) setStatus(ListingStatus.APPROVED);\n          return resp;\n        } catch (error) {\n          if (error.code === 4001) setStatus(ListingStatus.REJECTED);else setStatus(ListingStatus.FAILED);\n          return false;\n        }\n      }\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["BigNumber","Contract","parseEther","addressesByNetwork","signMakerOrder","SupportedChainId","Seaport","ItemType","OPENSEA_DEFAULT_CROSS_CHAIN_CONDUIT_KEY","OPENSEA_DEFAULT_ZONE","OPENSEA_KEY_TO_CONDUIT","ERC721","createLooksRareOrder","getOrderId","LOOKSRARE_MARKETPLACE_CONTRACT","newX2Y2Order","PostOpenSeaSellOrder","INVERSE_BASIS_POINTS","OPENSEA_DEFAULT_FEE","OPENSEA_FEE_ADDRESS","ListingStatus","createSellOrder","encodeOrder","signOrderData","LOOKS_RARE_CREATOR_BASIS_POINTS","ListingMarkets","name","fee","icon","createConsiderationItem","basisPoints","recipient","amount","getConsiderationItems","asset","price","signerAddress","openSeaBasisPoints","creatorFeeBasisPoints","sellerBasisPoints","openseaFee","mul","from","div","toString","creatorFee","sellerFee","asset_contract","payout_address","undefined","approveCollection","operator","collectionAddress","signer","setStatus","ERC721Contract","getAddress","PENDING","approved","isApprovedForAll","APPROVED","SIGNING","approvalTransaction","setApprovalForAll","tx","wait","status","FAILED","error","code","REJECTED","signListing","marketplace","provider","looksRareNonce","seaport","conduitKeyToConduit","overrides","defaultConduitKey","listingPrice","newListings","find","listing","expirationTime","address","tokenId","listingInWei","considerationItems","filter","item","executeAllActions","createOrder","offer","itemType","token","identifier","consideration","endTime","zone","restrictedByZone","allowPartialFills","order","res","addresses","MAINNET","currentTime","Math","round","Date","now","makerOrder","isOrderAsk","collection","strategy","STRATEGY_STANDARD_SALE","currency","WETH","nonce","startTime","minPercentageToAsk","sub","toNumber","params","signatureHash","payload","signature","orderItem","tokens","prevOrderId","isBundle","bundleName","bundleDesc","orderIds","changePrice","Boolean","isCollection","resp"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/nft/utils/listNfts.ts"],"sourcesContent":["import { Signer } from '@ethersproject/abstract-signer'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport type { JsonRpcSigner, Web3Provider } from '@ethersproject/providers'\nimport { parseEther } from '@ethersproject/units'\nimport { addressesByNetwork, MakerOrder, signMakerOrder, SupportedChainId } from '@looksrare/sdk'\nimport { Seaport } from '@opensea/seaport-js'\nimport { ItemType } from '@opensea/seaport-js/lib/constants'\nimport { ConsiderationInputItem } from '@opensea/seaport-js/lib/types'\nimport {\n  OPENSEA_DEFAULT_CROSS_CHAIN_CONDUIT_KEY,\n  OPENSEA_DEFAULT_ZONE,\n  OPENSEA_KEY_TO_CONDUIT,\n} from 'nft/queries/openSea'\n\nimport ERC721 from '../../abis/erc721.json'\nimport {\n  createLooksRareOrder,\n  getOrderId,\n  LOOKSRARE_MARKETPLACE_CONTRACT,\n  newX2Y2Order,\n  PostOpenSeaSellOrder,\n} from '../queries'\nimport { INVERSE_BASIS_POINTS, OPENSEA_DEFAULT_FEE, OPENSEA_FEE_ADDRESS } from '../queries/openSea'\nimport { ListingMarket, ListingStatus, WalletAsset } from '../types'\nimport { createSellOrder, encodeOrder, OfferItem, OrderPayload, signOrderData } from './x2y2'\n\nexport const LOOKS_RARE_CREATOR_BASIS_POINTS = 50\n\nexport const ListingMarkets: ListingMarket[] = [\n  {\n    name: 'X2Y2',\n    fee: 0.5,\n    icon: '/nft/svgs/marketplaces/x2y2.svg',\n  },\n  {\n    name: 'LooksRare',\n    fee: 1.5,\n    icon: '/nft/svgs/marketplaces/looksrare.svg',\n  },\n  {\n    name: 'OpenSea',\n    fee: 2.5,\n    icon: '/nft/svgs/marketplaces/opensea.svg',\n  },\n]\n\nconst createConsiderationItem = (basisPoints: string, recipient: string): ConsiderationInputItem => {\n  return {\n    amount: basisPoints,\n    recipient,\n  }\n}\n\nconst getConsiderationItems = (\n  asset: WalletAsset,\n  price: BigNumber,\n  signerAddress: string\n): {\n  sellerFee: ConsiderationInputItem\n  openseaFee: ConsiderationInputItem\n  creatorFee?: ConsiderationInputItem\n} => {\n  const openSeaBasisPoints = OPENSEA_DEFAULT_FEE * INVERSE_BASIS_POINTS\n  const creatorFeeBasisPoints = asset?.basisPoints ?? 0\n  const sellerBasisPoints = INVERSE_BASIS_POINTS - openSeaBasisPoints - creatorFeeBasisPoints\n\n  const openseaFee = price.mul(BigNumber.from(openSeaBasisPoints)).div(BigNumber.from(INVERSE_BASIS_POINTS)).toString()\n  const creatorFee = price\n    .mul(BigNumber.from(creatorFeeBasisPoints))\n    .div(BigNumber.from(INVERSE_BASIS_POINTS))\n    .toString()\n  const sellerFee = price.mul(BigNumber.from(sellerBasisPoints)).div(BigNumber.from(INVERSE_BASIS_POINTS)).toString()\n\n  return {\n    sellerFee: createConsiderationItem(sellerFee, signerAddress),\n    openseaFee: createConsiderationItem(openseaFee, OPENSEA_FEE_ADDRESS),\n    creatorFee:\n      creatorFeeBasisPoints > 0\n        ? createConsiderationItem(creatorFee, asset?.asset_contract?.payout_address ?? '')\n        : undefined,\n  }\n}\n\nexport async function approveCollection(\n  operator: string,\n  collectionAddress: string,\n  signer: Signer,\n  setStatus: (newStatus: ListingStatus) => void\n): Promise<void> {\n  // This will work for both 721s & 1155s because they both have the\n  // setApprovalForAll() method\n  const ERC721Contract = new Contract(collectionAddress, ERC721, signer)\n  const signerAddress = await signer.getAddress()\n  setStatus(ListingStatus.PENDING)\n  try {\n    const approved = await ERC721Contract.isApprovedForAll(signerAddress, operator)\n    if (approved) {\n      setStatus(ListingStatus.APPROVED)\n      return\n    }\n\n    setStatus(ListingStatus.SIGNING)\n    const approvalTransaction = await ERC721Contract.setApprovalForAll(operator, true)\n\n    setStatus(ListingStatus.PENDING)\n    const tx = await approvalTransaction.wait()\n\n    tx.status === 1 ? setStatus(ListingStatus.APPROVED) : setStatus(ListingStatus.FAILED)\n  } catch (error) {\n    if (error.code === 4001) setStatus(ListingStatus.REJECTED)\n    else setStatus(ListingStatus.FAILED)\n  }\n}\n\nexport async function signListing(\n  marketplace: ListingMarket,\n  asset: WalletAsset,\n  signer: JsonRpcSigner,\n  provider: Web3Provider,\n  looksRareNonce = 0,\n  setStatus: (newStatus: ListingStatus) => void\n): Promise<boolean> {\n  const seaport = new Seaport(provider, {\n    conduitKeyToConduit: OPENSEA_KEY_TO_CONDUIT,\n    overrides: {\n      defaultConduitKey: OPENSEA_DEFAULT_CROSS_CHAIN_CONDUIT_KEY,\n    },\n  })\n\n  const signerAddress = await signer.getAddress()\n  const listingPrice = asset.newListings?.find((listing) => listing.marketplace.name === marketplace.name)?.price\n  if (!listingPrice || !asset.expirationTime || !asset.asset_contract.address || !asset.tokenId) return false\n  switch (marketplace.name) {\n    case 'OpenSea':\n      try {\n        const listingInWei = parseEther(`${listingPrice}`)\n        const { sellerFee, openseaFee, creatorFee } = getConsiderationItems(asset, listingInWei, signerAddress)\n        const considerationItems = [sellerFee, openseaFee, creatorFee].filter(\n          (item): item is ConsiderationInputItem => item !== undefined\n        )\n\n        const { executeAllActions } = await seaport.createOrder(\n          {\n            offer: [\n              {\n                itemType: ItemType.ERC721,\n                token: asset.asset_contract.address,\n                identifier: asset.tokenId,\n                amount: '1',\n              },\n            ],\n            consideration: considerationItems,\n            endTime: asset.expirationTime.toString(),\n            zone: OPENSEA_DEFAULT_ZONE,\n            restrictedByZone: true,\n            allowPartialFills: true,\n          },\n          signerAddress\n        )\n\n        const order = await executeAllActions()\n        const res = await PostOpenSeaSellOrder(order)\n        if (res) setStatus(ListingStatus.APPROVED)\n        return res\n      } catch (error) {\n        if (error.code === 4001) setStatus(ListingStatus.REJECTED)\n        else setStatus(ListingStatus.FAILED)\n        return false\n      }\n    case 'LooksRare': {\n      const addresses = addressesByNetwork[SupportedChainId.MAINNET]\n      const currentTime = Math.round(Date.now() / 1000)\n      const makerOrder: MakerOrder = {\n        // true --> ask / false --> bid\n        isOrderAsk: true,\n        // signer address of the maker order\n        signer: signerAddress,\n        // collection address\n        collection: asset.asset_contract.address,\n        // Price in WEI\n        price: parseEther(listingPrice.toString()),\n        // Token ID\n        tokenId: BigNumber.from(asset.tokenId),\n        // amount of tokens to sell/purchase (must be 1 for ERC721, 1+ for ERC1155)\n        amount: BigNumber.from(1),\n        // strategy for trade execution (e.g., DutchAuction, StandardSaleForFixedPrice), see addresses in the SDK\n        strategy: addresses.STRATEGY_STANDARD_SALE,\n        // currency address\n        currency: addresses.WETH,\n        // order nonce (must be unique unless new maker order is meant to override existing one e.g., lower ask price)\n        nonce: BigNumber.from(looksRareNonce),\n        // startTime timestamp in seconds\n        startTime: BigNumber.from(currentTime),\n        // endTime timestamp in seconds\n        endTime: BigNumber.from(asset.expirationTime),\n        // minimum ratio to be received by the user (per 10000)\n        // As of 11.10.22 LooksRare charges 1.5% + 0.5% if there's creator royalties set https://docs.looksrare.org/blog/looksrare-offers-zero-royalty-trading-shares-protocol-fees-with-creators-instead\n        minPercentageToAsk: BigNumber.from(10000)\n          .sub(BigNumber.from(150 + (asset.basisPoints ? 50 : 0)))\n          .toNumber(),\n        // params (e.g., price, target account for private sale)\n        params: [],\n      }\n\n      try {\n        const signatureHash = await signMakerOrder(\n          signer,\n          SupportedChainId.MAINNET,\n          makerOrder,\n          LOOKSRARE_MARKETPLACE_CONTRACT\n        )\n        setStatus(ListingStatus.PENDING)\n        const payload = {\n          signature: signatureHash,\n          tokenId: asset.tokenId,\n          collection: asset.asset_contract.address,\n          strategy: addresses.STRATEGY_STANDARD_SALE,\n          currency: addresses.WETH,\n          signer: signerAddress,\n          isOrderAsk: true,\n          nonce: looksRareNonce,\n          amount: 1,\n          price: parseEther(listingPrice.toString()).toString(),\n          startTime: currentTime,\n          endTime: asset.expirationTime,\n          minPercentageToAsk: 10000 - (150 + (asset.basisPoints ? 50 : 0)),\n          params: [],\n        }\n        const res = await createLooksRareOrder(payload)\n        if (res) setStatus(ListingStatus.APPROVED)\n        return res\n      } catch (error) {\n        if (error.code === 4001) setStatus(ListingStatus.REJECTED)\n        else setStatus(ListingStatus.FAILED)\n        return false\n      }\n    }\n    case 'X2Y2': {\n      const orderItem: OfferItem = {\n        price: parseEther(listingPrice.toString()),\n        tokens: [\n          {\n            token: asset.asset_contract.address,\n            tokenId: BigNumber.from(asset.tokenId),\n          },\n        ],\n      }\n      const order = createSellOrder(signerAddress, asset.expirationTime, [orderItem])\n      try {\n        const prevOrderId = await getOrderId(asset.asset_contract.address, asset.tokenId)\n        await signOrderData(provider, order)\n        const payload: OrderPayload = {\n          order: encodeOrder(order),\n          isBundle: false,\n          bundleName: '',\n          bundleDesc: '',\n          orderIds: prevOrderId ? [prevOrderId] : [],\n          changePrice: Boolean(prevOrderId),\n          isCollection: false,\n        }\n        setStatus(ListingStatus.PENDING)\n        // call server api\n        const resp = await newX2Y2Order(payload)\n        if (resp) setStatus(ListingStatus.APPROVED)\n        return resp\n      } catch (error) {\n        if (error.code === 4001) setStatus(ListingStatus.REJECTED)\n        else setStatus(ListingStatus.FAILED)\n        return false\n      }\n    }\n    default:\n      return false\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}