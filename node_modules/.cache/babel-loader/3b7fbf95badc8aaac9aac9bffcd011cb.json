{"ast":null,"code":"import { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3/factories/IUniswapV3PoolState__factory';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V3PoolProvider {\n  /**\n   * Creates an instance of V3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  constructor(chainId, multicall2Provider) {\n    let retryOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      retries: 2,\n      minTimeout: 50,\n      maxTimeout: 500\n    };\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n    this.POOL_ADDRESS_CACHE = {};\n  }\n  async getPools(tokenPairs, providerConfig) {\n    const poolAddressSet = new Set();\n    const sortedTokenPairs = [];\n    const sortedPoolAddresses = [];\n    for (const tokenPair of tokenPairs) {\n      const [tokenA, tokenB, feeAmount] = tokenPair;\n      const {\n        poolAddress,\n        token0,\n        token1\n      } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n      if (poolAddressSet.has(poolAddress)) {\n        continue;\n      }\n      poolAddressSet.add(poolAddress);\n      sortedTokenPairs.push([token0, token1, feeAmount]);\n      sortedPoolAddresses.push(poolAddress);\n    }\n    log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n    const [slot0Results, liquidityResults] = await Promise.all([this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig), this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig)]);\n    log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.` : ``}`);\n    const poolAddressToPool = {};\n    const invalidPools = [];\n    for (let i = 0; i < sortedPoolAddresses.length; i++) {\n      const slot0Result = slot0Results[i];\n      const liquidityResult = liquidityResults[i];\n      // These properties tell us if a pool is valid and initialized or not.\n      if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) || !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) || slot0Result.result.sqrtPriceX96.eq(0)) {\n        const [token0, token1, fee] = sortedTokenPairs[i];\n        invalidPools.push([token0, token1, fee]);\n        continue;\n      }\n      const [token0, token1, fee] = sortedTokenPairs[i];\n      const slot0 = slot0Result.result;\n      const liquidity = liquidityResult.result[0];\n      const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n      const poolAddress = sortedPoolAddresses[i];\n      poolAddressToPool[poolAddress] = pool;\n    }\n    if (invalidPools.length > 0) {\n      log.info({\n        invalidPools: _.map(invalidPools, _ref => {\n          let [token0, token1, fee] = _ref;\n          return `${token0.symbol}/${token1.symbol}/${fee / 10000}%`;\n        })\n      }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n    }\n    const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n    log.debug({\n      poolStrs\n    }, `Found ${poolStrs.length} valid pools`);\n    return {\n      getPool: (tokenA, tokenB, feeAmount) => {\n        const {\n          poolAddress\n        } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n        return poolAddressToPool[poolAddress];\n      },\n      getPoolByAddress: address => poolAddressToPool[address],\n      getAllPools: () => Object.values(poolAddressToPool)\n    };\n  }\n  getPoolAddress(tokenA, tokenB, feeAmount) {\n    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n    const cacheKey = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;\n    const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n    if (cachedAddress) {\n      return {\n        poolAddress: cachedAddress,\n        token0,\n        token1\n      };\n    }\n    const poolAddress = computePoolAddress({\n      factoryAddress: V3_CORE_FACTORY_ADDRESSES[this.chainId],\n      tokenA: token0,\n      tokenB: token1,\n      fee: feeAmount\n    });\n    this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n    return {\n      poolAddress,\n      token0,\n      token1\n    };\n  }\n  async getPoolsData(poolAddresses, functionName, providerConfig) {\n    const {\n      results,\n      blockNumber\n    } = await retry(async () => {\n      return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n        addresses: poolAddresses,\n        contractInterface: IUniswapV3PoolState__factory.createInterface(),\n        functionName: functionName,\n        providerConfig\n      });\n    }, this.retryOptions);\n    log.debug(`Pool data fetched as of block ${blockNumber}`);\n    return results;\n  }\n}","map":{"version":3,"sources":["../../../../src/providers/v3/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3/factories/IUniswapV3PoolState__factory';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V3PoolProvider {\n    /**\n     * Creates an instance of V3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (const tokenPair of tokenPairs) {\n            const [tokenA, tokenB, feeAmount] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1, feeAmount]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const [slot0Results, liquidityResults] = await Promise.all([\n            this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig),\n            this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig),\n        ]);\n        log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const slot0Result = slot0Results[i];\n            const liquidityResult = liquidityResults[i];\n            // These properties tell us if a pool is valid and initialized or not.\n            if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) ||\n                !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) ||\n                slot0Result.result.sqrtPriceX96.eq(0)) {\n                const [token0, token1, fee] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1, fee]);\n                continue;\n            }\n            const [token0, token1, fee] = sortedTokenPairs[i];\n            const slot0 = slot0Result.result;\n            const liquidity = liquidityResult.result[0];\n            const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1, fee]) => `${token0.symbol}/${token1.symbol}/${fee / 10000}%`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB, feeAmount) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB, feeAmount) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = computePoolAddress({\n            factoryAddress: V3_CORE_FACTORY_ADDRESSES[this.chainId],\n            tokenA: token0,\n            tokenB: token1,\n            fee: feeAmount,\n        });\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV3PoolState__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjMvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsa0JBQWtCLEVBQWEsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdEUsT0FBTyxLQUFrQyxNQUFNLGFBQWEsQ0FBQztBQUM3RCxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFFdkIsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sdURBQXVELENBQUM7QUFFckcsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDakUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQThEakQsTUFBTSxPQUFPLGNBQWM7SUFLekI7Ozs7O09BS0c7SUFDSCxZQUNZLE9BQWdCLEVBQ2hCLGtCQUFzQyxFQUN0QyxlQUFtQztRQUMzQyxPQUFPLEVBQUUsQ0FBQztRQUNWLFVBQVUsRUFBRSxFQUFFO1FBQ2QsVUFBVSxFQUFFLEdBQUc7S0FDaEI7UUFOUyxZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQ2hCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFDdEMsaUJBQVksR0FBWixZQUFZLENBSXJCO1FBakJILHlFQUF5RTtRQUN6RSxrREFBa0Q7UUFDMUMsdUJBQWtCLEdBQThCLEVBQUUsQ0FBQztJQWdCeEQsQ0FBQztJQUVHLEtBQUssQ0FBQyxRQUFRLENBQ25CLFVBQXVDLEVBQ3ZDLGNBQStCO1FBRS9CLE1BQU0sY0FBYyxHQUFnQixJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3RELE1BQU0sZ0JBQWdCLEdBQXFDLEVBQUUsQ0FBQztRQUM5RCxNQUFNLG1CQUFtQixHQUFhLEVBQUUsQ0FBQztRQUV6QyxLQUFLLE1BQU0sU0FB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"]},"metadata":{},"sourceType":"module"}