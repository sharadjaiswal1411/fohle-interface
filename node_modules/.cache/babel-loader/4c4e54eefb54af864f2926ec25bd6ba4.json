{"ast":null,"code":"import _slicedToArray from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{Trans}from\"@lingui/react\";import{CurrencyAmount,Price,Rounding}from'@uniswap/sdk-core';import{encodeSqrtRatioX96,nearestUsableTick,Pool,Position,priceToClosestTick,TICK_SPACINGS,TickMath,tickToPrice}from'@uniswap/v3-sdk';import{useWeb3React}from'@web3-react/core';import{usePool}from'hooks/usePools';import JSBI from'jsbi';import tryParseCurrencyAmount from'lib/utils/tryParseCurrencyAmount';import{useCallback,useMemo}from'react';import{useLocation,useNavigate}from'react-router-dom';import{useAppDispatch,useAppSelector}from'state/hooks';import{getTickToPrice}from'utils/getTickToPrice';import{replaceURLParam}from'utils/routes';import{BIG_INT_ZERO}from'../../../constants/misc';import{PoolState}from'../../../hooks/usePools';import{useCurrencyBalances}from'../../connection/hooks';import{Bound,Field,setFullRange,typeInput,typeLeftRangeInput,typeRightRangeInput,typeStartPriceInput}from'./actions';import{tryParseTick}from'./utils';import{jsx as _jsx}from\"react/jsx-runtime\";export function useV3MintState(){return useAppSelector(function(state){return state.mintV3;});}export function useV3MintActionHandlers(noLiquidity){var dispatch=useAppDispatch();var navigate=useNavigate();var onFieldAInput=useCallback(function(typedValue){dispatch(typeInput({field:Field.CURRENCY_A,typedValue:typedValue,noLiquidity:noLiquidity===true}));},[dispatch,noLiquidity]);var onFieldBInput=useCallback(function(typedValue){dispatch(typeInput({field:Field.CURRENCY_B,typedValue:typedValue,noLiquidity:noLiquidity===true}));},[dispatch,noLiquidity]);var _useLocation=useLocation(),search=_useLocation.search;var onLeftRangeInput=useCallback(function(typedValue){dispatch(typeLeftRangeInput({typedValue:typedValue}));navigate({search:replaceURLParam(search,'minPrice',typedValue)},{replace:true});},[dispatch,navigate,search]);var onRightRangeInput=useCallback(function(typedValue){dispatch(typeRightRangeInput({typedValue:typedValue}));navigate({search:replaceURLParam(search,'maxPrice',typedValue)},{replace:true});},[dispatch,navigate,search]);var onStartPriceInput=useCallback(function(typedValue){dispatch(typeStartPriceInput({typedValue:typedValue}));},[dispatch]);return{onFieldAInput:onFieldAInput,onFieldBInput:onFieldBInput,onLeftRangeInput:onLeftRangeInput,onRightRangeInput:onRightRangeInput,onStartPriceInput:onStartPriceInput};}export function useV3DerivedMintInfo(currencyA,currencyB,feeAmount,baseCurrency,// override for existing position\nexistingPosition){var _currencyBalances,_currencyBalances$Fie,_currencyBalances$Fie2;var _useWeb3React=useWeb3React(),account=_useWeb3React.account;var _useV3MintState=useV3MintState(),independentField=_useV3MintState.independentField,typedValue=_useV3MintState.typedValue,leftRangeTypedValue=_useV3MintState.leftRangeTypedValue,rightRangeTypedValue=_useV3MintState.rightRangeTypedValue,startPriceTypedValue=_useV3MintState.startPriceTypedValue;var dependentField=independentField===Field.CURRENCY_A?Field.CURRENCY_B:Field.CURRENCY_A;// currencies\nvar currencies=useMemo(function(){var _ref;return _ref={},_defineProperty(_ref,Field.CURRENCY_A,currencyA),_defineProperty(_ref,Field.CURRENCY_B,currencyB),_ref;},[currencyA,currencyB]);// formatted with tokens\nvar _useMemo=useMemo(function(){return[currencyA===null||currencyA===void 0?void 0:currencyA.wrapped,currencyB===null||currencyB===void 0?void 0:currencyB.wrapped,baseCurrency===null||baseCurrency===void 0?void 0:baseCurrency.wrapped];},[currencyA,currencyB,baseCurrency]),_useMemo2=_slicedToArray(_useMemo,3),tokenA=_useMemo2[0],tokenB=_useMemo2[1],baseToken=_useMemo2[2];var _useMemo3=useMemo(function(){return tokenA&&tokenB?tokenA.sortsBefore(tokenB)?[tokenA,tokenB]:[tokenB,tokenA]:[undefined,undefined];},[tokenA,tokenB]),_useMemo4=_slicedToArray(_useMemo3,2),token0=_useMemo4[0],token1=_useMemo4[1];// balances\nvar balances=useCurrencyBalances(account!==null&&account!==void 0?account:undefined,useMemo(function(){return[currencies[Field.CURRENCY_A],currencies[Field.CURRENCY_B]];},[currencies]));var currencyBalances=(_currencyBalances={},_defineProperty(_currencyBalances,Field.CURRENCY_A,balances[0]),_defineProperty(_currencyBalances,Field.CURRENCY_B,balances[1]),_currencyBalances);// pool\nvar _usePool=usePool(currencies[Field.CURRENCY_A],currencies[Field.CURRENCY_B],feeAmount),_usePool2=_slicedToArray(_usePool,2),poolState=_usePool2[0],pool=_usePool2[1];var noLiquidity=poolState===PoolState.NOT_EXISTS;// note to parse inputs in reverse\nvar invertPrice=Boolean(baseToken&&token0&&!baseToken.equals(token0));// always returns the price with 0 as base token\nvar price=useMemo(function(){// if no liquidity use typed value\nif(noLiquidity){var parsedQuoteAmount=tryParseCurrencyAmount(startPriceTypedValue,invertPrice?token0:token1);if(parsedQuoteAmount&&token0&&token1){var _ref2;var baseAmount=tryParseCurrencyAmount('1',invertPrice?token1:token0);var _price=baseAmount&&parsedQuoteAmount?new Price(baseAmount.currency,parsedQuoteAmount.currency,baseAmount.quotient,parsedQuoteAmount.quotient):undefined;return(_ref2=invertPrice?_price===null||_price===void 0?void 0:_price.invert():_price)!==null&&_ref2!==void 0?_ref2:undefined;}return undefined;}else{// get the amount of quote currency\nreturn pool&&token0?pool.priceOf(token0):undefined;}},[noLiquidity,startPriceTypedValue,invertPrice,token1,token0,pool]);// check for invalid price input (converts to invalid ratio)\nvar invalidPrice=useMemo(function(){var sqrtRatioX96=price?encodeSqrtRatioX96(price.numerator,price.denominator):undefined;return price&&sqrtRatioX96&&!(JSBI.greaterThanOrEqual(sqrtRatioX96,TickMath.MIN_SQRT_RATIO)&&JSBI.lessThan(sqrtRatioX96,TickMath.MAX_SQRT_RATIO));},[price]);// used for ratio calculation when pool not initialized\nvar mockPool=useMemo(function(){if(tokenA&&tokenB&&feeAmount&&price&&!invalidPrice){var currentTick=priceToClosestTick(price);var currentSqrt=TickMath.getSqrtRatioAtTick(currentTick);return new Pool(tokenA,tokenB,feeAmount,currentSqrt,JSBI.BigInt(0),currentTick,[]);}else{return undefined;}},[feeAmount,invalidPrice,price,tokenA,tokenB]);// if pool exists use it, if not use the mock pool\nvar poolForPosition=pool!==null&&pool!==void 0?pool:mockPool;// lower and upper limits in the tick space for `feeAmoun<Trans>\nvar tickSpaceLimits=useMemo(function(){var _ref3;return _ref3={},_defineProperty(_ref3,Bound.LOWER,feeAmount?nearestUsableTick(TickMath.MIN_TICK,TICK_SPACINGS[feeAmount]):undefined),_defineProperty(_ref3,Bound.UPPER,feeAmount?nearestUsableTick(TickMath.MAX_TICK,TICK_SPACINGS[feeAmount]):undefined),_ref3;},[feeAmount]);// parse typed range values and determine closest ticks\n// lower should always be a smaller tick\nvar ticks=useMemo(function(){var _ref4;return _ref4={},_defineProperty(_ref4,Bound.LOWER,typeof(existingPosition===null||existingPosition===void 0?void 0:existingPosition.tickLower)==='number'?existingPosition.tickLower:invertPrice&&typeof rightRangeTypedValue==='boolean'||!invertPrice&&typeof leftRangeTypedValue==='boolean'?tickSpaceLimits[Bound.LOWER]:invertPrice?tryParseTick(token1,token0,feeAmount,rightRangeTypedValue.toString()):tryParseTick(token0,token1,feeAmount,leftRangeTypedValue.toString())),_defineProperty(_ref4,Bound.UPPER,typeof(existingPosition===null||existingPosition===void 0?void 0:existingPosition.tickUpper)==='number'?existingPosition.tickUpper:!invertPrice&&typeof rightRangeTypedValue==='boolean'||invertPrice&&typeof leftRangeTypedValue==='boolean'?tickSpaceLimits[Bound.UPPER]:invertPrice?tryParseTick(token1,token0,feeAmount,leftRangeTypedValue.toString()):tryParseTick(token0,token1,feeAmount,rightRangeTypedValue.toString())),_ref4;},[existingPosition,feeAmount,invertPrice,leftRangeTypedValue,rightRangeTypedValue,token0,token1,tickSpaceLimits]);var _ref5=ticks||{},tickLower=_ref5[Bound.LOWER],tickUpper=_ref5[Bound.UPPER];// specifies whether the lower and upper ticks is at the exteme bounds\nvar ticksAtLimit=useMemo(function(){var _ref6;return _ref6={},_defineProperty(_ref6,Bound.LOWER,feeAmount&&tickLower===tickSpaceLimits.LOWER),_defineProperty(_ref6,Bound.UPPER,feeAmount&&tickUpper===tickSpaceLimits.UPPER),_ref6;},[tickSpaceLimits,tickLower,tickUpper,feeAmount]);// mark invalid range\nvar invalidRange=Boolean(typeof tickLower==='number'&&typeof tickUpper==='number'&&tickLower>=tickUpper);// always returns the price with 0 as base token\nvar pricesAtTicks=useMemo(function(){var _ref7;return _ref7={},_defineProperty(_ref7,Bound.LOWER,getTickToPrice(token0,token1,ticks[Bound.LOWER])),_defineProperty(_ref7,Bound.UPPER,getTickToPrice(token0,token1,ticks[Bound.UPPER])),_ref7;},[token0,token1,ticks]);var lowerPrice=pricesAtTicks[Bound.LOWER],upperPrice=pricesAtTicks[Bound.UPPER];// liquidity range warning\nvar outOfRange=Boolean(!invalidRange&&price&&lowerPrice&&upperPrice&&(price.lessThan(lowerPrice)||price.greaterThan(upperPrice)));// amounts\nvar independentAmount=tryParseCurrencyAmount(typedValue,currencies[independentField]);var dependentAmount=useMemo(function(){// we wrap the currencies just to get the price in terms of the other token\nvar wrappedIndependentAmount=independentAmount===null||independentAmount===void 0?void 0:independentAmount.wrapped;var dependentCurrency=dependentField===Field.CURRENCY_B?currencyB:currencyA;if(independentAmount&&wrappedIndependentAmount&&typeof tickLower==='number'&&typeof tickUpper==='number'&&poolForPosition){// if price is out of range or invalid range - return 0 (single deposit will be independent)\nif(outOfRange||invalidRange){return undefined;}var _position=wrappedIndependentAmount.currency.equals(poolForPosition.token0)?Position.fromAmount0({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount0:independentAmount.quotient,useFullPrecision:true// we want full precision for the theoretical position\n}):Position.fromAmount1({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount1:independentAmount.quotient});var dependentTokenAmount=wrappedIndependentAmount.currency.equals(poolForPosition.token0)?_position.amount1:_position.amount0;return dependentCurrency&&CurrencyAmount.fromRawAmount(dependentCurrency,dependentTokenAmount.quotient);}return undefined;},[independentAmount,outOfRange,dependentField,currencyB,currencyA,tickLower,tickUpper,poolForPosition,invalidRange]);var parsedAmounts=useMemo(function(){var _ref8;return _ref8={},_defineProperty(_ref8,Field.CURRENCY_A,independentField===Field.CURRENCY_A?independentAmount:dependentAmount),_defineProperty(_ref8,Field.CURRENCY_B,independentField===Field.CURRENCY_A?dependentAmount:independentAmount),_ref8;},[dependentAmount,independentAmount,independentField]);// single deposit only if price is out of range\nvar deposit0Disabled=Boolean(typeof tickUpper==='number'&&poolForPosition&&poolForPosition.tickCurrent>=tickUpper);var deposit1Disabled=Boolean(typeof tickLower==='number'&&poolForPosition&&poolForPosition.tickCurrent<=tickLower);// sorted for token order\nvar depositADisabled=invalidRange||Boolean(deposit0Disabled&&poolForPosition&&tokenA&&poolForPosition.token0.equals(tokenA)||deposit1Disabled&&poolForPosition&&tokenA&&poolForPosition.token1.equals(tokenA));var depositBDisabled=invalidRange||Boolean(deposit0Disabled&&poolForPosition&&tokenB&&poolForPosition.token0.equals(tokenB)||deposit1Disabled&&poolForPosition&&tokenB&&poolForPosition.token1.equals(tokenB));// create position entity based on users selection\nvar position=useMemo(function(){var _parsedAmounts,_parsedAmounts2;if(!poolForPosition||!tokenA||!tokenB||typeof tickLower!=='number'||typeof tickUpper!=='number'||invalidRange){return undefined;}// mark as 0 if disabled because out of range\nvar amount0=!deposit0Disabled?parsedAmounts===null||parsedAmounts===void 0?void 0:(_parsedAmounts=parsedAmounts[tokenA.equals(poolForPosition.token0)?Field.CURRENCY_A:Field.CURRENCY_B])===null||_parsedAmounts===void 0?void 0:_parsedAmounts.quotient:BIG_INT_ZERO;var amount1=!deposit1Disabled?parsedAmounts===null||parsedAmounts===void 0?void 0:(_parsedAmounts2=parsedAmounts[tokenA.equals(poolForPosition.token0)?Field.CURRENCY_B:Field.CURRENCY_A])===null||_parsedAmounts2===void 0?void 0:_parsedAmounts2.quotient:BIG_INT_ZERO;if(amount0!==undefined&&amount1!==undefined){return Position.fromAmounts({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount0:amount0,amount1:amount1,useFullPrecision:true// we want full precision for the theoretical position\n});}else{return undefined;}},[parsedAmounts,poolForPosition,tokenA,tokenB,deposit0Disabled,deposit1Disabled,invalidRange,tickLower,tickUpper]);var errorMessage;if(!account){errorMessage=/*#__PURE__*/_jsx(Trans,{id:\"Connect Wallet\"});}if(poolState===PoolState.INVALID){var _errorMessage;errorMessage=(_errorMessage=errorMessage)!==null&&_errorMessage!==void 0?_errorMessage:/*#__PURE__*/_jsx(Trans,{id:\"Invalid pair\"});}if(invalidPrice){var _errorMessage2;errorMessage=(_errorMessage2=errorMessage)!==null&&_errorMessage2!==void 0?_errorMessage2:/*#__PURE__*/_jsx(Trans,{id:\"Invalid price input\"});}if(!parsedAmounts[Field.CURRENCY_A]&&!depositADisabled||!parsedAmounts[Field.CURRENCY_B]&&!depositBDisabled){var _errorMessage3;errorMessage=(_errorMessage3=errorMessage)!==null&&_errorMessage3!==void 0?_errorMessage3:/*#__PURE__*/_jsx(Trans,{id:\"Enter an amount\"});}var currencyAAmount=parsedAmounts[Field.CURRENCY_A],currencyBAmount=parsedAmounts[Field.CURRENCY_B];if(currencyAAmount&&(currencyBalances===null||currencyBalances===void 0?void 0:(_currencyBalances$Fie=currencyBalances[Field.CURRENCY_A])===null||_currencyBalances$Fie===void 0?void 0:_currencyBalances$Fie.lessThan(currencyAAmount))){var _currencies$Field$CUR;errorMessage=/*#__PURE__*/_jsx(Trans,{id:\"Insufficient {0} balance\",values:{0:(_currencies$Field$CUR=currencies[Field.CURRENCY_A])===null||_currencies$Field$CUR===void 0?void 0:_currencies$Field$CUR.symbol}});}if(currencyBAmount&&(currencyBalances===null||currencyBalances===void 0?void 0:(_currencyBalances$Fie2=currencyBalances[Field.CURRENCY_B])===null||_currencyBalances$Fie2===void 0?void 0:_currencyBalances$Fie2.lessThan(currencyBAmount))){var _currencies$Field$CUR2;errorMessage=/*#__PURE__*/_jsx(Trans,{id:\"Insufficient {0} balance\",values:{0:(_currencies$Field$CUR2=currencies[Field.CURRENCY_B])===null||_currencies$Field$CUR2===void 0?void 0:_currencies$Field$CUR2.symbol}});}var invalidPool=poolState===PoolState.INVALID;return{dependentField:dependentField,currencies:currencies,pool:pool,poolState:poolState,currencyBalances:currencyBalances,parsedAmounts:parsedAmounts,ticks:ticks,price:price,pricesAtTicks:pricesAtTicks,position:position,noLiquidity:noLiquidity,errorMessage:errorMessage,invalidPool:invalidPool,invalidRange:invalidRange,outOfRange:outOfRange,depositADisabled:depositADisabled,depositBDisabled:depositBDisabled,invertPrice:invertPrice,ticksAtLimit:ticksAtLimit};}export function useRangeHopCallbacks(baseCurrency,quoteCurrency,feeAmount,tickLower,tickUpper,pool){var dispatch=useAppDispatch();var baseToken=useMemo(function(){return baseCurrency===null||baseCurrency===void 0?void 0:baseCurrency.wrapped;},[baseCurrency]);var quoteToken=useMemo(function(){return quoteCurrency===null||quoteCurrency===void 0?void 0:quoteCurrency.wrapped;},[quoteCurrency]);var getDecrementLower=useCallback(function(){if(baseToken&&quoteToken&&typeof tickLower==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickLower-TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickLower==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice=tickToPrice(baseToken,quoteToken,pool.tickCurrent-TICK_SPACINGS[feeAmount]);return _newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickLower,feeAmount,pool]);var getIncrementLower=useCallback(function(){if(baseToken&&quoteToken&&typeof tickLower==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickLower+TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickLower==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice2=tickToPrice(baseToken,quoteToken,pool.tickCurrent+TICK_SPACINGS[feeAmount]);return _newPrice2.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickLower,feeAmount,pool]);var getDecrementUpper=useCallback(function(){if(baseToken&&quoteToken&&typeof tickUpper==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickUpper-TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickUpper==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice3=tickToPrice(baseToken,quoteToken,pool.tickCurrent-TICK_SPACINGS[feeAmount]);return _newPrice3.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickUpper,feeAmount,pool]);var getIncrementUpper=useCallback(function(){if(baseToken&&quoteToken&&typeof tickUpper==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickUpper+TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickUpper==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice4=tickToPrice(baseToken,quoteToken,pool.tickCurrent+TICK_SPACINGS[feeAmount]);return _newPrice4.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickUpper,feeAmount,pool]);var getSetFullRange=useCallback(function(){dispatch(setFullRange());},[dispatch]);return{getDecrementLower:getDecrementLower,getIncrementLower:getIncrementLower,getDecrementUpper:getDecrementUpper,getIncrementUpper:getIncrementUpper,getSetFullRange:getSetFullRange};}","map":{"version":3,"names":["CurrencyAmount","Price","Rounding","encodeSqrtRatioX96","nearestUsableTick","Pool","Position","priceToClosestTick","TICK_SPACINGS","TickMath","tickToPrice","useWeb3React","usePool","JSBI","tryParseCurrencyAmount","useCallback","useMemo","useLocation","useNavigate","useAppDispatch","useAppSelector","getTickToPrice","replaceURLParam","BIG_INT_ZERO","PoolState","useCurrencyBalances","Bound","Field","setFullRange","typeInput","typeLeftRangeInput","typeRightRangeInput","typeStartPriceInput","tryParseTick","useV3MintState","state","mintV3","useV3MintActionHandlers","noLiquidity","dispatch","navigate","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","search","onLeftRangeInput","replace","onRightRangeInput","onStartPriceInput","useV3DerivedMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","account","independentField","leftRangeTypedValue","rightRangeTypedValue","startPriceTypedValue","dependentField","currencies","wrapped","tokenA","tokenB","baseToken","sortsBefore","undefined","token0","token1","balances","currencyBalances","poolState","pool","NOT_EXISTS","invertPrice","Boolean","equals","price","parsedQuoteAmount","baseAmount","currency","quotient","invert","priceOf","invalidPrice","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","currentSqrt","getSqrtRatioAtTick","BigInt","poolForPosition","tickSpaceLimits","LOWER","MIN_TICK","UPPER","MAX_TICK","ticks","tickLower","toString","tickUpper","ticksAtLimit","invalidRange","pricesAtTicks","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","fromAmounts","errorMessage","INVALID","currencyAAmount","currencyBAmount","symbol","invalidPool","useRangeHopCallbacks","quoteCurrency","quoteToken","getDecrementLower","newPrice","toSignificant","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/mint/v3/hooks.tsx"],"sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Price, Rounding, Token } from '@uniswap/sdk-core'\nimport {\n  encodeSqrtRatioX96,\n  FeeAmount,\n  nearestUsableTick,\n  Pool,\n  Position,\n  priceToClosestTick,\n  TICK_SPACINGS,\n  TickMath,\n  tickToPrice,\n} from '@uniswap/v3-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { usePool } from 'hooks/usePools'\nimport JSBI from 'jsbi'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { ReactNode, useCallback, useMemo } from 'react'\nimport { useLocation, useNavigate } from 'react-router-dom'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { getTickToPrice } from 'utils/getTickToPrice'\nimport { replaceURLParam } from 'utils/routes'\n\nimport { BIG_INT_ZERO } from '../../../constants/misc'\nimport { PoolState } from '../../../hooks/usePools'\nimport { useCurrencyBalances } from '../../connection/hooks'\nimport { AppState } from '../../index'\nimport {\n  Bound,\n  Field,\n  setFullRange,\n  typeInput,\n  typeLeftRangeInput,\n  typeRightRangeInput,\n  typeStartPriceInput,\n} from './actions'\nimport { tryParseTick } from './utils'\n\nexport function useV3MintState(): AppState['mintV3'] {\n  return useAppSelector((state) => state.mintV3)\n}\n\nexport function useV3MintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n  onLeftRangeInput: (typedValue: string) => void\n  onRightRangeInput: (typedValue: string) => void\n  onStartPriceInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n  const navigate = useNavigate()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const { search } = useLocation()\n\n  const onLeftRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeLeftRangeInput({ typedValue }))\n      navigate({ search: replaceURLParam(search, 'minPrice', typedValue) }, { replace: true })\n    },\n    [dispatch, navigate, search]\n  )\n\n  const onRightRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeRightRangeInput({ typedValue }))\n      navigate({ search: replaceURLParam(search, 'maxPrice', typedValue) }, { replace: true })\n    },\n    [dispatch, navigate, search]\n  )\n\n  const onStartPriceInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeStartPriceInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  }\n}\n\nexport function useV3DerivedMintInfo(\n  currencyA?: Currency,\n  currencyB?: Currency,\n  feeAmount?: FeeAmount,\n  baseCurrency?: Currency,\n  // override for existing position\n  existingPosition?: Position\n): {\n  pool?: Pool | null\n  poolState: PoolState\n  ticks: { [bound in Bound]?: number | undefined }\n  price?: Price<Token, Token>\n  pricesAtTicks: {\n    [bound in Bound]?: Price<Token, Token> | undefined\n  }\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  dependentField: Field\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  position: Position | undefined\n  noLiquidity?: boolean\n  errorMessage?: ReactNode\n  invalidPool: boolean\n  outOfRange: boolean\n  invalidRange: boolean\n  depositADisabled: boolean\n  depositBDisabled: boolean\n  invertPrice: boolean\n  ticksAtLimit: { [bound in Bound]?: boolean | undefined }\n} {\n  const { account } = useWeb3React()\n\n  const { independentField, typedValue, leftRangeTypedValue, rightRangeTypedValue, startPriceTypedValue } =\n    useV3MintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // currencies\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA,\n      [Field.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency]\n  )\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB]\n  )\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies])\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount)\n  const noLiquidity = poolState === PoolState.NOT_EXISTS\n\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0))\n\n  // always returns the price with 0 as base token\n  const price: Price<Token, Token> | undefined = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseCurrencyAmount(startPriceTypedValue, invertPrice ? token0 : token1)\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseCurrencyAmount('1', invertPrice ? token1 : token0)\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient\n              )\n            : undefined\n        return (invertPrice ? price?.invert() : price) ?? undefined\n      }\n      return undefined\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool])\n\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined\n    return (\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      )\n    )\n  }, [price])\n\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price)\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick)\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, [])\n    } else {\n      return undefined\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB])\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition: Pool | undefined = pool ?? mockPool\n\n  // lower and upper limits in the tick space for `feeAmoun<Trans>\n  const tickSpaceLimits: {\n    [bound in Bound]: number | undefined\n  } = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount]\n  )\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks: {\n    [key: string]: number | undefined\n  } = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === 'number'\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (!invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === 'number'\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    }\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ])\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {}\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount]\n  )\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper)\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    }\n  }, [token0, token1, ticks])\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks\n\n  // liquidity range warning\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseCurrencyAmount(\n    typedValue,\n    currencies[independentField]\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === 'number' &&\n      typeof tickUpper === 'number' &&\n      poolForPosition\n    ) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined\n      }\n\n      const position: Position | undefined = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true, // we want full precision for the theoretical position\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          })\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n    }\n\n    return undefined\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper\n  )\n  const deposit1Disabled = Boolean(\n    typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower\n  )\n\n  // sorted for token order\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA))\n    )\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB))\n    )\n\n  // create position entity based on users selection\n  const position: Position | undefined = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== 'number' ||\n      typeof tickUpper !== 'number' ||\n      invalidRange\n    ) {\n      return undefined\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      })\n    } else {\n      return undefined\n    }\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ])\n\n  let errorMessage: ReactNode | undefined\n  if (!account) {\n    errorMessage = <Trans>Connect Wallet</Trans>\n  }\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? <Trans>Invalid price input</Trans>\n  }\n\n  if (\n    (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  }\n\n  const invalidPool = poolState === PoolState.INVALID\n\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit,\n  }\n}\n\nexport function useRangeHopCallbacks(\n  baseCurrency: Currency | undefined,\n  quoteCurrency: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool?: Pool | undefined | null\n) {\n  const dispatch = useAppDispatch()\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency])\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency])\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange())\n  }, [dispatch])\n\n  return { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper, getSetFullRange }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}