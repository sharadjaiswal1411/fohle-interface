{"ast":null,"code":"import _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { makeDsn, logger, checkOrSetAlreadyCaught, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, uuid4, dateTimestampInSeconds, normalize, truncate, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegrations as _setupIntegrations } from './integration.js';\nimport { Scope } from './scope.js';\nimport { updateSession } from './session.js';\nvar ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nvar BaseClient = /*#__PURE__*/function () {\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  function BaseClient(options) {\n    _classCallCheck(this, BaseClient);\n    ;\n    BaseClient.prototype.__init.call(this);\n    BaseClient.prototype.__init2.call(this);\n    BaseClient.prototype.__init3.call(this);\n    BaseClient.prototype.__init4.call(this);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport(_objectSpread(_objectSpread({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this)\n      }, options.transportOptions), {}, {\n        url: url\n      }));\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  _createClass(BaseClient, [{\n    key: \"__init\",\n    value: /** Options passed to the SDK. */\n\n    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n    /** Array of set up integrations. */\n    function __init() {\n      this._integrations = {};\n    }\n\n    /** Indicates whether this client's integrations have been set up. */\n  }, {\n    key: \"__init2\",\n    value: function __init2() {\n      this._integrationsInitialized = false;\n    }\n\n    /** Number of calls being processed */\n  }, {\n    key: \"__init3\",\n    value: function __init3() {\n      this._numProcessing = 0;\n    }\n\n    /** Holds flushable  */\n  }, {\n    key: \"__init4\",\n    value: function __init4() {\n      this._outcomes = {};\n    }\n  }, {\n    key: \"captureException\",\n    value: function captureException(exception, hint, scope) {\n      var _this = this;\n      // ensure we haven't captured this very object before\n      if (checkOrSetAlreadyCaught(exception)) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n        return;\n      }\n      var eventId = hint && hint.event_id;\n      this._process(this.eventFromException(exception, hint).then(function (event) {\n        return _this._captureEvent(event, hint, scope);\n      }).then(function (result) {\n        eventId = result;\n      }));\n      return eventId;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"captureMessage\",\n    value: function captureMessage(message,\n    // eslint-disable-next-line deprecation/deprecation\n    level, hint, scope) {\n      var _this2 = this;\n      var eventId = hint && hint.event_id;\n      var promisedEvent = isPrimitive(message) ? this.eventFromMessage(String(message), level, hint) : this.eventFromException(message, hint);\n      this._process(promisedEvent.then(function (event) {\n        return _this2._captureEvent(event, hint, scope);\n      }).then(function (result) {\n        eventId = result;\n      }));\n      return eventId;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"captureEvent\",\n    value: function captureEvent(event, hint, scope) {\n      // ensure we haven't captured this very object before\n      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n        return;\n      }\n      var eventId = hint && hint.event_id;\n      this._process(this._captureEvent(event, hint, scope).then(function (result) {\n        eventId = result;\n      }));\n      return eventId;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"captureSession\",\n    value: function captureSession(session) {\n      if (!this._isEnabled()) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture session.');\n        return;\n      }\n      if (!(typeof session.release === 'string')) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded session because of missing or non-string release');\n      } else {\n        this.sendSession(session);\n        // After sending, we set init false to indicate it's not the first occurrence\n        updateSession(session, {\n          init: false\n        });\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getDsn\",\n    value: function getDsn() {\n      return this._dsn;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this._options;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getTransport\",\n    value: function getTransport() {\n      return this._transport;\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"flush\",\n    value: function flush(timeout) {\n      var transport = this._transport;\n      if (transport) {\n        return this._isClientDoneProcessing(timeout).then(function (clientFinished) {\n          return transport.flush(timeout).then(function (transportFlushed) {\n            return clientFinished && transportFlushed;\n          });\n        });\n      } else {\n        return resolvedSyncPromise(true);\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"close\",\n    value: function close(timeout) {\n      var _this3 = this;\n      return this.flush(timeout).then(function (result) {\n        _this3.getOptions().enabled = false;\n        return result;\n      });\n    }\n\n    /**\n     * Sets up the integrations\n     */\n  }, {\n    key: \"setupIntegrations\",\n    value: function setupIntegrations() {\n      if (this._isEnabled() && !this._integrationsInitialized) {\n        this._integrations = _setupIntegrations(this._options.integrations);\n        this._integrationsInitialized = true;\n      }\n    }\n\n    /**\n     * Gets an installed integration by its `id`.\n     *\n     * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n     */\n  }, {\n    key: \"getIntegrationById\",\n    value: function getIntegrationById(integrationId) {\n      return this._integrations[integrationId];\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getIntegration\",\n    value: function getIntegration(integration) {\n      try {\n        return this._integrations[integration.id] || null;\n      } catch (_oO) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(\"Cannot retrieve integration \".concat(integration.id, \" from the current Client\"));\n        return null;\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(event) {\n      var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this._dsn) {\n        var env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n        var _iterator = _createForOfIteratorHelper(hint.attachments || []),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var attachment = _step.value;\n            env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment, this._options.transportOptions && this._options.transportOptions.textEncoder));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this._sendEnvelope(env);\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"sendSession\",\n    value: function sendSession(session) {\n      if (this._dsn) {\n        var env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n        this._sendEnvelope(env);\n      }\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"recordDroppedEvent\",\n    value: function recordDroppedEvent(reason, category) {\n      if (this._options.sendClientReports) {\n        // We want to track each category (error, transaction, session) separately\n        // but still keep the distinction between different type of outcomes.\n        // We could use nested maps, but it's much easier to read and type this way.\n        // A correct type for map-based implementation if we want to go that route\n        // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n        // With typescript 4.1 we could even use template literal types\n        var key = \"\".concat(reason, \":\").concat(category);\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"Adding outcome: \\\"\".concat(key, \"\\\"\"));\n\n        // The following works because undefined + 1 === NaN and NaN is falsy\n        this._outcomes[key] = this._outcomes[key] + 1 || 1;\n      }\n    }\n\n    /** Updates existing session based on the provided event */\n  }, {\n    key: \"_updateSessionFromEvent\",\n    value: function _updateSessionFromEvent(session, event) {\n      var crashed = false;\n      var errored = false;\n      var exceptions = event.exception && event.exception.values;\n      if (exceptions) {\n        errored = true;\n        var _iterator2 = _createForOfIteratorHelper(exceptions),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var ex = _step2.value;\n            var mechanism = ex.mechanism;\n            if (mechanism && mechanism.handled === false) {\n              crashed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      // A session is updated and that session update is sent in only one of the two following scenarios:\n      // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n      // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n      var sessionNonTerminal = session.status === 'ok';\n      var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n      if (shouldUpdateAndSend) {\n        updateSession(session, _objectSpread(_objectSpread({}, crashed && {\n          status: 'crashed'\n        }), {}, {\n          errors: session.errors || Number(errored || crashed)\n        }));\n        this.captureSession(session);\n      }\n    }\n\n    /**\n     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n     * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n     * `false` otherwise\n     */\n  }, {\n    key: \"_isClientDoneProcessing\",\n    value: function _isClientDoneProcessing(timeout) {\n      var _this4 = this;\n      return new SyncPromise(function (resolve) {\n        var ticked = 0;\n        var tick = 1;\n        var interval = setInterval(function () {\n          if (_this4._numProcessing == 0) {\n            clearInterval(interval);\n            resolve(true);\n          } else {\n            ticked += tick;\n            if (timeout && ticked >= timeout) {\n              clearInterval(interval);\n              resolve(false);\n            }\n          }\n        }, tick);\n      });\n    }\n\n    /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  }, {\n    key: \"_isEnabled\",\n    value: function _isEnabled() {\n      return this.getOptions().enabled !== false && this._dsn !== undefined;\n    }\n\n    /**\n     * Adds common information to events.\n     *\n     * The information includes release and environment from `options`,\n     * breadcrumbs and context (extra, tags and user) from the scope.\n     *\n     * Information that is already present in the event is never overwritten. For\n     * nested objects, such as the context, keys are merged.\n     *\n     * @param event The original event.\n     * @param hint May contain additional information about the original exception.\n     * @param scope A scope containing event metadata.\n     * @returns A new event with more information.\n     */\n  }, {\n    key: \"_prepareEvent\",\n    value: function _prepareEvent(event, hint, scope) {\n      var _this5 = this;\n      var _this$getOptions = this.getOptions(),\n        _this$getOptions$norm = _this$getOptions.normalizeDepth,\n        normalizeDepth = _this$getOptions$norm === void 0 ? 3 : _this$getOptions$norm,\n        _this$getOptions$norm2 = _this$getOptions.normalizeMaxBreadth,\n        normalizeMaxBreadth = _this$getOptions$norm2 === void 0 ? 1000 : _this$getOptions$norm2;\n      var prepared = _objectSpread(_objectSpread({}, event), {}, {\n        event_id: event.event_id || hint.event_id || uuid4(),\n        timestamp: event.timestamp || dateTimestampInSeconds()\n      });\n      this._applyClientOptions(prepared);\n      this._applyIntegrationsMetadata(prepared);\n\n      // If we have scope given to us, use it as the base for further modifications.\n      // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n      var finalScope = scope;\n      if (hint.captureContext) {\n        finalScope = Scope.clone(finalScope).update(hint.captureContext);\n      }\n\n      // We prepare the result here with a resolved Event.\n      var result = resolvedSyncPromise(prepared);\n\n      // This should be the last thing called, since we want that\n      // {@link Hub.addEventProcessor} gets the finished prepared event.\n      if (finalScope) {\n        // Collect attachments from the hint and scope\n        var attachments = [].concat(_toConsumableArray(hint.attachments || []), _toConsumableArray(finalScope.getAttachments()));\n        if (attachments.length) {\n          hint.attachments = attachments;\n        }\n\n        // In case we have a hub we reassign it.\n        result = finalScope.applyToEvent(prepared, hint);\n      }\n      return result.then(function (evt) {\n        if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n          return _this5._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n        }\n        return evt;\n      });\n    }\n\n    /**\n     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n     * Normalized keys:\n     * - `breadcrumbs.data`\n     * - `user`\n     * - `contexts`\n     * - `extra`\n     * @param event Event\n     * @returns Normalized event\n     */\n  }, {\n    key: \"_normalizeEvent\",\n    value: function _normalizeEvent(event, depth, maxBreadth) {\n      if (!event) {\n        return null;\n      }\n      var normalized = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, event), event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(function (b) {\n          return _objectSpread(_objectSpread({}, b), b.data && {\n            data: normalize(b.data, depth, maxBreadth)\n          });\n        })\n      }), event.user && {\n        user: normalize(event.user, depth, maxBreadth)\n      }), event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth)\n      }), event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth)\n      });\n\n      // event.contexts.trace stores information about a Transaction. Similarly,\n      // event.spans[] stores information about child Spans. Given that a\n      // Transaction is conceptually a Span, normalization should apply to both\n      // Transactions and Spans consistently.\n      // For now the decision is to skip normalization of Transactions and Spans,\n      // so this block overwrites the normalized event to add back the original\n      // Transaction information prior to normalization.\n      if (event.contexts && event.contexts.trace && normalized.contexts) {\n        normalized.contexts.trace = event.contexts.trace;\n\n        // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n        if (event.contexts.trace.data) {\n          normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n        }\n      }\n\n      // event.spans[].data may contain circular/dangerous data so we need to normalize it\n      if (event.spans) {\n        normalized.spans = event.spans.map(function (span) {\n          // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n          if (span.data) {\n            span.data = normalize(span.data, depth, maxBreadth);\n          }\n          return span;\n        });\n      }\n      return normalized;\n    }\n\n    /**\n     *  Enhances event using the client configuration.\n     *  It takes care of all \"static\" values like environment, release and `dist`,\n     *  as well as truncating overly long values.\n     * @param event event instance to be enhanced\n     */\n  }, {\n    key: \"_applyClientOptions\",\n    value: function _applyClientOptions(event) {\n      var options = this.getOptions();\n      var environment = options.environment,\n        release = options.release,\n        dist = options.dist,\n        _options$maxValueLeng = options.maxValueLength,\n        maxValueLength = _options$maxValueLeng === void 0 ? 250 : _options$maxValueLeng;\n      if (!('environment' in event)) {\n        event.environment = 'environment' in options ? environment : 'production';\n      }\n      if (event.release === undefined && release !== undefined) {\n        event.release = release;\n      }\n      if (event.dist === undefined && dist !== undefined) {\n        event.dist = dist;\n      }\n      if (event.message) {\n        event.message = truncate(event.message, maxValueLength);\n      }\n      var exception = event.exception && event.exception.values && event.exception.values[0];\n      if (exception && exception.value) {\n        exception.value = truncate(exception.value, maxValueLength);\n      }\n      var request = event.request;\n      if (request && request.url) {\n        request.url = truncate(request.url, maxValueLength);\n      }\n    }\n\n    /**\n     * This function adds all used integrations to the SDK info in the event.\n     * @param event The event that will be filled with all integrations.\n     */\n  }, {\n    key: \"_applyIntegrationsMetadata\",\n    value: function _applyIntegrationsMetadata(event) {\n      var integrationsArray = Object.keys(this._integrations);\n      if (integrationsArray.length > 0) {\n        event.sdk = event.sdk || {};\n        event.sdk.integrations = [].concat(_toConsumableArray(event.sdk.integrations || []), integrationsArray);\n      }\n    }\n\n    /**\n     * Processes the event and logs an error in case of rejection\n     * @param event\n     * @param hint\n     * @param scope\n     */\n  }, {\n    key: \"_captureEvent\",\n    value: function _captureEvent(event) {\n      var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var scope = arguments.length > 2 ? arguments[2] : undefined;\n      return this._processEvent(event, hint, scope).then(function (finalEvent) {\n        return finalEvent.event_id;\n      }, function (reason) {\n        if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          var sentryError = reason;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      });\n    }\n\n    /**\n     * Processes an event (either error or message) and sends it to Sentry.\n     *\n     * This also adds breadcrumbs and context information to the event. However,\n     * platform specific meta data (such as the User's IP address) must be added\n     * by the SDK implementor.\n     *\n     *\n     * @param event The event to send to Sentry.\n     * @param hint May contain additional information about the original exception.\n     * @param scope A scope containing event metadata.\n     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n     */\n  }, {\n    key: \"_processEvent\",\n    value: function _processEvent(event, hint, scope) {\n      var _this6 = this;\n      var options = this.getOptions();\n      var sampleRate = options.sampleRate;\n      if (!this._isEnabled()) {\n        return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n      }\n      var isTransaction = event.type === 'transaction';\n      var beforeSendProcessorName = isTransaction ? 'beforeSendTransaction' : 'beforeSend';\n      var beforeSendProcessor = options[beforeSendProcessorName];\n\n      // 1.0 === 100% events are sent\n      // 0.0 === 0% events are sent\n      // Sampling for transaction happens somewhere else\n      if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n        this.recordDroppedEvent('sample_rate', 'error');\n        return rejectedSyncPromise(new SentryError(\"Discarding event because it's not included in the random sample (sampling rate = \".concat(sampleRate, \")\"), 'log'));\n      }\n      return this._prepareEvent(event, hint, scope).then(function (prepared) {\n        if (prepared === null) {\n          _this6.recordDroppedEvent('event_processor', event.type || 'error');\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n        var isInternalException = hint.data && hint.data.__sentry__ === true;\n        if (isInternalException || !beforeSendProcessor) {\n          return prepared;\n        }\n        var beforeSendResult = beforeSendProcessor(prepared, hint);\n        return _validateBeforeSendResult(beforeSendResult, beforeSendProcessorName);\n      }).then(function (processedEvent) {\n        if (processedEvent === null) {\n          _this6.recordDroppedEvent('before_send', event.type || 'error');\n          throw new SentryError(\"`\".concat(beforeSendProcessorName, \"` returned `null`, will not send event.\"), 'log');\n        }\n        var session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          _this6._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        var transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          var source = 'custom';\n          processedEvent.transaction_info = _objectSpread(_objectSpread({}, transactionInfo), {}, {\n            source: source,\n            changes: [].concat(_toConsumableArray(transactionInfo.changes), [{\n              source: source,\n              // use the same timestamp as the processed event.\n              timestamp: processedEvent.timestamp,\n              propagations: transactionInfo.propagations\n            }])\n          });\n        }\n        _this6.sendEvent(processedEvent, hint);\n        return processedEvent;\n      }).then(null, function (reason) {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n        _this6.captureException(reason, {\n          data: {\n            __sentry__: true\n          },\n          originalException: reason\n        });\n        throw new SentryError(\"Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: \".concat(reason));\n      });\n    }\n\n    /**\n     * Occupies the client with processing and event\n     */\n  }, {\n    key: \"_process\",\n    value: function _process(promise) {\n      var _this7 = this;\n      this._numProcessing += 1;\n      void promise.then(function (value) {\n        _this7._numProcessing -= 1;\n        return value;\n      }, function (reason) {\n        _this7._numProcessing -= 1;\n        return reason;\n      });\n    }\n\n    /**\n     * @inheritdoc\n     */\n  }, {\n    key: \"_sendEnvelope\",\n    value: function _sendEnvelope(envelope) {\n      if (this._transport && this._dsn) {\n        this._transport.send(envelope).then(null, function (reason) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Error while sending event:', reason);\n        });\n      } else {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Transport disabled');\n      }\n    }\n\n    /**\n     * Clears outcomes on this client and returns them.\n     */\n  }, {\n    key: \"_clearOutcomes\",\n    value: function _clearOutcomes() {\n      var outcomes = this._outcomes;\n      this._outcomes = {};\n      return Object.keys(outcomes).map(function (key) {\n        var _key$split = key.split(':'),\n          _key$split2 = _slicedToArray(_key$split, 2),\n          reason = _key$split2[0],\n          category = _key$split2[1];\n        return {\n          reason: reason,\n          category: category,\n          quantity: outcomes[key]\n        };\n      });\n    }\n\n    /**\n     * @inheritDoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  }]);\n  return BaseClient;\n}();\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(beforeSendResult, beforeSendProcessorName) {\n  var invalidValueError = \"`\".concat(beforeSendProcessorName, \"` must return `null` or a valid event.\");\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(function (event) {\n      if (!isPlainObject(event) && event !== null) {\n        throw new SentryError(invalidValueError);\n      }\n      return event;\n    }, function (e) {\n      throw new SentryError(\"`\".concat(beforeSendProcessorName, \"` rejected with \").concat(e));\n    });\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\nexport { BaseClient };","map":{"version":3,"sources":["../../src/baseclient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport {\n  Client,\n  ClientOptions,\n  DataCategory,\n  DsnComponents,\n  Envelope,\n  Event,\n  EventDropReason,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Outcome,\n  Session,\n  SessionAggregates,\n  Severity,\n  SeverityLevel,\n  Transport,\n} from '@sentry/types';\nimport {\n  addItemToEnvelope,\n  checkOrSetAlreadyCaught,\n  createAttachmentEnvelopeItem,\n  dateTimestampInSeconds,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  normalize,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  SentryError,\n  SyncPromise,\n  truncate,\n  uuid4,\n} from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope';\nimport { IntegrationIndex, setupIntegrations } from './integration';\nimport { Scope } from './scope';\nimport { updateSession } from './session';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<O extends ClientOptions> implements Client<O> {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  protected readonly _transport?: Transport;\n\n  /** Array of set up integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Indicates whether this client's integrations have been set up. */\n  protected _integrationsInitialized: boolean = false;\n\n  /** Number of calls being processed */\n  protected _numProcessing: number = 0;\n\n  /** Holds flushable  */\n  private _outcomes: { [key: string]: number } = {};\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  protected constructor(options: O) {\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    } else {\n      __DEBUG_BUILD__ && logger.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      __DEBUG_BUILD__ && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(\n    message: string,\n    // eslint-disable-next-line deprecation/deprecation\n    level?: Severity | SeverityLevel,\n    hint?: EventHint,\n    scope?: Scope,\n  ): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(String(message), level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      __DEBUG_BUILD__ && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!this._isEnabled()) {\n      __DEBUG_BUILD__ && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      __DEBUG_BUILD__ && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    const transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n  public getIntegrationById(integrationId: string): Integration | undefined {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      __DEBUG_BUILD__ && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event, hint: EventHint = {}): void {\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n      for (const attachment of hint.attachments || []) {\n        env = addItemToEnvelope(\n          env,\n          createAttachmentEnvelopeItem(\n            attachment,\n            this._options.transportOptions && this._options.transportOptions.textEncoder,\n          ),\n        );\n      }\n\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): void {\n    if (this._dsn) {\n      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordDroppedEvent(reason: EventDropReason, category: DataCategory): void {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      __DEBUG_BUILD__ && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event | null> {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = this.getOptions();\n    const prepared: Event = {\n      ...event,\n      event_id: event.event_id || hint.event_id || uuid4(),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = resolvedSyncPromise<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // Collect attachments from the hint and scope\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n    if (!event) {\n      return null;\n    }\n\n    const normalized: Event = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth),\n      }),\n    };\n\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace && normalized.contexts) {\n      normalized.contexts.trace = event.contexts.trace;\n\n      // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n      if (event.contexts.trace.data) {\n        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n      }\n    }\n\n    // event.spans[].data may contain circular/dangerous data so we need to normalize it\n    if (event.spans) {\n      normalized.spans = event.spans.map(span => {\n        // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n        if (span.data) {\n          span.data = normalize(span.data, depth, maxBreadth);\n        }\n        return span;\n      });\n    }\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  protected _applyClientOptions(event: Event): void {\n    const options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n  protected _applyIntegrationsMetadata(event: Event): void {\n    const integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint: EventHint = {}, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (__DEBUG_BUILD__) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          const sentryError = reason as SentryError;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event> {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n\n    const isTransaction = event.type === 'transaction';\n    const beforeSendProcessorName = isTransaction ? 'beforeSendTransaction' : 'beforeSend';\n    const beforeSendProcessor = options[beforeSendProcessorName];\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, hint, scope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', event.type || 'error');\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n\n        const isInternalException = hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException || !beforeSendProcessor) {\n          return prepared;\n        }\n\n        const beforeSendResult = beforeSendProcessor(prepared, hint);\n        return _validateBeforeSendResult(beforeSendResult, beforeSendProcessorName);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', event.type || 'error');\n          throw new SentryError(`\\`${beforeSendProcessorName}\\` returned \\`null\\`, will not send event.`, 'log');\n        }\n\n        const session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n            changes: [\n              ...transactionInfo.changes,\n              {\n                source,\n                // use the same timestamp as the processed event.\n                timestamp: processedEvent.timestamp as number,\n                propagations: transactionInfo.propagations,\n              },\n            ],\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason as Error,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing += 1;\n    void promise.then(\n      value => {\n        this._numProcessing -= 1;\n        return value;\n      },\n      reason => {\n        this._numProcessing -= 1;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected _sendEnvelope(envelope: Envelope): void {\n    if (this._transport && this._dsn) {\n      this._transport.send(envelope).then(null, reason => {\n        __DEBUG_BUILD__ && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      __DEBUG_BUILD__ && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  protected _clearOutcomes(): Outcome[] {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') as [EventDropReason, DataCategory];\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public abstract eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;\n\n  /**\n   * @inheritDoc\n   */\n  public abstract eventFromMessage(\n    _message: string,\n    // eslint-disable-next-line deprecation/deprecation\n    _level?: Severity | SeverityLevel,\n    _hint?: EventHint,\n  ): PromiseLike<Event>;\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult: PromiseLike<Event | null> | Event | null,\n  beforeSendProcessorName: 'beforeSend' | 'beforeSendTransaction',\n): PromiseLike<Event | null> | Event | null {\n  const invalidValueError = `\\`${beforeSendProcessorName}\\` must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw new SentryError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`\\`${beforeSendProcessorName}\\` rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n"]},"metadata":{},"sourceType":"module"}