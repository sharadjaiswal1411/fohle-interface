{"ast":null,"code":"'use strict';\n\nvar trim = require('trim-trailing-lines');\nmodule.exports = fencedCode;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n    subvalue += character;\n    index++;\n  }\n  indent = index;\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n  while (index < length) {\n    character = value.charAt(index);\n    if (character !== marker) {\n      break;\n    }\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  flag = '';\n  queue = '';\n  while (index < length) {\n    character = value.charAt(index);\n    if (character === C_NEWLINE || character === C_TILDE || character === C_TICK) {\n      break;\n    }\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n    index++;\n  }\n  character = value.charAt(index);\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n  if (silent) {\n    return true;\n  }\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n  if (queue) {\n    subvalue += queue;\n  }\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n    queue = '';\n    index++;\n    while (index < length) {\n      character = value.charAt(index);\n      if (character !== C_SPACE) {\n        break;\n      }\n      queue += character;\n      index++;\n    }\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n    queue = '';\n    while (index < length) {\n      character = value.charAt(index);\n      if (character !== marker) {\n        break;\n      }\n      queue += character;\n      index++;\n    }\n    closing += queue;\n    exdentedClosing += queue;\n    if (queue.length < fenceCount) {\n      continue;\n    }\n    queue = '';\n    while (index < length) {\n      character = value.charAt(index);\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n  subvalue += content + closing;\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}","map":{"version":3,"names":["trim","require","module","exports","fencedCode","C_NEWLINE","C_TAB","C_SPACE","C_TILDE","C_TICK","MIN_FENCE_COUNT","CODE_INDENT_COUNT","eat","value","silent","self","settings","options","length","index","subvalue","fenceCount","marker","character","flag","queue","content","exdentedContent","closing","exdentedClosing","indent","now","gfm","charAt","column","offset","decode","raw","unescape","slice","type","lang"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"sourcesContent":["'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\n\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_NEWLINE ||\n      character === C_TILDE ||\n      character === C_TICK\n    ) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}