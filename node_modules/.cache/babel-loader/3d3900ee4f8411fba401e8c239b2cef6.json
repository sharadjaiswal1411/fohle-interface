{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/patternProperties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map"]},"metadata":{},"sourceType":"script"}