{"ast":null,"code":"import{arrayify}from'@ethersproject/bytes';import{parseBytes32String}from'@ethersproject/strings';import{Token}from'@uniswap/sdk-core';import{useWeb3React}from'@web3-react/core';import{isSupportedChain}from'constants/chains';import{useBytes32TokenContract,useTokenContract}from'hooks/useContract';import{NEVER_RELOAD,useSingleCallResult}from'lib/hooks/multicall';import useNativeCurrency from'lib/hooks/useNativeCurrency';import{useMemo}from'react';import{DEFAULT_ERC20_DECIMALS}from'../../constants/tokens';import{TOKEN_SHORTHANDS}from'../../constants/tokens';import{isAddress}from'../../utils';import{supportedChainId}from'../../utils/supportedChainId';// parse a name or symbol from a token response\nvar BYTES32_REGEX=/^0x[a-fA-F0-9]{64}$/;function parseStringOrBytes32(str,bytes32,defaultValue){return str&&str.length>0?str:// need to check for proper bytes string and valid terminator\nbytes32&&BYTES32_REGEX.test(bytes32)&&arrayify(bytes32)[31]===0?parseBytes32String(bytes32):defaultValue;}export var UNKNOWN_TOKEN_SYMBOL='UNKNOWN';var UNKNOWN_TOKEN_NAME='Unknown Token';/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */export function useTokenFromActiveNetwork(tokenAddress){var _useWeb3React=useWeb3React(),chainId=_useWeb3React.chainId;var formattedAddress=isAddress(tokenAddress);var tokenContract=useTokenContract(formattedAddress?formattedAddress:undefined,false);var tokenContractBytes32=useBytes32TokenContract(formattedAddress?formattedAddress:undefined,false);// TODO: Fix redux-multicall so that these values do not reload.\nvar tokenName=useSingleCallResult(tokenContract,'name',undefined,NEVER_RELOAD);var tokenNameBytes32=useSingleCallResult(tokenContractBytes32,'name',undefined,NEVER_RELOAD);var symbol=useSingleCallResult(tokenContract,'symbol',undefined,NEVER_RELOAD);var symbolBytes32=useSingleCallResult(tokenContractBytes32,'symbol',undefined,NEVER_RELOAD);var decimals=useSingleCallResult(tokenContract,'decimals',undefined,NEVER_RELOAD);var isLoading=useMemo(function(){return decimals.loading||symbol.loading||tokenName.loading;},[decimals.loading,symbol.loading,tokenName.loading]);var parsedDecimals=useMemo(function(){var _decimals$result$,_decimals$result;return(_decimals$result$=decimals===null||decimals===void 0?void 0:(_decimals$result=decimals.result)===null||_decimals$result===void 0?void 0:_decimals$result[0])!==null&&_decimals$result$!==void 0?_decimals$result$:DEFAULT_ERC20_DECIMALS;},[decimals.result]);var parsedSymbol=useMemo(function(){var _symbol$result,_symbolBytes32$result;return parseStringOrBytes32((_symbol$result=symbol.result)===null||_symbol$result===void 0?void 0:_symbol$result[0],(_symbolBytes32$result=symbolBytes32.result)===null||_symbolBytes32$result===void 0?void 0:_symbolBytes32$result[0],UNKNOWN_TOKEN_SYMBOL);},[symbol.result,symbolBytes32.result]);var parsedName=useMemo(function(){var _tokenName$result,_tokenNameBytes32$res;return parseStringOrBytes32((_tokenName$result=tokenName.result)===null||_tokenName$result===void 0?void 0:_tokenName$result[0],(_tokenNameBytes32$res=tokenNameBytes32.result)===null||_tokenNameBytes32$res===void 0?void 0:_tokenNameBytes32$res[0],UNKNOWN_TOKEN_NAME);},[tokenName.result,tokenNameBytes32.result]);return useMemo(function(){// If the token is on another chain, we cannot fetch it on-chain, and it is invalid.\nif(typeof tokenAddress!=='string'||!isSupportedChain(chainId)||!formattedAddress)return undefined;if(isLoading||!chainId)return null;return new Token(chainId,formattedAddress,parsedDecimals,parsedSymbol,parsedName);},[chainId,tokenAddress,formattedAddress,isLoading,parsedDecimals,parsedSymbol,parsedName]);}/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */export function useTokenFromMapOrNetwork(tokens,tokenAddress){var address=isAddress(tokenAddress);var token=address?tokens[address]:undefined;var tokenFromNetwork=useTokenFromActiveNetwork(token?undefined:address?address:undefined);return tokenFromNetwork!==null&&tokenFromNetwork!==void 0?tokenFromNetwork:token;}/**\n * Returns a Currency from the currencyId.\n * Returns null if currency is loading or null was passed.\n * Returns undefined if currencyId is invalid or token does not exist.\n */export function useCurrencyFromMap(tokens,currencyId){var _wrappedNative$addres;var nativeCurrency=useNativeCurrency();var _useWeb3React2=useWeb3React(),chainId=_useWeb3React2.chainId;var isNative=Boolean(nativeCurrency&&(currencyId===null||currencyId===void 0?void 0:currencyId.toUpperCase())==='ETH');var shorthandMatchAddress=useMemo(function(){var _TOKEN_SHORTHANDS$cur;var chain=supportedChainId(chainId);return chain&&currencyId?(_TOKEN_SHORTHANDS$cur=TOKEN_SHORTHANDS[currencyId.toUpperCase()])===null||_TOKEN_SHORTHANDS$cur===void 0?void 0:_TOKEN_SHORTHANDS$cur[chain]:undefined;},[chainId,currencyId]);var token=useTokenFromMapOrNetwork(tokens,isNative?undefined:shorthandMatchAddress!==null&&shorthandMatchAddress!==void 0?shorthandMatchAddress:currencyId);if(currencyId===null||currencyId===undefined||!isSupportedChain(chainId))return null;// this case so we use our builtin wrapped token instead of wrapped tokens on token lists\nvar wrappedNative=nativeCurrency===null||nativeCurrency===void 0?void 0:nativeCurrency.wrapped;if((wrappedNative===null||wrappedNative===void 0?void 0:(_wrappedNative$addres=wrappedNative.address)===null||_wrappedNative$addres===void 0?void 0:_wrappedNative$addres.toUpperCase())===(currencyId===null||currencyId===void 0?void 0:currencyId.toUpperCase()))return wrappedNative;return isNative?nativeCurrency:token;}","map":{"version":3,"names":["arrayify","parseBytes32String","Token","useWeb3React","isSupportedChain","useBytes32TokenContract","useTokenContract","NEVER_RELOAD","useSingleCallResult","useNativeCurrency","useMemo","DEFAULT_ERC20_DECIMALS","TOKEN_SHORTHANDS","isAddress","supportedChainId","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","UNKNOWN_TOKEN_SYMBOL","UNKNOWN_TOKEN_NAME","useTokenFromActiveNetwork","tokenAddress","chainId","formattedAddress","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","isLoading","loading","parsedDecimals","result","parsedSymbol","parsedName","useTokenFromMapOrNetwork","tokens","address","token","tokenFromNetwork","useCurrencyFromMap","currencyId","nativeCurrency","isNative","Boolean","toUpperCase","shorthandMatchAddress","chain","wrappedNative","wrapped"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useCurrency.ts"],"sourcesContent":["import { arrayify } from '@ethersproject/bytes'\nimport { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport { isSupportedChain } from 'constants/chains'\nimport { useBytes32TokenContract, useTokenContract } from 'hooks/useContract'\nimport { NEVER_RELOAD, useSingleCallResult } from 'lib/hooks/multicall'\nimport useNativeCurrency from 'lib/hooks/useNativeCurrency'\nimport { useMemo } from 'react'\n\nimport { DEFAULT_ERC20_DECIMALS } from '../../constants/tokens'\nimport { TOKEN_SHORTHANDS } from '../../constants/tokens'\nimport { isAddress } from '../../utils'\nimport { supportedChainId } from '../../utils/supportedChainId'\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : // need to check for proper bytes string and valid terminator\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\nexport const UNKNOWN_TOKEN_SYMBOL = 'UNKNOWN'\nconst UNKNOWN_TOKEN_NAME = 'Unknown Token'\n\n/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */\nexport function useTokenFromActiveNetwork(tokenAddress: string | undefined): Token | null | undefined {\n  const { chainId } = useWeb3React()\n\n  const formattedAddress = isAddress(tokenAddress)\n  const tokenContract = useTokenContract(formattedAddress ? formattedAddress : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(formattedAddress ? formattedAddress : undefined, false)\n\n  // TODO: Fix redux-multicall so that these values do not reload.\n  const tokenName = useSingleCallResult(tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(tokenContractBytes32, 'name', undefined, NEVER_RELOAD)\n  const symbol = useSingleCallResult(tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  const isLoading = useMemo(\n    () => decimals.loading || symbol.loading || tokenName.loading,\n    [decimals.loading, symbol.loading, tokenName.loading]\n  )\n  const parsedDecimals = useMemo(() => decimals?.result?.[0] ?? DEFAULT_ERC20_DECIMALS, [decimals.result])\n\n  const parsedSymbol = useMemo(\n    () => parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], UNKNOWN_TOKEN_SYMBOL),\n    [symbol.result, symbolBytes32.result]\n  )\n  const parsedName = useMemo(\n    () => parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], UNKNOWN_TOKEN_NAME),\n    [tokenName.result, tokenNameBytes32.result]\n  )\n\n  return useMemo(() => {\n    // If the token is on another chain, we cannot fetch it on-chain, and it is invalid.\n    if (typeof tokenAddress !== 'string' || !isSupportedChain(chainId) || !formattedAddress) return undefined\n    if (isLoading || !chainId) return null\n\n    return new Token(chainId, formattedAddress, parsedDecimals, parsedSymbol, parsedName)\n  }, [chainId, tokenAddress, formattedAddress, isLoading, parsedDecimals, parsedSymbol, parsedName])\n}\n\ntype TokenMap = { [address: string]: Token }\n\n/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */\nexport function useTokenFromMapOrNetwork(tokens: TokenMap, tokenAddress?: string | null): Token | null | undefined {\n  const address = isAddress(tokenAddress)\n  const token: Token | undefined = address ? tokens[address] : undefined\n  const tokenFromNetwork = useTokenFromActiveNetwork(token ? undefined : address ? address : undefined)\n\n  return tokenFromNetwork ?? token\n}\n\n/**\n * Returns a Currency from the currencyId.\n * Returns null if currency is loading or null was passed.\n * Returns undefined if currencyId is invalid or token does not exist.\n */\nexport function useCurrencyFromMap(tokens: TokenMap, currencyId?: string | null): Currency | null | undefined {\n  const nativeCurrency = useNativeCurrency()\n  const { chainId } = useWeb3React()\n  const isNative = Boolean(nativeCurrency && currencyId?.toUpperCase() === 'ETH')\n  const shorthandMatchAddress = useMemo(() => {\n    const chain = supportedChainId(chainId)\n    return chain && currencyId ? TOKEN_SHORTHANDS[currencyId.toUpperCase()]?.[chain] : undefined\n  }, [chainId, currencyId])\n\n  const token = useTokenFromMapOrNetwork(tokens, isNative ? undefined : shorthandMatchAddress ?? currencyId)\n\n  if (currencyId === null || currencyId === undefined || !isSupportedChain(chainId)) return null\n\n  // this case so we use our builtin wrapped token instead of wrapped tokens on token lists\n  const wrappedNative = nativeCurrency?.wrapped\n  if (wrappedNative?.address?.toUpperCase() === currencyId?.toUpperCase()) return wrappedNative\n\n  return isNative ? nativeCurrency : token\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}