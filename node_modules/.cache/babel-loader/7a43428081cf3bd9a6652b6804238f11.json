{"ast":null,"code":"import { tickToPrice } from '@uniswap/v3-sdk';\nimport JSBI from 'jsbi';\nconst PRICE_FIXED_DIGITS = 8;\n\n// Computes the numSurroundingTicks above or below the active tick.\nexport default function computeSurroundingTicks(token0, token1, activeTickProcessed, sortedTickData, pivot, ascending) {\n  let previousTickProcessed = {\n    ...activeTickProcessed\n  };\n  // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n  let processedTicks = [];\n  for (let i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    const tick = Number(sortedTickData[i].tick);\n    const currentTickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tick,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tick).toFixed(PRICE_FIXED_DIGITS)\n    };\n\n    // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(previousTickProcessed.liquidityActive, JSBI.BigInt(sortedTickData[i].liquidityNet));\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(previousTickProcessed.liquidityActive, previousTickProcessed.liquidityNet);\n    }\n    processedTicks.push(currentTickProcessed);\n    previousTickProcessed = currentTickProcessed;\n  }\n  if (!ascending) {\n    processedTicks = processedTicks.reverse();\n  }\n  return processedTicks;\n}","map":{"version":3,"names":["tickToPrice","JSBI","PRICE_FIXED_DIGITS","computeSurroundingTicks","token0","token1","activeTickProcessed","sortedTickData","pivot","ascending","previousTickProcessed","processedTicks","i","length","tick","Number","currentTickProcessed","liquidityActive","liquidityNet","BigInt","price0","toFixed","add","notEqual","subtract","push","reverse"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/utils/computeSurroundingTicks.ts"],"sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { tickToPrice } from '@uniswap/v3-sdk'\nimport { TickProcessed } from 'hooks/usePoolTickData'\nimport JSBI from 'jsbi'\n\nimport { Ticks } from '../graphql/thegraph/AllV3TicksQuery'\n\nconst PRICE_FIXED_DIGITS = 8\n\n// Computes the numSurroundingTicks above or below the active tick.\nexport default function computeSurroundingTicks(\n  token0: Token,\n  token1: Token,\n  activeTickProcessed: TickProcessed,\n  sortedTickData: Ticks,\n  pivot: number,\n  ascending: boolean\n): TickProcessed[] {\n  let previousTickProcessed: TickProcessed = {\n    ...activeTickProcessed,\n  }\n  // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n  let processedTicks: TickProcessed[] = []\n  for (let i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    const tick = Number(sortedTickData[i].tick)\n    const currentTickProcessed: TickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tick,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tick).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(\n        previousTickProcessed.liquidityActive,\n        JSBI.BigInt(sortedTickData[i].liquidityNet)\n      )\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(\n        previousTickProcessed.liquidityActive,\n        previousTickProcessed.liquidityNet\n      )\n    }\n\n    processedTicks.push(currentTickProcessed)\n    previousTickProcessed = currentTickProcessed\n  }\n\n  if (!ascending) {\n    processedTicks = processedTicks.reverse()\n  }\n\n  return processedTicks\n}\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,iBAAiB;AAE7C,OAAOC,IAAI,MAAM,MAAM;AAIvB,MAAMC,kBAAkB,GAAG,CAAC;;AAE5B;AACA,eAAe,SAASC,uBAAuB,CAC7CC,MAAa,EACbC,MAAa,EACbC,mBAAkC,EAClCC,cAAqB,EACrBC,KAAa,EACbC,SAAkB,EACD;EACjB,IAAIC,qBAAoC,GAAG;IACzC,GAAGJ;EACL,CAAC;EACD;EACA;EACA,IAAIK,cAA+B,GAAG,EAAE;EACxC,KAAK,IAAIC,CAAC,GAAGJ,KAAK,IAAIC,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAEA,SAAS,GAAGG,CAAC,GAAGL,cAAc,CAACM,MAAM,GAAGD,CAAC,IAAI,CAAC,EAAEH,SAAS,GAAGG,CAAC,EAAE,GAAGA,CAAC,EAAE,EAAE;IAChH,MAAME,IAAI,GAAGC,MAAM,CAACR,cAAc,CAACK,CAAC,CAAC,CAACE,IAAI,CAAC;IAC3C,MAAME,oBAAmC,GAAG;MAC1CC,eAAe,EAAEP,qBAAqB,CAACO,eAAe;MACtDH,IAAI;MACJI,YAAY,EAAEjB,IAAI,CAACkB,MAAM,CAACZ,cAAc,CAACK,CAAC,CAAC,CAACM,YAAY,CAAC;MACzDE,MAAM,EAAEpB,WAAW,CAACI,MAAM,EAAEC,MAAM,EAAES,IAAI,CAAC,CAACO,OAAO,CAACnB,kBAAkB;IACtE,CAAC;;IAED;IACA;IACA;IACA;IACA,IAAIO,SAAS,EAAE;MACbO,oBAAoB,CAACC,eAAe,GAAGhB,IAAI,CAACqB,GAAG,CAC7CZ,qBAAqB,CAACO,eAAe,EACrChB,IAAI,CAACkB,MAAM,CAACZ,cAAc,CAACK,CAAC,CAAC,CAACM,YAAY,CAAC,CAC5C;IACH,CAAC,MAAM,IAAI,CAACT,SAAS,IAAIR,IAAI,CAACsB,QAAQ,CAACb,qBAAqB,CAACQ,YAAY,EAAEjB,IAAI,CAACkB,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;MAC1F;MACAH,oBAAoB,CAACC,eAAe,GAAGhB,IAAI,CAACuB,QAAQ,CAClDd,qBAAqB,CAACO,eAAe,EACrCP,qBAAqB,CAACQ,YAAY,CACnC;IACH;IAEAP,cAAc,CAACc,IAAI,CAACT,oBAAoB,CAAC;IACzCN,qBAAqB,GAAGM,oBAAoB;EAC9C;EAEA,IAAI,CAACP,SAAS,EAAE;IACdE,cAAc,GAAGA,cAAc,CAACe,OAAO,EAAE;EAC3C;EAEA,OAAOf,cAAc;AACvB"},"metadata":{},"sourceType":"module"}