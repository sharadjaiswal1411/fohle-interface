{"ast":null,"code":"import { Pair } from '@uniswap/v2-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2/factories/IUniswapV2Pair__factory';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V2PoolProvider {\n  /**\n   * Creates an instance of V2PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  constructor(chainId, multicall2Provider) {\n    let retryOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      retries: 2,\n      minTimeout: 50,\n      maxTimeout: 500\n    };\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n    this.POOL_ADDRESS_CACHE = {};\n  }\n  async getPools(tokenPairs, providerConfig) {\n    const poolAddressSet = new Set();\n    const sortedTokenPairs = [];\n    const sortedPoolAddresses = [];\n    for (const tokenPair of tokenPairs) {\n      const [tokenA, tokenB] = tokenPair;\n      const {\n        poolAddress,\n        token0,\n        token1\n      } = this.getPoolAddress(tokenA, tokenB);\n      if (poolAddressSet.has(poolAddress)) {\n        continue;\n      }\n      poolAddressSet.add(poolAddress);\n      sortedTokenPairs.push([token0, token1]);\n      sortedPoolAddresses.push(poolAddress);\n    }\n    log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n    const reservesResults = await this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n    log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.` : ``}`);\n    const poolAddressToPool = {};\n    const invalidPools = [];\n    for (let i = 0; i < sortedPoolAddresses.length; i++) {\n      const reservesResult = reservesResults[i];\n      if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {\n        const [token0, token1] = sortedTokenPairs[i];\n        invalidPools.push([token0, token1]);\n        continue;\n      }\n      const [token0, token1] = sortedTokenPairs[i];\n      const {\n        reserve0,\n        reserve1\n      } = reservesResult.result;\n      const pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n      const poolAddress = sortedPoolAddresses[i];\n      poolAddressToPool[poolAddress] = pool;\n    }\n    if (invalidPools.length > 0) {\n      log.info({\n        invalidPools: _.map(invalidPools, _ref => {\n          let [token0, token1] = _ref;\n          return `${token0.symbol}/${token1.symbol}`;\n        })\n      }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n    }\n    const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n    log.debug({\n      poolStrs\n    }, `Found ${poolStrs.length} valid pools`);\n    return {\n      getPool: (tokenA, tokenB) => {\n        const {\n          poolAddress\n        } = this.getPoolAddress(tokenA, tokenB);\n        return poolAddressToPool[poolAddress];\n      },\n      getPoolByAddress: address => poolAddressToPool[address],\n      getAllPools: () => Object.values(poolAddressToPool)\n    };\n  }\n  getPoolAddress(tokenA, tokenB) {\n    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n    const cacheKey = `${this.chainId}/${token0.address}/${token1.address}`;\n    const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n    if (cachedAddress) {\n      return {\n        poolAddress: cachedAddress,\n        token0,\n        token1\n      };\n    }\n    const poolAddress = Pair.getAddress(token0, token1);\n    this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n    return {\n      poolAddress,\n      token0,\n      token1\n    };\n  }\n  async getPoolsData(poolAddresses, functionName, providerConfig) {\n    const {\n      results,\n      blockNumber\n    } = await retry(async () => {\n      return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n        addresses: poolAddresses,\n        contractInterface: IUniswapV2Pair__factory.createInterface(),\n        functionName: functionName,\n        providerConfig\n      });\n    }, this.retryOptions);\n    log.debug(`Pool data fetched as of block ${blockNumber}`);\n    return results;\n  }\n}","map":{"version":3,"sources":["../../../../src/providers/v2/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Pair } from '@uniswap/v2-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2/factories/IUniswapV2Pair__factory';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V2PoolProvider {\n    /**\n     * Creates an instance of V2PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (const tokenPair of tokenPairs) {\n            const [tokenA, tokenB] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const reservesResults = await this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n        log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const reservesResult = reservesResults[i];\n            if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {\n                const [token0, token1] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1]);\n                continue;\n            }\n            const [token0, token1] = sortedTokenPairs[i];\n            const { reserve0, reserve1 } = reservesResult.result;\n            const pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1]) => `${token0.symbol}/${token1.symbol}`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = Pair.getAddress(token0, token1);\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV2Pair__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjIvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxLQUFrQyxNQUFNLGFBQWEsQ0FBQztBQUM3RCxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFFdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sa0RBQWtELENBQUM7QUFDM0YsT0FBTyxFQUFXLGNBQWMsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNyRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBa0RqRCxNQUFNLE9BQU8sY0FBYztJQUt6Qjs7Ozs7T0FLRztJQUNILFlBQ1ksT0FBZ0IsRUFDaEIsa0JBQXNDLEVBQ3RDLGVBQW1DO1FBQzNDLE9BQU8sRUFBRSxDQUFDO1FBQ1YsVUFBVSxFQUFFLEVBQUU7UUFDZCxVQUFVLEVBQUUsR0FBRztLQUNoQjtRQU5TLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxpQkFBWSxHQUFaLFlBQVksQ0FJckI7UUFqQkgseUVBQXlFO1FBQ3pFLGtEQUFrRDtRQUMxQyx1QkFBa0IsR0FBOEIsRUFBRSxDQUFDO0lBZ0J4RCxDQUFDO0lBRUcsS0FBSyxDQUFDLFFBQVEsQ0FDbkIsVUFBNEIsRUFDNUIsY0FBK0I7UUFFL0IsTUFBTSxjQUFjLEdBQWdCLElBQUksR0FBRyxFQUFVLENBQUM7UUFDdEQsTUFBTSxnQkFBZ0IsR0FBMEIsRUFBRSxDQUFDO1FBQ25ELE1BQU0sbUJBQW1CLEdBQWEsRUFBRSxDQUFDO1FBRXpDLEtBQUssTUFBTSxTQUFTLElBQUksVUFBVSxFQUFFO1lBQ2xDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEdBQUcsU0FBUyxDQUFDO1lBRW5DLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQ3pELE1BQU0sRUFDTixNQUFNLENBQ1AsQ0FBQztZQUVGLElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDbkMsU0FBUzthQUNWO1lBRUQsY0FBYyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNoQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUN4QyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDdkM7UUFFRCxHQUFHLENBQUMsS0FBSyxDQUNQLHdCQUF3QixVQUFVLENBQUMsTUFBTSxpQ0FBaUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUNoRyxDQUFDO1FBRUYsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUM3QyxtQkFBbUIsRUFDbkIsYUFBYSxFQUNiLGNBQWMsQ0FDZixDQUFDO1FBRUYsR0FBRyxDQUFDLElBQUksQ0FDTixvQkFBb0IsY0FBYyxDQUFDLElBQUksVUFDckMsQ0FBQSxjQUFjLGFBQWQsY0FBYyx1QkFBZCxjQUFjLENBQUUsV0FBVztZQUN6QixDQUFDLENBQUMsZ0JBQWdCLE1BQU0sQ0FBQSxjQUFjLGFBQWQsY0FBYyx1QkFBZCxjQUFjLENBQUUsV0FBVyxDQUFBLEdBQUc7WUFDdEQsQ0FBQyxDQUFDLEVBQ04sRUFBRSxDQUNILENBQUM7UUFFRixNQUFNLGlCQUFpQixHQUFvQyxFQUFFLENBQUM7UUFFOUQsTUFBTSxZQUFZLEdBQXFCLEVBQUUsQ0FBQztRQUUxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ25ELE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUUsQ0FBQztZQUUzQyxJQUFJLENBQUMsQ0FBQSxjQUFjLGFBQWQsY0FBYyx1QkFBZCxjQUFjLENBQUUsT0FBTyxDQUFBLEVBQUU7Z0JBQzVCLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFFLENBQUM7Z0JBQzlDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFFcEMsU0FBUzthQUNWO1lBRUQsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUUsQ0FBQztZQUM5QyxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUM7WUFFckQsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQ25CLGNBQWMsQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUN6RCxjQUFjLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDMUQsQ0FBQztZQUVGLE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBRSxDQUFDO1lBRTVDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztTQUN2QztRQUVELElBQUksWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDM0IsR0FBRyxDQUFDLElBQUksQ0FDTjtnQkFDRSxZQUFZLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDakIsWUFBWSxFQUNaLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFLENBQzFEO2FBQ0YsRUFDRCxHQUFHLFlBQVksQ0FBQyxNQUFNLDRFQUE0RSxDQUNuRyxDQUFDO1NBQ0g7UUFFRCxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUV2RSxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsU0FBUyxRQUFRLENBQUMsTUFBTSxjQUFjLENBQUMsQ0FBQztRQUVoRSxPQUFPO1lBQ0wsT0FBTyxFQUFFLENBQUMsTUFBYSxFQUFFLE1BQWEsRUFBb0IsRUFBRTtnQkFDMUQsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM1RCxPQUFPLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3hDLENBQUM7WUFDRCxnQkFBZ0IsRUFBRSxDQUFDLE9BQWUsRUFBb0IsRUFBRSxDQUN0RCxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7WUFDNUIsV0FBVyxFQUFFLEdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUM7U0FDNUQsQ0FBQztJQUNKLENBQUM7SUFFTSxjQUFjLENBQ25CLE1BQWEsRUFDYixNQUFhO1FBRWIsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztZQUNqRCxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO1lBQ2xCLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVyQixNQUFNLFFBQVEsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLE9BQU8sSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFdkUsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXhELElBQUksYUFBYSxFQUFFO1lBQ2pCLE9BQU8sRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUN2RDtRQUVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUM7UUFFaEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUM7SUFDekMsQ0FBQztJQUVPLEtBQUssQ0FBQyxZQUFZLENBQ3hCLGFBQXVCLEVBQ3ZCLFlBQW9CLEVBQ3BCLGNBQStCO1FBRS9CLE1BQU0sRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEdBQUcsTUFBTSxLQUFLLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDdEQsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsbUNBQW1DLENBR2hFO2dCQUNBLFNBQVMsRUFBRSxhQUFhO2dCQUN4QixpQkFBaUIsRUFBRSx1QkFBdUIsQ0FBQyxlQUFlLEVBQUU7Z0JBQzVELFlBQVksRUFBRSxZQUFZO2dCQUMxQixjQUFjO2FBQ2YsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUV0QixHQUFHLENBQUMsS0FBSyxDQUFDLGlDQUFpQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBRTFELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7Q0FDRiJ9"]},"metadata":{},"sourceType":"module"}