{"ast":null,"code":"/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n  MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n  MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n  MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n  MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\nexports.getPointerArray = function (size) {\n  var maxIndex = size - 1;\n  if (maxIndex <= MAX_8BIT_INTEGER) return Uint8Array;\n  if (maxIndex <= MAX_16BIT_INTEGER) return Uint16Array;\n  if (maxIndex <= MAX_32BIT_INTEGER) return Uint32Array;\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\nexports.getSignedPointerArray = function (size) {\n  var maxIndex = size - 1;\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER) return Int8Array;\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER) return Int16Array;\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER) return Int32Array;\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function (value) {\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128) return Int8Array;\n      if (value <= 32767 && value >= -32768) return Int16Array;\n      return Int32Array;\n    } else {\n      if (value <= 255) return Uint8Array;\n      if (value <= 65535) return Uint16Array;\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function (array, getter) {\n  var maxType = null,\n    maxPriority = 0,\n    p,\n    t,\n    v,\n    i,\n    l;\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function (value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function () {\n  var length = 0,\n    i,\n    o,\n    l;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    length += arguments[i].length;\n  }\n  var array = new arguments[0].constructor(length);\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function (length) {\n  var PointerArray = exports.getPointerArray(length);\n  var array = new PointerArray(length);\n  for (var i = 0; i < length; i++) {\n    array[i] = i;\n  }\n  return array;\n};","map":{"version":3,"names":["MAX_8BIT_INTEGER","Math","pow","MAX_16BIT_INTEGER","MAX_32BIT_INTEGER","MAX_SIGNED_8BIT_INTEGER","MAX_SIGNED_16BIT_INTEGER","MAX_SIGNED_32BIT_INTEGER","exports","getPointerArray","size","maxIndex","Uint8Array","Uint16Array","Uint32Array","Error","getSignedPointerArray","Int8Array","Int16Array","Int32Array","Float64Array","getNumberType","value","sign","TYPE_PRIORITY","Float32Array","getMinimalRepresentation","array","getter","maxType","maxPriority","p","t","v","i","l","length","name","isTypedArray","ArrayBuffer","isView","concat","o","arguments","constructor","set","indices","PointerArray"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/mnemonist/utils/typed-arrays.js"],"sourcesContent":["/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}