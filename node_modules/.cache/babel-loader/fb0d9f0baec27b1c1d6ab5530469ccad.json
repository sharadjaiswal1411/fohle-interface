{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { Trans } from \"@lingui/react\";\nimport { CurrencyAmount, Price, Rounding } from '@uniswap/sdk-core';\nimport { encodeSqrtRatioX96, nearestUsableTick, Pool, Position, priceToClosestTick, TICK_SPACINGS, TickMath, tickToPrice } from '@uniswap/v3-sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { usePool } from 'hooks/usePools';\nimport JSBI from 'jsbi';\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount';\nimport { useCallback, useMemo } from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { getTickToPrice } from 'utils/getTickToPrice';\nimport { replaceURLParam } from 'utils/routes';\nimport { BIG_INT_ZERO } from '../../../constants/misc';\nimport { PoolState } from '../../../hooks/usePools';\nimport { useCurrencyBalances } from '../../connection/hooks';\nimport { Bound, Field, setFullRange, typeInput, typeLeftRangeInput, typeRightRangeInput, typeStartPriceInput } from './actions';\nimport { tryParseTick } from './utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function useV3MintState() {\n  _s();\n  return useAppSelector(state => state.mintV3);\n}\n_s(useV3MintState, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\nexport function useV3MintActionHandlers(noLiquidity) {\n  _s2();\n  const dispatch = useAppDispatch();\n  const navigate = useNavigate();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const {\n    search\n  } = useLocation();\n  const onLeftRangeInput = useCallback(typedValue => {\n    dispatch(typeLeftRangeInput({\n      typedValue\n    }));\n    navigate({\n      search: replaceURLParam(search, 'minPrice', typedValue)\n    }, {\n      replace: true\n    });\n  }, [dispatch, navigate, search]);\n  const onRightRangeInput = useCallback(typedValue => {\n    dispatch(typeRightRangeInput({\n      typedValue\n    }));\n    navigate({\n      search: replaceURLParam(search, 'maxPrice', typedValue)\n    }, {\n      replace: true\n    });\n  }, [dispatch, navigate, search]);\n  const onStartPriceInput = useCallback(typedValue => {\n    dispatch(typeStartPriceInput({\n      typedValue\n    }));\n  }, [dispatch]);\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput\n  };\n}\n_s2(useV3MintActionHandlers, \"CRSbb1tZNncPhMu/SIX1I7eStws=\", false, function () {\n  return [useAppDispatch, useNavigate, useLocation];\n});\nexport function useV3DerivedMintInfo(currencyA, currencyB, feeAmount, baseCurrency,\n// override for existing position\nexistingPosition) {\n  _s3();\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n  const {\n    account\n  } = useWeb3React();\n  const {\n    independentField,\n    typedValue,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    startPriceTypedValue\n  } = useV3MintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\n\n  // currencies\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA,\n    [Field.CURRENCY_B]: currencyB\n  }), [currencyA, currencyB]);\n\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(() => [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped], [currencyA, currencyB, baseCurrency]);\n  const [token0, token1] = useMemo(() => tokenA && tokenB ? tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] : [undefined, undefined], [tokenA, tokenB]);\n\n  // balances\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies]));\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  };\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount);\n  const noLiquidity = poolState === PoolState.NOT_EXISTS;\n\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0));\n\n  // always returns the price with 0 as base token\n  const price = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseCurrencyAmount(startPriceTypedValue, invertPrice ? token0 : token1);\n      if (parsedQuoteAmount && token0 && token1) {\n        var _ref;\n        const baseAmount = tryParseCurrencyAmount('1', invertPrice ? token1 : token0);\n        const price = baseAmount && parsedQuoteAmount ? new Price(baseAmount.currency, parsedQuoteAmount.currency, baseAmount.quotient, parsedQuoteAmount.quotient) : undefined;\n        return (_ref = invertPrice ? price === null || price === void 0 ? void 0 : price.invert() : price) !== null && _ref !== void 0 ? _ref : undefined;\n      }\n      return undefined;\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined;\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool]);\n\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined;\n    return price && sqrtRatioX96 && !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO));\n  }, [price]);\n\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price);\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, []);\n    } else {\n      return undefined;\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB]);\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition = pool !== null && pool !== void 0 ? pool : mockPool;\n\n  // lower and upper limits in the tick space for `feeAmoun<Trans>\n  const tickSpaceLimits = useMemo(() => ({\n    [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined\n  }), [feeAmount]);\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks = useMemo(() => {\n    return {\n      [Bound.LOWER]: typeof (existingPosition === null || existingPosition === void 0 ? void 0 : existingPosition.tickLower) === 'number' ? existingPosition.tickLower : invertPrice && typeof rightRangeTypedValue === 'boolean' || !invertPrice && typeof leftRangeTypedValue === 'boolean' ? tickSpaceLimits[Bound.LOWER] : invertPrice ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString()) : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]: typeof (existingPosition === null || existingPosition === void 0 ? void 0 : existingPosition.tickUpper) === 'number' ? existingPosition.tickUpper : !invertPrice && typeof rightRangeTypedValue === 'boolean' || invertPrice && typeof leftRangeTypedValue === 'boolean' ? tickSpaceLimits[Bound.UPPER] : invertPrice ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString()) : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString())\n    };\n  }, [existingPosition, feeAmount, invertPrice, leftRangeTypedValue, rightRangeTypedValue, token0, token1, tickSpaceLimits]);\n  const {\n    [Bound.LOWER]: tickLower,\n    [Bound.UPPER]: tickUpper\n  } = ticks || {};\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(() => ({\n    [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n    [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER\n  }), [tickSpaceLimits, tickLower, tickUpper, feeAmount]);\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper);\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER])\n    };\n  }, [token0, token1, ticks]);\n  const {\n    [Bound.LOWER]: lowerPrice,\n    [Bound.UPPER]: upperPrice\n  } = pricesAtTicks;\n\n  // liquidity range warning\n  const outOfRange = Boolean(!invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice)));\n\n  // amounts\n  const independentAmount = tryParseCurrencyAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n    if (independentAmount && wrappedIndependentAmount && typeof tickLower === 'number' && typeof tickUpper === 'number' && poolForPosition) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined;\n      }\n      const position = wrappedIndependentAmount.currency.equals(poolForPosition.token0) ? Position.fromAmount0({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0: independentAmount.quotient,\n        useFullPrecision: true // we want full precision for the theoretical position\n      }) : Position.fromAmount1({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount1: independentAmount.quotient\n      });\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0) ? position.amount1 : position.amount0;\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient);\n    }\n    return undefined;\n  }, [independentAmount, outOfRange, dependentField, currencyB, currencyA, tickLower, tickUpper, poolForPosition, invalidRange]);\n  const parsedAmounts = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper);\n  const deposit1Disabled = Boolean(typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower);\n\n  // sorted for token order\n  const depositADisabled = invalidRange || Boolean(deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA) || deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA));\n  const depositBDisabled = invalidRange || Boolean(deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB) || deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB));\n\n  // create position entity based on users selection\n  const position = useMemo(() => {\n    var _parsedAmounts, _parsedAmounts2;\n    if (!poolForPosition || !tokenA || !tokenB || typeof tickLower !== 'number' || typeof tickUpper !== 'number' || invalidRange) {\n      return undefined;\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled ? parsedAmounts === null || parsedAmounts === void 0 ? void 0 : (_parsedAmounts = parsedAmounts[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]) === null || _parsedAmounts === void 0 ? void 0 : _parsedAmounts.quotient : BIG_INT_ZERO;\n    const amount1 = !deposit1Disabled ? parsedAmounts === null || parsedAmounts === void 0 ? void 0 : (_parsedAmounts2 = parsedAmounts[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]) === null || _parsedAmounts2 === void 0 ? void 0 : _parsedAmounts2.quotient : BIG_INT_ZERO;\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true // we want full precision for the theoretical position\n      });\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, poolForPosition, tokenA, tokenB, deposit0Disabled, deposit1Disabled, invalidRange, tickLower, tickUpper]);\n  let errorMessage;\n  if (!account) {\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n  if (poolState === PoolState.INVALID) {\n    var _errorMessage;\n    errorMessage = (_errorMessage = errorMessage) !== null && _errorMessage !== void 0 ? _errorMessage : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid pair\"\n    }, void 0, false, void 0, this);\n  }\n  if (invalidPrice) {\n    var _errorMessage2;\n    errorMessage = (_errorMessage2 = errorMessage) !== null && _errorMessage2 !== void 0 ? _errorMessage2 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid price input\"\n    }, void 0, false, void 0, this);\n  }\n  if (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled || !parsedAmounts[Field.CURRENCY_B] && !depositBDisabled) {\n    var _errorMessage3;\n    errorMessage = (_errorMessage3 = errorMessage) !== null && _errorMessage3 !== void 0 ? _errorMessage3 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n  const invalidPool = poolState === PoolState.INVALID;\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit\n  };\n}\n_s3(useV3DerivedMintInfo, \"43vM3ZsbigkJ1nA9t5RE/4nUFOE=\", false, function () {\n  return [useWeb3React, useV3MintState, useCurrencyBalances, usePool];\n});\nexport function useRangeHopCallbacks(baseCurrency, quoteCurrency, feeAmount, tickLower, tickUpper, pool) {\n  _s4();\n  const dispatch = useAppDispatch();\n  const baseToken = useMemo(() => baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped, [baseCurrency]);\n  const quoteToken = useMemo(() => quoteCurrency === null || quoteCurrency === void 0 ? void 0 : quoteCurrency.wrapped, [quoteCurrency]);\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return '';\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return '';\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return '';\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return '';\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange());\n  }, [dispatch]);\n  return {\n    getDecrementLower,\n    getIncrementLower,\n    getDecrementUpper,\n    getIncrementUpper,\n    getSetFullRange\n  };\n}\n_s4(useRangeHopCallbacks, \"5VrOUxhhOxfWbS+6gNLkNCiogqw=\", false, function () {\n  return [useAppDispatch];\n});","map":{"version":3,"names":["CurrencyAmount","Price","Rounding","encodeSqrtRatioX96","nearestUsableTick","Pool","Position","priceToClosestTick","TICK_SPACINGS","TickMath","tickToPrice","useWeb3React","usePool","JSBI","tryParseCurrencyAmount","useCallback","useMemo","useLocation","useNavigate","useAppDispatch","useAppSelector","getTickToPrice","replaceURLParam","BIG_INT_ZERO","PoolState","useCurrencyBalances","Bound","Field","setFullRange","typeInput","typeLeftRangeInput","typeRightRangeInput","typeStartPriceInput","tryParseTick","useV3MintState","state","mintV3","useV3MintActionHandlers","noLiquidity","dispatch","navigate","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","search","onLeftRangeInput","replace","onRightRangeInput","onStartPriceInput","useV3DerivedMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","account","independentField","leftRangeTypedValue","rightRangeTypedValue","startPriceTypedValue","dependentField","currencies","tokenA","tokenB","baseToken","wrapped","token0","token1","sortsBefore","undefined","balances","currencyBalances","poolState","pool","NOT_EXISTS","invertPrice","Boolean","equals","price","parsedQuoteAmount","baseAmount","currency","quotient","invert","priceOf","invalidPrice","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","currentSqrt","getSqrtRatioAtTick","BigInt","poolForPosition","tickSpaceLimits","LOWER","MIN_TICK","UPPER","MAX_TICK","ticks","tickLower","toString","tickUpper","ticksAtLimit","invalidRange","pricesAtTicks","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","fromAmounts","errorMessage","INVALID","currencyAAmount","currencyBAmount","symbol","invalidPool","useRangeHopCallbacks","quoteCurrency","quoteToken","getDecrementLower","newPrice","toSignificant","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/mint/v3/hooks.tsx"],"sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Price, Rounding, Token } from '@uniswap/sdk-core'\nimport {\n  encodeSqrtRatioX96,\n  FeeAmount,\n  nearestUsableTick,\n  Pool,\n  Position,\n  priceToClosestTick,\n  TICK_SPACINGS,\n  TickMath,\n  tickToPrice,\n} from '@uniswap/v3-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { usePool } from 'hooks/usePools'\nimport JSBI from 'jsbi'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { ReactNode, useCallback, useMemo } from 'react'\nimport { useLocation, useNavigate } from 'react-router-dom'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { getTickToPrice } from 'utils/getTickToPrice'\nimport { replaceURLParam } from 'utils/routes'\n\nimport { BIG_INT_ZERO } from '../../../constants/misc'\nimport { PoolState } from '../../../hooks/usePools'\nimport { useCurrencyBalances } from '../../connection/hooks'\nimport { AppState } from '../../index'\nimport {\n  Bound,\n  Field,\n  setFullRange,\n  typeInput,\n  typeLeftRangeInput,\n  typeRightRangeInput,\n  typeStartPriceInput,\n} from './actions'\nimport { tryParseTick } from './utils'\n\nexport function useV3MintState(): AppState['mintV3'] {\n  return useAppSelector((state) => state.mintV3)\n}\n\nexport function useV3MintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n  onLeftRangeInput: (typedValue: string) => void\n  onRightRangeInput: (typedValue: string) => void\n  onStartPriceInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n  const navigate = useNavigate()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const { search } = useLocation()\n\n  const onLeftRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeLeftRangeInput({ typedValue }))\n      navigate({ search: replaceURLParam(search, 'minPrice', typedValue) }, { replace: true })\n    },\n    [dispatch, navigate, search]\n  )\n\n  const onRightRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeRightRangeInput({ typedValue }))\n      navigate({ search: replaceURLParam(search, 'maxPrice', typedValue) }, { replace: true })\n    },\n    [dispatch, navigate, search]\n  )\n\n  const onStartPriceInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeStartPriceInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  }\n}\n\nexport function useV3DerivedMintInfo(\n  currencyA?: Currency,\n  currencyB?: Currency,\n  feeAmount?: FeeAmount,\n  baseCurrency?: Currency,\n  // override for existing position\n  existingPosition?: Position\n): {\n  pool?: Pool | null\n  poolState: PoolState\n  ticks: { [bound in Bound]?: number | undefined }\n  price?: Price<Token, Token>\n  pricesAtTicks: {\n    [bound in Bound]?: Price<Token, Token> | undefined\n  }\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  dependentField: Field\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  position: Position | undefined\n  noLiquidity?: boolean\n  errorMessage?: ReactNode\n  invalidPool: boolean\n  outOfRange: boolean\n  invalidRange: boolean\n  depositADisabled: boolean\n  depositBDisabled: boolean\n  invertPrice: boolean\n  ticksAtLimit: { [bound in Bound]?: boolean | undefined }\n} {\n  const { account } = useWeb3React()\n\n  const { independentField, typedValue, leftRangeTypedValue, rightRangeTypedValue, startPriceTypedValue } =\n    useV3MintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // currencies\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA,\n      [Field.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency]\n  )\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB]\n  )\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies])\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount)\n  const noLiquidity = poolState === PoolState.NOT_EXISTS\n\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0))\n\n  // always returns the price with 0 as base token\n  const price: Price<Token, Token> | undefined = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseCurrencyAmount(startPriceTypedValue, invertPrice ? token0 : token1)\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseCurrencyAmount('1', invertPrice ? token1 : token0)\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient\n              )\n            : undefined\n        return (invertPrice ? price?.invert() : price) ?? undefined\n      }\n      return undefined\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool])\n\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined\n    return (\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      )\n    )\n  }, [price])\n\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price)\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick)\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, [])\n    } else {\n      return undefined\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB])\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition: Pool | undefined = pool ?? mockPool\n\n  // lower and upper limits in the tick space for `feeAmoun<Trans>\n  const tickSpaceLimits: {\n    [bound in Bound]: number | undefined\n  } = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount]\n  )\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks: {\n    [key: string]: number | undefined\n  } = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === 'number'\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (!invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === 'number'\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    }\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ])\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {}\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount]\n  )\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper)\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    }\n  }, [token0, token1, ticks])\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks\n\n  // liquidity range warning\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseCurrencyAmount(\n    typedValue,\n    currencies[independentField]\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === 'number' &&\n      typeof tickUpper === 'number' &&\n      poolForPosition\n    ) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined\n      }\n\n      const position: Position | undefined = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true, // we want full precision for the theoretical position\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          })\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n    }\n\n    return undefined\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper\n  )\n  const deposit1Disabled = Boolean(\n    typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower\n  )\n\n  // sorted for token order\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA))\n    )\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB))\n    )\n\n  // create position entity based on users selection\n  const position: Position | undefined = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== 'number' ||\n      typeof tickUpper !== 'number' ||\n      invalidRange\n    ) {\n      return undefined\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      })\n    } else {\n      return undefined\n    }\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ])\n\n  let errorMessage: ReactNode | undefined\n  if (!account) {\n    errorMessage = <Trans>Connect Wallet</Trans>\n  }\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? <Trans>Invalid price input</Trans>\n  }\n\n  if (\n    (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  }\n\n  const invalidPool = poolState === PoolState.INVALID\n\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit,\n  }\n}\n\nexport function useRangeHopCallbacks(\n  baseCurrency: Currency | undefined,\n  quoteCurrency: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool?: Pool | undefined | null\n) {\n  const dispatch = useAppDispatch()\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency])\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency])\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange())\n  }, [dispatch])\n\n  return { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper, getSetFullRange }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}