{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { arrayify } from '@ethersproject/bytes';\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { Token } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport { isSupportedChain } from 'constants/chains';\nimport { useBytes32TokenContract, useTokenContract } from 'hooks/useContract';\nimport { NEVER_RELOAD, useSingleCallResult } from 'lib/hooks/multicall';\nimport useNativeCurrency from 'lib/hooks/useNativeCurrency';\nimport { useMemo } from 'react';\nimport { DEFAULT_ERC20_DECIMALS } from '../../constants/tokens';\nimport { TOKEN_SHORTHANDS } from '../../constants/tokens';\nimport { isAddress } from '../../utils';\nimport { supportedChainId } from '../../utils/supportedChainId';\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str :\n  // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n}\nexport const UNKNOWN_TOKEN_SYMBOL = 'UNKNOWN';\nconst UNKNOWN_TOKEN_NAME = 'Unknown Token';\n\n/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */\nexport function useTokenFromActiveNetwork(tokenAddress) {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  const formattedAddress = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(formattedAddress ? formattedAddress : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(formattedAddress ? formattedAddress : undefined, false);\n\n  // TODO: Fix redux-multicall so that these values do not reload.\n  const tokenName = useSingleCallResult(tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  const isLoading = useMemo(() => decimals.loading || symbol.loading || tokenName.loading, [decimals.loading, symbol.loading, tokenName.loading]);\n  const parsedDecimals = useMemo(() => {\n    var _decimals$result$, _decimals$result;\n    return (_decimals$result$ = decimals === null || decimals === void 0 ? void 0 : (_decimals$result = decimals.result) === null || _decimals$result === void 0 ? void 0 : _decimals$result[0]) !== null && _decimals$result$ !== void 0 ? _decimals$result$ : DEFAULT_ERC20_DECIMALS;\n  }, [decimals.result]);\n  const parsedSymbol = useMemo(() => {\n    var _symbol$result, _symbolBytes32$result;\n    return parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], UNKNOWN_TOKEN_SYMBOL);\n  }, [symbol.result, symbolBytes32.result]);\n  const parsedName = useMemo(() => {\n    var _tokenName$result, _tokenNameBytes32$res;\n    return parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], UNKNOWN_TOKEN_NAME);\n  }, [tokenName.result, tokenNameBytes32.result]);\n  return useMemo(() => {\n    // If the token is on another chain, we cannot fetch it on-chain, and it is invalid.\n    if (typeof tokenAddress !== 'string' || !isSupportedChain(chainId) || !formattedAddress) return undefined;\n    if (isLoading || !chainId) return null;\n    return new Token(chainId, formattedAddress, parsedDecimals, parsedSymbol, parsedName);\n  }, [chainId, tokenAddress, formattedAddress, isLoading, parsedDecimals, parsedSymbol, parsedName]);\n}\n_s(useTokenFromActiveNetwork, \"VuZ7tWHRSe44NoullolzI7Eyv4M=\", false, function () {\n  return [useWeb3React, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\n/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */\nexport function useTokenFromMapOrNetwork(tokens, tokenAddress) {\n  _s2();\n  const address = isAddress(tokenAddress);\n  const token = address ? tokens[address] : undefined;\n  const tokenFromNetwork = useTokenFromActiveNetwork(token ? undefined : address ? address : undefined);\n  return tokenFromNetwork !== null && tokenFromNetwork !== void 0 ? tokenFromNetwork : token;\n}\n\n/**\n * Returns a Currency from the currencyId.\n * Returns null if currency is loading or null was passed.\n * Returns undefined if currencyId is invalid or token does not exist.\n */\n_s2(useTokenFromMapOrNetwork, \"XPJm874rN+vaVgum1F/wQXQbzI4=\", false, function () {\n  return [useTokenFromActiveNetwork];\n});\nexport function useCurrencyFromMap(tokens, currencyId) {\n  _s3();\n  var _wrappedNative$addres;\n  const nativeCurrency = useNativeCurrency();\n  const {\n    chainId\n  } = useWeb3React();\n  const isNative = Boolean(nativeCurrency && (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'ETH');\n  const shorthandMatchAddress = useMemo(() => {\n    var _TOKEN_SHORTHANDS$cur;\n    const chain = supportedChainId(chainId);\n    return chain && currencyId ? (_TOKEN_SHORTHANDS$cur = TOKEN_SHORTHANDS[currencyId.toUpperCase()]) === null || _TOKEN_SHORTHANDS$cur === void 0 ? void 0 : _TOKEN_SHORTHANDS$cur[chain] : undefined;\n  }, [chainId, currencyId]);\n  const token = useTokenFromMapOrNetwork(tokens, isNative ? undefined : shorthandMatchAddress !== null && shorthandMatchAddress !== void 0 ? shorthandMatchAddress : currencyId);\n  if (currencyId === null || currencyId === undefined || !isSupportedChain(chainId)) return null;\n\n  // this case so we use our builtin wrapped token instead of wrapped tokens on token lists\n  const wrappedNative = nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.wrapped;\n  if ((wrappedNative === null || wrappedNative === void 0 ? void 0 : (_wrappedNative$addres = wrappedNative.address) === null || _wrappedNative$addres === void 0 ? void 0 : _wrappedNative$addres.toUpperCase()) === (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase())) return wrappedNative;\n  return isNative ? nativeCurrency : token;\n}\n_s3(useCurrencyFromMap, \"iQAtwZD6nPA86+dTJz7EYzMHKAA=\", false, function () {\n  return [useNativeCurrency, useWeb3React, useTokenFromMapOrNetwork];\n});","map":{"version":3,"names":["arrayify","parseBytes32String","Token","useWeb3React","isSupportedChain","useBytes32TokenContract","useTokenContract","NEVER_RELOAD","useSingleCallResult","useNativeCurrency","useMemo","DEFAULT_ERC20_DECIMALS","TOKEN_SHORTHANDS","isAddress","supportedChainId","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","UNKNOWN_TOKEN_SYMBOL","UNKNOWN_TOKEN_NAME","useTokenFromActiveNetwork","tokenAddress","chainId","formattedAddress","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","isLoading","loading","parsedDecimals","result","parsedSymbol","parsedName","useTokenFromMapOrNetwork","tokens","address","token","tokenFromNetwork","useCurrencyFromMap","currencyId","nativeCurrency","isNative","Boolean","toUpperCase","shorthandMatchAddress","chain","wrappedNative","wrapped"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/lib/hooks/useCurrency.ts"],"sourcesContent":["import { arrayify } from '@ethersproject/bytes'\nimport { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport { isSupportedChain } from 'constants/chains'\nimport { useBytes32TokenContract, useTokenContract } from 'hooks/useContract'\nimport { NEVER_RELOAD, useSingleCallResult } from 'lib/hooks/multicall'\nimport useNativeCurrency from 'lib/hooks/useNativeCurrency'\nimport { useMemo } from 'react'\n\nimport { DEFAULT_ERC20_DECIMALS } from '../../constants/tokens'\nimport { TOKEN_SHORTHANDS } from '../../constants/tokens'\nimport { isAddress } from '../../utils'\nimport { supportedChainId } from '../../utils/supportedChainId'\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : // need to check for proper bytes string and valid terminator\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\nexport const UNKNOWN_TOKEN_SYMBOL = 'UNKNOWN'\nconst UNKNOWN_TOKEN_NAME = 'Unknown Token'\n\n/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */\nexport function useTokenFromActiveNetwork(tokenAddress: string | undefined): Token | null | undefined {\n  const { chainId } = useWeb3React()\n\n  const formattedAddress = isAddress(tokenAddress)\n  const tokenContract = useTokenContract(formattedAddress ? formattedAddress : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(formattedAddress ? formattedAddress : undefined, false)\n\n  // TODO: Fix redux-multicall so that these values do not reload.\n  const tokenName = useSingleCallResult(tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(tokenContractBytes32, 'name', undefined, NEVER_RELOAD)\n  const symbol = useSingleCallResult(tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  const isLoading = useMemo(\n    () => decimals.loading || symbol.loading || tokenName.loading,\n    [decimals.loading, symbol.loading, tokenName.loading]\n  )\n  const parsedDecimals = useMemo(() => decimals?.result?.[0] ?? DEFAULT_ERC20_DECIMALS, [decimals.result])\n\n  const parsedSymbol = useMemo(\n    () => parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], UNKNOWN_TOKEN_SYMBOL),\n    [symbol.result, symbolBytes32.result]\n  )\n  const parsedName = useMemo(\n    () => parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], UNKNOWN_TOKEN_NAME),\n    [tokenName.result, tokenNameBytes32.result]\n  )\n\n  return useMemo(() => {\n    // If the token is on another chain, we cannot fetch it on-chain, and it is invalid.\n    if (typeof tokenAddress !== 'string' || !isSupportedChain(chainId) || !formattedAddress) return undefined\n    if (isLoading || !chainId) return null\n\n    return new Token(chainId, formattedAddress, parsedDecimals, parsedSymbol, parsedName)\n  }, [chainId, tokenAddress, formattedAddress, isLoading, parsedDecimals, parsedSymbol, parsedName])\n}\n\ntype TokenMap = { [address: string]: Token }\n\n/**\n * Returns a Token from the tokenAddress.\n * Returns null if token is loading or null was passed.\n * Returns undefined if tokenAddress is invalid or token does not exist.\n */\nexport function useTokenFromMapOrNetwork(tokens: TokenMap, tokenAddress?: string | null): Token | null | undefined {\n  const address = isAddress(tokenAddress)\n  const token: Token | undefined = address ? tokens[address] : undefined\n  const tokenFromNetwork = useTokenFromActiveNetwork(token ? undefined : address ? address : undefined)\n\n  return tokenFromNetwork ?? token\n}\n\n/**\n * Returns a Currency from the currencyId.\n * Returns null if currency is loading or null was passed.\n * Returns undefined if currencyId is invalid or token does not exist.\n */\nexport function useCurrencyFromMap(tokens: TokenMap, currencyId?: string | null): Currency | null | undefined {\n  const nativeCurrency = useNativeCurrency()\n  const { chainId } = useWeb3React()\n  const isNative = Boolean(nativeCurrency && currencyId?.toUpperCase() === 'ETH')\n  const shorthandMatchAddress = useMemo(() => {\n    const chain = supportedChainId(chainId)\n    return chain && currencyId ? TOKEN_SHORTHANDS[currencyId.toUpperCase()]?.[chain] : undefined\n  }, [chainId, currencyId])\n\n  const token = useTokenFromMapOrNetwork(tokens, isNative ? undefined : shorthandMatchAddress ?? currencyId)\n\n  if (currencyId === null || currencyId === undefined || !isSupportedChain(chainId)) return null\n\n  // this case so we use our builtin wrapped token instead of wrapped tokens on token lists\n  const wrappedNative = nativeCurrency?.wrapped\n  if (wrappedNative?.address?.toUpperCase() === currencyId?.toUpperCase()) return wrappedNative\n\n  return isNative ? nativeCurrency : token\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}