{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3/factories/IUniswapV3PoolState__factory';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport var V3PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of V3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  function V3PoolProvider(chainId, multicall2Provider) {\n    var retryOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      retries: 2,\n      minTimeout: 50,\n      maxTimeout: 500\n    };\n    _classCallCheck(this, V3PoolProvider);\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n    this.POOL_ADDRESS_CACHE = {};\n  }\n  _createClass(V3PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n        var poolAddressSet, sortedTokenPairs, sortedPoolAddresses, _iterator, _step, tokenPair, _tokenPair, tokenA, tokenB, feeAmount, _this$getPoolAddress2, _poolAddress, _token3, _token4, _yield$Promise$all, _yield$Promise$all2, slot0Results, liquidityResults, poolAddressToPool, invalidPools, i, slot0Result, liquidityResult, _sortedTokenPairs$i, _token, _token2, _fee, _sortedTokenPairs$i2, token0, token1, fee, slot0, liquidity, pool, poolAddress, poolStrs;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                sortedTokenPairs = [];\n                sortedPoolAddresses = [];\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 4;\n                _iterator.s();\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 17;\n                  break;\n                }\n                tokenPair = _step.value;\n                _tokenPair = _slicedToArray(tokenPair, 3), tokenA = _tokenPair[0], tokenB = _tokenPair[1], feeAmount = _tokenPair[2];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB, feeAmount), _poolAddress = _this$getPoolAddress2.poolAddress, _token3 = _this$getPoolAddress2.token0, _token4 = _this$getPoolAddress2.token1;\n                if (!poolAddressSet.has(_poolAddress)) {\n                  _context.next = 12;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 15);\n              case 12:\n                poolAddressSet.add(_poolAddress);\n                sortedTokenPairs.push([_token3, _token4, feeAmount]);\n                sortedPoolAddresses.push(_poolAddress);\n              case 15:\n                _context.next = 6;\n                break;\n              case 17:\n                _context.next = 22;\n                break;\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](4);\n                _iterator.e(_context.t0);\n              case 22:\n                _context.prev = 22;\n                _iterator.f();\n                return _context.finish(22);\n              case 25:\n                log.debug(\"getPools called with \".concat(tokenPairs.length, \" token pairs. Deduped down to \").concat(poolAddressSet.size));\n                _context.next = 28;\n                return Promise.all([this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig), this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig)]);\n              case 28:\n                _yield$Promise$all = _context.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                slot0Results = _yield$Promise$all2[0];\n                liquidityResults = _yield$Promise$all2[1];\n                log.info(\"Got liquidity and slot0s for \".concat(poolAddressSet.size, \" pools \").concat((providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? \"as of block: \".concat(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber, \".\") : \"\"));\n                poolAddressToPool = {};\n                invalidPools = [];\n                i = 0;\n              case 36:\n                if (!(i < sortedPoolAddresses.length)) {\n                  _context.next = 52;\n                  break;\n                }\n                slot0Result = slot0Results[i];\n                liquidityResult = liquidityResults[i]; // These properties tell us if a pool is valid and initialized or not.\n                if (!(!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) || !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) || slot0Result.result.sqrtPriceX96.eq(0))) {\n                  _context.next = 43;\n                  break;\n                }\n                _sortedTokenPairs$i = _slicedToArray(sortedTokenPairs[i], 3), _token = _sortedTokenPairs$i[0], _token2 = _sortedTokenPairs$i[1], _fee = _sortedTokenPairs$i[2];\n                invalidPools.push([_token, _token2, _fee]);\n                return _context.abrupt(\"continue\", 49);\n              case 43:\n                _sortedTokenPairs$i2 = _slicedToArray(sortedTokenPairs[i], 3), token0 = _sortedTokenPairs$i2[0], token1 = _sortedTokenPairs$i2[1], fee = _sortedTokenPairs$i2[2];\n                slot0 = slot0Result.result;\n                liquidity = liquidityResult.result[0];\n                pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n                poolAddress = sortedPoolAddresses[i];\n                poolAddressToPool[poolAddress] = pool;\n              case 49:\n                i++;\n                _context.next = 36;\n                break;\n              case 52:\n                if (invalidPools.length > 0) {\n                  log.info({\n                    invalidPools: _.map(invalidPools, function (_ref) {\n                      var _ref2 = _slicedToArray(_ref, 3),\n                        token0 = _ref2[0],\n                        token1 = _ref2[1],\n                        fee = _ref2[2];\n                      return \"\".concat(token0.symbol, \"/\").concat(token1.symbol, \"/\").concat(fee / 10000, \"%\");\n                    })\n                  }, \"\".concat(invalidPools.length, \" pools invalid after checking their slot0 and liquidity results. Dropping.\"));\n                }\n                poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n                log.debug({\n                  poolStrs: poolStrs\n                }, \"Found \".concat(poolStrs.length, \" valid pools\"));\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB, feeAmount) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB, feeAmount),\n                      poolAddress = _this$getPoolAddress.poolAddress;\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n              case 56:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 19, 22, 25]]);\n      }));\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB, feeAmount) {\n      var _ref3 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n        _ref4 = _slicedToArray(_ref3, 2),\n        token0 = _ref4[0],\n        token1 = _ref4[1];\n      var cacheKey = \"\".concat(this.chainId, \"/\").concat(token0.address, \"/\").concat(token1.address, \"/\").concat(feeAmount);\n      var cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n      if (cachedAddress) {\n        return {\n          poolAddress: cachedAddress,\n          token0: token0,\n          token1: token1\n        };\n      }\n      var poolAddress = computePoolAddress({\n        factoryAddress: V3_CORE_FACTORY_ADDRESSES[this.chainId],\n        tokenA: token0,\n        tokenB: token1,\n        fee: feeAmount\n      });\n      this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n      return {\n        poolAddress: poolAddress,\n        token0: token0,\n        token1: token1\n      };\n    }\n  }, {\n    key: \"getPoolsData\",\n    value: function () {\n      var _getPoolsData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(poolAddresses, functionName, providerConfig) {\n        var _this2 = this;\n        var _yield$retry, results, blockNumber;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return retry( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          return _context2.abrupt(\"return\", _this2.multicall2Provider.callSameFunctionOnMultipleContracts({\n                            addresses: poolAddresses,\n                            contractInterface: IUniswapV3PoolState__factory.createInterface(),\n                            functionName: functionName,\n                            providerConfig: providerConfig\n                          }));\n                        case 1:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })), this.retryOptions);\n              case 2:\n                _yield$retry = _context3.sent;\n                results = _yield$retry.results;\n                blockNumber = _yield$retry.blockNumber;\n                log.debug(\"Pool data fetched as of block \".concat(blockNumber));\n                return _context3.abrupt(\"return\", results);\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function getPoolsData(_x3, _x4, _x5) {\n        return _getPoolsData.apply(this, arguments);\n      }\n      return getPoolsData;\n    }()\n  }]);\n  return V3PoolProvider;\n}();","map":{"version":3,"sources":["../../../../src/providers/v3/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3/factories/IUniswapV3PoolState__factory';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V3PoolProvider {\n    /**\n     * Creates an instance of V3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (const tokenPair of tokenPairs) {\n            const [tokenA, tokenB, feeAmount] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1, feeAmount]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const [slot0Results, liquidityResults] = await Promise.all([\n            this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig),\n            this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig),\n        ]);\n        log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const slot0Result = slot0Results[i];\n            const liquidityResult = liquidityResults[i];\n            // These properties tell us if a pool is valid and initialized or not.\n            if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) ||\n                !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) ||\n                slot0Result.result.sqrtPriceX96.eq(0)) {\n                const [token0, token1, fee] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1, fee]);\n                continue;\n            }\n            const [token0, token1, fee] = sortedTokenPairs[i];\n            const slot0 = slot0Result.result;\n            const liquidity = liquidityResult.result[0];\n            const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1, fee]) => `${token0.symbol}/${token1.symbol}/${fee / 10000}%`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB, feeAmount) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB, feeAmount) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = computePoolAddress({\n            factoryAddress: V3_CORE_FACTORY_ADDRESSES[this.chainId],\n            tokenA: token0,\n            tokenB: token1,\n            fee: feeAmount,\n        });\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV3PoolState__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjMvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsa0JBQWtCLEVBQWEsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdEUsT0FBTyxLQUFrQyxNQUFNLGFBQWEsQ0FBQztBQUM3RCxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFFdkIsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sdURBQXVELENBQUM7QUFFckcsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDakUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQThEakQsTUFBTSxPQUFPLGNBQWM7SUFLekI7Ozs7O09BS0c7SUFDSCxZQUNZLE9BQWdCLEVBQ2hCLGtCQUFzQyxFQUN0QyxlQUFtQztRQUMzQyxPQUFPLEVBQUUsQ0FBQztRQUNWLFVBQVUsRUFBRSxFQUFFO1FBQ2QsVUFBVSxFQUFFLEdBQUc7S0FDaEI7UUFOUyxZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQ2hCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFDdEMsaUJBQVksR0FBWixZQUFZLENBSXJCO1FBakJILHlFQUF5RTtRQUN6RSxrREFBa0Q7UUFDMUMsdUJBQWtCLEdBQThCLEVBQUUsQ0FBQztJQWdCeEQsQ0FBQztJQUVHLEtBQUssQ0FBQyxRQUFRLENBQ25CLFVBQXVDLEVBQ3ZDLGNBQStCO1FBRS9CLE1BQU0sY0FBYyxHQUFnQixJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3RELE1BQU0sZ0JBQWdCLEdBQXFDLEVBQUUsQ0FBQztRQUM5RCxNQUFNLG1CQUFtQixHQUFhLEVBQUUsQ0FBQztRQUV6QyxLQUFLLE1BQU0sU0FB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"]},"metadata":{},"sourceType":"module"}