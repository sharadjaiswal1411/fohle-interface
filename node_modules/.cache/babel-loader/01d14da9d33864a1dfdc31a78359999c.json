{"ast":null,"code":"import _regeneratorRuntime from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Pair } from '@uniswap/v2-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2/factories/IUniswapV2Pair__factory';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport var V2PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of V2PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  function V2PoolProvider(chainId, multicall2Provider) {\n    var retryOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      retries: 2,\n      minTimeout: 50,\n      maxTimeout: 500\n    };\n    _classCallCheck(this, V2PoolProvider);\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n    this.POOL_ADDRESS_CACHE = {};\n  }\n  _createClass(V2PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n        var poolAddressSet, sortedTokenPairs, sortedPoolAddresses, _iterator, _step, tokenPair, _tokenPair, tokenA, tokenB, _this$getPoolAddress2, _poolAddress, _token3, _token4, reservesResults, poolAddressToPool, invalidPools, i, reservesResult, _sortedTokenPairs$i, _token, _token2, _sortedTokenPairs$i2, token0, token1, _reservesResult$resul, reserve0, reserve1, pool, poolAddress, poolStrs;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                sortedTokenPairs = [];\n                sortedPoolAddresses = [];\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 4;\n                _iterator.s();\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 17;\n                  break;\n                }\n                tokenPair = _step.value;\n                _tokenPair = _slicedToArray(tokenPair, 2), tokenA = _tokenPair[0], tokenB = _tokenPair[1];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB), _poolAddress = _this$getPoolAddress2.poolAddress, _token3 = _this$getPoolAddress2.token0, _token4 = _this$getPoolAddress2.token1;\n                if (!poolAddressSet.has(_poolAddress)) {\n                  _context.next = 12;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 15);\n              case 12:\n                poolAddressSet.add(_poolAddress);\n                sortedTokenPairs.push([_token3, _token4]);\n                sortedPoolAddresses.push(_poolAddress);\n              case 15:\n                _context.next = 6;\n                break;\n              case 17:\n                _context.next = 22;\n                break;\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](4);\n                _iterator.e(_context.t0);\n              case 22:\n                _context.prev = 22;\n                _iterator.f();\n                return _context.finish(22);\n              case 25:\n                log.debug(\"getPools called with \".concat(tokenPairs.length, \" token pairs. Deduped down to \").concat(poolAddressSet.size));\n                _context.next = 28;\n                return this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n              case 28:\n                reservesResults = _context.sent;\n                _context.t1 = log;\n                _context.t2 = \"Got reserves for \".concat(poolAddressSet.size, \" pools \");\n                if (!(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)) {\n                  _context.next = 39;\n                  break;\n                }\n                _context.t4 = \"as of block: \";\n                _context.next = 35;\n                return providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber;\n              case 35:\n                _context.t5 = _context.sent;\n                _context.t3 = _context.t4.concat.call(_context.t4, _context.t5, \".\");\n                _context.next = 40;\n                break;\n              case 39:\n                _context.t3 = \"\";\n              case 40:\n                _context.t6 = _context.t3;\n                _context.t7 = _context.t2.concat.call(_context.t2, _context.t6);\n                _context.t1.info.call(_context.t1, _context.t7);\n                poolAddressToPool = {};\n                invalidPools = [];\n                i = 0;\n              case 46:\n                if (!(i < sortedPoolAddresses.length)) {\n                  _context.next = 60;\n                  break;\n                }\n                reservesResult = reservesResults[i];\n                if (reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success) {\n                  _context.next = 52;\n                  break;\n                }\n                _sortedTokenPairs$i = _slicedToArray(sortedTokenPairs[i], 2), _token = _sortedTokenPairs$i[0], _token2 = _sortedTokenPairs$i[1];\n                invalidPools.push([_token, _token2]);\n                return _context.abrupt(\"continue\", 57);\n              case 52:\n                _sortedTokenPairs$i2 = _slicedToArray(sortedTokenPairs[i], 2), token0 = _sortedTokenPairs$i2[0], token1 = _sortedTokenPairs$i2[1];\n                _reservesResult$resul = reservesResult.result, reserve0 = _reservesResult$resul.reserve0, reserve1 = _reservesResult$resul.reserve1;\n                pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n                poolAddress = sortedPoolAddresses[i];\n                poolAddressToPool[poolAddress] = pool;\n              case 57:\n                i++;\n                _context.next = 46;\n                break;\n              case 60:\n                if (invalidPools.length > 0) {\n                  log.info({\n                    invalidPools: _.map(invalidPools, function (_ref) {\n                      var _ref2 = _slicedToArray(_ref, 2),\n                        token0 = _ref2[0],\n                        token1 = _ref2[1];\n                      return \"\".concat(token0.symbol, \"/\").concat(token1.symbol);\n                    })\n                  }, \"\".concat(invalidPools.length, \" pools invalid after checking their slot0 and liquidity results. Dropping.\"));\n                }\n                poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n                log.debug({\n                  poolStrs: poolStrs\n                }, \"Found \".concat(poolStrs.length, \" valid pools\"));\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB),\n                      poolAddress = _this$getPoolAddress.poolAddress;\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n              case 64:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 19, 22, 25]]);\n      }));\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB) {\n      var _ref3 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n        _ref4 = _slicedToArray(_ref3, 2),\n        token0 = _ref4[0],\n        token1 = _ref4[1];\n      var cacheKey = \"\".concat(this.chainId, \"/\").concat(token0.address, \"/\").concat(token1.address);\n      var cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n      if (cachedAddress) {\n        return {\n          poolAddress: cachedAddress,\n          token0: token0,\n          token1: token1\n        };\n      }\n      var poolAddress = Pair.getAddress(token0, token1);\n      this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n      return {\n        poolAddress: poolAddress,\n        token0: token0,\n        token1: token1\n      };\n    }\n  }, {\n    key: \"getPoolsData\",\n    value: function () {\n      var _getPoolsData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(poolAddresses, functionName, providerConfig) {\n        var _this2 = this;\n        var _yield$retry, results, blockNumber;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return retry( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          return _context2.abrupt(\"return\", _this2.multicall2Provider.callSameFunctionOnMultipleContracts({\n                            addresses: poolAddresses,\n                            contractInterface: IUniswapV2Pair__factory.createInterface(),\n                            functionName: functionName,\n                            providerConfig: providerConfig\n                          }));\n                        case 1:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })), this.retryOptions);\n              case 2:\n                _yield$retry = _context3.sent;\n                results = _yield$retry.results;\n                blockNumber = _yield$retry.blockNumber;\n                log.debug(\"Pool data fetched as of block \".concat(blockNumber));\n                return _context3.abrupt(\"return\", results);\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function getPoolsData(_x3, _x4, _x5) {\n        return _getPoolsData.apply(this, arguments);\n      }\n      return getPoolsData;\n    }()\n  }]);\n  return V2PoolProvider;\n}();","map":{"version":3,"sources":["../../../../src/providers/v2/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Pair } from '@uniswap/v2-sdk';\nimport retry from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2/factories/IUniswapV2Pair__factory';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V2PoolProvider {\n    /**\n     * Creates an instance of V2PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (const tokenPair of tokenPairs) {\n            const [tokenA, tokenB] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const reservesResults = await this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n        log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const reservesResult = reservesResults[i];\n            if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {\n                const [token0, token1] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1]);\n                continue;\n            }\n            const [token0, token1] = sortedTokenPairs[i];\n            const { reserve0, reserve1 } = reservesResult.result;\n            const pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1]) => `${token0.symbol}/${token1.symbol}`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = Pair.getAddress(token0, token1);\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV2Pair__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjIvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxLQUFrQyxNQUFNLGFBQWEsQ0FBQztBQUM3RCxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFFdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sa0RBQWtELENBQUM7QUFDM0YsT0FBTyxFQUFXLGNBQWMsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNyRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBa0RqRCxNQUFNLE9BQU8sY0FBYztJQUt6Qjs7Ozs7T0FLRztJQUNILFlBQ1ksT0FBZ0IsRUFDaEIsa0JBQXNDLEVBQ3RDLGVBQW1DO1FBQzNDLE9BQU8sRUFBRSxDQUFDO1FBQ1YsVUFBVSxFQUFFLEVBQUU7UUFDZCxVQUFVLEVBQUUsR0FBRztLQUNoQjtRQU5TLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxpQkFBWSxHQUFaLFlBQVksQ0FJckI7UUFqQkgseUVBQXlFO1FBQ3pFLGtEQUFrRDtRQUMxQyx1QkFBa0IsR0FBOEIsRUFBRSxDQUFDO0lBZ0J4RCxDQUFDO0lBRUcsS0FBSyxDQUFDLFFBQVEsQ0FDbkIsVUFBNEIsRUFDNUIsY0FBK0I7UUFFL0IsTUFBTSxjQUFjLEdBQWdCLElBQUksR0FBRyxFQUFVLENBQUM7UUFDdEQsTUFBTSxnQkFBZ0IsR0FBMEIsRUFBRSxDQUFDO1FBQ25ELE1BQU0sbUJBQW1CLEdBQWEsRUFBRSxDQUFDO1FBRXpDLEtBQUssTUFBTSxTQUFTLElBQUksVUFBVSxFQUFF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"]},"metadata":{},"sourceType":"module"}