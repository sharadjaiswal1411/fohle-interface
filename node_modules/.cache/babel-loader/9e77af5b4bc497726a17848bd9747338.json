{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      it\n    } = cxt;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      cxt.fail();\n      return;\n    }\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n      keyword: \"not\",\n      compositeRule: true,\n      createErrors: false,\n      allErrors: false\n    }, valid);\n    cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n  },\n  error: {\n    message: \"must NOT be valid\"\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/not.ts"],"names":[],"mappings":";;;;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAIA,MAAM,GAAG,GAA0B;EACjC,OAAO,EAAE,KAAK;EACd,UAAU,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC;EACjC,WAAW,EAAE,IAAI;EACjB,IAAI,CAAC,GAAe,EAAA;IAClB,MAAM;MAAC,GAAG;MAAE,MAAM;MAAE;IAAE,CAAC,GAAG,GAAG;IAC7B,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,iBAAiB,EAAC,EAAE,EAAE,MAAM,CAAC,EAAE;MACjC,GAAG,CAAC,IAAI,EAAE;MACV;IACD;IAED,MAAM,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;IAC/B,GAAG,CAAC,SAAS,CACX;MACE,OAAO,EAAE,KAAK;MACd,aAAa,EAAE,IAAI;MACnB,YAAY,EAAE,KAAK;MACnB,SAAS,EAAE;KACZ,EACD,KAAK,CACN;IAED,GAAG,CAAC,UAAU,CACZ,KAAK,EACL,MAAM,GAAG,CAAC,KAAK,EAAE,EACjB,MAAM,GAAG,CAAC,KAAK,EAAE,CAClB;EACH,CAAC;EACD,KAAK,EAAE;IAAC,OAAO,EAAE;EAAmB;CACrC;AAED,OAAA,CAAA,OAAA,GAAe,GAAG","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map"]},"metadata":{},"sourceType":"script"}