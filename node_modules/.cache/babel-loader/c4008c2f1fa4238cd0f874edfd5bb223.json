{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { Trans } from \"@lingui/react\";\nimport { CurrencyAmount, Percent, Price } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport JSBI from 'jsbi';\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount';\nimport { useCallback, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { useTotalSupply } from '../../hooks/useTotalSupply';\nimport { PairState, useV2Pair } from '../../hooks/useV2Pairs';\nimport { useCurrencyBalances } from '../connection/hooks';\nimport { Field, typeInput } from './actions';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  _s();\n  return useAppSelector(state => state.mint);\n}\n_s(useMintState, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\nexport function useMintActionHandlers(noLiquidity) {\n  _s2();\n  const dispatch = useAppDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput,\n    onFieldBInput\n  };\n}\n_s2(useMintActionHandlers, \"SD7NTLW00Yoy8nJI/INxRyad7FM=\", false, function () {\n  return [useAppDispatch];\n});\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  _s3();\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n  const {\n    account\n  } = useWeb3React();\n  const {\n    independentField,\n    typedValue,\n    otherTypedValue\n  } = useMintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\n\n  // tokens\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]);\n\n  // pair\n  const [pairState, pair] = useV2Pair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO)) || Boolean(pairState === PairState.EXISTS && pair && JSBI.equal(pair.reserve0.quotient, ZERO) && JSBI.equal(pair.reserve1.quotient, ZERO));\n\n  // balances\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies]));\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  };\n\n  // amounts\n  const independentAmount = tryParseCurrencyAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseCurrencyAmount(otherTypedValue, currencies[dependentField]);\n      }\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n      const [tokenA, tokenB] = [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped];\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return (dependentCurrency === null || dependentCurrency === void 0 ? void 0 : dependentCurrency.isNative) ? CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient) : dependentTokenAmount;\n      }\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair]);\n  const parsedAmounts = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n      if ((currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.greaterThan(0)) && (currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.greaterThan(0))) {\n        const value = currencyBAmount.divide(currencyAAmount);\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, value.denominator, value.numerator);\n      }\n      return undefined;\n    } else {\n      const wrappedCurrencyA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts]);\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.wrapped, currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.wrapped];\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n      } catch (error) {\n        console.error(error);\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n  if (!account) {\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n  if (pairState === PairState.INVALID) {\n    var _error;\n    error = (_error = error) !== null && _error !== void 0 ? _error : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid pair\"\n    }, void 0, false, void 0, this);\n  }\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}\n_s3(useDerivedMintInfo, \"SlgcRjWd6B0ztD86V0mU+NZKMx0=\", false, function () {\n  return [useWeb3React, useMintState, useV2Pair, useTotalSupply, useCurrencyBalances];\n});","map":{"version":3,"names":["CurrencyAmount","Percent","Price","useWeb3React","JSBI","tryParseCurrencyAmount","useCallback","useMemo","useAppDispatch","useAppSelector","useTotalSupply","PairState","useV2Pair","useCurrencyBalances","Field","typeInput","ZERO","BigInt","useMintState","state","mint","useMintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","useDerivedMintInfo","currencyA","currencyB","account","independentField","otherTypedValue","dependentField","currencies","undefined","pairState","pair","totalSupply","liquidityToken","NOT_EXISTS","Boolean","equal","quotient","EXISTS","reserve0","reserve1","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","wrapped","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","isNative","fromRawAmount","parsedAmounts","price","currencyAAmount","currencyBAmount","greaterThan","value","divide","currency","denominator","numerator","wrappedCurrencyA","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","error","console","poolTokenPercentage","add","INVALID","lessThan","symbol"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/mint/hooks.tsx"],"sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Percent, Price, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport JSBI from 'jsbi'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { ReactNode, useCallback, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\n\nimport { useTotalSupply } from '../../hooks/useTotalSupply'\nimport { PairState, useV2Pair } from '../../hooks/useV2Pairs'\nimport { useCurrencyBalances } from '../connection/hooks'\nimport { AppState } from '../index'\nimport { Field, typeInput } from './actions'\n\nconst ZERO = JSBI.BigInt(0)\n\nexport function useMintState(): AppState['mint'] {\n  return useAppSelector((state) => state.mint)\n}\n\nexport function useMintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n  }\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  price?: Price<Currency, Currency>\n  noLiquidity?: boolean\n  liquidityMinted?: CurrencyAmount<Token>\n  poolTokenPercentage?: Percent\n  error?: ReactNode\n} {\n  const { account } = useWeb3React()\n\n  const { independentField, typedValue, otherTypedValue } = useMintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // pair\n  const [pairState, pair] = useV2Pair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B])\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS ||\n    Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO)) ||\n    Boolean(\n      pairState === PairState.EXISTS &&\n        pair &&\n        JSBI.equal(pair.reserve0.quotient, ZERO) &&\n        JSBI.equal(pair.reserve1.quotient, ZERO)\n    )\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies])\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseCurrencyAmount(\n    typedValue,\n    currencies[independentField]\n  )\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseCurrencyAmount(otherTypedValue, currencies[dependentField])\n      }\n      return undefined\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount?.wrapped\n      const [tokenA, tokenB] = [currencyA?.wrapped, currencyB?.wrapped]\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount)\n        return dependentCurrency?.isNative\n          ? CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n          : dependentTokenAmount\n      }\n      return undefined\n    } else {\n      return undefined\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n      if (currencyAAmount?.greaterThan(0) && currencyBAmount?.greaterThan(0)) {\n        const value = currencyBAmount.divide(currencyAAmount)\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, value.denominator, value.numerator)\n      }\n      return undefined\n    } else {\n      const wrappedCurrencyA = currencyA?.wrapped\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount?.wrapped, currencyBAmount?.wrapped]\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n      } catch (error) {\n        console.error(error)\n        return undefined\n      }\n    } else {\n      return undefined\n    }\n  }, [parsedAmounts, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient)\n    } else {\n      return undefined\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let error: ReactNode | undefined\n  if (!account) {\n    error = <Trans>Connect Wallet</Trans>\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}