{"ast":null,"code":"import { withScope, captureException } from '@sentry/core';\nimport { GLOBAL_OBJ, getOriginalFunction, addExceptionTypeValue, addExceptionMechanism, markFunctionWrapped, addNonEnumerableProperty } from '@sentry/utils';\nconst WINDOW = GLOBAL_OBJ;\nlet ignoreOnError = 0;\n\n/**\n * @hidden\n */\nfunction shouldIgnoreOnError() {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nfunction ignoreNextOnError() {\n  // onerror should trigger before setTimeout\n  ignoreOnError += 1;\n  setTimeout(() => {\n    ignoreOnError -= 1;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nfunction wrap(fn) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let before\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  = arguments.length > 2 ? arguments[2] : undefined;\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    const wrapper = fn.__sentry_wrapped__;\n    if (wrapper) {\n      return wrapper;\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  /* eslint-disable prefer-rest-params */\n  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  const sentryWrapped = function () {\n    const args = Array.prototype.slice.call(arguments);\n    try {\n      if (before && typeof before === 'function') {\n        before.apply(this, arguments);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      const wrappedArguments = args.map(arg => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n      withScope(scope => {\n        scope.addEventProcessor(event => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n          event.extra = {\n            ...event.extra,\n            arguments: args\n          };\n          return event;\n        });\n        captureException(ex);\n      });\n      throw ex;\n    }\n  };\n  /* eslint-enable prefer-rest-params */\n\n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} // eslint-disable-line no-empty\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name');\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get() {\n          return fn.name;\n        }\n      });\n    }\n    // eslint-disable-next-line no-empty\n  } catch (_oO) {}\n  return sentryWrapped;\n}\n\n/**\n * All properties the report dialog supports\n */\n\nexport { WINDOW, ignoreNextOnError, shouldIgnoreOnError, wrap };","map":{"version":3,"sources":["../../../src/helpers.ts"],"names":[],"mappings":";;AAWA,MAAA,MAAA,GAAA,UAAA;AAEA,IAAA,aAAA,GAAA,CAAA;;AAEA;AACA;AACA;AACA,SAAA,mBAAA,GAAA;EACA,OAAA,aAAA,GAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA,SAAA,iBAAA,GAAA;EACA;EACA,aAAA,IAAA,CAAA;EACA,UAAA,CAAA,MAAA;IACA,aAAA,IAAA,CAAA;EACA,CAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,IAAA,CACA,EAAA,EAMA;EAAA,IALA,OAAA,uEAEA,CAAA,CAAA;EAAA,IACA;EACA;EAAA;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAA,OAAA,EAAA,KAAA,UAAA,EAAA;IACA,OAAA,EAAA;EACA;EAEA,IAAA;IACA;IACA;IACA,MAAA,OAAA,GAAA,EAAA,CAAA,kBAAA;IACA,IAAA,OAAA,EAAA;MACA,OAAA,OAAA;IACA;;IAEA;IACA,IAAA,mBAAA,CAAA,EAAA,CAAA,EAAA;MACA,OAAA,EAAA;IACA;EACA,CAAA,CAAA,OAAA,CAAA,EAAA;IACA;IACA;IACA;IACA,OAAA,EAAA;EACA;;EAEA;EACA;EACA,MAAA,aAAA,GAAA,YAAA;IACA,MAAA,IAAA,GAAA,KAAA,CAAA,SAAA,CAAA,KAAA,CAAA,IAAA,CAAA,SAAA,CAAA;IAEA,IAAA;MACA,IAAA,MAAA,IAAA,OAAA,MAAA,KAAA,UAAA,EAAA;QACA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA;MACA;;MAEA;MACA,MAAA,gBAAA,GAAA,IAAA,CAAA,GAAA,CAAA,GAAA,IAAA,IAAA,CAAA,GAAA,EAAA,OAAA,CAAA,CAAA;;MAEA;MACA;MACA;MACA;MACA,OAAA,EAAA,CAAA,KAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;IACA,CAAA,CAAA,OAAA,EAAA,EAAA;MACA,iBAAA,EAAA;MAEA,SAAA,CAAA,KAAA,IAAA;QACA,KAAA,CAAA,iBAAA,CAAA,KAAA,IAAA;UACA,IAAA,OAAA,CAAA,SAAA,EAAA;YACA,qBAAA,CAAA,KAAA,EAAA,SAAA,EAAA,SAAA,CAAA;YACA,qBAAA,CAAA,KAAA,EAAA,OAAA,CAAA,SAAA,CAAA;UACA;UAEA,KAAA,CAAA,KAAA,GAAA;YACA,GAAA,KAAA,CAAA,KAAA;YACA,SAAA,EAAA;UACA,CAAA;UAEA,OAAA,KAAA;QACA,CAAA,CAAA;QAEA,gBAAA,CAAA,EAAA,CAAA;MACA,CAAA,CAAA;MAEA,MAAA,EAAA;IACA;EACA,CAAA;EACA;;EAEA;EACA;EACA,IAAA;IACA,KAAA,MAAA,QAAA,IAAA,EAAA,EAAA;MACA,IAAA,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,EAAA,EAAA,QAAA,CAAA,EAAA;QACA,aAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,QAAA,CAAA;MACA;IACA;EACA,CAAA,CAAA,OAAA,GAAA,EAAA,CAAA,CAAA,CAAA;;EAEA;EACA;EACA,mBAAA,CAAA,aAAA,EAAA,EAAA,CAAA;EAEA,wBAAA,CAAA,EAAA,EAAA,oBAAA,EAAA,aAAA,CAAA;;EAEA;EACA,IAAA;IACA,MAAA,UAAA,GAAA,MAAA,CAAA,wBAAA,CAAA,aAAA,EAAA,MAAA,CAAA;IACA,IAAA,UAAA,CAAA,YAAA,EAAA;MACA,MAAA,CAAA,cAAA,CAAA,aAAA,EAAA,MAAA,EAAA;QACA,GAAA,GAAA;UACA,OAAA,EAAA,CAAA,IAAA;QACA;MACA,CAAA,CAAA;IACA;IACA;EACA,CAAA,CAAA,OAAA,GAAA,EAAA,CAAA;EAEA,OAAA,aAAA;AACA;;AAEA;AACA;AACA","sourcesContent":["import { captureException, withScope } from '@sentry/core';\nimport { DsnLike, Event as SentryEvent, Mechanism, Scope, WrappedFunction } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  addNonEnumerableProperty,\n  getOriginalFunction,\n  GLOBAL_OBJ,\n  markFunctionWrapped,\n} from '@sentry/utils';\n\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nlet ignoreOnError: number = 0;\n\n/**\n * @hidden\n */\nexport function shouldIgnoreOnError(): boolean {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nexport function ignoreNextOnError(): void {\n  // onerror should trigger before setTimeout\n  ignoreOnError += 1;\n  setTimeout(() => {\n    ignoreOnError -= 1;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nexport function wrap(\n  fn: WrappedFunction,\n  options: {\n    mechanism?: Mechanism;\n  } = {},\n  before?: WrappedFunction,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    const wrapper = fn.__sentry_wrapped__;\n    if (wrapper) {\n      return wrapper;\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  /* eslint-disable prefer-rest-params */\n  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  const sentryWrapped: WrappedFunction = function (this: unknown): void {\n    const args = Array.prototype.slice.call(arguments);\n\n    try {\n      if (before && typeof before === 'function') {\n        before.apply(this, arguments);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      const wrappedArguments = args.map((arg: any) => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope((scope: Scope) => {\n        scope.addEventProcessor((event: SentryEvent) => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n\n          event.extra = {\n            ...event.extra,\n            arguments: args,\n          };\n\n          return event;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  };\n  /* eslint-enable prefer-rest-params */\n\n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} // eslint-disable-line no-empty\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') as PropertyDescriptor;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get(): string {\n          return fn.name;\n        },\n      });\n    }\n    // eslint-disable-next-line no-empty\n  } catch (_oO) {}\n\n  return sentryWrapped;\n}\n\n/**\n * All properties the report dialog supports\n */\nexport interface ReportDialogOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n  eventId?: string;\n  dsn?: DsnLike;\n  user?: {\n    email?: string;\n    name?: string;\n  };\n  lang?: string;\n  title?: string;\n  subtitle?: string;\n  subtitle2?: string;\n  labelName?: string;\n  labelEmail?: string;\n  labelComments?: string;\n  labelClose?: string;\n  labelSubmit?: string;\n  errorGeneric?: string;\n  errorFormEntry?: string;\n  successMessage?: string;\n  /** Callback after reportDialog showed up */\n  onLoad?(): void;\n}\n"]},"metadata":{},"sourceType":"module"}