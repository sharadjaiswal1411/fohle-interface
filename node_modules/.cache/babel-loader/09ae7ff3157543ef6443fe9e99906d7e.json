{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1._)`{allowedValues: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    let eql;\n    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n    let valid;\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n    cxt.pass(valid);\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/enum.ts"],"names":[],"mappings":";;;;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AAIA,MAAM,KAAK,GAA2B;EACpC,OAAO,EAAE,4CAA4C;EACrD,MAAM,EAAE;IAAA,IAAC;MAAC;IAAU,CAAC;IAAA,OAAK,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,mBAAmB,UAAU,GAAG;EAAA;CAC5D;AAED,MAAM,GAAG,GAA0B;EACjC,OAAO,EAAE,MAAM;EACf,UAAU,EAAE,OAAO;EACnB,KAAK,EAAE,IAAI;EACX,KAAK;EACL,IAAI,CAAC,GAAe,EAAA;IAClB,MAAM;MAAC,GAAG;MAAE,IAAI;MAAE,KAAK;MAAE,MAAM;MAAE,UAAU;MAAE;IAAE,CAAC,GAAG,GAAG;IACtD,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;IACpF,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ;IACjD,IAAI,GAAqB;IACzB,MAAM,MAAM,GAAG,MAAa,GAAG,KAAA,IAAA,IAAH,GAAG,KAAA,KAAA,CAAA,GAAH,GAAG,GAAH,GAAG,GAAK,CAAA,CAAA,EAAA,MAAA,CAAA,OAAO,EAAC,GAAG,EAAE,OAAA,CAAA,OAAK,CAAE;IAExD,IAAI,KAAW;IACf,IAAI,OAAO,IAAI,KAAK,EAAE;MACpB,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC;MACxB,GAAG,CAAC,UAAU,CAAC,KAAK,EAAE,QAAQ,CAAC;KAChC,MAAM;MACL;MACA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;MACvE,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,SAAS,EAAE,UAAU,CAAC;MAChD,KAAK,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,EAAE,EAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,EAAW,EAAE,CAAS,KAAK,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;IAC7E;IACD,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC;IAEf,SAAS,QAAQ,GAAA;MACf,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC;MACxB,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,UAAkB,EAAG,CAAC,IACnC,GAAG,CAAC,EAAE,CAAC,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,MAAM,EAAE,IAAI,IAAI,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,CAC7E;IACH;IAEA,SAAS,SAAS,CAAC,OAAa,EAAE,CAAS,EAAA;MACzC,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC;MACrB,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,GAC1C,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,MAAM,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI,GACzC,CAAA,CAAA,EAAA,SAAA,CAAA,CAAC,CAAA,GAAG,IAAI,QAAQ,GAAG,EAAE;IAC3B;EACF;CACD;AAED,OAAA,CAAA,OAAA,GAAe,GAAG","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}