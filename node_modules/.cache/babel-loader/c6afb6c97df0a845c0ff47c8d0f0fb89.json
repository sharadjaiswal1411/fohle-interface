{"ast":null,"code":"import _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { SentryError } from './error.js';\n\n/** Regular expression used to parse a Dsn. */\nvar DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn) {\n  var withPassword = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var host = dsn.host,\n    path = dsn.path,\n    pass = dsn.pass,\n    port = dsn.port,\n    projectId = dsn.projectId,\n    protocol = dsn.protocol,\n    publicKey = dsn.publicKey;\n  return \"\".concat(protocol, \"://\").concat(publicKey).concat(withPassword && pass ? \":\".concat(pass) : '') + \"@\".concat(host).concat(port ? \":\".concat(port) : '', \"/\").concat(path ? \"\".concat(path, \"/\") : path).concat(projectId);\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents\n */\nfunction dsnFromString(str) {\n  var match = DSN_REGEX.exec(str);\n  if (!match) {\n    throw new SentryError(\"Invalid Sentry Dsn: \".concat(str));\n  }\n  var _match$slice = match.slice(1),\n    _match$slice2 = _slicedToArray(_match$slice, 6),\n    protocol = _match$slice2[0],\n    publicKey = _match$slice2[1],\n    _match$slice2$ = _match$slice2[2],\n    pass = _match$slice2$ === void 0 ? '' : _match$slice2$,\n    host = _match$slice2[3],\n    _match$slice2$2 = _match$slice2[4],\n    port = _match$slice2$2 === void 0 ? '' : _match$slice2$2,\n    lastPath = _match$slice2[5];\n  var path = '';\n  var projectId = lastPath;\n  var split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop();\n  }\n  if (projectId) {\n    var projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n  return dsnFromComponents({\n    host: host,\n    pass: pass,\n    path: path,\n    projectId: projectId,\n    port: port,\n    protocol: protocol,\n    publicKey: publicKey\n  });\n}\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId\n  };\n}\nfunction validateDsn(dsn) {\n  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    return;\n  }\n  var port = dsn.port,\n    projectId = dsn.projectId,\n    protocol = dsn.protocol;\n  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(function (component) {\n    if (!dsn[component]) {\n      throw new SentryError(\"Invalid Sentry Dsn: \".concat(component, \" missing\"));\n    }\n  });\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(\"Invalid Sentry Dsn: Invalid projectId \".concat(projectId));\n  }\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(\"Invalid Sentry Dsn: Invalid protocol \".concat(protocol));\n  }\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(\"Invalid Sentry Dsn: Invalid port \".concat(port));\n  }\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nfunction makeDsn(from) {\n  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  validateDsn(components);\n  return components;\n}\nexport { dsnFromString, dsnToString, makeDsn };","map":{"version":3,"sources":["../../src/dsn.ts"],"names":[],"mappings":"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","sourcesContent":["import { DsnComponents, DsnLike, DsnProtocol } from '@sentry/types';\n\nimport { SentryError } from './error';\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol?: string): protocol is DsnProtocol {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nexport function dsnToString(dsn: DsnComponents, withPassword: boolean = false): string {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents\n */\nexport function dsnFromString(str: string): DsnComponents {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() as string;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol as DsnProtocol, publicKey });\n}\n\nfunction dsnFromComponents(components: DsnComponents): DsnComponents {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn: DsnComponents): boolean | void {\n  if (!__DEBUG_BUILD__) {\n    return;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents: ReadonlyArray<keyof DsnComponents> = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nexport function makeDsn(from: DsnLike): DsnComponents {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  validateDsn(components);\n  return components;\n}\n"]},"metadata":{},"sourceType":"module"}