{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport axios from 'axios';\nimport { COINGECKO_API_URL } from 'constants/index';\nimport { getUnixTime, subHours } from 'date-fns';\nimport { useMemo } from 'react';\nimport useSWR from 'swr';\nimport { useWeb3React } from '@web3-react/core';\nexport let LiveDataTimeframeEnum;\n(function (LiveDataTimeframeEnum) {\n  LiveDataTimeframeEnum[\"HOUR\"] = \"1H\";\n  LiveDataTimeframeEnum[\"FOUR_HOURS\"] = \"4H\";\n  LiveDataTimeframeEnum[\"DAY\"] = \"1D\";\n  LiveDataTimeframeEnum[\"WEEK\"] = \"1W\";\n  LiveDataTimeframeEnum[\"MONTH\"] = \"1M\";\n  LiveDataTimeframeEnum[\"SIX_MONTHS\"] = \"6M\";\n})(LiveDataTimeframeEnum || (LiveDataTimeframeEnum = {}));\nconst getTimeFrameHours = timeFrame => {\n  switch (timeFrame) {\n    case LiveDataTimeframeEnum.HOUR:\n      return 1;\n    case LiveDataTimeframeEnum.FOUR_HOURS:\n      return 4;\n    case LiveDataTimeframeEnum.DAY:\n      return 24;\n    case LiveDataTimeframeEnum.WEEK:\n      return 7 * 24;\n    case LiveDataTimeframeEnum.MONTH:\n      return 30 * 24;\n    case LiveDataTimeframeEnum.SIX_MONTHS:\n      return 180 * 24;\n    default:\n      return 7 * 24;\n  }\n};\nconst generateCoingeckoUrl = (chainName, address, timeFrame) => {\n  const timeTo = getUnixTime(new Date());\n  const timeFrom = timeFrame === 'live' ? timeTo - 1000 : getUnixTime(subHours(new Date(), getTimeFrameHours(timeFrame)));\n  return `${COINGECKO_API_URL}/${chainName}/contract/${address}/market_chart/range?vs_currency=usd&from=${timeFrom}&to=${timeTo}`;\n};\nconst getClosestPrice = (prices, time) => {\n  let closestIndex = 0;\n  prices.forEach((item, index) => {\n    if (Math.abs(item[0] - time) < Math.abs(prices[closestIndex][0] - time)) {\n      closestIndex = index;\n    }\n  });\n  return prices[closestIndex][0] - time > 10000000 ? 0 : prices[closestIndex][1];\n};\nconst fetchCoingeckoDataSWR = async data => {\n  const {\n    chainName,\n    tokenAddresses,\n    timeFrame\n  } = data;\n  console.log('chainName', {\n    chainName,\n    tokenAddresses\n  });\n  return await Promise.all([tokenAddresses[0], tokenAddresses[1]].map(address => axios.get(generateCoingeckoUrl(chainName, address, timeFrame), {\n    timeout: 5000\n  }).then(res => {\n    if (res.status === 204) {\n      throw new Error('No content');\n    }\n    return res.data;\n  }).catch(error => {\n    throw error;\n  })));\n};\nfunction getCoingeckoNetworkName() {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  return 'polygon-pos';\n  //ethereum;\n}\n_s(getCoingeckoNetworkName, \"reA9FJLirN6bQm5X4sUUozGx1bA=\", false, function () {\n  return [useWeb3React];\n});\nexport default function useBasicChartData(tokens, timeFrame) {\n  _s2();\n  const isReverse = useMemo(() => {\n    if (!tokens || !tokens[0] || !tokens[1] || tokens[0].equals(tokens[1])) return false;\n    const [token0] = tokens[0].sortsBefore(tokens[1]) ? [tokens[0], tokens[1]] : [tokens[1], tokens[0]];\n    return token0 !== tokens[0];\n  }, [tokens]);\n  const tokenAddresses = useMemo(() => tokens.filter(Boolean).map(token => {\n    var _ref;\n    return (_ref = (token === null || token === void 0 ? void 0 : token.isNative) ? '0x0000000000000000000000000000000000001010' : token === null || token === void 0 ? void 0 : token.address) === null || _ref === void 0 ? void 0 : _ref.toLowerCase();\n  }), [tokens]);\n  let chainName = getCoingeckoNetworkName();\n  const {\n    data: coingeckoData,\n    error: coingeckoError,\n    isValidating: coingeckoLoading\n  } = useSWR(tokenAddresses[0] && tokenAddresses[1] && {\n    tokenAddresses,\n    chainName,\n    timeFrame\n  }, fetchCoingeckoDataSWR, {\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  });\n  const chartData = useMemo(() => {\n    var _coingeckoData$, _coingeckoData$$price, _coingeckoData$2, _coingeckoData$2$pric;\n    if (coingeckoData && ((_coingeckoData$ = coingeckoData[0]) === null || _coingeckoData$ === void 0 ? void 0 : (_coingeckoData$$price = _coingeckoData$.prices) === null || _coingeckoData$$price === void 0 ? void 0 : _coingeckoData$$price.length) > 0 && ((_coingeckoData$2 = coingeckoData[1]) === null || _coingeckoData$2 === void 0 ? void 0 : (_coingeckoData$2$pric = _coingeckoData$2.prices) === null || _coingeckoData$2$pric === void 0 ? void 0 : _coingeckoData$2$pric.length) > 0) {\n      const [data1, data2] = coingeckoData;\n      return data1.prices.map(item => {\n        const closestPrice = getClosestPrice(data2.prices, item[0]);\n        return {\n          time: item[0],\n          value: closestPrice > 0 ? parseFloat((item[1] / closestPrice).toPrecision(6)) : 0\n        };\n      });\n    } else return [];\n  }, [coingeckoData, isReverse]);\n  const error = !!coingeckoError || chartData.length === 0;\n  const {\n    data: liveCoingeckoData\n  } = useSWR(coingeckoData ? [tokenAddresses, chainName, 'live'] : null, fetchCoingeckoDataSWR, {\n    refreshInterval: 60000,\n    shouldRetryOnError: false,\n    revalidateOnFocus: false,\n    revalidateIfStale: false\n  });\n  const latestData = useMemo(() => {\n    if (liveCoingeckoData) {\n      var _data1$prices, _data2$prices;\n      const [data1, data2] = liveCoingeckoData;\n      if (((_data1$prices = data1.prices) === null || _data1$prices === void 0 ? void 0 : _data1$prices.length) > 0 && ((_data2$prices = data2.prices) === null || _data2$prices === void 0 ? void 0 : _data2$prices.length) > 0) {\n        const newValue = parseFloat((data1.prices[data1.prices.length - 1][1] / data2.prices[data2.prices.length - 1][1]).toPrecision(6));\n        return {\n          time: new Date().getTime(),\n          value: newValue\n        };\n      }\n    }\n    return null;\n  }, [liveCoingeckoData, tokenAddresses]);\n  return {\n    data: useMemo(() => latestData ? [...chartData, latestData] : chartData, [latestData, chartData]),\n    error,\n    loading: !tokenAddresses[0] || !tokenAddresses[1] || coingeckoLoading\n  };\n}\n_s2(useBasicChartData, \"IcoQY9upjk8AyKHwCO6z/tnJoSI=\", false, function () {\n  return [useSWR, useSWR];\n});","map":{"version":3,"names":["axios","COINGECKO_API_URL","getUnixTime","subHours","useMemo","useSWR","useWeb3React","LiveDataTimeframeEnum","getTimeFrameHours","timeFrame","HOUR","FOUR_HOURS","DAY","WEEK","MONTH","SIX_MONTHS","generateCoingeckoUrl","chainName","address","timeTo","Date","timeFrom","getClosestPrice","prices","time","closestIndex","forEach","item","index","Math","abs","fetchCoingeckoDataSWR","data","tokenAddresses","console","log","Promise","all","map","get","timeout","then","res","status","Error","catch","error","getCoingeckoNetworkName","chainId","useBasicChartData","tokens","isReverse","equals","token0","sortsBefore","filter","Boolean","token","isNative","toLowerCase","coingeckoData","coingeckoError","isValidating","coingeckoLoading","shouldRetryOnError","revalidateOnFocus","revalidateIfStale","chartData","length","data1","data2","closestPrice","value","parseFloat","toPrecision","liveCoingeckoData","refreshInterval","latestData","newValue","getTime","loading"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useBasicChartData.ts"],"sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport axios from 'axios'\nimport { COINGECKO_API_URL } from 'constants/index'\nimport { getUnixTime, subHours } from 'date-fns'\nimport { useMemo } from 'react'\nimport useSWR from 'swr'\nimport { useWeb3React } from '@web3-react/core'\nexport enum LiveDataTimeframeEnum {\n  HOUR = '1H',\n  FOUR_HOURS = '4H',\n  DAY = '1D',\n  WEEK = '1W',\n  MONTH = '1M',\n  SIX_MONTHS = '6M',\n}\n\nconst getTimeFrameHours = (timeFrame: LiveDataTimeframeEnum) => {\n  switch (timeFrame) {\n    case LiveDataTimeframeEnum.HOUR:\n      return 1\n    case LiveDataTimeframeEnum.FOUR_HOURS:\n      return 4\n    case LiveDataTimeframeEnum.DAY:\n      return 24\n    case LiveDataTimeframeEnum.WEEK:\n      return 7 * 24\n    case LiveDataTimeframeEnum.MONTH:\n      return 30 * 24\n    case LiveDataTimeframeEnum.SIX_MONTHS:\n      return 180 * 24\n    default:\n      return 7 * 24\n  }\n}\nconst generateCoingeckoUrl = (\n  chainName: string,\n  address: string | undefined,\n  timeFrame: LiveDataTimeframeEnum | 'live'\n): string => {\n  const timeTo = getUnixTime(new Date())\n  const timeFrom =\n    timeFrame === 'live' ? timeTo - 1000 : getUnixTime(subHours(new Date(), getTimeFrameHours(timeFrame)))\n\n  return `${COINGECKO_API_URL}/${chainName}/contract/${address}/market_chart/range?vs_currency=usd&from=${timeFrom}&to=${timeTo}`\n}\nconst getClosestPrice = (prices: any[], time: number) => {\n  let closestIndex = 0\n  prices.forEach((item, index) => {\n    if (Math.abs(item[0] - time) < Math.abs(prices[closestIndex][0] - time)) {\n      closestIndex = index\n    }\n  })\n  return prices[closestIndex][0] - time > 10000000 ? 0 : prices[closestIndex][1]\n}\n\nexport interface ChartDataInfo {\n  readonly time: number\n  readonly value: number\n}\n\nconst fetchCoingeckoDataSWR = async (data: any): Promise<any> => {\n  const { chainName, tokenAddresses, timeFrame } = data\n  console.log('chainName', { chainName, tokenAddresses })\n  return await Promise.all(\n    [tokenAddresses[0], tokenAddresses[1]].map((address) =>\n      axios\n        .get(generateCoingeckoUrl(chainName, address, timeFrame), { timeout: 5000 })\n        .then((res) => {\n          if (res.status === 204) {\n            throw new Error('No content')\n          }\n          return res.data\n        })\n        .catch((error) => {\n          throw error\n        })\n    )\n  )\n}\n\nfunction getCoingeckoNetworkName(){\n   const { chainId } = useWeb3React()\n\n   return 'polygon-pos';\n    //ethereum;\n}\n\nexport default function useBasicChartData(tokens: (Token | null | undefined)[], timeFrame: LiveDataTimeframeEnum) {\n  const isReverse = useMemo(() => {\n    if (!tokens || !tokens[0] || !tokens[1] || tokens[0].equals(tokens[1])) return false\n    const [token0] = tokens[0].sortsBefore(tokens[1]) ? [tokens[0], tokens[1]] : [tokens[1], tokens[0]]\n    return token0 !== tokens[0]\n  }, [tokens])\n\n  const tokenAddresses = useMemo(\n    () =>\n      tokens\n        .filter(Boolean)\n        .map((token) =>\n          (token?.isNative ? '0x0000000000000000000000000000000000001010' : token?.address)?.toLowerCase()\n        ),\n    [tokens]\n  )\n  \n\n\n  let chainName = getCoingeckoNetworkName();\n\n \n  const {\n    data: coingeckoData,\n    error: coingeckoError,\n    isValidating: coingeckoLoading,\n  } = useSWR(\n    tokenAddresses[0] && tokenAddresses[1] && { tokenAddresses, chainName, timeFrame },\n    fetchCoingeckoDataSWR,\n    {\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    }\n  )\n\n  const chartData = useMemo(() => {\n    if (coingeckoData && coingeckoData[0]?.prices?.length > 0 && coingeckoData[1]?.prices?.length > 0) {\n      const [data1, data2] = coingeckoData\n      return data1.prices.map((item: number[]) => {\n        const closestPrice = getClosestPrice(data2.prices, item[0])\n        return { time: item[0], value: closestPrice > 0 ? parseFloat((item[1] / closestPrice).toPrecision(6)) : 0 }\n      })\n    } else return []\n  }, [coingeckoData, isReverse])\n\n  const error = !!coingeckoError || chartData.length === 0\n\n  const { data: liveCoingeckoData } = useSWR(\n    coingeckoData ? [tokenAddresses, chainName, 'live'] : null,\n    fetchCoingeckoDataSWR,\n    {\n      refreshInterval: 60000,\n      shouldRetryOnError: false,\n      revalidateOnFocus: false,\n      revalidateIfStale: false,\n    }\n  )\n\n  const latestData = useMemo(() => {\n    if (liveCoingeckoData) {\n      const [data1, data2] = liveCoingeckoData\n      if (data1.prices?.length > 0 && data2.prices?.length > 0) {\n        const newValue = parseFloat(\n          (data1.prices[data1.prices.length - 1][1] / data2.prices[data2.prices.length - 1][1]).toPrecision(6)\n        )\n        return { time: new Date().getTime(), value: newValue }\n      }\n    }\n\n    return null\n  }, [liveCoingeckoData, tokenAddresses])\n\n  return {\n    data: useMemo(() => (latestData ? [...chartData, latestData] : chartData), [latestData, chartData]),\n    error,\n    loading: !tokenAddresses[0] || !tokenAddresses[1] || coingeckoLoading,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}