{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Base = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nclass Base {\n  /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */\n  print() {\n    Base.print(this);\n  }\n  /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */\n  _bufferIndexOf(array, element) {\n    for (let i = 0; i < array.length; i++) {\n      if (element.equals(array[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */\n  static bufferify(value) {\n    if (!buffer_1.Buffer.isBuffer(value)) {\n      // crypto-js support\n      if (typeof value === 'object' && value.words) {\n        return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n      } else if (Base.isHexString(value)) {\n        return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n      } else if (typeof value === 'string') {\n        return buffer_1.Buffer.from(value);\n      } else if (typeof value === 'number') {\n        let s = value.toString();\n        if (s.length % 2) {\n          s = `0${s}`;\n        }\n        return buffer_1.Buffer.from(s, 'hex');\n      } else if (ArrayBuffer.isView(value)) {\n        return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n      }\n    }\n    return value;\n  }\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  static isHexString(v) {\n    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n  /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */\n  static print(tree) {\n    console.log(tree.toString());\n  }\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Base.bufferToHex(value, withPrefix);\n  }\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  static bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n  }\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */\n  bufferify(value) {\n    return Base.bufferify(value);\n  }\n  /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */\n  bufferifyFn(f) {\n    return value => {\n      const v = f(value);\n      if (buffer_1.Buffer.isBuffer(v)) {\n        return v;\n      }\n      if (this._isHexString(v)) {\n        return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n      }\n      if (typeof v === 'string') {\n        return buffer_1.Buffer.from(v);\n      }\n      if (ArrayBuffer.isView(v)) {\n        return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n      }\n      // crypto-js support\n      return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n    };\n  }\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  _isHexString(value) {\n    return Base.isHexString(value);\n  }\n  /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */\n  _log2(n) {\n    return n === 1 ? 0 : 1 + this._log2(n / 2 | 0);\n  }\n  /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */\n  _zip(a, b) {\n    return a.map((e, i) => [e, b[i]]);\n  }\n}\nexports.Base = Base;\nexports.default = Base;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Base","buffer_1","require","crypto_js_1","print","_bufferIndexOf","array","element","i","length","equals","bufferify","Buffer","isBuffer","words","from","toString","default","enc","Hex","isHexString","replace","s","ArrayBuffer","isView","buffer","byteOffset","byteLength","v","test","tree","console","log","bufferToHex","withPrefix","alloc","bufferifyFn","f","_isHexString","parse","_log2","n","_zip","a","b","map","e"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/merkletreejs/dist/Base.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Base = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nclass Base {\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    print() {\n        Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n    _bufferIndexOf(array, element) {\n        for (let i = 0; i < array.length; i++) {\n            if (element.equals(array[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n    static bufferify(value) {\n        if (!buffer_1.Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === 'object' && value.words) {\n                return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n            }\n            else if (Base.isHexString(value)) {\n                return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n            }\n            else if (typeof value === 'string') {\n                return buffer_1.Buffer.from(value);\n            }\n            else if (typeof value === 'number') {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return buffer_1.Buffer.from(s, 'hex');\n            }\n            else if (ArrayBuffer.isView(value)) {\n                return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    static isHexString(v) {\n        return (typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v));\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n    static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    bufferToHex(value, withPrefix = true) {\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    static bufferToHex(value, withPrefix = true) {\n        return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n    bufferifyFn(f) {\n        return (value) => {\n            const v = f(value);\n            if (buffer_1.Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this._isHexString(v)) {\n                return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n            }\n            if (typeof v === 'string') {\n                return buffer_1.Buffer.from(v);\n            }\n            if (ArrayBuffer.isView(v)) {\n                return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n        };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    _isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n    _log2(n) {\n        return n === 1 ? 0 : 1 + this._log2((n / 2) | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n    _zip(a, b) {\n        return a.map((e, i) => [e, b[i]]);\n    }\n}\nexports.Base = Base;\nexports.default = Base;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}