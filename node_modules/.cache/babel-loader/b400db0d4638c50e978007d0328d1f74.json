{"ast":null,"code":"import _createForOfIteratorHelper from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { normalize } from './normalize.js';\nimport { dropUndefinedKeys } from './object.js';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction createEnvelope(headers) {\n  var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return [headers, items];\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction addItemToEnvelope(envelope, newItem) {\n  var _envelope = _slicedToArray(envelope, 2),\n    headers = _envelope[0],\n    items = _envelope[1];\n  return [headers, [].concat(_toConsumableArray(items), [newItem])];\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n */\nfunction forEachEnvelopeItem(envelope, callback) {\n  var envelopeItems = envelope[1];\n  envelopeItems.forEach(function (envelopeItem) {\n    var envelopeItemType = envelopeItem[0].type;\n    callback(envelopeItem, envelopeItemType);\n  });\n}\nfunction encodeUTF8(input, textEncoder) {\n  var utf8 = textEncoder || new TextEncoder();\n  return utf8.encode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nfunction serializeEnvelope(envelope, textEncoder) {\n  var _envelope2 = _slicedToArray(envelope, 2),\n    envHeaders = _envelope2[0],\n    items = _envelope2[1];\n\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  var parts = JSON.stringify(envHeaders);\n  function append(next) {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);\n    }\n  }\n  var _iterator = _createForOfIteratorHelper(items),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var _item = _slicedToArray(item, 2),\n        itemHeaders = _item[0],\n        payload = _item[1];\n      append(\"\\n\".concat(JSON.stringify(itemHeaders), \"\\n\"));\n      if (typeof payload === 'string' || payload instanceof Uint8Array) {\n        append(payload);\n      } else {\n        var stringifiedPayload = void 0;\n        try {\n          stringifiedPayload = JSON.stringify(payload);\n        } catch (e) {\n          // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.strinify()` still\n          // fails, we try again after normalizing it again with infinite normalization depth. This of course has a\n          // performance impact but in this case a performance hit is better than throwing.\n          stringifiedPayload = JSON.stringify(normalize(payload));\n        }\n        append(stringifiedPayload);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\nfunction concatBuffers(buffers) {\n  var totalLength = buffers.reduce(function (acc, buf) {\n    return acc + buf.length;\n  }, 0);\n  var merged = new Uint8Array(totalLength);\n  var offset = 0;\n  var _iterator2 = _createForOfIteratorHelper(buffers),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var buffer = _step2.value;\n      merged.set(buffer, offset);\n      offset += buffer.length;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return merged;\n}\n\n/**\n * Creates attachment envelope items\n */\nfunction createAttachmentEnvelopeItem(attachment, textEncoder) {\n  var buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;\n  return [dropUndefinedKeys({\n    type: 'attachment',\n    length: buffer.length,\n    filename: attachment.filename,\n    content_type: attachment.contentType,\n    attachment_type: attachment.attachmentType\n  }), buffer];\n}\nvar ITEM_TYPE_TO_DATA_CATEGORY_MAP = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default'\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nfunction envelopeItemTypeToDataCategory(type) {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\nexport { addItemToEnvelope, createAttachmentEnvelopeItem, createEnvelope, envelopeItemTypeToDataCategory, forEachEnvelopeItem, serializeEnvelope };","map":{"version":3,"sources":["../../src/envelope.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Attachment,\n  AttachmentItem,\n  DataCategory,\n  Envelope,\n  EnvelopeItem,\n  EnvelopeItemType,\n  TextEncoderInternal,\n} from '@sentry/types';\n\nimport { normalize } from './normalize';\nimport { dropUndefinedKeys } from './object';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope<E extends Envelope>(headers: E[0], items: E[1] = []): E {\n  return [headers, items] as E;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] as E;\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n */\nexport function forEachEnvelopeItem<E extends Envelope>(\n  envelope: Envelope,\n  callback: (envelopeItem: E[1][number], envelopeItemType: E[1][number][0]['type']) => void,\n): void {\n  const envelopeItems = envelope[1];\n  envelopeItems.forEach((envelopeItem: EnvelopeItem) => {\n    const envelopeItemType = envelopeItem[0].type;\n    callback(envelopeItem, envelopeItemType);\n  });\n}\n\nfunction encodeUTF8(input: string, textEncoder?: TextEncoderInternal): Uint8Array {\n  const utf8 = textEncoder || new TextEncoder();\n  return utf8.encode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nexport function serializeEnvelope(envelope: Envelope, textEncoder?: TextEncoderInternal): string | Uint8Array {\n  const [envHeaders, items] = envelope;\n\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts: string | Uint8Array[] = JSON.stringify(envHeaders);\n\n  function append(next: string | Uint8Array): void {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);\n    }\n  }\n\n  for (const item of items) {\n    const [itemHeaders, payload] = item;\n\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n\n    if (typeof payload === 'string' || payload instanceof Uint8Array) {\n      append(payload);\n    } else {\n      let stringifiedPayload: string;\n      try {\n        stringifiedPayload = JSON.stringify(payload);\n      } catch (e) {\n        // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.strinify()` still\n        // fails, we try again after normalizing it again with infinite normalization depth. This of course has a\n        // performance impact but in this case a performance hit is better than throwing.\n        stringifiedPayload = JSON.stringify(normalize(payload));\n      }\n      append(stringifiedPayload);\n    }\n  }\n\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\n\nfunction concatBuffers(buffers: Uint8Array[]): Uint8Array {\n  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n\n  const merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return merged;\n}\n\n/**\n * Creates attachment envelope items\n */\nexport function createAttachmentEnvelopeItem(\n  attachment: Attachment,\n  textEncoder?: TextEncoderInternal,\n): AttachmentItem {\n  const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;\n\n  return [\n    dropUndefinedKeys({\n      type: 'attachment',\n      length: buffer.length,\n      filename: attachment.filename,\n      content_type: attachment.contentType,\n      attachment_type: attachment.attachmentType,\n    }),\n    buffer,\n  ];\n}\n\nconst ITEM_TYPE_TO_DATA_CATEGORY_MAP: Record<EnvelopeItemType, DataCategory> = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nexport function envelopeItemTypeToDataCategory(type: EnvelopeItemType): DataCategory {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n"]},"metadata":{},"sourceType":"module"}