{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)`await `), e => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n  function assignValid() {\n    let _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)`await ` : codegen_1.nil;\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n  function reportErrs(errors) {\n    var _a;\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\nfunction checkAsyncKeyword(_ref, def) {\n  let {\n    schemaEnv\n  } = _ref;\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\nfunction validSchemaType(schema, schemaType) {\n  let allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage(_ref2, def, keyword) {\n  let {\n    schema,\n    opts,\n    self,\n    errSchemaPath\n  } = _ref2;\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n  const deps = def.dependencies;\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"sources":["../../../lib/compile/validate/keyword.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map"]},"metadata":{},"sourceType":"script"}