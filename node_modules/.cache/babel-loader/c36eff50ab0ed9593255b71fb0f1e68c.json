{"ast":null,"code":"/**\n * Converts a filter to the corresponding string key\n * @param filter the filter to convert\n */\nexport function filterToKey(filter) {\n  var _filter$address, _filter$topics$map$jo, _filter$topics, _filter$topics$map, _filter$fromBlock, _filter$toBlock;\n  return `${(_filter$address = filter.address) !== null && _filter$address !== void 0 ? _filter$address : ''}:${(_filter$topics$map$jo = (_filter$topics = filter.topics) === null || _filter$topics === void 0 ? void 0 : (_filter$topics$map = _filter$topics.map(topic => topic ? Array.isArray(topic) ? topic.join(';') : topic : '\\0')) === null || _filter$topics$map === void 0 ? void 0 : _filter$topics$map.join('-')) !== null && _filter$topics$map$jo !== void 0 ? _filter$topics$map$jo : ''}:${(_filter$fromBlock = filter.fromBlock) !== null && _filter$fromBlock !== void 0 ? _filter$fromBlock : ''}:${(_filter$toBlock = filter.toBlock) !== null && _filter$toBlock !== void 0 ? _filter$toBlock : ''}`;\n}\n\n/**\n * Convert a filter key to the corresponding filter\n * @param key key to convert\n */\nexport function keyToFilter(key) {\n  const pcs = key.split(':');\n  const address = pcs[0];\n  const topics = pcs[1].split('-').map(topic => {\n    if (topic === '\\0') return null;\n    const parts = topic.split(';');\n    if (parts.length === 1) return parts[0];\n    return parts;\n  });\n  const fromBlock = pcs[2];\n  const toBlock = pcs[3];\n  return {\n    address: address.length === 0 ? undefined : address,\n    topics,\n    fromBlock: fromBlock.length === 0 ? undefined : fromBlock,\n    toBlock: toBlock.length === 0 ? undefined : toBlock\n  };\n}\n\n/**\n * Determines whether a filter is for a historical log that doesn't need to be re-fetched.\n * @param filter The filter to check.\n * @param blockNumber The current block number.\n */\nexport function isHistoricalLog(filter, blockNumber) {\n  if (!filter.toBlock) return false;\n  let toBlock = filter.toBlock;\n  if (typeof toBlock === 'string') toBlock = Number.parseInt(toBlock);\n  return toBlock <= blockNumber;\n}","map":{"version":3,"names":["filterToKey","filter","address","topics","map","topic","Array","isArray","join","fromBlock","toBlock","keyToFilter","key","pcs","split","parts","length","undefined","isHistoricalLog","blockNumber","Number","parseInt"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/state/logs/utils.ts"],"sourcesContent":["import type { Filter } from '@ethersproject/providers'\n\nexport interface Log {\n  topics: Array<string>\n  data: string\n  transactionIndex: number\n  logIndex: number\n  blockNumber: number\n}\n\n/**\n * Converts a filter to the corresponding string key\n * @param filter the filter to convert\n */\nexport function filterToKey(filter: Filter): string {\n  return `${filter.address ?? ''}:${\n    filter.topics?.map((topic) => (topic ? (Array.isArray(topic) ? topic.join(';') : topic) : '\\0'))?.join('-') ?? ''\n  }:${filter.fromBlock ?? ''}:${filter.toBlock ?? ''}`\n}\n\n/**\n * Convert a filter key to the corresponding filter\n * @param key key to convert\n */\nexport function keyToFilter(key: string): Filter {\n  const pcs = key.split(':')\n  const address = pcs[0]\n  const topics = pcs[1].split('-').map((topic) => {\n    if (topic === '\\0') return null\n    const parts = topic.split(';')\n    if (parts.length === 1) return parts[0]\n    return parts\n  })\n  const fromBlock = pcs[2]\n  const toBlock = pcs[3]\n\n  return {\n    address: address.length === 0 ? undefined : address,\n    topics,\n    fromBlock: fromBlock.length === 0 ? undefined : fromBlock,\n    toBlock: toBlock.length === 0 ? undefined : toBlock,\n  }\n}\n\n/**\n * Determines whether a filter is for a historical log that doesn't need to be re-fetched.\n * @param filter The filter to check.\n * @param blockNumber The current block number.\n */\nexport function isHistoricalLog(filter: Filter, blockNumber: number): boolean {\n  if (!filter.toBlock) return false\n\n  let toBlock = filter.toBlock\n  if (typeof toBlock === 'string') toBlock = Number.parseInt(toBlock)\n  return toBlock <= blockNumber\n}\n"],"mappings":"AAUA;AACA;AACA;AACA;AACA,OAAO,SAASA,WAAW,CAACC,MAAc,EAAU;EAAA;EAClD,OAAQ,sBAAEA,MAAM,CAACC,OAAO,6DAAI,EAAG,IAAC,2CAC9BD,MAAM,CAACE,MAAM,yEAAb,eAAeC,GAAG,CAAEC,KAAK,IAAMA,KAAK,GAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GAAGA,KAAK,CAACG,IAAI,CAAC,GAAG,CAAC,GAAGH,KAAK,GAAI,IAAK,CAAC,uDAAhG,mBAAkGG,IAAI,CAAC,GAAG,CAAC,yEAAI,EAChH,IAAC,qBAAEP,MAAM,CAACQ,SAAS,iEAAI,EAAG,IAAC,mBAAER,MAAM,CAACS,OAAO,6DAAI,EAAG,EAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAW,CAACC,GAAW,EAAU;EAC/C,MAAMC,GAAG,GAAGD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;EAC1B,MAAMZ,OAAO,GAAGW,GAAG,CAAC,CAAC,CAAC;EACtB,MAAMV,MAAM,GAAGU,GAAG,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAACV,GAAG,CAAEC,KAAK,IAAK;IAC9C,IAAIA,KAAK,KAAK,IAAI,EAAE,OAAO,IAAI;IAC/B,MAAMU,KAAK,GAAGV,KAAK,CAACS,KAAK,CAAC,GAAG,CAAC;IAC9B,IAAIC,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE,OAAOD,KAAK,CAAC,CAAC,CAAC;IACvC,OAAOA,KAAK;EACd,CAAC,CAAC;EACF,MAAMN,SAAS,GAAGI,GAAG,CAAC,CAAC,CAAC;EACxB,MAAMH,OAAO,GAAGG,GAAG,CAAC,CAAC,CAAC;EAEtB,OAAO;IACLX,OAAO,EAAEA,OAAO,CAACc,MAAM,KAAK,CAAC,GAAGC,SAAS,GAAGf,OAAO;IACnDC,MAAM;IACNM,SAAS,EAAEA,SAAS,CAACO,MAAM,KAAK,CAAC,GAAGC,SAAS,GAAGR,SAAS;IACzDC,OAAO,EAAEA,OAAO,CAACM,MAAM,KAAK,CAAC,GAAGC,SAAS,GAAGP;EAC9C,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,eAAe,CAACjB,MAAc,EAAEkB,WAAmB,EAAW;EAC5E,IAAI,CAAClB,MAAM,CAACS,OAAO,EAAE,OAAO,KAAK;EAEjC,IAAIA,OAAO,GAAGT,MAAM,CAACS,OAAO;EAC5B,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAEA,OAAO,GAAGU,MAAM,CAACC,QAAQ,CAACX,OAAO,CAAC;EACnE,OAAOA,OAAO,IAAIS,WAAW;AAC/B"},"metadata":{},"sourceType":"module"}