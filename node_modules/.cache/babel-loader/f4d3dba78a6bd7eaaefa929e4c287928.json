{"ast":null,"code":"/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url) {\n  if (!url) {\n    return {};\n  }\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\nexport { getNumberOfUrlSegments, parseUrl, stripUrlQueryAndFragment };","map":{"version":3,"sources":["../../src/url.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,QAAA,CAAA,GAAA,EAKA;EACA,IAAA,CAAA,GAAA,EAAA;IACA,OAAA,CAAA,CAAA;EACA;EAEA,MAAA,KAAA,GAAA,GAAA,CAAA,KAAA,CAAA,8DAAA,CAAA;EAEA,IAAA,CAAA,KAAA,EAAA;IACA,OAAA,CAAA,CAAA;EACA;;EAEA;EACA,MAAA,KAAA,GAAA,KAAA,CAAA,CAAA,CAAA,IAAA,EAAA;EACA,MAAA,QAAA,GAAA,KAAA,CAAA,CAAA,CAAA,IAAA,EAAA;EACA,OAAA;IACA,IAAA,EAAA,KAAA,CAAA,CAAA,CAAA;IACA,IAAA,EAAA,KAAA,CAAA,CAAA,CAAA;IACA,QAAA,EAAA,KAAA,CAAA,CAAA,CAAA;IACA,QAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,KAAA,GAAA,QAAA,CAAA;EACA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,wBAAA,CAAA,OAAA,EAAA;EACA;EACA,OAAA,OAAA,CAAA,KAAA,CAAA,OAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA,SAAA,sBAAA,CAAA,GAAA,EAAA;EACA;EACA,OAAA,GAAA,CAAA,KAAA,CAAA,OAAA,CAAA,CAAA,MAAA,CAAA,CAAA,IAAA,CAAA,CAAA,MAAA,GAAA,CAAA,IAAA,CAAA,KAAA,GAAA,CAAA,CAAA,MAAA;AACA","sourcesContent":["/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nexport function parseUrl(url: string): {\n  host?: string;\n  path?: string;\n  protocol?: string;\n  relative?: string;\n} {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nexport function stripUrlQueryAndFragment(urlPath: string): string {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nexport function getNumberOfUrlSegments(url: string): number {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n"]},"metadata":{},"sourceType":"module"}