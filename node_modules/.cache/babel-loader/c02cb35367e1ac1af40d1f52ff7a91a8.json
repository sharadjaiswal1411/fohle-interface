{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\nmodule.exports = table;\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n\n  /* Exit when not in gfm-mode. */\n  if (!self.options.gfm) {\n    return;\n  }\n\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n      break;\n    }\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n\n  /* Parse the alignment row. */\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n  while (index < length) {\n    character = alignments.charAt(index);\n    if (character === C_PIPE) {\n      hasDash = null;\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n    index++;\n  }\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n\n  /* Exit when without enough columns. */\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  /* Parse the rows. */\n  position = -1;\n  rows = [];\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {\n      type: 'tableRow',\n      children: []\n    };\n\n    /* Eat a newline character when this is not the\n     * first row. */\n    if (position) {\n      eat(C_NEWLINE);\n    }\n\n    /* Eat the row. */\n    eat(line).reset(row, table);\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n    while (index < length) {\n      character = line.charAt(index);\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n        index++;\n        continue;\n      }\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n            now = eat.now();\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n          eat(queue + character);\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n        cell += character;\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n        if (character === C_TICK) {\n          count = 1;\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n      preamble = false;\n      index++;\n    }\n\n    /* Eat the alignment row. */\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n  return table;\n}","map":{"version":3,"names":["whitespace","require","module","exports","table","C_BACKSLASH","C_TICK","C_DASH","C_PIPE","C_COLON","C_SPACE","C_NEWLINE","C_TAB","MIN_TABLE_COLUMNS","MIN_TABLE_ROWS","TABLE_ALIGN_LEFT","TABLE_ALIGN_CENTER","TABLE_ALIGN_RIGHT","TABLE_ALIGN_NONE","eat","value","silent","self","index","alignments","alignment","subvalue","row","length","lines","queue","character","hasDash","align","cell","preamble","count","opening","now","position","lineCount","line","rows","lineIndex","pipeIndex","first","options","gfm","indexOf","push","slice","join","splice","charAt","reset","type","children","tokenizeInline"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/node_modules/remark-parse/lib/tokenize/table.js"],"sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\n\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\n\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n\n  /* Exit when not in gfm-mode. */\n  if (!self.options.gfm) {\n    return;\n  }\n\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n\n  /* Parse the alignment row. */\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n\n  /* Exit when without enough columns. */\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  /* Parse the rows. */\n  position = -1;\n  rows = [];\n\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {type: 'tableRow', children: []};\n\n    /* Eat a newline character when this is not the\n     * first row. */\n    if (position) {\n      eat(C_NEWLINE);\n    }\n\n    /* Eat the row. */\n    eat(line).reset(row, table);\n\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n\n    /* Eat the alignment row. */\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}