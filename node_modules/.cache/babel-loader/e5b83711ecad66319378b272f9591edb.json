{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n  constructor(name) {\n    super(`CodeGen: \"code\" for ${name} not defined`);\n    this.value = name.value;\n  }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\nclass Scope {\n  constructor() {\n    let {\n      prefixes,\n      parent\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n    return `${prefix}${ng.index++}`;\n  }\n  _nameGroup(prefix) {\n    var _a, _b;\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n    }\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n  setValue(value, _ref) {\n    let {\n      property,\n      itemIndex\n    } = _ref;\n    this.value = value;\n    this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)`\\n`;\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = {\n      ...opts,\n      _n: opts.lines ? line : code_1.nil\n    };\n  }\n  get() {\n    return this._scope;\n  }\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n  value(nameOrPrefix, value) {\n    var _a;\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n    if (vs) {\n      const _name = vs.get(valueKey);\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n  scopeRefs(scopeName) {\n    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._values;\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return (0, code_1._)`${scopeName}${name.scopePath}`;\n    });\n  }\n  scopeCode() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._values;\n    let usedValues = arguments.length > 1 ? arguments[1] : undefined;\n    let getCode = arguments.length > 2 ? arguments[2] : undefined;\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n  _reduceValues(values, valueCode) {\n    let usedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let getCode = arguments.length > 3 ? arguments[3] : undefined;\n    let code = code_1.nil;\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)`${code}${c}${this.opts._n}`;\n        } else {\n          throw new ValueError(name);\n        }\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n    return code;\n  }\n}\nexports.ValueScope = ValueScope;","map":{"version":3,"sources":["../../../lib/compile/codegen/scope.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map"]},"metadata":{},"sourceType":"script"}