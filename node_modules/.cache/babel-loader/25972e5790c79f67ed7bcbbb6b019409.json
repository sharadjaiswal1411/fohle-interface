{"ast":null,"code":"var _s = $RefreshSig$();\nimport { Route } from '@uniswap/v3-sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { useMemo } from 'react';\nimport { useV3SwapPools } from './useV3SwapPools';\n\n/**\n * Returns true if poolA is equivalent to poolB\n * @param poolA one of the two pools\n * @param poolB the other pool\n */\nfunction poolEquals(poolA, poolB) {\n  return poolA === poolB || poolA.token0.equals(poolB.token0) && poolA.token1.equals(poolB.token1) && poolA.fee === poolB.fee;\n}\nfunction computeAllRoutes(currencyIn, currencyOut, pools, chainId) {\n  let currentPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  let allPaths = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n  let startCurrencyIn = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : currencyIn;\n  let maxHops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2;\n  const tokenIn = currencyIn === null || currencyIn === void 0 ? void 0 : currencyIn.wrapped;\n  const tokenOut = currencyOut === null || currencyOut === void 0 ? void 0 : currencyOut.wrapped;\n  if (!tokenIn || !tokenOut) throw new Error('Missing tokenIn/tokenOut');\n  for (const pool of pools) {\n    if (!pool.involvesToken(tokenIn) || currentPath.find(pathPool => poolEquals(pool, pathPool))) continue;\n    const outputToken = pool.token0.equals(tokenIn) ? pool.token1 : pool.token0;\n    if (outputToken.equals(tokenOut)) {\n      allPaths.push(new Route([...currentPath, pool], startCurrencyIn, currencyOut));\n    } else if (maxHops > 1) {\n      computeAllRoutes(outputToken, currencyOut, pools, chainId, [...currentPath, pool], allPaths, startCurrencyIn, maxHops - 1);\n    }\n  }\n  return allPaths;\n}\n\n/**\n * Returns all the routes from an input currency to an output currency\n * @param currencyIn the input currency\n * @param currencyOut the output currency\n */\nexport function useAllV3Routes(currencyIn, currencyOut) {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  const {\n    pools,\n    loading: poolsLoading\n  } = useV3SwapPools(currencyIn, currencyOut);\n  return useMemo(() => {\n    if (poolsLoading || !chainId || !pools || !currencyIn || !currencyOut) return {\n      loading: true,\n      routes: []\n    };\n    const routes = computeAllRoutes(currencyIn, currencyOut, pools, chainId, [], [], currencyIn, 2);\n    return {\n      loading: false,\n      routes\n    };\n  }, [chainId, currencyIn, currencyOut, pools, poolsLoading]);\n}\n_s(useAllV3Routes, \"X/Brc+xV8BQNOi3zIobfF40yck8=\", false, function () {\n  return [useWeb3React, useV3SwapPools];\n});","map":{"version":3,"names":["Route","useWeb3React","useMemo","useV3SwapPools","poolEquals","poolA","poolB","token0","equals","token1","fee","computeAllRoutes","currencyIn","currencyOut","pools","chainId","currentPath","allPaths","startCurrencyIn","maxHops","tokenIn","wrapped","tokenOut","Error","pool","involvesToken","find","pathPool","outputToken","push","useAllV3Routes","loading","poolsLoading","routes"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/fohle-interface/src/hooks/useAllV3Routes.ts"],"sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { Pool, Route } from '@uniswap/v3-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { useMemo } from 'react'\n\nimport { useV3SwapPools } from './useV3SwapPools'\n\n/**\n * Returns true if poolA is equivalent to poolB\n * @param poolA one of the two pools\n * @param poolB the other pool\n */\nfunction poolEquals(poolA: Pool, poolB: Pool): boolean {\n  return (\n    poolA === poolB ||\n    (poolA.token0.equals(poolB.token0) && poolA.token1.equals(poolB.token1) && poolA.fee === poolB.fee)\n  )\n}\n\nfunction computeAllRoutes(\n  currencyIn: Currency,\n  currencyOut: Currency,\n  pools: Pool[],\n  chainId: number,\n  currentPath: Pool[] = [],\n  allPaths: Route<Currency, Currency>[] = [],\n  startCurrencyIn: Currency = currencyIn,\n  maxHops = 2\n): Route<Currency, Currency>[] {\n  const tokenIn = currencyIn?.wrapped\n  const tokenOut = currencyOut?.wrapped\n  if (!tokenIn || !tokenOut) throw new Error('Missing tokenIn/tokenOut')\n\n  for (const pool of pools) {\n    if (!pool.involvesToken(tokenIn) || currentPath.find((pathPool) => poolEquals(pool, pathPool))) continue\n\n    const outputToken = pool.token0.equals(tokenIn) ? pool.token1 : pool.token0\n    if (outputToken.equals(tokenOut)) {\n      allPaths.push(new Route([...currentPath, pool], startCurrencyIn, currencyOut))\n    } else if (maxHops > 1) {\n      computeAllRoutes(\n        outputToken,\n        currencyOut,\n        pools,\n        chainId,\n        [...currentPath, pool],\n        allPaths,\n        startCurrencyIn,\n        maxHops - 1\n      )\n    }\n  }\n\n  return allPaths\n}\n\n/**\n * Returns all the routes from an input currency to an output currency\n * @param currencyIn the input currency\n * @param currencyOut the output currency\n */\nexport function useAllV3Routes(\n  currencyIn?: Currency,\n  currencyOut?: Currency\n): { loading: boolean; routes: Route<Currency, Currency>[] } {\n  const { chainId } = useWeb3React()\n  const { pools, loading: poolsLoading } = useV3SwapPools(currencyIn, currencyOut)\n\n  return useMemo(() => {\n    if (poolsLoading || !chainId || !pools || !currencyIn || !currencyOut) return { loading: true, routes: [] }\n\n    const routes = computeAllRoutes(currencyIn, currencyOut, pools, chainId, [], [], currencyIn, 2)\n    return { loading: false, routes }\n  }, [chainId, currencyIn, currencyOut, pools, poolsLoading])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}